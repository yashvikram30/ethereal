"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana";
exports.ids = ["vendor-chunks/@solana"];
exports.modules = {

/***/ "(ssr)/./node_modules/@solana/buffer-layout/lib/Layout.js":
/*!**********************************************************!*\
  !*** ./node_modules/@solana/buffer-layout/lib/Layout.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */ /**\n * Support for translating between Uint8Array instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\n/* Check if a value is a Uint8Array.\n *\n * @ignore */ function checkUint8Array(b) {\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError(\"b must be a Uint8Array\");\n    }\n}\nexports.checkUint8Array = checkUint8Array;\n/* Create a Buffer instance from a Uint8Array.\n *\n * @ignore */ function uint8ArrayToBuffer(b) {\n    checkUint8Array(b);\n    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n}\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */ class Layout {\n    constructor(span, property){\n        if (!Number.isInteger(span)) {\n            throw new TypeError(\"span must be an integer\");\n        }\n        /** The span of the layout in bytes.\n         *\n         * Positive values are generally expected.\n         *\n         * Zero will only appear in {@link Constant}s and in {@link\n         * Sequence}s where the {@link Sequence#count|count} is zero.\n         *\n         * A negative value indicates that the span is value-specific, and\n         * must be obtained using {@link Layout#getSpan|getSpan}. */ this.span = span;\n        /** The property name used when this layout is represented in an\n         * Object.\n         *\n         * Used only for layouts that {@link Layout#decode|decode} to Object\n         * instances.  If left undefined the span of the unnamed layout will\n         * be treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */ this.property = property;\n    }\n    /** Function to create an Object into which decoded properties will\n     * be written.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances, which means:\n     * * {@link Structure}\n     * * {@link Union}\n     * * {@link VariantLayout}\n     * * {@link BitStructure}\n     *\n     * If left undefined the JavaScript representation of these layouts\n     * will be Object instances.\n     *\n     * See {@link bindConstructorLayout}.\n     */ makeDestinationObject() {\n        return {};\n    }\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Uint8Array} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */ getSpan(b, offset) {\n        if (0 > this.span) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return this.span;\n    }\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */ replicate(property) {\n        const rv = Object.create(this.constructor.prototype);\n        Object.assign(rv, this);\n        rv.property = property;\n        return rv;\n    }\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */ fromArray(values) {\n        return undefined;\n    }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */ function nameWithProperty(name, lo) {\n    if (lo.property) {\n        return name + \"[\" + lo.property + \"]\";\n    }\n    return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */ // `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction bindConstructorLayout(Class, layout) {\n    if (\"function\" !== typeof Class) {\n        throw new TypeError(\"Class must be constructor\");\n    }\n    if (Object.prototype.hasOwnProperty.call(Class, \"layout_\")) {\n        throw new Error(\"Class is already bound to a layout\");\n    }\n    if (!(layout && layout instanceof Layout)) {\n        throw new TypeError(\"layout must be a Layout\");\n    }\n    if (Object.prototype.hasOwnProperty.call(layout, \"boundConstructor_\")) {\n        throw new Error(\"layout is already bound to a constructor\");\n    }\n    Class.layout_ = layout;\n    layout.boundConstructor_ = Class;\n    layout.makeDestinationObject = ()=>new Class();\n    Object.defineProperty(Class.prototype, \"encode\", {\n        value (b, offset) {\n            return layout.encode(this, b, offset);\n        },\n        writable: true\n    });\n    Object.defineProperty(Class, \"decode\", {\n        value (b, offset) {\n            return layout.decode(b, offset);\n        },\n        writable: true\n    });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */ class ExternalLayout extends Layout {\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */ isCount() {\n        throw new Error(\"ExternalLayout is abstract\");\n    }\n}\nexports.ExternalLayout = ExternalLayout;\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */ class GreedyCount extends ExternalLayout {\n    constructor(elementSpan = 1, property){\n        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n            throw new TypeError(\"elementSpan must be a (positive) integer\");\n        }\n        super(-1, property);\n        /** The layout for individual elements of the sequence.  The value\n         * must be a positive integer.  If not provided, the value will be\n         * 1. */ this.elementSpan = elementSpan;\n    }\n    /** @override */ isCount() {\n        return true;\n    }\n    /** @override */ decode(b, offset = 0) {\n        checkUint8Array(b);\n        const rem = b.length - offset;\n        return Math.floor(rem / this.elementSpan);\n    }\n    /** @override */ encode(src, b, offset) {\n        return 0;\n    }\n}\nexports.GreedyCount = GreedyCount;\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */ class OffsetLayout extends ExternalLayout {\n    constructor(layout, offset = 0, property){\n        if (!(layout instanceof Layout)) {\n            throw new TypeError(\"layout must be a Layout\");\n        }\n        if (!Number.isInteger(offset)) {\n            throw new TypeError(\"offset must be integer or undefined\");\n        }\n        super(layout.span, property || layout.property);\n        /** The subordinated layout. */ this.layout = layout;\n        /** The location of {@link OffsetLayout#layout} relative to the\n         * start of another layout.\n         *\n         * The value may be positive or negative, but an error will thrown\n         * if at the point of use it goes outside the span of the Uint8Array\n         * being accessed.  */ this.offset = offset;\n    }\n    /** @override */ isCount() {\n        return this.layout instanceof UInt || this.layout instanceof UIntBE;\n    }\n    /** @override */ decode(b, offset = 0) {\n        return this.layout.decode(b, offset + this.offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        return this.layout.encode(src, b, offset + this.offset);\n    }\n}\nexports.OffsetLayout = OffsetLayout;\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UInt extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UInt = UInt;\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UIntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UIntBE = UIntBE;\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Int extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.Int = Int;\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class IntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.IntBE = IntBE;\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */ function divmodInt64(src) {\n    const hi32 = Math.floor(src / V2E32);\n    const lo32 = src - hi32 * V2E32;\n    return {\n        hi32,\n        lo32\n    };\n}\n/* Reconstruct Number from quotient and non-negative remainder */ function roundedInt64(hi32, lo32) {\n    return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readUInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeUInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64 = NearUInt64;\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readUInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64BE = NearUInt64BE;\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64 = NearInt64;\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64BE = NearInt64BE;\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Float extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatLE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatLE(src, offset);\n        return 4;\n    }\n}\nexports.Float = Float;\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class FloatBE extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatBE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatBE(src, offset);\n        return 4;\n    }\n}\nexports.FloatBE = FloatBE;\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Double extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleLE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\n        return 8;\n    }\n}\nexports.Double = Double;\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class DoubleBE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleBE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\n        return 8;\n    }\n}\nexports.DoubleBE = DoubleBE;\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Sequence extends Layout {\n    constructor(elementLayout, count, property){\n        if (!(elementLayout instanceof Layout)) {\n            throw new TypeError(\"elementLayout must be a Layout\");\n        }\n        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n            throw new TypeError(\"count must be non-negative integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n            span = count * elementLayout.span;\n        }\n        super(span, property);\n        /** The layout for individual elements of the sequence. */ this.elementLayout = elementLayout;\n        /** The number of elements in the sequence.\n         *\n         * This will be either a non-negative integer or an instance of\n         * {@link ExternalLayout} for which {@link\n         * ExternalLayout#isCount|isCount()} is `true`. */ this.count = count;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        if (0 < this.elementLayout.span) {\n            span = count * this.elementLayout.span;\n        } else {\n            let idx = 0;\n            while(idx < count){\n                span += this.elementLayout.getSpan(b, offset + span);\n                ++idx;\n            }\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const rv = [];\n        let i = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        while(i < count){\n            rv.push(this.elementLayout.decode(b, offset));\n            offset += this.elementLayout.getSpan(b, offset);\n            i += 1;\n        }\n        return rv;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n     *\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n     * the unused space in the buffer is left unchanged.  If `src` is\n     * longer than {@link Sequence#count|count} the unneeded elements are\n     * ignored.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */ encode(src, b, offset = 0) {\n        const elo = this.elementLayout;\n        const span = src.reduce((span, v)=>{\n            return span + elo.encode(v, b, offset + span);\n        }, 0);\n        if (this.count instanceof ExternalLayout) {\n            this.count.encode(src.length, b, offset);\n        }\n        return span;\n    }\n}\nexports.Sequence = Sequence;\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */ class Structure extends Layout {\n    constructor(fields, property, decodePrefixes){\n        if (!(Array.isArray(fields) && fields.reduce((acc, v)=>acc && v instanceof Layout, true))) {\n            throw new TypeError(\"fields must be array of Layout instances\");\n        }\n        if (\"boolean\" === typeof property && undefined === decodePrefixes) {\n            decodePrefixes = property;\n            property = undefined;\n        }\n        /* Verify absence of unnamed variable-length fields. */ for (const fd of fields){\n            if (0 > fd.span && undefined === fd.property) {\n                throw new Error(\"fields cannot contain unnamed variable-length layout\");\n            }\n        }\n        let span = -1;\n        try {\n            span = fields.reduce((span, fd)=>span + fd.getSpan(), 0);\n        } catch (e) {\n        // ignore error\n        }\n        super(span, property);\n        /** The sequence of {@link Layout} values that comprise the\n         * structure.\n         *\n         * The individual elements need not be the same type, and may be\n         * either scalar or aggregate layouts.  If a member layout leaves\n         * its {@link Layout#property|property} undefined the\n         * corresponding region of the buffer associated with the element\n         * will not be mutated.\n         *\n         * @type {Layout[]} */ this.fields = fields;\n        /** Control behavior of {@link Layout#decode|decode()} given short\n         * buffers.\n         *\n         * In some situations a structure many be extended with additional\n         * fields over time, with older installations providing only a\n         * prefix of the full structure.  If this property is `true`\n         * decoding will accept those buffers and leave subsequent fields\n         * undefined, as long as the buffer ends at a field boundary.\n         * Defaults to `false`. */ this.decodePrefixes = !!decodePrefixes;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        try {\n            span = this.fields.reduce((span, fd)=>{\n                const fsp = fd.getSpan(b, offset);\n                offset += fsp;\n                return span + fsp;\n            }, 0);\n        } catch (e) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        checkUint8Array(b);\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b, offset);\n            }\n            offset += fd.getSpan(b, offset);\n            if (this.decodePrefixes && b.length === offset) {\n                break;\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */ encode(src, b, offset = 0) {\n        const firstOffset = offset;\n        let lastOffset = 0;\n        let lastWrote = 0;\n        for (const fd of this.fields){\n            let span = fd.span;\n            lastWrote = 0 < span ? span : 0;\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    lastWrote = fd.encode(fv, b, offset);\n                    if (0 > span) {\n                        /* Read the as-encoded span, which is not necessarily the\n                         * same as what we wrote. */ span = fd.getSpan(b, offset);\n                    }\n                }\n            }\n            lastOffset = offset;\n            offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n         * item may have had a dynamic length and we don't want to include\n         * the padding between it and the end of the space reserved for\n         * it. */ return lastOffset + lastWrote - firstOffset;\n    }\n    /** @override */ fromArray(values) {\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property && 0 < values.length) {\n                dest[fd.property] = values.shift();\n            }\n        }\n        return dest;\n    }\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */ layoutFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */ offsetOf(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        let offset = 0;\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return offset;\n            }\n            if (0 > fd.span) {\n                offset = -1;\n            } else if (0 <= offset) {\n                offset += fd.span;\n            }\n        }\n        return undefined;\n    }\n}\nexports.Structure = Structure;\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */ class UnionDiscriminator {\n    constructor(property){\n        /** The {@link Layout#property|property} to be used when the\n         * discriminator is referenced in isolation (generally when {@link\n         * Union#decode|Union decode} cannot delegate to a specific\n         * variant). */ this.property = property;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n     *\n     * The implementation of this method need not reference the buffer if\n     * variant information is available through other means. */ decode(b, offset) {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */ encode(src, b, offset) {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n}\nexports.UnionDiscriminator = UnionDiscriminator;\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */ class UnionLayoutDiscriminator extends UnionDiscriminator {\n    constructor(layout, property){\n        if (!(layout instanceof ExternalLayout && layout.isCount())) {\n            throw new TypeError(\"layout must be an unsigned integer ExternalLayout\");\n        }\n        super(property || layout.property || \"variant\");\n        /** The {@link ExternalLayout} used to access the discriminator\n         * value. */ this.layout = layout;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */ decode(b, offset) {\n        return this.layout.decode(b, offset);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */ encode(src, b, offset) {\n        return this.layout.encode(src, b, offset);\n    }\n}\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Union extends Layout {\n    constructor(discr, defaultLayout, property){\n        let discriminator;\n        if (discr instanceof UInt || discr instanceof UIntBE) {\n            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n        } else if (discr instanceof ExternalLayout && discr.isCount()) {\n            discriminator = new UnionLayoutDiscriminator(discr);\n        } else if (!(discr instanceof UnionDiscriminator)) {\n            throw new TypeError(\"discr must be a UnionDiscriminator \" + \"or an unsigned integer layout\");\n        } else {\n            discriminator = discr;\n        }\n        if (undefined === defaultLayout) {\n            defaultLayout = null;\n        }\n        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n            throw new TypeError(\"defaultLayout must be null or a Layout\");\n        }\n        if (null !== defaultLayout) {\n            if (0 > defaultLayout.span) {\n                throw new Error(\"defaultLayout must have constant span\");\n            }\n            if (undefined === defaultLayout.property) {\n                defaultLayout = defaultLayout.replicate(\"content\");\n            }\n        }\n        /* The union span can be estimated only if there's a default\n         * layout.  The union spans its default layout, plus any prefix\n         * variant layout.  By construction both layouts, if present, have\n         * non-negative span. */ let span = -1;\n        if (defaultLayout) {\n            span = defaultLayout.span;\n            if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {\n                span += discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The interface for the discriminator value in isolation.\n         *\n         * This a {@link UnionDiscriminator} either passed to the\n         * constructor or synthesized from the `discr` constructor\n         * argument.  {@link\n         * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n         * `true` iff the `discr` parameter was a non-offset {@link\n         * Layout} instance. */ this.discriminator = discriminator;\n        /** `true` if the {@link Union#discriminator|discriminator} is the\n         * first field in the union.\n         *\n         * If `false` the discriminator is obtained from somewhere\n         * else. */ this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;\n        /** The layout for non-discriminator content when the value of the\n         * discriminator is not recognized.\n         *\n         * This is the value passed to the constructor.  It is\n         * structurally equivalent to the second component of {@link\n         * Union#layout|layout} but may have a different property\n         * name. */ this.defaultLayout = defaultLayout;\n        /** A registry of allowed variants.\n         *\n         * The keys are unsigned integers which should be compatible with\n         * {@link Union.discriminator|discriminator}.  The property value\n         * is the corresponding {@link VariantLayout} instances assigned\n         * to this union by {@link Union#addVariant|addVariant}.\n         *\n         * **NOTE** The registry remains mutable so that variants can be\n         * {@link Union#addVariant|added} at any time.  Users should not\n         * manipulate the content of this property. */ this.registry = {};\n        /* Private variable used when invoking getSourceVariant */ let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n        /** Function to infer the variant selected by a source object.\n         *\n         * Defaults to {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n         * be overridden using {@link\n         * Union#configGetSourceVariant|configGetSourceVariant}.\n         *\n         * @param {Object} src - as with {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * @returns {(undefined|VariantLayout)} The default variant\n         * (`undefined`) or first registered variant that uses a property\n         * available in `src`. */ this.getSourceVariant = function(src) {\n            return boundGetSourceVariant(src);\n        };\n        /** Function to override the implementation of {@link\n         * Union#getSourceVariant|getSourceVariant}.\n         *\n         * Use this if the desired variant cannot be identified using the\n         * algorithm of {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * **NOTE** The provided function will be invoked bound to this\n         * Union instance, providing local access to {@link\n         * Union#registry|registry}.\n         *\n         * @param {Function} gsv - a function that follows the API of\n         * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */ this.configGetSourceVariant = function(gsv) {\n            boundGetSourceVariant = gsv.bind(this);\n        };\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        /* Default layouts always have non-negative span, so we don't have\n         * one and we have to recognize the variant which will in turn\n         * determine the span. */ const vlo = this.getVariant(b, offset);\n        if (!vlo) {\n            throw new Error(\"unable to determine span for unrecognized variant\");\n        }\n        return vlo.getSpan(b, offset);\n    }\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisfied rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */ defaultGetSourceVariant(src) {\n        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n                return undefined;\n            }\n            const vlo = this.registry[src[this.discriminator.property]];\n            if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {\n                return vlo;\n            }\n        } else {\n            for(const tag in this.registry){\n                const vlo = this.registry[tag];\n                if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n                    return vlo;\n                }\n            }\n        }\n        throw new Error(\"unable to infer src variant\");\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */ decode(b, offset = 0) {\n        let dest;\n        const dlo = this.discriminator;\n        const discr = dlo.decode(b, offset);\n        const clo = this.registry[discr];\n        if (undefined === clo) {\n            const defaultLayout = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dest = this.makeDestinationObject();\n            dest[dlo.property] = discr;\n            // defaultLayout.property can be undefined, but this is allowed by buffer-layout\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\n        } else {\n            dest = clo.decode(b, offset);\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */ encode(src, b, offset = 0) {\n        const vlo = this.getSourceVariant(src);\n        if (undefined === vlo) {\n            const dlo = this.discriminator;\n            // this.defaultLayout is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const clo = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dlo.encode(src[dlo.property], b, offset);\n            // clo.property is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n        }\n        return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */ addVariant(variant, layout, property) {\n        const rv = new VariantLayout(this, variant, layout, property);\n        this.registry[variant] = rv;\n        return rv;\n    }\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Uint8Array)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Uint8Array}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */ getVariant(vb, offset = 0) {\n        let variant;\n        if (vb instanceof Uint8Array) {\n            variant = this.discriminator.decode(vb, offset);\n        } else {\n            variant = vb;\n        }\n        return this.registry[variant];\n    }\n}\nexports.Union = Union;\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */ class VariantLayout extends Layout {\n    constructor(union, variant, layout, property){\n        if (!(union instanceof Union)) {\n            throw new TypeError(\"union must be a Union\");\n        }\n        if (!Number.isInteger(variant) || 0 > variant) {\n            throw new TypeError(\"variant must be a (non-negative) integer\");\n        }\n        if (\"string\" === typeof layout && undefined === property) {\n            property = layout;\n            layout = null;\n        }\n        if (layout) {\n            if (!(layout instanceof Layout)) {\n                throw new TypeError(\"layout must be a Layout\");\n            }\n            if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n                throw new Error(\"variant span exceeds span of containing union\");\n            }\n            if (\"string\" !== typeof property) {\n                throw new TypeError(\"variant must have a String property\");\n            }\n        }\n        let span = union.span;\n        if (0 > union.span) {\n            span = layout ? layout.span : 0;\n            if (0 <= span && union.usesPrefixDiscriminator) {\n                span += union.discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The {@link Union} to which this variant belongs. */ this.union = union;\n        /** The unsigned integral value identifying this variant within\n         * the {@link Union#discriminator|discriminator} of the containing\n         * union. */ this.variant = variant;\n        /** The {@link Layout} to be used when reading/writing the\n         * non-discriminator part of the {@link\n         * VariantLayout#union|union}.  If `null` the variant carries no\n         * data. */ this.layout = layout || null;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            /* Will be equal to the containing union span if that is not\n             * variable. */ return this.span;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        /* Span is defined solely by the variant (and prefix discriminator) */ let span = 0;\n        if (this.layout) {\n            span = this.layout.getSpan(b, offset + contentOffset);\n        }\n        return contentOffset + span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        if (this !== this.union.getVariant(b, offset)) {\n            throw new Error(\"variant mismatch\");\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout) {\n            dest[this.property] = this.layout.decode(b, offset + contentOffset);\n        } else if (this.property) {\n            dest[this.property] = true;\n        } else if (this.union.usesPrefixDiscriminator) {\n            dest[this.union.discriminator.property] = this.variant;\n        }\n        return dest;\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {\n            throw new TypeError(\"variant lacks property \" + this.property);\n        }\n        this.union.discriminator.encode(this.variant, b, offset);\n        let span = contentOffset;\n        if (this.layout) {\n            this.layout.encode(src[this.property], b, offset + contentOffset);\n            span += this.layout.getSpan(b, offset + contentOffset);\n            if (0 <= this.union.span && span > this.union.span) {\n                throw new Error(\"encoded variant overruns containing union\");\n            }\n        }\n        return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */ fromArray(values) {\n        if (this.layout) {\n            return this.layout.fromArray(values);\n        }\n        return undefined;\n    }\n}\nexports.VariantLayout = VariantLayout;\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */ function fixBitwiseResult(v) {\n    if (0 > v) {\n        v += 0x100000000;\n    }\n    return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class BitStructure extends Layout {\n    constructor(word, msb, property){\n        if (!(word instanceof UInt || word instanceof UIntBE)) {\n            throw new TypeError(\"word must be a UInt or UIntBE layout\");\n        }\n        if (\"string\" === typeof msb && undefined === property) {\n            property = msb;\n            msb = false;\n        }\n        if (4 < word.span) {\n            throw new RangeError(\"word cannot exceed 32 bits\");\n        }\n        super(word.span, property);\n        /** The layout used for the packed value.  {@link BitField}\n         * instances are packed sequentially depending on {@link\n         * BitStructure#msb|msb}. */ this.word = word;\n        /** Whether the bit sequences are packed starting at the most\n         * significant bit growing down (`true`), or the least significant\n         * bit growing up (`false`).\n         *\n         * **NOTE** Regardless of this value, the least significant bit of\n         * any {@link BitField} value is the least significant bit of the\n         * corresponding section of the packed value. */ this.msb = !!msb;\n        /** The sequence of {@link BitField} layouts that comprise the\n         * packed structure.\n         *\n         * **NOTE** The array remains mutable to allow fields to be {@link\n         * BitStructure#addField|added} after construction.  Users should\n         * not manipulate the content of this property.*/ this.fields = [];\n        /* Storage for the value.  Capture a variable instead of using an\n         * instance property because we don't want anything to change the\n         * value without going through the mutator. */ let value = 0;\n        this._packedSetValue = function(v) {\n            value = fixBitwiseResult(v);\n            return this;\n        };\n        this._packedGetValue = function() {\n            return value;\n        };\n    }\n    /** @override */ decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b);\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the packed\n     * value is left unmodified.  Unused bits are also left unmodified. */ encode(src, b, offset = 0) {\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    fd.encode(fv);\n                }\n            }\n        }\n        return this.word.encode(this._packedGetValue(), b, offset);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n     * resulting bitfield is returned.\n     *\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {BitField} */ addField(bits, property) {\n        const bf = new BitField(this, bits, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n     * fields with `boolean` value representation.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {Boolean} */ // `Boolean` conflicts with the native primitive type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    addBoolean(property) {\n        // This is my Boolean, not the Javascript one.\n        const bf = new Boolean(this, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /**\n     * Get access to the bit field for a given property.\n     *\n     * @param {String} property - the bit field of interest.\n     *\n     * @return {BitField} - the field associated with `property`, or\n     * undefined if there is no such property.\n     */ fieldFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n}\nexports.BitStructure = BitStructure;\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */ class BitField {\n    constructor(container, bits, property){\n        if (!(container instanceof BitStructure)) {\n            throw new TypeError(\"container must be a BitStructure\");\n        }\n        if (!Number.isInteger(bits) || 0 >= bits) {\n            throw new TypeError(\"bits must be positive integer\");\n        }\n        const totalBits = 8 * container.span;\n        const usedBits = container.fields.reduce((sum, fd)=>sum + fd.bits, 0);\n        if (bits + usedBits > totalBits) {\n            throw new Error(\"bits too long for span remainder (\" + (totalBits - usedBits) + \" of \" + totalBits + \" remain)\");\n        }\n        /** The {@link BitStructure} instance to which this bit field\n         * belongs. */ this.container = container;\n        /** The span of this value in bits. */ this.bits = bits;\n        /** A mask of {@link BitField#bits|bits} bits isolating value bits\n         * that fit within the field.\n         *\n         * That is, it masks a value that has not yet been shifted into\n         * position within its containing packed integer. */ this.valueMask = (1 << bits) - 1;\n        if (32 === bits) {\n            this.valueMask = 0xFFFFFFFF;\n        }\n        /** The offset of the value within the containing packed unsigned\n         * integer.  The least significant bit of the packed value is at\n         * offset zero, regardless of bit ordering used. */ this.start = usedBits;\n        if (this.container.msb) {\n            this.start = totalBits - usedBits - bits;\n        }\n        /** A mask of {@link BitField#bits|bits} isolating the field value\n         * within the containing packed unsigned integer. */ this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n        /** The property name used when this bitfield is represented in an\n         * Object.\n         *\n         * Intended to be functionally equivalent to {@link\n         * Layout#property}.\n         *\n         * If left undefined the corresponding span of bits will be\n         * treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */ this.property = property;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field. */ decode(b, offset) {\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(word & this.wordMask);\n        const value = wordValue >>> this.start;\n        return value;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field.\n     *\n     * **NOTE** This is not a specialization of {@link\n     * Layout#encode|Layout.encode} and there is no return value. */ encode(value) {\n        if (\"number\" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n            throw new TypeError(nameWithProperty(\"BitField.encode\", this) + \" value must be integer not exceeding \" + this.valueMask);\n        }\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(value << this.start);\n        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n    }\n}\nexports.BitField = BitField;\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */ /* eslint-disable no-extend-native */ class Boolean extends BitField {\n    constructor(container, property){\n        super(container, 1, property);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n     *\n     * @returns {boolean} */ decode(b, offset) {\n        return !!super.decode(b, offset);\n    }\n    /** @override */ encode(value) {\n        if (\"boolean\" === typeof value) {\n            // BitField requires integer values\n            value = +value;\n        }\n        super.encode(value);\n    }\n}\nexports.Boolean = Boolean;\n/* eslint-enable no-extend-native */ /**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Uint8Array.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Blob extends Layout {\n    constructor(length, property){\n        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n            throw new TypeError(\"length must be positive integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(length instanceof ExternalLayout)) {\n            span = length;\n        }\n        super(span, property);\n        /** The number of bytes in the blob.\n         *\n         * This may be a non-negative integer, or an instance of {@link\n         * ExternalLayout} that satisfies {@link\n         * ExternalLayout#isCount|isCount()}. */ this.length = length;\n    }\n    /** @override */ getSpan(b, offset) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */ encode(src, b, offset) {\n        let span = this.length;\n        if (this.length instanceof ExternalLayout) {\n            span = src.length;\n        }\n        if (!(src instanceof Uint8Array && span === src.length)) {\n            throw new TypeError(nameWithProperty(\"Blob.encode\", this) + \" requires (length \" + span + \") Uint8Array as src\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Uint8Array\");\n        }\n        const srcBuffer = uint8ArrayToBuffer(src);\n        uint8ArrayToBuffer(b).write(srcBuffer.toString(\"hex\"), offset, span, \"hex\");\n        if (this.length instanceof ExternalLayout) {\n            this.length.encode(span, b, offset);\n        }\n        return span;\n    }\n}\nexports.Blob = Blob;\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class CString extends Layout {\n    constructor(property){\n        super(-1, property);\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        let idx = offset;\n        while(idx < b.length && 0 !== b[idx]){\n            idx += 1;\n        }\n        return 1 + idx - offset;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */ if (\"string\" !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, \"utf8\");\n        const span = srcb.length;\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        const buffer = uint8ArrayToBuffer(b);\n        srcb.copy(buffer, offset);\n        buffer[offset + span] = 0;\n        return span + 1;\n    }\n}\nexports.CString = CString;\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UTF8 extends Layout {\n    constructor(maxSpan, property){\n        if (\"string\" === typeof maxSpan && undefined === property) {\n            property = maxSpan;\n            maxSpan = undefined;\n        }\n        if (undefined === maxSpan) {\n            maxSpan = -1;\n        } else if (!Number.isInteger(maxSpan)) {\n            throw new TypeError(\"maxSpan must be an integer\");\n        }\n        super(-1, property);\n        /** The maximum span of the layout in bytes.\n         *\n         * Positive values are generally expected.  Zero is abnormal.\n         * Attempts to encode or decode a value that exceeds this length\n         * will throw a `RangeError`.\n         *\n         * A negative value indicates that there is no bound on the length\n         * of the content. */ this.maxSpan = maxSpan;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        return b.length - offset;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */ if (\"string\" !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, \"utf8\");\n        const span = srcb.length;\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        srcb.copy(uint8ArrayToBuffer(b), offset);\n        return span;\n    }\n}\nexports.UTF8 = UTF8;\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Constant extends Layout {\n    constructor(value, property){\n        super(0, property);\n        /** The value produced by this constant when the layout is {@link\n         * Constant#decode|decoded}.\n         *\n         * Any JavaScript value including `null` and `undefined` is\n         * permitted.\n         *\n         * **WARNING** If `value` passed in the constructor was not\n         * frozen, it is possible for users of decoded values to change\n         * the content of the value. */ this.value = value;\n    }\n    /** @override */ decode(b, offset) {\n        return this.value;\n    }\n    /** @override */ encode(src, b, offset) {\n        /* Constants take no space */ return 0;\n    }\n}\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */ exports.greedy = (elementSpan, property)=>new GreedyCount(elementSpan, property);\n/** Factory for {@link OffsetLayout}. */ exports.offset = (layout, offset, property)=>new OffsetLayout(layout, offset, property);\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */ exports.u8 = (property)=>new UInt(1, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16 = (property)=>new UInt(2, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24 = (property)=>new UInt(3, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32 = (property)=>new UInt(4, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40 = (property)=>new UInt(5, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48 = (property)=>new UInt(6, property);\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64 = (property)=>new NearUInt64(property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16be = (property)=>new UIntBE(2, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24be = (property)=>new UIntBE(3, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32be = (property)=>new UIntBE(4, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40be = (property)=>new UIntBE(5, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48be = (property)=>new UIntBE(6, property);\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64be = (property)=>new NearUInt64BE(property);\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */ exports.s8 = (property)=>new Int(1, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */ exports.s16 = (property)=>new Int(2, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */ exports.s24 = (property)=>new Int(3, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */ exports.s32 = (property)=>new Int(4, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */ exports.s40 = (property)=>new Int(5, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */ exports.s48 = (property)=>new Int(6, property);\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64 = (property)=>new NearInt64(property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */ exports.s16be = (property)=>new IntBE(2, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */ exports.s24be = (property)=>new IntBE(3, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */ exports.s32be = (property)=>new IntBE(4, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */ exports.s40be = (property)=>new IntBE(5, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */ exports.s48be = (property)=>new IntBE(6, property);\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64be = (property)=>new NearInt64BE(property);\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */ exports.f32 = (property)=>new Float(property);\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */ exports.f32be = (property)=>new FloatBE(property);\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */ exports.f64 = (property)=>new Double(property);\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */ exports.f64be = (property)=>new DoubleBE(property);\n/** Factory for {@link Structure} values. */ exports.struct = (fields, property, decodePrefixes)=>new Structure(fields, property, decodePrefixes);\n/** Factory for {@link BitStructure} values. */ exports.bits = (word, msb, property)=>new BitStructure(word, msb, property);\n/** Factory for {@link Sequence} values. */ exports.seq = (elementLayout, count, property)=>new Sequence(elementLayout, count, property);\n/** Factory for {@link Union} values. */ exports.union = (discr, defaultLayout, property)=>new Union(discr, defaultLayout, property);\n/** Factory for {@link UnionLayoutDiscriminator} values. */ exports.unionLayoutDiscriminator = (layout, property)=>new UnionLayoutDiscriminator(layout, property);\n/** Factory for {@link Blob} values. */ exports.blob = (length, property)=>new Blob(length, property);\n/** Factory for {@link CString} values. */ exports.cstr = (property)=>new CString(property);\n/** Factory for {@link UTF8} values. */ exports.utf8 = (maxSpan, property)=>new UTF8(maxSpan, property);\n/** Factory for {@link Constant} values. */ exports.constant = (value, property)=>new Constant(value, property); //# sourceMappingURL=Layout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9idWZmZXItbGF5b3V0L2xpYi9MYXlvdXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJHQyxHQUNEO0FBQ0FBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxXQUFXLEdBQUdBLFVBQVUsR0FBR0EsY0FBYyxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsWUFBWSxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsVUFBVSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsZ0JBQWdCLEdBQUdBLFlBQVksR0FBR0EsZUFBZSxHQUFHQSxZQUFZLEdBQUdBLGVBQWUsR0FBR0EsZ0JBQWdCLEdBQUdBLG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxnQ0FBZ0MsR0FBR0EsMEJBQTBCLEdBQUdBLGlCQUFpQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGNBQWMsR0FBR0EsZUFBZSxHQUFHQSxhQUFhLEdBQUdBLG1CQUFtQixHQUFHQSxpQkFBaUIsR0FBR0Esb0JBQW9CLEdBQUdBLGtCQUFrQixHQUFHQSxhQUFhLEdBQUdBLFdBQVcsR0FBR0EsY0FBYyxHQUFHQSxZQUFZLEdBQUdBLG9CQUFvQixHQUFHQSxtQkFBbUIsR0FBR0Esc0JBQXNCLEdBQUdBLDZCQUE2QixHQUFHQSx3QkFBd0IsR0FBR0EsY0FBYyxHQUFHQSwwQkFBMEIsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUN0N0JBLGdCQUFnQixH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QUFDekQseUNBQXlDLEdBQ3pDeEYsZ0JBQWdCLEdBQUksQ0FBQ0MsT0FBT3VGLFdBQWEsSUFBSXJFLFNBQVNsQixPQUFPdUYsV0FDN0Qsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9idWZmZXItbGF5b3V0L2xpYi9MYXlvdXQuanM/NjdkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IFBldGVyIEEuIEJpZ290XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqXG4gKiBTdXBwb3J0IGZvciB0cmFuc2xhdGluZyBiZXR3ZWVuIFVpbnQ4QXJyYXkgaW5zdGFuY2VzIGFuZCBKYXZhU2NyaXB0XG4gKiBuYXRpdmUgdHlwZXMuXG4gKlxuICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH0gaXMgdGhlIGJhc2lzIG9mIGEgY2xhc3NcbiAqIGhpZXJhcmNoeSB0aGF0IGFzc29jaWF0ZXMgcHJvcGVydHkgbmFtZXMgd2l0aCBzZXF1ZW5jZXMgb2YgZW5jb2RlZFxuICogYnl0ZXMuXG4gKlxuICogTGF5b3V0cyBhcmUgc3VwcG9ydGVkIGZvciB0aGVzZSBzY2FsYXIgKG51bWVyaWMpIHR5cGVzOlxuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5VSW50fFVuc2lnbmVkIGludGVnZXJzIGluIGxpdHRsZS1lbmRpYW5cbiAqICAgZm9ybWF0fSB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnU4fDgtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTE2fDE2LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUyNHwyNC1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJ8MzItYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTQwfDQwLWJpdH0sIGFuZCB7QGxpbmsgbW9kdWxlOkxheW91dC51NDh8NDgtYml0fVxuICogICByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0flVJbnRCRXxVbnNpZ25lZCBpbnRlZ2VycyBpbiBiaWctZW5kaWFuXG4gKiAgIGZvcm1hdH0gd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC51MTZiZXwxNi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51MjRiZXwyNC1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJiZXwzMi1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC51NDBiZXw0MC1iaXR9LCBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTQ4YmV8NDgtYml0fSByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0fkludHxTaWduZWQgaW50ZWdlcnMgaW4gbGl0dGxlLWVuZGlhblxuICogICBmb3JtYXR9IHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQuczh8OC1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zMTZ8MTYtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0fDI0LWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnMzMnwzMi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zNDB8NDAtYml0fSwgYW5kIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0OHw0OC1iaXR9XG4gKiAgIHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+SW50QkV8U2lnbmVkIGludGVnZXJzIGluIGJpZy1lbmRpYW4gZm9ybWF0fVxuICogICB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnMxNmJlfDE2LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnMyNGJlfDI0LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnMzMmJlfDMyLWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0MGJlfDQwLWJpdH0sIGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zNDhiZXw0OC1iaXR9IHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICogNjQtYml0IGludGVncmFsIHZhbHVlcyB0aGF0IGRlY29kZSB0byBhbiBleGFjdCAoaWYgbWFnbml0dWRlIGlzXG4gKiAgIGxlc3MgdGhhbiAyXjUzKSBvciBuZWFyYnkgaW50ZWdyYWwgTnVtYmVyIGluIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm51NjR8dW5zaWduZWQgbGl0dGxlLWVuZGlhbn0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm51NjRiZXx1bnNpZ25lZCBiaWctZW5kaWFufSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnM2NHxzaWduZWQgbGl0dGxlLWVuZGlhbn0sIGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5uczY0YmV8dW5zaWduZWQgYmlnLWVuZGlhbn0gZW5jb2RpbmdzO1xuICogKiAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgdmFsdWVzIHdpdGgge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjMyfGxpdHRsZS1lbmRpYW59IGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mMzJiZXxiaWctZW5kaWFufSByZXByZXNlbnRhdGlvbnM7XG4gKiAqIDY0LWJpdCBmbG9hdGluZyBwb2ludCB2YWx1ZXMgd2l0aCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mNjR8bGl0dGxlLWVuZGlhbn0gYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmY2NGJlfGJpZy1lbmRpYW59IHJlcHJlc2VudGF0aW9ucztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuY29uc3R8Q29uc3RhbnRzfSB0aGF0IHRha2Ugbm8gc3BhY2UgaW4gdGhlXG4gKiAgIGVuY29kZWQgZXhwcmVzc2lvbi5cbiAqXG4gKiBhbmQgZm9yIHRoZXNlIGFnZ3JlZ2F0ZSB0eXBlczpcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc2VxfFNlcXVlbmNlfXMgb2YgaW5zdGFuY2VzIG9mIGEge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH0sIHdpdGggSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBhc1xuICogICBhbiBBcnJheSBhbmQgY29uc3RhbnQgb3IgZGF0YS1kZXBlbmRlbnQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+U2VxdWVuY2UjY291bnR8bGVuZ3RofTtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc3RydWN0fFN0cnVjdHVyZX1zIHRoYXQgYWdncmVnYXRlIGFcbiAqICAgaGV0ZXJvZ2VuZW91cyBzZXF1ZW5jZSBvZiB7QGxpbmsgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fVxuICogICBpbnN0YW5jZXMsIHdpdGggSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBhcyBhbiBPYmplY3Q7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnVuaW9ufFVuaW9ufXMgdGhhdCBzdXBwb3J0IG11bHRpcGxlIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0flZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXRzfSBvdmVyIGEgZml4ZWRcbiAqICAgKHBhZGRlZCkgb3IgdmFyaWFibGUgKG5vdCBwYWRkZWQpIHNwYW4gb2YgYnl0ZXMsIHVzaW5nIGFuXG4gKiAgIHVuc2lnbmVkIGludGVnZXIgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkYXRhIG9yIGEgc2VwYXJhdGUge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudW5pb25MYXlvdXREaXNjcmltaW5hdG9yfGxheW91dCBlbGVtZW50fSB0b1xuICogICBkZXRlcm1pbmUgd2hpY2ggbGF5b3V0IHRvIHVzZSB3aGVuIGludGVycHJldGluZyB0aGUgYnVmZmVyXG4gKiAgIGNvbnRlbnRzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5iaXRzfEJpdFN0cnVjdHVyZX1zIHRoYXQgY29udGFpbiBhIHNlcXVlbmNlXG4gKiAgIG9mIGluZGl2aWR1YWwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+Qml0U3RydWN0dXJlI2FkZEZpZWxkfEJpdEZpZWxkfXMgcGFja2VkIGludG8gYW4gOCxcbiAqICAgMTYsIDI0LCBvciAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciBzdGFydGluZyBhdCB0aGUgbGVhc3QtIG9yXG4gKiAgIG1vc3Qtc2lnbmlmaWNhbnQgYml0O1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5jc3RyfEMgc3RyaW5nc30gb2YgdmFyeWluZyBsZW5ndGg7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmJsb2J8QmxvYnN9IG9mIGZpeGVkLSBvciB2YXJpYWJsZS17QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5CbG9iI2xlbmd0aHxsZW5ndGh9IHJhdyBkYXRhLlxuICpcbiAqIEFsbCB7QGxpbmsgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fSBpbnN0YW5jZXMgYXJlIGltbXV0YWJsZVxuICogYWZ0ZXIgY29uc3RydWN0aW9uLCB0byBwcmV2ZW50IGludGVybmFsIHN0YXRlIGZyb20gYmVjb21pbmdcbiAqIGluY29uc2lzdGVudC5cbiAqXG4gKiBAbG9jYWwgTGF5b3V0XG4gKiBAbG9jYWwgRXh0ZXJuYWxMYXlvdXRcbiAqIEBsb2NhbCBHcmVlZHlDb3VudFxuICogQGxvY2FsIE9mZnNldExheW91dFxuICogQGxvY2FsIFVJbnRcbiAqIEBsb2NhbCBVSW50QkVcbiAqIEBsb2NhbCBJbnRcbiAqIEBsb2NhbCBJbnRCRVxuICogQGxvY2FsIE5lYXJVSW50NjRcbiAqIEBsb2NhbCBOZWFyVUludDY0QkVcbiAqIEBsb2NhbCBOZWFySW50NjRcbiAqIEBsb2NhbCBOZWFySW50NjRCRVxuICogQGxvY2FsIEZsb2F0XG4gKiBAbG9jYWwgRmxvYXRCRVxuICogQGxvY2FsIERvdWJsZVxuICogQGxvY2FsIERvdWJsZUJFXG4gKiBAbG9jYWwgU2VxdWVuY2VcbiAqIEBsb2NhbCBTdHJ1Y3R1cmVcbiAqIEBsb2NhbCBVbmlvbkRpc2NyaW1pbmF0b3JcbiAqIEBsb2NhbCBVbmlvbkxheW91dERpc2NyaW1pbmF0b3JcbiAqIEBsb2NhbCBVbmlvblxuICogQGxvY2FsIFZhcmlhbnRMYXlvdXRcbiAqIEBsb2NhbCBCaXRTdHJ1Y3R1cmVcbiAqIEBsb2NhbCBCaXRGaWVsZFxuICogQGxvY2FsIEJvb2xlYW5cbiAqIEBsb2NhbCBCbG9iXG4gKiBAbG9jYWwgQ1N0cmluZ1xuICogQGxvY2FsIENvbnN0YW50XG4gKiBAbG9jYWwgYmluZENvbnN0cnVjdG9yTGF5b3V0XG4gKiBAbW9kdWxlIExheW91dFxuICogQGxpY2Vuc2UgTUlUXG4gKiBAYXV0aG9yIFBldGVyIEEuIEJpZ290XG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGFiaWdvdC9idWZmZXItbGF5b3V0fGJ1ZmZlci1sYXlvdXQgb24gR2l0SHVifVxuICovXG4ndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnMxNiA9IGV4cG9ydHMuczggPSBleHBvcnRzLm51NjRiZSA9IGV4cG9ydHMudTQ4YmUgPSBleHBvcnRzLnU0MGJlID0gZXhwb3J0cy51MzJiZSA9IGV4cG9ydHMudTI0YmUgPSBleHBvcnRzLnUxNmJlID0gZXhwb3J0cy5udTY0ID0gZXhwb3J0cy51NDggPSBleHBvcnRzLnU0MCA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51MjQgPSBleHBvcnRzLnUxNiA9IGV4cG9ydHMudTggPSBleHBvcnRzLm9mZnNldCA9IGV4cG9ydHMuZ3JlZWR5ID0gZXhwb3J0cy5Db25zdGFudCA9IGV4cG9ydHMuVVRGOCA9IGV4cG9ydHMuQ1N0cmluZyA9IGV4cG9ydHMuQmxvYiA9IGV4cG9ydHMuQm9vbGVhbiA9IGV4cG9ydHMuQml0RmllbGQgPSBleHBvcnRzLkJpdFN0cnVjdHVyZSA9IGV4cG9ydHMuVmFyaWFudExheW91dCA9IGV4cG9ydHMuVW5pb24gPSBleHBvcnRzLlVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IGV4cG9ydHMuVW5pb25EaXNjcmltaW5hdG9yID0gZXhwb3J0cy5TdHJ1Y3R1cmUgPSBleHBvcnRzLlNlcXVlbmNlID0gZXhwb3J0cy5Eb3VibGVCRSA9IGV4cG9ydHMuRG91YmxlID0gZXhwb3J0cy5GbG9hdEJFID0gZXhwb3J0cy5GbG9hdCA9IGV4cG9ydHMuTmVhckludDY0QkUgPSBleHBvcnRzLk5lYXJJbnQ2NCA9IGV4cG9ydHMuTmVhclVJbnQ2NEJFID0gZXhwb3J0cy5OZWFyVUludDY0ID0gZXhwb3J0cy5JbnRCRSA9IGV4cG9ydHMuSW50ID0gZXhwb3J0cy5VSW50QkUgPSBleHBvcnRzLlVJbnQgPSBleHBvcnRzLk9mZnNldExheW91dCA9IGV4cG9ydHMuR3JlZWR5Q291bnQgPSBleHBvcnRzLkV4dGVybmFsTGF5b3V0ID0gZXhwb3J0cy5iaW5kQ29uc3RydWN0b3JMYXlvdXQgPSBleHBvcnRzLm5hbWVXaXRoUHJvcGVydHkgPSBleHBvcnRzLkxheW91dCA9IGV4cG9ydHMudWludDhBcnJheVRvQnVmZmVyID0gZXhwb3J0cy5jaGVja1VpbnQ4QXJyYXkgPSB2b2lkIDA7XG5leHBvcnRzLmNvbnN0YW50ID0gZXhwb3J0cy51dGY4ID0gZXhwb3J0cy5jc3RyID0gZXhwb3J0cy5ibG9iID0gZXhwb3J0cy51bmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSBleHBvcnRzLnVuaW9uID0gZXhwb3J0cy5zZXEgPSBleHBvcnRzLmJpdHMgPSBleHBvcnRzLnN0cnVjdCA9IGV4cG9ydHMuZjY0YmUgPSBleHBvcnRzLmY2NCA9IGV4cG9ydHMuZjMyYmUgPSBleHBvcnRzLmYzMiA9IGV4cG9ydHMubnM2NGJlID0gZXhwb3J0cy5zNDhiZSA9IGV4cG9ydHMuczQwYmUgPSBleHBvcnRzLnMzMmJlID0gZXhwb3J0cy5zMjRiZSA9IGV4cG9ydHMuczE2YmUgPSBleHBvcnRzLm5zNjQgPSBleHBvcnRzLnM0OCA9IGV4cG9ydHMuczQwID0gZXhwb3J0cy5zMzIgPSBleHBvcnRzLnMyNCA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbi8qIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBVaW50OEFycmF5LlxuICpcbiAqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIGNoZWNrVWludDhBcnJheShiKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2IgbXVzdCBiZSBhIFVpbnQ4QXJyYXknKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVWludDhBcnJheSA9IGNoZWNrVWludDhBcnJheTtcbi8qIENyZWF0ZSBhIEJ1ZmZlciBpbnN0YW5jZSBmcm9tIGEgVWludDhBcnJheS5cbiAqXG4gKiBAaWdub3JlICovXG5mdW5jdGlvbiB1aW50OEFycmF5VG9CdWZmZXIoYikge1xuICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20oYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5sZW5ndGgpO1xufVxuZXhwb3J0cy51aW50OEFycmF5VG9CdWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXI7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGxheW91dCBvYmplY3RzLlxuICpcbiAqICoqTk9URSoqIFRoaXMgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzczsgeW91IGNhbiBjcmVhdGUgaW5zdGFuY2VzXG4gKiBpZiBpdCBhbXVzZXMgeW91LCBidXQgdGhleSB3b24ndCBzdXBwb3J0IHRoZSB7QGxpbmtcbiAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBvciB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIEluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uICBUaGVcbiAqIHBhcmFtZXRlciBtdXN0IGJlIGFuIGludGVnZXI7IGEgbmVnYXRpdmUgdmFsdWUgc2lnbmlmaWVzIHRoYXQgdGhlXG4gKiBzcGFuIGlzIHtAbGluayBMYXlvdXQjZ2V0U3Bhbnx2YWx1ZS1zcGVjaWZpY30uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBJbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzcGFuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3BhbiBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogVGhlIHNwYW4gb2YgdGhlIGxheW91dCBpbiBieXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogUG9zaXRpdmUgdmFsdWVzIGFyZSBnZW5lcmFsbHkgZXhwZWN0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFplcm8gd2lsbCBvbmx5IGFwcGVhciBpbiB7QGxpbmsgQ29uc3RhbnR9cyBhbmQgaW4ge0BsaW5rXG4gICAgICAgICAqIFNlcXVlbmNlfXMgd2hlcmUgdGhlIHtAbGluayBTZXF1ZW5jZSNjb3VudHxjb3VudH0gaXMgemVyby5cbiAgICAgICAgICpcbiAgICAgICAgICogQSBuZWdhdGl2ZSB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgc3BhbiBpcyB2YWx1ZS1zcGVjaWZpYywgYW5kXG4gICAgICAgICAqIG11c3QgYmUgb2J0YWluZWQgdXNpbmcge0BsaW5rIExheW91dCNnZXRTcGFufGdldFNwYW59LiAqL1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICAvKiogVGhlIHByb3BlcnR5IG5hbWUgdXNlZCB3aGVuIHRoaXMgbGF5b3V0IGlzIHJlcHJlc2VudGVkIGluIGFuXG4gICAgICAgICAqIE9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlZCBvbmx5IGZvciBsYXlvdXRzIHRoYXQge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSB0byBPYmplY3RcbiAgICAgICAgICogaW5zdGFuY2VzLiAgSWYgbGVmdCB1bmRlZmluZWQgdGhlIHNwYW4gb2YgdGhlIHVubmFtZWQgbGF5b3V0IHdpbGxcbiAgICAgICAgICogYmUgdHJlYXRlZCBhcyBwYWRkaW5nOiBpdCB3aWxsIG5vdCBiZSBtdXRhdGVkIGJ5IHtAbGlua1xuICAgICAgICAgKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gbm9yIHJlcHJlc2VudGVkIGFzIGEgcHJvcGVydHkgaW4gdGhlXG4gICAgICAgICAqIGRlY29kZWQgT2JqZWN0LiAqL1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgfVxuICAgIC8qKiBGdW5jdGlvbiB0byBjcmVhdGUgYW4gT2JqZWN0IGludG8gd2hpY2ggZGVjb2RlZCBwcm9wZXJ0aWVzIHdpbGxcbiAgICAgKiBiZSB3cml0dGVuLlxuICAgICAqXG4gICAgICogVXNlZCBvbmx5IGZvciBsYXlvdXRzIHRoYXQge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSB0byBPYmplY3RcbiAgICAgKiBpbnN0YW5jZXMsIHdoaWNoIG1lYW5zOlxuICAgICAqICoge0BsaW5rIFN0cnVjdHVyZX1cbiAgICAgKiAqIHtAbGluayBVbmlvbn1cbiAgICAgKiAqIHtAbGluayBWYXJpYW50TGF5b3V0fVxuICAgICAqICoge0BsaW5rIEJpdFN0cnVjdHVyZX1cbiAgICAgKlxuICAgICAqIElmIGxlZnQgdW5kZWZpbmVkIHRoZSBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIHRoZXNlIGxheW91dHNcbiAgICAgKiB3aWxsIGJlIE9iamVjdCBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIGJpbmRDb25zdHJ1Y3RvckxheW91dH0uXG4gICAgICovXG4gICAgbWFrZURlc3RpbmF0aW9uT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc3BhbiBvZiBhIHNwZWNpZmljIGluc3RhbmNlIG9mIGEgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBiIC0gdGhlIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIGFuIGVuY29kZWQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldF0gLSB0aGUgb2Zmc2V0IGF0IHdoaWNoIHRoZSBlbmNvZGVkIGluc3RhbmNlXG4gICAgICogc3RhcnRzLiAgSWYgYWJzZW50IGEgemVybyBvZmZzZXQgaXMgaW5mZXJyZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIG51bWJlciBvZiBieXRlcyBjb3ZlcmVkIGJ5IHRoZSBsYXlvdXRcbiAgICAgKiBpbnN0YW5jZS4gIElmIHRoaXMgbWV0aG9kIGlzIG5vdCBvdmVycmlkZGVuIGluIGEgc3ViY2xhc3MgdGhlXG4gICAgICogZGVmaW5pdGlvbi10aW1lIGNvbnN0YW50IHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSAtIGlmIHRoZSBsZW5ndGggb2YgdGhlIHZhbHVlIGNhbm5vdCBiZVxuICAgICAqIGRldGVybWluZWQuXG4gICAgICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKDAgPiB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRldGVybWluYXRlIHNwYW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsaWNhdGUgdGhlIGxheW91dCB1c2luZyBhIG5ldyBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIGdldCBhIHN0cnVjdHVyYWxseS1lcXVpdmFsZW50IGxheW91dFxuICAgICAqIHdpdGggYSBkaWZmZXJlbnQgbmFtZSBzaW5jZSBhbGwge0BsaW5rIExheW91dH0gaW5zdGFuY2VzIGFyZVxuICAgICAqIGltbXV0YWJsZS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIFRoaXMgaXMgYSBzaGFsbG93IGNvcHkuICBBbGwgZmllbGRzIGV4Y2VwdCB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IGFyZSBzdHJpY3RseSBlcXVhbCB0byB0aGUgb3JpZ2luIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSB2YWx1ZSBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSBpbiB0aGUgcmVwbGljYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtMYXlvdXR9IC0gdGhlIGNvcHkgd2l0aCB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fVxuICAgICAqIHNldCB0byBgcHJvcGVydHlgLlxuICAgICAqL1xuICAgIHJlcGxpY2F0ZShwcm9wZXJ0eSkge1xuICAgICAgICBjb25zdCBydiA9IE9iamVjdC5jcmVhdGUodGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHJ2LCB0aGlzKTtcbiAgICAgICAgcnYucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gb2JqZWN0IGZyb20gbGF5b3V0IHByb3BlcnRpZXMgYW5kIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYCBpZiBpbnZva2VkIG9uIGEgbGF5b3V0XG4gICAgICogdGhhdCBkb2VzIG5vdCByZXR1cm4gaXRzIHZhbHVlIGFzIGFuIE9iamVjdC4gIE9iamVjdHMgYXJlXG4gICAgICogcmV0dXJuZWQgZm9yIHRoaW5ncyB0aGF0IGFyZSBhIHtAbGluayBTdHJ1Y3R1cmV9LCB3aGljaCBpbmNsdWRlc1xuICAgICAqIHtAbGluayBWYXJpYW50TGF5b3V0fHZhcmlhbnQgbGF5b3V0c30gaWYgdGhleSBhcmUgc3RydWN0dXJlcywgYW5kXG4gICAgICogZXhjbHVkZXMge0BsaW5rIFVuaW9ufXMuICBJZiB5b3Ugd2FudCB0aGlzIGZlYXR1cmUgZm9yIGEgdW5pb25cbiAgICAgKiB5b3UgbXVzdCB1c2Uge0BsaW5rIFVuaW9uLmdldFZhcmlhbnR8Z2V0VmFyaWFudH0gdG8gc2VsZWN0IHRoZVxuICAgICAqIGRlc2lyZWQgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIC0gYW4gYXJyYXkgb2YgdmFsdWVzIHRoYXQgY29ycmVzcG9uZCB0byB0aGVcbiAgICAgKiBkZWZhdWx0IG9yZGVyIGZvciBwcm9wZXJ0aWVzLiAgQXMgd2l0aCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9XG4gICAgICogbGF5b3V0IGVsZW1lbnRzIHRoYXQgaGF2ZSBubyBwcm9wZXJ0eSBuYW1lIGFyZSBza2lwcGVkIHdoZW5cbiAgICAgKiBpdGVyYXRpbmcgb3ZlciB0aGUgYXJyYXkgdmFsdWVzLiAgT25seSB0aGUgdG9wLWxldmVsIHByb3BlcnRpZXMgYXJlXG4gICAgICogYXNzaWduZWQ7IGFyZ3VtZW50cyBhcmUgbm90IGFzc2lnbmVkIHRvIHByb3BlcnRpZXMgb2YgY29udGFpbmVkXG4gICAgICogbGF5b3V0cy4gIEFueSB1bnVzZWQgdmFsdWVzIGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7KE9iamVjdHx1bmRlZmluZWQpfVxuICAgICAqL1xuICAgIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLkxheW91dCA9IExheW91dDtcbi8qIFByb3ZpZGUgdGV4dCB0aGF0IGNhcnJpZXMgYSBuYW1lIChzdWNoIGFzIGZvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbFxuICogYmUgdGhyb3dpbmcgYW4gZXJyb3IpIGFubm90YXRlZCB3aXRoIHRoZSBwcm9wZXJ0eSBvZiBhIGdpdmVuIGxheW91dFxuICogKHN1Y2ggYXMgb25lIGZvciB3aGljaCB0aGUgdmFsdWUgd2FzIHVuYWNjZXB0YWJsZSkuXG4gKlxuICogQGlnbm9yZSAqL1xuZnVuY3Rpb24gbmFtZVdpdGhQcm9wZXJ0eShuYW1lLCBsbykge1xuICAgIGlmIChsby5wcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gbmFtZSArICdbJyArIGxvLnByb3BlcnR5ICsgJ10nO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cbmV4cG9ydHMubmFtZVdpdGhQcm9wZXJ0eSA9IG5hbWVXaXRoUHJvcGVydHk7XG4vKipcbiAqIEF1Z21lbnQgYSBjbGFzcyBzbyB0aGF0IGluc3RhbmNlcyBjYW4gYmUgZW5jb2RlZC9kZWNvZGVkIHVzaW5nIGFcbiAqIGdpdmVuIGxheW91dC5cbiAqXG4gKiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gY291cGxlcyBgQ2xhc3NgIHdpdGggYGxheW91dGAgaW4gc2V2ZXJhbCB3YXlzOlxuICpcbiAqICogYENsYXNzLmxheW91dF9gIGJlY29tZXMgYSBzdGF0aWMgbWVtYmVyIHByb3BlcnR5IGVxdWFsIHRvIGBsYXlvdXRgO1xuICogKiBgbGF5b3V0LmJvdW5kQ29uc3RydWN0b3JfYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBwcm9wZXJ0eSBlcXVhbFxuICogICAgdG8gYENsYXNzYDtcbiAqICogVGhlIHtAbGluayBMYXlvdXQjbWFrZURlc3RpbmF0aW9uT2JqZWN0fG1ha2VEZXN0aW5hdGlvbk9iamVjdCgpfVxuICogICBwcm9wZXJ0eSBvZiBgbGF5b3V0YCBpcyBzZXQgdG8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBgbmV3XG4gKiAgIENsYXNzKClgO1xuICogKiBgQ2xhc3MuZGVjb2RlKGIsIG9mZnNldClgIGJlY29tZXMgYSBzdGF0aWMgbWVtYmVyIGZ1bmN0aW9uIHRoYXRcbiAqICAgZGVsZWdhdGVzIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfGxheW91dC5kZWNvZGV9LiAgVGhlXG4gKiAgIHN5bnRoZXNpemVkIGZ1bmN0aW9uIG1heSBiZSBjYXB0dXJlZCBhbmQgZXh0ZW5kZWQuXG4gKiAqIGBDbGFzcy5wcm90b3R5cGUuZW5jb2RlKGIsIG9mZnNldClgIHByb3ZpZGVzIGFuIGluc3RhbmNlIG1lbWJlclxuICogICBmdW5jdGlvbiB0aGF0IGRlbGVnYXRlcyB0byB7QGxpbmsgTGF5b3V0I2VuY29kZXxsYXlvdXQuZW5jb2RlfVxuICogICB3aXRoIGBzcmNgIHNldCB0byBgdGhpc2AuICBUaGUgc3ludGhlc2l6ZWQgZnVuY3Rpb24gbWF5IGJlXG4gKiAgIGNhcHR1cmVkIGFuZCBleHRlbmRlZCwgYnV0IHdoZW4gdGhlIGV4dGVuc2lvbiBpcyBpbnZva2VkIGB0aGlzYFxuICogICBtdXN0IGJlIGV4cGxpY2l0bHkgYm91bmQgdG8gdGhlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Y2xhc3N9IENsYXNzIC0gYSBKYXZhU2NyaXB0IGNsYXNzIHdpdGggYSBudWxsYXJ5XG4gKiBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gdGhlIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIHVzZWQgdG8gZW5jb2RlXG4gKiBpbnN0YW5jZXMgb2YgYENsYXNzYC5cbiAqL1xuLy8gYENsYXNzYCBtdXN0IGJlIGEgY29uc3RydWN0b3IgRnVuY3Rpb24sIGJ1dCB0aGUgYXNzaWdubWVudCBvZiBhIGBsYXlvdXRfYCBwcm9wZXJ0eSB0byBpdCBtYWtlcyBpdCBkaWZmaWN1bHQgdG8gdHlwZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGJpbmRDb25zdHJ1Y3RvckxheW91dChDbGFzcywgbGF5b3V0KSB7XG4gICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDbGFzcyBtdXN0IGJlIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQ2xhc3MsICdsYXlvdXRfJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzcyBpcyBhbHJlYWR5IGJvdW5kIHRvIGEgbGF5b3V0Jyk7XG4gICAgfVxuICAgIGlmICghKGxheW91dCAmJiAobGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsYXlvdXQsICdib3VuZENvbnN0cnVjdG9yXycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGF5b3V0IGlzIGFscmVhZHkgYm91bmQgdG8gYSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cbiAgICBDbGFzcy5sYXlvdXRfID0gbGF5b3V0O1xuICAgIGxheW91dC5ib3VuZENvbnN0cnVjdG9yXyA9IENsYXNzO1xuICAgIGxheW91dC5tYWtlRGVzdGluYXRpb25PYmplY3QgPSAoKCkgPT4gbmV3IENsYXNzKCkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsICdlbmNvZGUnLCB7XG4gICAgICAgIHZhbHVlKGIsIG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGxheW91dC5lbmNvZGUodGhpcywgYiwgb2Zmc2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLCAnZGVjb2RlJywge1xuICAgICAgICB2YWx1ZShiLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0cy5iaW5kQ29uc3RydWN0b3JMYXlvdXQgPSBiaW5kQ29uc3RydWN0b3JMYXlvdXQ7XG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGJlaGF2ZXMgbGlrZSBhIGxheW91dCBidXQgZG9lcyBub3QgY29uc3VtZSBzcGFjZVxuICogd2l0aGluIGl0cyBjb250YWluaW5nIGxheW91dC5cbiAqXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIG9idGFpbiBtZXRhZGF0YSBhYm91dCBhIG1lbWJlciwgc3VjaCBhcyBhXG4gKiB7QGxpbmsgT2Zmc2V0TGF5b3V0fSB0aGF0IGNhbiBwcm92aWRlIGRhdGEgYWJvdXQgYSB7QGxpbmtcbiAqIExheW91dCNnZXRTcGFufHZhbHVlLXNwZWNpZmljIHNwYW59LlxuICpcbiAqICoqTk9URSoqIFRoaXMgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzczsgeW91IGNhbiBjcmVhdGUgaW5zdGFuY2VzXG4gKiBpZiBpdCBhbXVzZXMgeW91LCBidXQgdGhleSB3b24ndCBzdXBwb3J0IHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50fSBvciBvdGhlciB7QGxpbmsgTGF5b3V0fSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGFic3RyYWN0XG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRXh0ZXJuYWxMYXlvdXQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWZmIHRoZSBleHRlcm5hbCBsYXlvdXQgZGVjb2RlcyB0byBhbiB1bnNpZ25lZFxuICAgICAqIGludGVnZXIgbGF5b3V0LlxuICAgICAqXG4gICAgICogSW4gdGhhdCBjYXNlIGl0IGNhbiBiZSB1c2VkIGFzIHRoZSBzb3VyY2Ugb2Yge0BsaW5rXG4gICAgICogU2VxdWVuY2UjY291bnR8U2VxdWVuY2UgY291bnRzfSwge0BsaW5rIEJsb2IjbGVuZ3RofEJsb2IgbGVuZ3Roc30sXG4gICAgICogb3IgYXMge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8ZXh0ZXJuYWwgdW5pb25cbiAgICAgKiBkaXNjcmltaW5hdG9yc30uXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBpc0NvdW50KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVybmFsTGF5b3V0IGlzIGFic3RyYWN0Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlcm5hbExheW91dCA9IEV4dGVybmFsTGF5b3V0O1xuLyoqXG4gKiBBbiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgZGV0ZXJtaW5lcyBpdHMge0BsaW5rXG4gKiBMYXlvdXQjZGVjb2RlfHZhbHVlfSBiYXNlZCBvbiBvZmZzZXQgaW50byBhbmQgbGVuZ3RoIG9mIHRoZSBidWZmZXJcbiAqIG9uIHdoaWNoIGl0IGlzIGludm9rZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5ncmVlZHl8Z3JlZWR5fVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbZWxlbWVudFNwYW5dIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogR3JlZWR5Q291bnQjZWxlbWVudFNwYW58ZWxlbWVudFNwYW59LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0V4dGVybmFsTGF5b3V0fVxuICovXG5jbGFzcyBHcmVlZHlDb3VudCBleHRlbmRzIEV4dGVybmFsTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50U3BhbiA9IDEsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIoZWxlbWVudFNwYW4pKSB8fCAoMCA+PSBlbGVtZW50U3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VsZW1lbnRTcGFuIG11c3QgYmUgYSAocG9zaXRpdmUpIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigtMSwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIGxheW91dCBmb3IgaW5kaXZpZHVhbCBlbGVtZW50cyBvZiB0aGUgc2VxdWVuY2UuICBUaGUgdmFsdWVcbiAgICAgICAgICogbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuICBJZiBub3QgcHJvdmlkZWQsIHRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICAgICAqIDEuICovXG4gICAgICAgIHRoaXMuZWxlbWVudFNwYW4gPSBlbGVtZW50U3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGlzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgICAgICBjb25zdCByZW0gPSBiLmxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocmVtIC8gdGhpcy5lbGVtZW50U3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZXhwb3J0cy5HcmVlZHlDb3VudCA9IEdyZWVkeUNvdW50O1xuLyoqXG4gKiBBbiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc3VwcG9ydHMgYWNjZXNzaW5nIGEge0BsaW5rIExheW91dH1cbiAqIGF0IGEgZml4ZWQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIGFub3RoZXIgTGF5b3V0LiAgVGhlIG9mZnNldCBtYXlcbiAqIGJlIGJlZm9yZSwgd2l0aGluLCBvciBhZnRlciB0aGUgYmFzZSBsYXlvdXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5vZmZzZXR8b2Zmc2V0fVxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBPZmZzZXRMYXlvdXQjbGF5b3V0fGxheW91dH0sIG1vZHVsbyBgcHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIEluaXRpYWxpemVzIHtAbGlua1xuICogT2Zmc2V0TGF5b3V0I29mZnNldHxvZmZzZXR9LiAgRGVmYXVsdHMgdG8gemVyby5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIE9wdGlvbmFsIG5ldyBwcm9wZXJ0eSBuYW1lIGZvciBhXG4gKiB7QGxpbmsgTGF5b3V0I3JlcGxpY2F0ZXwgcmVwbGljYX0gb2YgYGxheW91dGAgdG8gYmUgdXNlZCBhcyB7QGxpbmtcbiAqIE9mZnNldExheW91dCNsYXlvdXR8bGF5b3V0fS4gIElmIG5vdCBwcm92aWRlZCB0aGUgYGxheW91dGAgaXMgdXNlZFxuICogdW5jaGFuZ2VkLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBPZmZzZXRMYXlvdXQgZXh0ZW5kcyBFeHRlcm5hbExheW91dCB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBvZmZzZXQgPSAwLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoIShsYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihvZmZzZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvZmZzZXQgbXVzdCBiZSBpbnRlZ2VyIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGxheW91dC5zcGFuLCBwcm9wZXJ0eSB8fCBsYXlvdXQucHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIHN1Ym9yZGluYXRlZCBsYXlvdXQuICovXG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICAvKiogVGhlIGxvY2F0aW9uIG9mIHtAbGluayBPZmZzZXRMYXlvdXQjbGF5b3V0fSByZWxhdGl2ZSB0byB0aGVcbiAgICAgICAgICogc3RhcnQgb2YgYW5vdGhlciBsYXlvdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB2YWx1ZSBtYXkgYmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUsIGJ1dCBhbiBlcnJvciB3aWxsIHRocm93blxuICAgICAgICAgKiBpZiBhdCB0aGUgcG9pbnQgb2YgdXNlIGl0IGdvZXMgb3V0c2lkZSB0aGUgc3BhbiBvZiB0aGUgVWludDhBcnJheVxuICAgICAgICAgKiBiZWluZyBhY2Nlc3NlZC4gICovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgaXNDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5sYXlvdXQgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgfHwgKHRoaXMubGF5b3V0IGluc3RhbmNlb2YgVUludEJFKSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCArIHRoaXMub2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShzcmMsIGIsIG9mZnNldCArIHRoaXMub2Zmc2V0KTtcbiAgICB9XG59XG5leHBvcnRzLk9mZnNldExheW91dCA9IE9mZnNldExheW91dDtcbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51OHx1OH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQudTE2fHUxNn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUyNHx1MjR9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnUzMnx1MzJ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51NDB8dTQwfSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC51NDh8dTQ4fVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVSW50IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRVSW50TEUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVVSW50TEUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5VSW50ID0gVUludDtcbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51OGJlfHU4YmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQudTE2YmV8dTE2YmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjRiZXx1MjRiZX0sXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJiZXx1MzJiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC51NDBiZXx1NDBiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0OGJlfHU0OGJlfVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVSW50QkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZFVJbnRCRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZVVJbnRCRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLlVJbnRCRSA9IFVJbnRCRTtcbi8qKlxuICogUmVwcmVzZW50IGEgc2lnbmVkIGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zOHxzOH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQuczE2fHMxNn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnMyNHxzMjR9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnMzMnxzMzJ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDB8czQwfSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC5zNDh8czQ4fVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBJbnQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZEludExFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlSW50TEUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5JbnQgPSBJbnQ7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczhiZXxzOGJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnMxNmJlfHMxNmJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0YmV8czI0YmV9LFxuICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyYmV8czMyYmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQuczQwYmV8czQwYmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDhiZXxzNDhiZX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgSW50QkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZEludEJFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlSW50QkUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5JbnRCRSA9IEludEJFO1xuY29uc3QgVjJFMzIgPSBNYXRoLnBvdygyLCAzMik7XG4vKiBUcnVlIG1vZHVsdXMgaGlnaCBhbmQgbG93IDMyLWJpdCB3b3Jkcywgd2hlcmUgbG93IHdvcmQgaXMgYWx3YXlzXG4gKiBub24tbmVnYXRpdmUuICovXG5mdW5jdGlvbiBkaXZtb2RJbnQ2NChzcmMpIHtcbiAgICBjb25zdCBoaTMyID0gTWF0aC5mbG9vcihzcmMgLyBWMkUzMik7XG4gICAgY29uc3QgbG8zMiA9IHNyYyAtIChoaTMyICogVjJFMzIpO1xuICAgIHJldHVybiB7IGhpMzIsIGxvMzIgfTtcbn1cbi8qIFJlY29uc3RydWN0IE51bWJlciBmcm9tIHF1b3RpZW50IGFuZCBub24tbmVnYXRpdmUgcmVtYWluZGVyICovXG5mdW5jdGlvbiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMikge1xuICAgIHJldHVybiBoaTMyICogVjJFMzIgKyBsbzMyO1xufVxuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgNjQtYml0IGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm51NjR8bnU2NH1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhclVJbnQ2NCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBjb25zdCBsbzMyID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICAgICAgICBjb25zdCBoaTMyID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHNwbGl0LmxvMzIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHNwbGl0LmhpMzIsIG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLk5lYXJVSW50NjQgPSBOZWFyVUludDY0O1xuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgNjQtYml0IGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm51NjRiZXxudTY0YmV9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJVSW50NjRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBjb25zdCBoaTMyID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICAgICAgICBjb25zdCBsbzMyID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHNwbGl0LmhpMzIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHNwbGl0LmxvMzIsIG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLk5lYXJVSW50NjRCRSA9IE5lYXJVSW50NjRCRTtcbi8qKlxuICogUmVwcmVzZW50IGEgc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5uczY0fG5zNjR9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJJbnQ2NCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBjb25zdCBsbzMyID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICAgICAgICBjb25zdCBoaTMyID0gYnVmZmVyLnJlYWRJbnQzMkxFKG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUoc3BsaXQubG8zMiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlSW50MzJMRShzcGxpdC5oaTMyLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5OZWFySW50NjQgPSBOZWFySW50NjQ7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnM2NGJlfG5zNjRiZX1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhckludDY0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgY29uc3QgaGkzMiA9IGJ1ZmZlci5yZWFkSW50MzJCRShvZmZzZXQpO1xuICAgICAgICBjb25zdCBsbzMyID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGJ1ZmZlci53cml0ZUludDMyQkUoc3BsaXQuaGkzMiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUoc3BsaXQubG8zMiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhckludDY0QkUgPSBOZWFySW50NjRCRTtcbi8qKlxuICogUmVwcmVzZW50IGEgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmYzMnxmMzJ9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBGbG9hdCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoNCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkRmxvYXRMRShvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVGbG9hdExFKHNyYywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxufVxuZXhwb3J0cy5GbG9hdCA9IEZsb2F0O1xuLyoqXG4gKiBSZXByZXNlbnQgYSAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjMyYmV8ZjMyYmV9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBGbG9hdEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig0LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRGbG9hdEJFKG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZUZsb2F0QkUoc3JjLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG59XG5leHBvcnRzLkZsb2F0QkUgPSBGbG9hdEJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjY0fGY2NH1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIERvdWJsZSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkRG91YmxlTEUob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlRG91YmxlTEUoc3JjLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLkRvdWJsZSA9IERvdWJsZTtcbi8qKlxuICogUmVwcmVzZW50IGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmY2NGJlfGY2NGJlfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRG91YmxlQkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZERvdWJsZUJFKG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZURvdWJsZUJFKHNyYywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5Eb3VibGVCRSA9IERvdWJsZUJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBjb250aWd1b3VzIHNlcXVlbmNlIG9mIGEgc3BlY2lmaWMgbGF5b3V0IGFzIGFuIEFycmF5LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc2VxfHNlcX1cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gZWxlbWVudExheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFNlcXVlbmNlI2VsZW1lbnRMYXlvdXR8ZWxlbWVudExheW91dH0uXG4gKlxuICogQHBhcmFtIHsoTnVtYmVyfEV4dGVybmFsTGF5b3V0KX0gY291bnQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBTZXF1ZW5jZSNjb3VudHxjb3VudH0uICBUaGUgcGFyYW1ldGVyIG11c3QgYmUgZWl0aGVyIGEgcG9zaXRpdmVcbiAqIGludGVnZXIgb3IgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEV4dGVybmFsTGF5b3V0fS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFNlcXVlbmNlIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEoZWxlbWVudExheW91dCBpbnN0YW5jZW9mIExheW91dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VsZW1lbnRMYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKCgoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkgJiYgY291bnQuaXNDb3VudCgpKVxuICAgICAgICAgICAgfHwgKE51bWJlci5pc0ludGVnZXIoY291bnQpICYmICgwIDw9IGNvdW50KSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb3VudCBtdXN0IGJlIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyICdcbiAgICAgICAgICAgICAgICArICdvciBhbiB1bnNpZ25lZCBpbnRlZ2VyIEV4dGVybmFsTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAtMTtcbiAgICAgICAgaWYgKCghKGNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpKVxuICAgICAgICAgICAgJiYgKDAgPCBlbGVtZW50TGF5b3V0LnNwYW4pKSB7XG4gICAgICAgICAgICBzcGFuID0gY291bnQgKiBlbGVtZW50TGF5b3V0LnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIGxheW91dCBmb3IgaW5kaXZpZHVhbCBlbGVtZW50cyBvZiB0aGUgc2VxdWVuY2UuICovXG4gICAgICAgIHRoaXMuZWxlbWVudExheW91dCA9IGVsZW1lbnRMYXlvdXQ7XG4gICAgICAgIC8qKiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB3aWxsIGJlIGVpdGhlciBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG9yIGFuIGluc3RhbmNlIG9mXG4gICAgICAgICAqIHtAbGluayBFeHRlcm5hbExheW91dH0gZm9yIHdoaWNoIHtAbGlua1xuICAgICAgICAgKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0gaXMgYHRydWVgLiAqL1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gMDtcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgaWYgKGNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIGNvdW50ID0gY291bnQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgPCB0aGlzLmVsZW1lbnRMYXlvdXQuc3Bhbikge1xuICAgICAgICAgICAgc3BhbiA9IGNvdW50ICogdGhpcy5lbGVtZW50TGF5b3V0LnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBjb3VudCkge1xuICAgICAgICAgICAgICAgIHNwYW4gKz0gdGhpcy5lbGVtZW50TGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgc3Bhbik7XG4gICAgICAgICAgICAgICAgKytpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBydiA9IFtdO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgIGlmIChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICAgICAgICBjb3VudCA9IGNvdW50LmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgY291bnQpIHtcbiAgICAgICAgICAgIHJ2LnB1c2godGhpcy5lbGVtZW50TGF5b3V0LmRlY29kZShiLCBvZmZzZXQpKTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLmVsZW1lbnRMYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgU2VxdWVuY2V9LlxuICAgICAqXG4gICAgICogKipOT1RFKiogSWYgYHNyY2AgaXMgc2hvcnRlciB0aGFuIHtAbGluayBTZXF1ZW5jZSNjb3VudHxjb3VudH0gdGhlblxuICAgICAqIHRoZSB1bnVzZWQgc3BhY2UgaW4gdGhlIGJ1ZmZlciBpcyBsZWZ0IHVuY2hhbmdlZC4gIElmIGBzcmNgIGlzXG4gICAgICogbG9uZ2VyIHRoYW4ge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSB0aGUgdW5uZWVkZWQgZWxlbWVudHMgYXJlXG4gICAgICogaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIElmIHtAbGluayBMYXlvdXQjY291bnR8Y291bnR9IGlzIGFuIGluc3RhbmNlIG9mIHtAbGlua1xuICAgICAqIEV4dGVybmFsTGF5b3V0fSB0aGVuIHRoZSBsZW5ndGggb2YgYHNyY2Agd2lsbCBiZSBlbmNvZGVkIGFzIHRoZVxuICAgICAqIGNvdW50IGFmdGVyIGBzcmNgIGlzIGVuY29kZWQuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBlbG8gPSB0aGlzLmVsZW1lbnRMYXlvdXQ7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBzcmMucmVkdWNlKChzcGFuLCB2KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3BhbiArIGVsby5lbmNvZGUodiwgYiwgb2Zmc2V0ICsgc3Bhbik7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBpZiAodGhpcy5jb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50LmVuY29kZShzcmMubGVuZ3RoLCBiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VxdWVuY2UgPSBTZXF1ZW5jZTtcbi8qKlxuICogUmVwcmVzZW50IGEgY29udGlndW91cyBzZXF1ZW5jZSBvZiBhcmJpdHJhcnkgbGF5b3V0IGVsZW1lbnRzIGFzIGFuXG4gKiBPYmplY3QuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zdHJ1Y3R8c3RydWN0fVxuICpcbiAqICoqTk9URSoqIFRoZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gb2YgdGhlIHN0cnVjdHVyZSBpcyB2YXJpYWJsZVxuICogaWYgYW55IGxheW91dCBpbiB7QGxpbmsgU3RydWN0dXJlI2ZpZWxkc3xmaWVsZHN9IGhhcyBhIHZhcmlhYmxlXG4gKiBzcGFuLiAgV2hlbiB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGluZ30gd2UgbXVzdCBoYXZlIGEgdmFsdWUgZm9yXG4gKiBhbGwgdmFyaWFibGUtbGVuZ3RoIGZpZWxkcywgb3Igd2Ugd291bGRuJ3QgYmUgYWJsZSB0byBmaWd1cmUgb3V0XG4gKiBob3cgbXVjaCBzcGFjZSB0byB1c2UgZm9yIHN0b3JhZ2UuICBXZSBjYW4gb25seSBpZGVudGlmeSB0aGUgdmFsdWVcbiAqIGZvciBhIGZpZWxkIHdoZW4gaXQgaGFzIGEge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uICBBc1xuICogc3VjaCwgYWx0aG91Z2ggYSBzdHJ1Y3R1cmUgbWF5IGNvbnRhaW4gYm90aCB1bm5hbWVkIGZpZWxkcyBhbmRcbiAqIHZhcmlhYmxlLWxlbmd0aCBmaWVsZHMsIGl0IGNhbm5vdCBjb250YWluIGFuIHVubmFtZWRcbiAqIHZhcmlhYmxlLWxlbmd0aCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0ge0xheW91dFtdfSBmaWVsZHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBTdHJ1Y3R1cmUjZmllbGRzfGZpZWxkc30uICBBbiBlcnJvciBpcyByYWlzZWQgaWYgdGhpcyBjb250YWlucyBhXG4gKiB2YXJpYWJsZS1sZW5ndGggZmllbGQgZm9yIHdoaWNoIGEge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX1cbiAqIGlzIG5vdCBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWNvZGVQcmVmaXhlc10gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBTdHJ1Y3R1cmUjZGVjb2RlUHJlZml4ZXN8cHJvcGVydHl9LlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSAtIGlmIGBmaWVsZHNgIGNvbnRhaW5zIGFuIHVubmFtZWQgdmFyaWFibGUtbGVuZ3RoXG4gKiBsYXlvdXQuXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFN0cnVjdHVyZSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBwcm9wZXJ0eSwgZGVjb2RlUHJlZml4ZXMpIHtcbiAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShmaWVsZHMpXG4gICAgICAgICAgICAmJiBmaWVsZHMucmVkdWNlKChhY2MsIHYpID0+IGFjYyAmJiAodiBpbnN0YW5jZW9mIExheW91dCksIHRydWUpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmllbGRzIG11c3QgYmUgYXJyYXkgb2YgTGF5b3V0IGluc3RhbmNlcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoJ2Jvb2xlYW4nID09PSB0eXBlb2YgcHJvcGVydHkpXG4gICAgICAgICAgICAmJiAodW5kZWZpbmVkID09PSBkZWNvZGVQcmVmaXhlcykpIHtcbiAgICAgICAgICAgIGRlY29kZVByZWZpeGVzID0gcHJvcGVydHk7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKiBWZXJpZnkgYWJzZW5jZSBvZiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aCBmaWVsZHMuICovXG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoKDAgPiBmZC5zcGFuKVxuICAgICAgICAgICAgICAgICYmICh1bmRlZmluZWQgPT09IGZkLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGRzIGNhbm5vdCBjb250YWluIHVubmFtZWQgdmFyaWFibGUtbGVuZ3RoIGxheW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gLTE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzcGFuID0gZmllbGRzLnJlZHVjZSgoc3BhbiwgZmQpID0+IHNwYW4gKyBmZC5nZXRTcGFuKCksIDApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgc2VxdWVuY2Ugb2Yge0BsaW5rIExheW91dH0gdmFsdWVzIHRoYXQgY29tcHJpc2UgdGhlXG4gICAgICAgICAqIHN0cnVjdHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGluZGl2aWR1YWwgZWxlbWVudHMgbmVlZCBub3QgYmUgdGhlIHNhbWUgdHlwZSwgYW5kIG1heSBiZVxuICAgICAgICAgKiBlaXRoZXIgc2NhbGFyIG9yIGFnZ3JlZ2F0ZSBsYXlvdXRzLiAgSWYgYSBtZW1iZXIgbGF5b3V0IGxlYXZlc1xuICAgICAgICAgKiBpdHMge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdW5kZWZpbmVkIHRoZVxuICAgICAgICAgKiBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgYnVmZmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICAgICAgICAgKiB3aWxsIG5vdCBiZSBtdXRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7TGF5b3V0W119ICovXG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICAvKiogQ29udHJvbCBiZWhhdmlvciBvZiB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGUoKX0gZ2l2ZW4gc2hvcnRcbiAgICAgICAgICogYnVmZmVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gc29tZSBzaXR1YXRpb25zIGEgc3RydWN0dXJlIG1hbnkgYmUgZXh0ZW5kZWQgd2l0aCBhZGRpdGlvbmFsXG4gICAgICAgICAqIGZpZWxkcyBvdmVyIHRpbWUsIHdpdGggb2xkZXIgaW5zdGFsbGF0aW9ucyBwcm92aWRpbmcgb25seSBhXG4gICAgICAgICAqIHByZWZpeCBvZiB0aGUgZnVsbCBzdHJ1Y3R1cmUuICBJZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYFxuICAgICAgICAgKiBkZWNvZGluZyB3aWxsIGFjY2VwdCB0aG9zZSBidWZmZXJzIGFuZCBsZWF2ZSBzdWJzZXF1ZW50IGZpZWxkc1xuICAgICAgICAgKiB1bmRlZmluZWQsIGFzIGxvbmcgYXMgdGhlIGJ1ZmZlciBlbmRzIGF0IGEgZmllbGQgYm91bmRhcnkuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuICovXG4gICAgICAgIHRoaXMuZGVjb2RlUHJlZml4ZXMgPSAhIWRlY29kZVByZWZpeGVzO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzcGFuID0gdGhpcy5maWVsZHMucmVkdWNlKChzcGFuLCBmZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZzcCA9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZnNwO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGFuICsgZnNwO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRldGVybWluYXRlIHNwYW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICAgICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSBmZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCArPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVQcmVmaXhlc1xuICAgICAgICAgICAgICAgICYmIChiLmxlbmd0aCA9PT0gb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBTdHJ1Y3R1cmV9LlxuICAgICAqXG4gICAgICogSWYgYHNyY2AgaXMgbWlzc2luZyBhIHByb3BlcnR5IGZvciBhIG1lbWJlciB3aXRoIGEgZGVmaW5lZCB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgYnVmZmVyIGlzXG4gICAgICogbGVmdCB1bm1vZGlmaWVkLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZmlyc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGxldCBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGxhc3RXcm90ZSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gZmQuc3BhbjtcbiAgICAgICAgICAgIGxhc3RXcm90ZSA9ICgwIDwgc3BhbikgPyBzcGFuIDogMDtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnYgPSBzcmNbZmQucHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZ2KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RXcm90ZSA9IGZkLmVuY29kZShmdiwgYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPiBzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBSZWFkIHRoZSBhcy1lbmNvZGVkIHNwYW4sIHdoaWNoIGlzIG5vdCBuZWNlc3NhcmlseSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNhbWUgYXMgd2hhdCB3ZSB3cm90ZS4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4gPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHNwYW47XG4gICAgICAgIH1cbiAgICAgICAgLyogVXNlIChsYXN0T2Zmc2V0ICsgbGFzdFdyb3RlKSBpbnN0ZWFkIG9mIG9mZnNldCBiZWNhdXNlIHRoZSBsYXN0XG4gICAgICAgICAqIGl0ZW0gbWF5IGhhdmUgaGFkIGEgZHluYW1pYyBsZW5ndGggYW5kIHdlIGRvbid0IHdhbnQgdG8gaW5jbHVkZVxuICAgICAgICAgKiB0aGUgcGFkZGluZyBiZXR3ZWVuIGl0IGFuZCB0aGUgZW5kIG9mIHRoZSBzcGFjZSByZXNlcnZlZCBmb3JcbiAgICAgICAgICogaXQuICovXG4gICAgICAgIHJldHVybiAobGFzdE9mZnNldCArIGxhc3RXcm90ZSkgLSBmaXJzdE9mZnNldDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICgodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICAmJiAoMCA8IHZhbHVlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSB2YWx1ZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFjY2VzcyB0byB0aGUgbGF5b3V0IG9mIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgc3RydWN0dXJlIG1lbWJlciBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0xheW91dH0gLSB0aGUgbGF5b3V0IGFzc29jaWF0ZWQgd2l0aCBgcHJvcGVydHlgLCBvclxuICAgICAqIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBzdWNoIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGxheW91dEZvcihwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmQucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb2Zmc2V0IG9mIGEgc3RydWN0dXJlIG1lbWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBzdHJ1Y3R1cmUgbWVtYmVyIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIHRoZSBvZmZzZXQgaW4gYnl0ZXMgdG8gdGhlIHN0YXJ0IG9mIGBwcm9wZXJ0eWBcbiAgICAgKiB3aXRoaW4gdGhlIHN0cnVjdHVyZSwgb3IgdW5kZWZpbmVkIGlmIGBwcm9wZXJ0eWAgaXMgbm90IGEgZmllbGRcbiAgICAgKiB3aXRoaW4gdGhlIHN0cnVjdHVyZS4gIElmIHRoZSBwcm9wZXJ0eSBpcyBhIG1lbWJlciBidXQgZm9sbG93cyBhXG4gICAgICogdmFyaWFibGUtbGVuZ3RoIHN0cnVjdHVyZSBtZW1iZXIgYSBuZWdhdGl2ZSBudW1iZXIgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqL1xuICAgIG9mZnNldE9mKHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmQucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgwID4gZmQuc3Bhbikge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoMCA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZmQuc3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RydWN0dXJlID0gU3RydWN0dXJlO1xuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gcHJvdmlkZSBhIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBBUEkgZm9yIHtAbGluayBVbmlvbn0uXG4gKlxuICogKipOT1RFKiogVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzOyB5b3UgY2FuIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGlmIGl0IGFtdXNlcyB5b3UsIGJ1dCB0aGV5IHdvbid0IHN1cHBvcnQgdGhlIHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yI2VuY29kZXxlbmNvZGV9IG9yIHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yI2RlY29kZXxkZWNvZGV9IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIERlZmF1bHQgZm9yIHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yI3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgVW5pb25EaXNjcmltaW5hdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICAvKiogVGhlIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRvIGJlIHVzZWQgd2hlbiB0aGVcbiAgICAgICAgICogZGlzY3JpbWluYXRvciBpcyByZWZlcmVuY2VkIGluIGlzb2xhdGlvbiAoZ2VuZXJhbGx5IHdoZW4ge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2RlY29kZXxVbmlvbiBkZWNvZGV9IGNhbm5vdCBkZWxlZ2F0ZSB0byBhIHNwZWNpZmljXG4gICAgICAgICAqIHZhcmlhbnQpLiAqL1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgfVxuICAgIC8qKiBBbmFsb2cgdG8ge0BsaW5rIExheW91dCNkZWNvZGV8TGF5b3V0IGRlY29kZX0gZm9yIHVuaW9uIGRpc2NyaW1pbmF0b3JzLlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIG5lZWQgbm90IHJlZmVyZW5jZSB0aGUgYnVmZmVyIGlmXG4gICAgICogdmFyaWFudCBpbmZvcm1hdGlvbiBpcyBhdmFpbGFibGUgdGhyb3VnaCBvdGhlciBtZWFucy4gKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pb25EaXNjcmltaW5hdG9yIGlzIGFic3RyYWN0Jyk7XG4gICAgfVxuICAgIC8qKiBBbmFsb2cgdG8ge0BsaW5rIExheW91dCNkZWNvZGV8TGF5b3V0IGVuY29kZX0gZm9yIHVuaW9uIGRpc2NyaW1pbmF0b3JzLlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIG5lZWQgbm90IHN0b3JlIHRoZSB2YWx1ZSBpZlxuICAgICAqIHZhcmlhbnQgaW5mb3JtYXRpb24gaXMgbWFpbnRhaW5lZCB0aHJvdWdoIG90aGVyIG1lYW5zLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW9uRGlzY3JpbWluYXRvciBpcyBhYnN0cmFjdCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5pb25EaXNjcmltaW5hdG9yID0gVW5pb25EaXNjcmltaW5hdG9yO1xuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gcHJvdmlkZSBhIHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3IgQVBJfSBmb3Ige0BsaW5rIFVuaW9ufSB1c2luZyBhblxuICogdW5zaWduZWQgaW50ZWdyYWwge0BsaW5rIExheW91dH0gaW5zdGFuY2UgbG9jYXRlZCBlaXRoZXIgaW5zaWRlIG9yXG4gKiBvdXRzaWRlIHRoZSB1bmlvbi5cbiAqXG4gKiBAcGFyYW0ge0V4dGVybmFsTGF5b3V0fSBsYXlvdXQgLSBpbml0aWFsaXplcyB7QGxpbmtcbiAqIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8bGF5b3V0fS4gIE11c3Qgc2F0aXNmeSB7QGxpbmtcbiAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudCgpfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIERlZmF1bHQgZm9yIHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yI3Byb3BlcnR5fHByb3BlcnR5fSwgc3VwZXJzZWRpbmcgdGhlIHByb3BlcnR5XG4gKiBmcm9tIGBsYXlvdXRgLCBidXQgZGVmYXVsdGluZyB0byBgdmFyaWFudGAgaWYgbmVpdGhlciBgcHJvcGVydHlgXG4gKiBub3IgbGF5b3V0IHByb3ZpZGUgYSBwcm9wZXJ0eSBuYW1lLlxuICpcbiAqIEBhdWdtZW50cyB7VW5pb25EaXNjcmltaW5hdG9yfVxuICovXG5jbGFzcyBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IgZXh0ZW5kcyBVbmlvbkRpc2NyaW1pbmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEoKGxheW91dCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KVxuICAgICAgICAgICAgJiYgbGF5b3V0LmlzQ291bnQoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihwcm9wZXJ0eSB8fCBsYXlvdXQucHJvcGVydHkgfHwgJ3ZhcmlhbnQnKTtcbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHVzZWQgdG8gYWNjZXNzIHRoZSBkaXNjcmltaW5hdG9yXG4gICAgICAgICAqIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB9XG4gICAgLyoqIERlbGVnYXRlIGRlY29kaW5nIHRvIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBEZWxlZ2F0ZSBlbmNvZGluZyB0byB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZW5jb2RlKHNyYywgYiwgb2Zmc2V0KTtcbiAgICB9XG59XG5leHBvcnRzLlVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcjtcbi8qKlxuICogUmVwcmVzZW50IGFueSBudW1iZXIgb2Ygc3Bhbi1jb21wYXRpYmxlIGxheW91dHMuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51bmlvbnx1bmlvbn1cbiAqXG4gKiBJZiB0aGUgdW5pb24gaGFzIGEge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9IHRoYXRcbiAqIGxheW91dCBtdXN0IGhhdmUgYSBub24tbmVnYXRpdmUge0BsaW5rIExheW91dCNzcGFufHNwYW59LiAgVGhlIHNwYW5cbiAqIG9mIGEgZml4ZWQtc3BhbiB1bmlvbiBpbmNsdWRlcyBpdHMge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IGlmIHRoZSB2YXJpYW50IGlzIGEge0BsaW5rXG4gKiBVbmlvbiN1c2VzUHJlZml4RGlzY3JpbWluYXRvcnxwcmVmaXggb2YgdGhlIHVuaW9ufSwgcGx1cyB0aGUgc3BhblxuICogb2YgaXRzIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fS5cbiAqXG4gKiBJZiB0aGUgdW5pb24gZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHQgbGF5b3V0IHRoZW4gdGhlIGVuY29kZWQgc3BhblxuICogb2YgdGhlIHVuaW9uIGRlcGVuZHMgb24gdGhlIGVuY29kZWQgc3BhbiBvZiBpdHMgdmFyaWFudCAod2hpY2ggbWF5XG4gKiBiZSBmaXhlZCBvciB2YXJpYWJsZSkuXG4gKlxuICoge0BsaW5rIFZhcmlhbnRMYXlvdXQjbGF5b3V0fFZhcmlhbnQgbGF5b3V0fXMgYXJlIGFkZGVkIHRocm91Z2hcbiAqIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZFZhcmlhbnR9LiAgSWYgdGhlIHVuaW9uIGhhcyBhIGRlZmF1bHRcbiAqIGxheW91dCwgdGhlIHNwYW4gb2YgdGhlIHtAbGluayBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXRcbiAqIGNvbnRhaW5lZCBieSB0aGUgdmFyaWFudH0gbXVzdCBub3QgZXhjZWVkIHRoZSBzcGFuIG9mIHRoZSB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9IChtaW51cyB0aGUgc3BhbiBvZiBhIHtAbGlua1xuICogVW5pb24jdXNlc1ByZWZpeERpc2NyaW1pbmF0b3J8cHJlZml4IGRpc3JpbWluYXRvcn0sIGlmIHVzZWQpLiAgVGhlXG4gKiBzcGFuIG9mIHRoZSB2YXJpYW50IHdpbGwgZXF1YWwgdGhlIHNwYW4gb2YgdGhlIHVuaW9uIGl0c2VsZi5cbiAqXG4gKiBUaGUgdmFyaWFudCBmb3IgYSBidWZmZXIgY2FuIG9ubHkgYmUgaWRlbnRpZmllZCBmcm9tIHRoZSB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0ge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9IChpbiB0aGUgY2FzZSBvZiB0aGUge0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fSksIG9yIGJ5IHVzaW5nIHtAbGlua1xuICogVW5pb24jZ2V0VmFyaWFudHxnZXRWYXJpYW50fSBhbmQgZXhhbWluaW5nIHRoZSByZXN1bHRpbmcge0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0fSBpbnN0YW5jZS5cbiAqXG4gKiBBIHZhcmlhbnQgY29tcGF0aWJsZSB3aXRoIGEgSmF2YVNjcmlwdCBvYmplY3QgY2FuIGJlIGlkZW50aWZpZWRcbiAqIHVzaW5nIHtAbGluayBVbmlvbiNnZXRTb3VyY2VWYXJpYW50fGdldFNvdXJjZVZhcmlhbnR9LlxuICpcbiAqIEBwYXJhbSB7KFVuaW9uRGlzY3JpbWluYXRvcnxFeHRlcm5hbExheW91dHxMYXlvdXQpfSBkaXNjciAtIEhvdyB0b1xuICogaWRlbnRpZnkgdGhlIGxheW91dCB1c2VkIHRvIGludGVycHJldCB0aGUgdW5pb24gY29udGVudHMuICBUaGVcbiAqIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHtAbGluayBVbmlvbkRpc2NyaW1pbmF0b3J9LCBhblxuICoge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB0aGF0IHNhdGlzZmllcyB7QGxpbmtcbiAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudCgpfSwgb3Ige0BsaW5rIFVJbnR9IChvciB7QGxpbmtcbiAqIFVJbnRCRX0pLiAgV2hlbiBhIG5vbi1leHRlcm5hbCBsYXlvdXQgZWxlbWVudCBpcyBwYXNzZWQgdGhlIGxheW91dFxuICogYXBwZWFycyBhdCB0aGUgc3RhcnQgb2YgdGhlIHVuaW9uLiAgSW4gYWxsIGNhc2VzIHRoZSAoc3ludGhlc2l6ZWQpXG4gKiB7QGxpbmsgVW5pb25EaXNjcmltaW5hdG9yfSBpbnN0YW5jZSBpcyByZWNvcmRlZCBhcyB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0uXG4gKlxuICogQHBhcmFtIHsoTGF5b3V0fG51bGwpfSBkZWZhdWx0TGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0TGF5b3V0fS4gIElmIGFic2VudCBkZWZhdWx0cyB0byBgbnVsbGAuXG4gKiBJZiBgbnVsbGAgdGhlcmUgaXMgbm8gZGVmYXVsdCBsYXlvdXQ6IHRoZSB1bmlvbiBoYXMgZGF0YS1kZXBlbmRlbnRcbiAqIGxlbmd0aCBhbmQgYXR0ZW1wdHMgdG8gZGVjb2RlIG9yIGVuY29kZSB1bnJlY29nbml6ZWQgdmFyaWFudHMgd2lsbFxuICogdGhyb3cgYW4gZXhjZXB0aW9uLiAgQSB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSBtdXN0IGhhdmUgYVxuICogbm9uLW5lZ2F0aXZlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSwgYW5kIGlmIGl0IGxhY2tzIGEge0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdExheW91dH0gd2lsbCBiZSBhIHtAbGlua1xuICogTGF5b3V0I3JlcGxpY2F0ZXxyZXBsaWNhfSB3aXRoIHByb3BlcnR5IGBjb250ZW50YC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVuaW9uIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpIHtcbiAgICAgICAgbGV0IGRpc2NyaW1pbmF0b3I7XG4gICAgICAgIGlmICgoZGlzY3IgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgfHwgKGRpc2NyIGluc3RhbmNlb2YgVUludEJFKSkge1xuICAgICAgICAgICAgZGlzY3JpbWluYXRvciA9IG5ldyBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IobmV3IE9mZnNldExheW91dChkaXNjcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChkaXNjciBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KVxuICAgICAgICAgICAgJiYgZGlzY3IuaXNDb3VudCgpKSB7XG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yID0gbmV3IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcihkaXNjcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShkaXNjciBpbnN0YW5jZW9mIFVuaW9uRGlzY3JpbWluYXRvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Rpc2NyIG11c3QgYmUgYSBVbmlvbkRpc2NyaW1pbmF0b3IgJ1xuICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgbGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yID0gZGlzY3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZGVmYXVsdExheW91dCkge1xuICAgICAgICAgICAgZGVmYXVsdExheW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKG51bGwgPT09IGRlZmF1bHRMYXlvdXQpXG4gICAgICAgICAgICB8fCAoZGVmYXVsdExheW91dCBpbnN0YW5jZW9mIExheW91dCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkZWZhdWx0TGF5b3V0IG11c3QgYmUgbnVsbCBvciBhIExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxsICE9PSBkZWZhdWx0TGF5b3V0KSB7XG4gICAgICAgICAgICBpZiAoMCA+IGRlZmF1bHRMYXlvdXQuc3Bhbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGVmYXVsdExheW91dCBtdXN0IGhhdmUgY29uc3RhbnQgc3BhbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZGVmYXVsdExheW91dC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRMYXlvdXQgPSBkZWZhdWx0TGF5b3V0LnJlcGxpY2F0ZSgnY29udGVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIFRoZSB1bmlvbiBzcGFuIGNhbiBiZSBlc3RpbWF0ZWQgb25seSBpZiB0aGVyZSdzIGEgZGVmYXVsdFxuICAgICAgICAgKiBsYXlvdXQuICBUaGUgdW5pb24gc3BhbnMgaXRzIGRlZmF1bHQgbGF5b3V0LCBwbHVzIGFueSBwcmVmaXhcbiAgICAgICAgICogdmFyaWFudCBsYXlvdXQuICBCeSBjb25zdHJ1Y3Rpb24gYm90aCBsYXlvdXRzLCBpZiBwcmVzZW50LCBoYXZlXG4gICAgICAgICAqIG5vbi1uZWdhdGl2ZSBzcGFuLiAqL1xuICAgICAgICBsZXQgc3BhbiA9IC0xO1xuICAgICAgICBpZiAoZGVmYXVsdExheW91dCkge1xuICAgICAgICAgICAgc3BhbiA9IGRlZmF1bHRMYXlvdXQuc3BhbjtcbiAgICAgICAgICAgIGlmICgoMCA8PSBzcGFuKSAmJiAoKGRpc2NyIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgICAgICB8fCAoZGlzY3IgaW5zdGFuY2VvZiBVSW50QkUpKSkge1xuICAgICAgICAgICAgICAgIHNwYW4gKz0gZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgZGlzY3JpbWluYXRvciB2YWx1ZSBpbiBpc29sYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgYSB7QGxpbmsgVW5pb25EaXNjcmltaW5hdG9yfSBlaXRoZXIgcGFzc2VkIHRvIHRoZVxuICAgICAgICAgKiBjb25zdHJ1Y3RvciBvciBzeW50aGVzaXplZCBmcm9tIHRoZSBgZGlzY3JgIGNvbnN0cnVjdG9yXG4gICAgICAgICAqIGFyZ3VtZW50LiAge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHVzZXNQcmVmaXhEaXNjcmltaW5hdG9yfSB3aWxsIGJlXG4gICAgICAgICAqIGB0cnVlYCBpZmYgdGhlIGBkaXNjcmAgcGFyYW1ldGVyIHdhcyBhIG5vbi1vZmZzZXQge0BsaW5rXG4gICAgICAgICAqIExheW91dH0gaW5zdGFuY2UuICovXG4gICAgICAgIHRoaXMuZGlzY3JpbWluYXRvciA9IGRpc2NyaW1pbmF0b3I7XG4gICAgICAgIC8qKiBgdHJ1ZWAgaWYgdGhlIHtAbGluayBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IGlzIHRoZVxuICAgICAgICAgKiBmaXJzdCBmaWVsZCBpbiB0aGUgdW5pb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBmYWxzZWAgdGhlIGRpc2NyaW1pbmF0b3IgaXMgb2J0YWluZWQgZnJvbSBzb21ld2hlcmVcbiAgICAgICAgICogZWxzZS4gKi9cbiAgICAgICAgdGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvciA9IChkaXNjciBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAoZGlzY3IgaW5zdGFuY2VvZiBVSW50QkUpO1xuICAgICAgICAvKiogVGhlIGxheW91dCBmb3Igbm9uLWRpc2NyaW1pbmF0b3IgY29udGVudCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgICAgICogZGlzY3JpbWluYXRvciBpcyBub3QgcmVjb2duaXplZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyB0aGUgdmFsdWUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gIEl0IGlzXG4gICAgICAgICAqIHN0cnVjdHVyYWxseSBlcXVpdmFsZW50IHRvIHRoZSBzZWNvbmQgY29tcG9uZW50IG9mIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNsYXlvdXR8bGF5b3V0fSBidXQgbWF5IGhhdmUgYSBkaWZmZXJlbnQgcHJvcGVydHlcbiAgICAgICAgICogbmFtZS4gKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0TGF5b3V0ID0gZGVmYXVsdExheW91dDtcbiAgICAgICAgLyoqIEEgcmVnaXN0cnkgb2YgYWxsb3dlZCB2YXJpYW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGtleXMgYXJlIHVuc2lnbmVkIGludGVnZXJzIHdoaWNoIHNob3VsZCBiZSBjb21wYXRpYmxlIHdpdGhcbiAgICAgICAgICoge0BsaW5rIFVuaW9uLmRpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0uICBUaGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICogaXMgdGhlIGNvcnJlc3BvbmRpbmcge0BsaW5rIFZhcmlhbnRMYXlvdXR9IGluc3RhbmNlcyBhc3NpZ25lZFxuICAgICAgICAgKiB0byB0aGlzIHVuaW9uIGJ5IHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZFZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEUqKiBUaGUgcmVnaXN0cnkgcmVtYWlucyBtdXRhYmxlIHNvIHRoYXQgdmFyaWFudHMgY2FuIGJlXG4gICAgICAgICAqIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZGVkfSBhdCBhbnkgdGltZS4gIFVzZXJzIHNob3VsZCBub3RcbiAgICAgICAgICogbWFuaXB1bGF0ZSB0aGUgY29udGVudCBvZiB0aGlzIHByb3BlcnR5LiAqL1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0ge307XG4gICAgICAgIC8qIFByaXZhdGUgdmFyaWFibGUgdXNlZCB3aGVuIGludm9raW5nIGdldFNvdXJjZVZhcmlhbnQgKi9cbiAgICAgICAgbGV0IGJvdW5kR2V0U291cmNlVmFyaWFudCA9IHRoaXMuZGVmYXVsdEdldFNvdXJjZVZhcmlhbnQuYmluZCh0aGlzKTtcbiAgICAgICAgLyoqIEZ1bmN0aW9uIHRvIGluZmVyIHRoZSB2YXJpYW50IHNlbGVjdGVkIGJ5IGEgc291cmNlIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogRGVmYXVsdHMgdG8ge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fSBidXQgbWF5XG4gICAgICAgICAqIGJlIG92ZXJyaWRkZW4gdXNpbmcge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2NvbmZpZ0dldFNvdXJjZVZhcmlhbnR8Y29uZmlnR2V0U291cmNlVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgLSBhcyB3aXRoIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHsodW5kZWZpbmVkfFZhcmlhbnRMYXlvdXQpfSBUaGUgZGVmYXVsdCB2YXJpYW50XG4gICAgICAgICAqIChgdW5kZWZpbmVkYCkgb3IgZmlyc3QgcmVnaXN0ZXJlZCB2YXJpYW50IHRoYXQgdXNlcyBhIHByb3BlcnR5XG4gICAgICAgICAqIGF2YWlsYWJsZSBpbiBgc3JjYC4gKi9cbiAgICAgICAgdGhpcy5nZXRTb3VyY2VWYXJpYW50ID0gZnVuY3Rpb24gKHNyYykge1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kR2V0U291cmNlVmFyaWFudChzcmMpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogRnVuY3Rpb24gdG8gb3ZlcnJpZGUgdGhlIGltcGxlbWVudGF0aW9uIG9mIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNnZXRTb3VyY2VWYXJpYW50fGdldFNvdXJjZVZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2UgdGhpcyBpZiB0aGUgZGVzaXJlZCB2YXJpYW50IGNhbm5vdCBiZSBpZGVudGlmaWVkIHVzaW5nIHRoZVxuICAgICAgICAgKiBhbGdvcml0aG0gb2Yge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFKiogVGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBib3VuZCB0byB0aGlzXG4gICAgICAgICAqIFVuaW9uIGluc3RhbmNlLCBwcm92aWRpbmcgbG9jYWwgYWNjZXNzIHRvIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNyZWdpc3RyeXxyZWdpc3RyeX0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdzdiAtIGEgZnVuY3Rpb24gdGhhdCBmb2xsb3dzIHRoZSBBUEkgb2ZcbiAgICAgICAgICoge0BsaW5rIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fS4gKi9cbiAgICAgICAgdGhpcy5jb25maWdHZXRTb3VyY2VWYXJpYW50ID0gZnVuY3Rpb24gKGdzdikge1xuICAgICAgICAgICAgYm91bmRHZXRTb3VyY2VWYXJpYW50ID0gZ3N2LmJpbmQodGhpcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIC8qIERlZmF1bHQgbGF5b3V0cyBhbHdheXMgaGF2ZSBub24tbmVnYXRpdmUgc3Bhbiwgc28gd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgKiBvbmUgYW5kIHdlIGhhdmUgdG8gcmVjb2duaXplIHRoZSB2YXJpYW50IHdoaWNoIHdpbGwgaW4gdHVyblxuICAgICAgICAgKiBkZXRlcm1pbmUgdGhlIHNwYW4uICovXG4gICAgICAgIGNvbnN0IHZsbyA9IHRoaXMuZ2V0VmFyaWFudChiLCBvZmZzZXQpO1xuICAgICAgICBpZiAoIXZsbykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGV0ZXJtaW5lIHNwYW4gZm9yIHVucmVjb2duaXplZCB2YXJpYW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZsby5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBpbmZlciBhIHJlZ2lzdGVyZWQgVW5pb24gdmFyaWFudCBjb21wYXRpYmxlIHdpdGggYHNyY2AuXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3Qgc2F0aXNmaWVkIHJ1bGUgaW4gdGhlIGZvbGxvd2luZyBzZXF1ZW5jZSBkZWZpbmVzIHRoZVxuICAgICAqIHJldHVybiB2YWx1ZTpcbiAgICAgKiAqIElmIGBzcmNgIGhhcyBwcm9wZXJ0aWVzIG1hdGNoaW5nIHRoZSBVbmlvbiBkaXNjcmltaW5hdG9yIGFuZFxuICAgICAqICAgdGhlIGRlZmF1bHQgbGF5b3V0LCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCByZWdhcmRsZXNzIG9mIHRoZVxuICAgICAqICAgdmFsdWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkgKHRoaXMgZW5zdXJlcyB0aGUgZGVmYXVsdFxuICAgICAqICAgbGF5b3V0IHdpbGwgYmUgdXNlZCk7XG4gICAgICogKiBJZiBgc3JjYCBoYXMgYSBwcm9wZXJ0eSBtYXRjaGluZyB0aGUgVW5pb24gZGlzY3JpbWluYXRvciwgdGhlXG4gICAgICogICB2YWx1ZSBvZiB0aGUgZGlzY3JpbWluYXRvciBpZGVudGlmaWVzIGEgcmVnaXN0ZXJlZCB2YXJpYW50LCBhbmRcbiAgICAgKiAgIGVpdGhlciAoYSkgdGhlIHZhcmlhbnQgaGFzIG5vIGxheW91dCwgb3IgKGIpIGBzcmNgIGhhcyB0aGVcbiAgICAgKiAgIHZhcmlhbnQncyBwcm9wZXJ0eSwgdGhlbiB0aGUgdmFyaWFudCBpcyByZXR1cm5lZCAoYmVjYXVzZSB0aGVcbiAgICAgKiAgIHNvdXJjZSBzYXRpc2ZpZXMgdGhlIGNvbnN0cmFpbnRzIG9mIHRoZSB2YXJpYW50IGl0IGlkZW50aWZpZXMpO1xuICAgICAqICogSWYgYHNyY2AgZG9lcyBub3QgaGF2ZSBhIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBVbmlvblxuICAgICAqICAgZGlzY3JpbWluYXRvciwgYnV0IGRvZXMgaGF2ZSBhIHByb3BlcnR5IG1hdGNoaW5nIGEgcmVnaXN0ZXJlZFxuICAgICAqICAgdmFyaWFudCwgdGhlbiB0aGUgdmFyaWFudCBpcyByZXR1cm5lZCAoYmVjYXVzZSB0aGUgc291cmNlXG4gICAgICogICBtYXRjaGVzIGEgdmFyaWFudCB3aXRob3V0IGFuIGV4cGxpY2l0IGNvbmZsaWN0KTtcbiAgICAgKiAqIEFuIGVycm9yIGlzIHRocm93biAoYmVjYXVzZSB3ZSBlaXRoZXIgY2FuJ3QgaWRlbnRpZnkgYSB2YXJpYW50LFxuICAgICAqICAgb3Igd2Ugd2VyZSBleHBsaWNpdGx5IHRvbGQgdGhlIHZhcmlhbnQgYnV0IGNhbid0IHNhdGlzZnkgaXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyYyAtIGFuIG9iamVjdCBwcmVzdW1lZCB0byBiZSBjb21wYXRpYmxlIHdpdGhcbiAgICAgKiB0aGUgY29udGVudCBvZiB0aGUgVW5pb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsodW5kZWZpbmVkfFZhcmlhbnRMYXlvdXQpfSAtIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSAtIGlmIGBzcmNgIGNhbm5vdCBiZSBhc3NvY2lhdGVkIHdpdGggYSBkZWZhdWx0IG9yXG4gICAgICogcmVnaXN0ZXJlZCB2YXJpYW50LlxuICAgICAqL1xuICAgIGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50KHNyYykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgdGhpcy5kaXNjcmltaW5hdG9yLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdExheW91dCAmJiB0aGlzLmRlZmF1bHRMYXlvdXQucHJvcGVydHlcbiAgICAgICAgICAgICAgICAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB0aGlzLmRlZmF1bHRMYXlvdXQucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZsbyA9IHRoaXMucmVnaXN0cnlbc3JjW3RoaXMuZGlzY3JpbWluYXRvci5wcm9wZXJ0eV1dO1xuICAgICAgICAgICAgaWYgKHZsb1xuICAgICAgICAgICAgICAgICYmICgoIXZsby5sYXlvdXQpXG4gICAgICAgICAgICAgICAgICAgIHx8ICh2bG8ucHJvcGVydHkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgdmxvLnByb3BlcnR5KSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZsbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFnIGluIHRoaXMucmVnaXN0cnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2bG8gPSB0aGlzLnJlZ2lzdHJ5W3RhZ107XG4gICAgICAgICAgICAgICAgaWYgKHZsby5wcm9wZXJ0eSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB2bG8ucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2bG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGluZmVyIHNyYyB2YXJpYW50Jyk7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAgICAgKlxuICAgICAqIElmIHRoZSB2YXJpYW50IGlzIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fHJlZ2lzdGVyZWR9IHRoZSByZXR1cm5cbiAgICAgKiB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGF0IHZhcmlhbnQsIHdpdGggbm8gZXhwbGljaXRcbiAgICAgKiBkaXNjcmltaW5hdG9yLiAgT3RoZXJ3aXNlIHRoZSB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0XG4gICAgICogbGF5b3V0fSBpcyB1c2VkIHRvIGRlY29kZSB0aGUgY29udGVudC4gKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZGVzdDtcbiAgICAgICAgY29uc3QgZGxvID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjciA9IGRsby5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgY2xvID0gdGhpcy5yZWdpc3RyeVtkaXNjcl07XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNsbykge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdExheW91dCA9IHRoaXMuZGVmYXVsdExheW91dDtcbiAgICAgICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICAgICAgY29udGVudE9mZnNldCA9IGRsby5sYXlvdXQuc3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICAgICAgZGVzdFtkbG8ucHJvcGVydHldID0gZGlzY3I7XG4gICAgICAgICAgICAvLyBkZWZhdWx0TGF5b3V0LnByb3BlcnR5IGNhbiBiZSB1bmRlZmluZWQsIGJ1dCB0aGlzIGlzIGFsbG93ZWQgYnkgYnVmZmVyLWxheW91dFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGRlc3RbZGVmYXVsdExheW91dC5wcm9wZXJ0eV0gPSBkZWZhdWx0TGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3QgPSBjbG8uZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAgICAgKlxuICAgICAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGBzcmNgIG9iamVjdCBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHVuaW9uJ3NcbiAgICAgKiB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0uICBUbyBlbmNvZGUgdmFyaWFudHNcbiAgICAgKiB1c2UgdGhlIGFwcHJvcHJpYXRlIHZhcmlhbnQtc3BlY2lmaWMge0BsaW5rIFZhcmlhbnRMYXlvdXQjZW5jb2RlfVxuICAgICAqIG1ldGhvZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHZsbyA9IHRoaXMuZ2V0U291cmNlVmFyaWFudChzcmMpO1xuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB2bG8pIHtcbiAgICAgICAgICAgIGNvbnN0IGRsbyA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgICAgIC8vIHRoaXMuZGVmYXVsdExheW91dCBpcyBub3QgdW5kZWZpbmVkIHdoZW4gdmxvIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGNvbnN0IGNsbyA9IHRoaXMuZGVmYXVsdExheW91dDtcbiAgICAgICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICAgICAgY29udGVudE9mZnNldCA9IGRsby5sYXlvdXQuc3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRsby5lbmNvZGUoc3JjW2Rsby5wcm9wZXJ0eV0sIGIsIG9mZnNldCk7XG4gICAgICAgICAgICAvLyBjbG8ucHJvcGVydHkgaXMgbm90IHVuZGVmaW5lZCB3aGVuIHZsbyBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICByZXR1cm4gY29udGVudE9mZnNldCArIGNsby5lbmNvZGUoc3JjW2Nsby5wcm9wZXJ0eV0sIGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bG8uZW5jb2RlKHNyYywgYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVyIGEgbmV3IHZhcmlhbnQgc3RydWN0dXJlIHdpdGhpbiBhIHVuaW9uLiAgVGhlIG5ld2x5XG4gICAgICogY3JlYXRlZCB2YXJpYW50IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhcmlhbnQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogVmFyaWFudExheW91dCN2YXJpYW50fHZhcmlhbnR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWYXJpYW50TGF5b3V0fSAqL1xuICAgIGFkZFZhcmlhbnQodmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBjb25zdCBydiA9IG5ldyBWYXJpYW50TGF5b3V0KHRoaXMsIHZhcmlhbnQsIGxheW91dCwgcHJvcGVydHkpO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5W3ZhcmlhbnRdID0gcnY7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsYXlvdXQgYXNzb2NpYXRlZCB3aXRoIGEgcmVnaXN0ZXJlZCB2YXJpYW50LlxuICAgICAqXG4gICAgICogSWYgYHZiYCBkb2VzIG5vdCBwcm9kdWNlIGEgcmVnaXN0ZXJlZCB2YXJpYW50IHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhOdW1iZXJ8VWludDhBcnJheSl9IHZiIC0gZWl0aGVyIHRoZSB2YXJpYW50IG51bWJlciwgb3IgYVxuICAgICAqIGJ1ZmZlciBmcm9tIHdoaWNoIHRoZSBkaXNjcmltaW5hdG9yIGlzIHRvIGJlIHJlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IC0gb2Zmc2V0IGludG8gYHZiYCBmb3IgdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIHVuaW9uLiAgVXNlZCBvbmx5IHdoZW4gYHZiYCBpcyBhbiBpbnN0YW5jZSBvZiB7VWludDhBcnJheX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsoe1ZhcmlhbnRMYXlvdXR9fHVuZGVmaW5lZCl9XG4gICAgICovXG4gICAgZ2V0VmFyaWFudCh2Yiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgdmFyaWFudDtcbiAgICAgICAgaWYgKHZiIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgdmFyaWFudCA9IHRoaXMuZGlzY3JpbWluYXRvci5kZWNvZGUodmIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXJpYW50ID0gdmI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnlbdmFyaWFudF07XG4gICAgfVxufVxuZXhwb3J0cy5VbmlvbiA9IFVuaW9uO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzcGVjaWZpYyB2YXJpYW50IHdpdGhpbiBhIGNvbnRhaW5pbmcgdW5pb24uXG4gKlxuICogKipOT1RFKiogVGhlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBvZiB0aGUgdmFyaWFudCBtYXkgaW5jbHVkZVxuICogdGhlIHNwYW4gb2YgdGhlIHtAbGluayBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IHVzZWQgdG9cbiAqIGlkZW50aWZ5IGl0LCBidXQgdmFsdWVzIHJlYWQgYW5kIHdyaXR0ZW4gdXNpbmcgdGhlIHZhcmlhbnQgc3RyaWN0bHlcbiAqIGNvbmZvcm0gdG8gdGhlIGNvbnRlbnQgb2Yge0BsaW5rIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uXG4gKlxuICogKipOT1RFKiogVXNlciBjb2RlIHNob3VsZCBub3QgaW52b2tlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuICBVc2VcbiAqIHRoZSB1bmlvbiB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRWYXJpYW50fSBoZWxwZXIgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7VW5pb259IHVuaW9uIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVmFyaWFudExheW91dCN1bmlvbnx1bmlvbn0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhcmlhbnQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0I3ZhcmlhbnR8dmFyaWFudH0uXG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IFtsYXlvdXRdIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS4gIElmIGFic2VudCB0aGUgdmFyaWFudCBjYXJyaWVzIG5vXG4gKiBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS4gIFVubGlrZSBtYW55IG90aGVyIGxheW91dHMsIHZhcmlhbnRcbiAqIGxheW91dHMgbm9ybWFsbHkgaW5jbHVkZSBhIHByb3BlcnR5IG5hbWUgc28gdGhleSBjYW4gYmUgaWRlbnRpZmllZFxuICogd2l0aGluIHRoZWlyIGNvbnRhaW5pbmcge0BsaW5rIFVuaW9ufS4gIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVyIG1heVxuICogYmUgYWJzZW50IG9ubHkgaWYgYGxheW91dGAgaXMgaXMgYWJzZW50LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBWYXJpYW50TGF5b3V0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcih1bmlvbiwgdmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoISh1bmlvbiBpbnN0YW5jZW9mIFVuaW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5pb24gbXVzdCBiZSBhIFVuaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghTnVtYmVyLmlzSW50ZWdlcih2YXJpYW50KSkgfHwgKDAgPiB2YXJpYW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFyaWFudCBtdXN0IGJlIGEgKG5vbi1uZWdhdGl2ZSkgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoJ3N0cmluZycgPT09IHR5cGVvZiBsYXlvdXQpXG4gICAgICAgICAgICAmJiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gbGF5b3V0O1xuICAgICAgICAgICAgbGF5b3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5b3V0KSB7XG4gICAgICAgICAgICBpZiAoIShsYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobnVsbCAhPT0gdW5pb24uZGVmYXVsdExheW91dClcbiAgICAgICAgICAgICAgICAmJiAoMCA8PSBsYXlvdXQuc3BhbilcbiAgICAgICAgICAgICAgICAmJiAobGF5b3V0LnNwYW4gPiB1bmlvbi5kZWZhdWx0TGF5b3V0LnNwYW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYW50IHNwYW4gZXhjZWVkcyBzcGFuIG9mIGNvbnRhaW5pbmcgdW5pb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFyaWFudCBtdXN0IGhhdmUgYSBTdHJpbmcgcHJvcGVydHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IHVuaW9uLnNwYW47XG4gICAgICAgIGlmICgwID4gdW5pb24uc3Bhbikge1xuICAgICAgICAgICAgc3BhbiA9IGxheW91dCA/IGxheW91dC5zcGFuIDogMDtcbiAgICAgICAgICAgIGlmICgoMCA8PSBzcGFuKSAmJiB1bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgICAgIHNwYW4gKz0gdW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIFVuaW9ufSB0byB3aGljaCB0aGlzIHZhcmlhbnQgYmVsb25ncy4gKi9cbiAgICAgICAgdGhpcy51bmlvbiA9IHVuaW9uO1xuICAgICAgICAvKiogVGhlIHVuc2lnbmVkIGludGVncmFsIHZhbHVlIGlkZW50aWZ5aW5nIHRoaXMgdmFyaWFudCB3aXRoaW5cbiAgICAgICAgICogdGhlIHtAbGluayBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IG9mIHRoZSBjb250YWluaW5nXG4gICAgICAgICAqIHVuaW9uLiAqL1xuICAgICAgICB0aGlzLnZhcmlhbnQgPSB2YXJpYW50O1xuICAgICAgICAvKiogVGhlIHtAbGluayBMYXlvdXR9IHRvIGJlIHVzZWQgd2hlbiByZWFkaW5nL3dyaXRpbmcgdGhlXG4gICAgICAgICAqIG5vbi1kaXNjcmltaW5hdG9yIHBhcnQgb2YgdGhlIHtAbGlua1xuICAgICAgICAgKiBWYXJpYW50TGF5b3V0I3VuaW9ufHVuaW9ufS4gIElmIGBudWxsYCB0aGUgdmFyaWFudCBjYXJyaWVzIG5vXG4gICAgICAgICAqIGRhdGEuICovXG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0IHx8IG51bGw7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICAvKiBXaWxsIGJlIGVxdWFsIHRvIHRoZSBjb250YWluaW5nIHVuaW9uIHNwYW4gaWYgdGhhdCBpcyBub3RcbiAgICAgICAgICAgICAqIHZhcmlhYmxlLiAqL1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIC8qIFNwYW4gaXMgZGVmaW5lZCBzb2xlbHkgYnkgdGhlIHZhcmlhbnQgKGFuZCBwcmVmaXggZGlzY3JpbWluYXRvcikgKi9cbiAgICAgICAgbGV0IHNwYW4gPSAwO1xuICAgICAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLmxheW91dC5nZXRTcGFuKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50T2Zmc2V0ICsgc3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICBpZiAodGhpcyAhPT0gdGhpcy51bmlvbi5nZXRWYXJpYW50KGIsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmFyaWFudCBtaXNtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICAgICAgICBkZXN0W3RoaXMucHJvcGVydHldID0gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcGVydHkpIHtcbiAgICAgICAgICAgIGRlc3RbdGhpcy5wcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIGRlc3RbdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLnByb3BlcnR5XSA9IHRoaXMudmFyaWFudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXlvdXRcbiAgICAgICAgICAgICYmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgdGhpcy5wcm9wZXJ0eSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YXJpYW50IGxhY2tzIHByb3BlcnR5ICcgKyB0aGlzLnByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IuZW5jb2RlKHRoaXMudmFyaWFudCwgYiwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IHNwYW4gPSBjb250ZW50T2Zmc2V0O1xuICAgICAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0LmVuY29kZShzcmNbdGhpcy5wcm9wZXJ0eV0sIGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICAgICAgc3BhbiArPSB0aGlzLmxheW91dC5nZXRTcGFuKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCgwIDw9IHRoaXMudW5pb24uc3BhbilcbiAgICAgICAgICAgICAgICAmJiAoc3BhbiA+IHRoaXMudW5pb24uc3BhbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuY29kZWQgdmFyaWFudCBvdmVycnVucyBjb250YWluaW5nIHVuaW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIC8qKiBEZWxlZ2F0ZSB7QGxpbmsgTGF5b3V0I2Zyb21BcnJheXxmcm9tQXJyYXl9IHRvIHtAbGlua1xuICAgICAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uICovXG4gICAgZnJvbUFycmF5KHZhbHVlcykge1xuICAgICAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5mcm9tQXJyYXkodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFyaWFudExheW91dCA9IFZhcmlhbnRMYXlvdXQ7XG4vKiogSmF2YVNjcmlwdCBjaG9zZSB0byBkZWZpbmUgYml0d2lzZSBvcGVyYXRpb25zIGFzIG9wZXJhdGluZyBvblxuICogc2lnbmVkIDMyLWJpdCB2YWx1ZXMgaW4gMidzIGNvbXBsZW1lbnQgZm9ybSwgbWVhbmluZyBhbnkgaW50ZWdlclxuICogd2l0aCBiaXQgMzEgc2V0IGlzIGdvaW5nIHRvIGxvb2sgbmVnYXRpdmUuICBGb3IgcmlnaHQgc2hpZnRzIHRoYXQnc1xuICogbm90IGEgcHJvYmxlbSwgYmVjYXVzZSBgPj4+YCBpcyBhIGxvZ2ljYWwgc2hpZnQsIGJ1dCBmb3IgZXZlcnlcbiAqIG90aGVyIGJpdHdpc2Ugb3BlcmF0b3Igd2UgaGF2ZSB0byBjb21wZW5zYXRlIGZvciBwb3NzaWJsZSBuZWdhdGl2ZVxuICogcmVzdWx0cy4gKi9cbmZ1bmN0aW9uIGZpeEJpdHdpc2VSZXN1bHQodikge1xuICAgIGlmICgwID4gdikge1xuICAgICAgICB2ICs9IDB4MTAwMDAwMDAwO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbi8qKlxuICogQ29udGFpbiBhIHNlcXVlbmNlIG9mIGJpdCBmaWVsZHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmJpdHN8Yml0c31cbiAqXG4gKiBUaGlzIGlzIGEgY29udGFpbmVyIGVsZW1lbnQ7IHdpdGhpbiBpdCB0aGVyZSBhcmUge0BsaW5rIEJpdEZpZWxkfVxuICogaW5zdGFuY2VzIHRoYXQgcHJvdmlkZSB0aGUgZXh0cmFjdGVkIHByb3BlcnRpZXMuICBUaGUgY29udGFpbmVyXG4gKiBzaW1wbHkgZGVmaW5lcyB0aGUgYWdncmVnYXRlIHJlcHJlc2VudGF0aW9uIGFuZCBpdHMgYml0IG9yZGVyaW5nLlxuICogVGhlIHJlcHJlc2VudGF0aW9uIGlzIGFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgd2l0aCBudW1lcmljXG4gKiBvciB7QGxpbmsgQm9vbGVhbn0gdmFsdWVzLlxuICpcbiAqIHtAbGluayBCaXRGaWVsZH1zIGFyZSBhZGRlZCB3aXRoIHRoZSB7QGxpbmtcbiAqIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gYW5kIHtAbGlua1xuICogQml0U3RydWN0dXJlI2FkZEJvb2xlYW58YWRkQm9vbGVhbn0gbWV0aG9kcy5cblxuICogQHBhcmFtIHtMYXlvdXR9IHdvcmQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBCaXRTdHJ1Y3R1cmUjd29yZHx3b3JkfS4gIFRoZSBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZlxuICoge0BsaW5rIFVJbnR9IChvciB7QGxpbmsgVUludEJFfSkgdGhhdCBpcyBubyBtb3JlIHRoYW4gNCBieXRlcyB3aWRlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbH0gW21zYl0gLSBgdHJ1ZWAgaWYgdGhlIGJpdCBudW1iZXJpbmcgc3RhcnRzIGF0IHRoZVxuICogbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGNvbnRhaW5pbmcgd29yZDsgYGZhbHNlYCAoZGVmYXVsdCkgaWZcbiAqIGl0IHN0YXJ0cyBhdCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBjb250YWluaW5nIHdvcmQuICBJZlxuICogdGhlIHBhcmFtZXRlciBhdCB0aGlzIHBvc2l0aW9uIGlzIGEgc3RyaW5nIGFuZCBgcHJvcGVydHlgIGlzXG4gKiBgdW5kZWZpbmVkYCB0aGUgdmFsdWUgb2YgdGhpcyBhcmd1bWVudCB3aWxsIGluc3RlYWQgYmUgdXNlZCBhcyB0aGVcbiAqIHZhbHVlIG9mIGBwcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBCaXRTdHJ1Y3R1cmUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHdvcmQsIG1zYiwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEoKHdvcmQgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgfHwgKHdvcmQgaW5zdGFuY2VvZiBVSW50QkUpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd29yZCBtdXN0IGJlIGEgVUludCBvciBVSW50QkUgbGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgnc3RyaW5nJyA9PT0gdHlwZW9mIG1zYilcbiAgICAgICAgICAgICYmICh1bmRlZmluZWQgPT09IHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBtc2I7XG4gICAgICAgICAgICBtc2IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoNCA8IHdvcmQuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dvcmQgY2Fubm90IGV4Y2VlZCAzMiBiaXRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIod29yZC5zcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbGF5b3V0IHVzZWQgZm9yIHRoZSBwYWNrZWQgdmFsdWUuICB7QGxpbmsgQml0RmllbGR9XG4gICAgICAgICAqIGluc3RhbmNlcyBhcmUgcGFja2VkIHNlcXVlbnRpYWxseSBkZXBlbmRpbmcgb24ge0BsaW5rXG4gICAgICAgICAqIEJpdFN0cnVjdHVyZSNtc2J8bXNifS4gKi9cbiAgICAgICAgdGhpcy53b3JkID0gd29yZDtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGJpdCBzZXF1ZW5jZXMgYXJlIHBhY2tlZCBzdGFydGluZyBhdCB0aGUgbW9zdFxuICAgICAgICAgKiBzaWduaWZpY2FudCBiaXQgZ3Jvd2luZyBkb3duIChgdHJ1ZWApLCBvciB0aGUgbGVhc3Qgc2lnbmlmaWNhbnRcbiAgICAgICAgICogYml0IGdyb3dpbmcgdXAgKGBmYWxzZWApLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEUqKiBSZWdhcmRsZXNzIG9mIHRoaXMgdmFsdWUsIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2ZcbiAgICAgICAgICogYW55IHtAbGluayBCaXRGaWVsZH0gdmFsdWUgaXMgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZiB0aGVcbiAgICAgICAgICogY29ycmVzcG9uZGluZyBzZWN0aW9uIG9mIHRoZSBwYWNrZWQgdmFsdWUuICovXG4gICAgICAgIHRoaXMubXNiID0gISFtc2I7XG4gICAgICAgIC8qKiBUaGUgc2VxdWVuY2Ugb2Yge0BsaW5rIEJpdEZpZWxkfSBsYXlvdXRzIHRoYXQgY29tcHJpc2UgdGhlXG4gICAgICAgICAqIHBhY2tlZCBzdHJ1Y3R1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URSoqIFRoZSBhcnJheSByZW1haW5zIG11dGFibGUgdG8gYWxsb3cgZmllbGRzIHRvIGJlIHtAbGlua1xuICAgICAgICAgKiBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkZWR9IGFmdGVyIGNvbnN0cnVjdGlvbi4gIFVzZXJzIHNob3VsZFxuICAgICAgICAgKiBub3QgbWFuaXB1bGF0ZSB0aGUgY29udGVudCBvZiB0aGlzIHByb3BlcnR5LiovXG4gICAgICAgIHRoaXMuZmllbGRzID0gW107XG4gICAgICAgIC8qIFN0b3JhZ2UgZm9yIHRoZSB2YWx1ZS4gIENhcHR1cmUgYSB2YXJpYWJsZSBpbnN0ZWFkIG9mIHVzaW5nIGFuXG4gICAgICAgICAqIGluc3RhbmNlIHByb3BlcnR5IGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBhbnl0aGluZyB0byBjaGFuZ2UgdGhlXG4gICAgICAgICAqIHZhbHVlIHdpdGhvdXQgZ29pbmcgdGhyb3VnaCB0aGUgbXV0YXRvci4gKi9cbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5fcGFja2VkU2V0VmFsdWUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFsdWUgPSBmaXhCaXR3aXNlUmVzdWx0KHYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BhY2tlZEdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy53b3JkLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSBmZC5kZWNvZGUoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIEJpdFN0cnVjdHVyZX0uXG4gICAgICpcbiAgICAgKiBJZiBgc3JjYCBpcyBtaXNzaW5nIGEgcHJvcGVydHkgZm9yIGEgbWVtYmVyIHdpdGggYSBkZWZpbmVkIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIGNvcnJlc3BvbmRpbmcgcmVnaW9uIG9mIHRoZSBwYWNrZWRcbiAgICAgKiB2YWx1ZSBpcyBsZWZ0IHVubW9kaWZpZWQuICBVbnVzZWQgYml0cyBhcmUgYWxzbyBsZWZ0IHVubW9kaWZpZWQuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMud29yZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fcGFja2VkU2V0VmFsdWUodmFsdWUpO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ2ID0gc3JjW2ZkLnByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmdikge1xuICAgICAgICAgICAgICAgICAgICBmZC5lbmNvZGUoZnYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53b3JkLmVuY29kZSh0aGlzLl9wYWNrZWRHZXRWYWx1ZSgpLCBiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogUmVnaXN0ZXIgYSBuZXcgYml0ZmllbGQgd2l0aCBhIGNvbnRhaW5pbmcgYml0IHN0cnVjdHVyZS4gIFRoZVxuICAgICAqIHJlc3VsdGluZyBiaXRmaWVsZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiaXRzIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCaXRGaWVsZH0gKi9cbiAgICBhZGRGaWVsZChiaXRzLCBwcm9wZXJ0eSkge1xuICAgICAgICBjb25zdCBiZiA9IG5ldyBCaXRGaWVsZCh0aGlzLCBiaXRzLCBwcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMuZmllbGRzLnB1c2goYmYpO1xuICAgICAgICByZXR1cm4gYmY7XG4gICAgfVxuICAgIC8qKiBBcyB3aXRoIHtAbGluayBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkRmllbGR9IGZvciBzaW5nbGUtYml0XG4gICAgICogZmllbGRzIHdpdGggYGJvb2xlYW5gIHZhbHVlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAqL1xuICAgIC8vIGBCb29sZWFuYCBjb25mbGljdHMgd2l0aCB0aGUgbmF0aXZlIHByaW1pdGl2ZSB0eXBlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgICBhZGRCb29sZWFuKHByb3BlcnR5KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgbXkgQm9vbGVhbiwgbm90IHRoZSBKYXZhc2NyaXB0IG9uZS5cbiAgICAgICAgY29uc3QgYmYgPSBuZXcgQm9vbGVhbih0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMuZmllbGRzLnB1c2goYmYpO1xuICAgICAgICByZXR1cm4gYmY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhY2Nlc3MgdG8gdGhlIGJpdCBmaWVsZCBmb3IgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBiaXQgZmllbGQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCaXRGaWVsZH0gLSB0aGUgZmllbGQgYXNzb2NpYXRlZCB3aXRoIGBwcm9wZXJ0eWAsIG9yXG4gICAgICogdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcHJvcGVydHkuXG4gICAgICovXG4gICAgZmllbGRGb3IocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IG11c3QgYmUgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuQml0U3RydWN0dXJlID0gQml0U3RydWN0dXJlO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzZXF1ZW5jZSBvZiBiaXRzIHdpdGhpbiBhIHtAbGluayBCaXRTdHJ1Y3R1cmV9LlxuICpcbiAqIEFsbCBiaXQgZmllbGQgdmFsdWVzIGFyZSByZXByZXNlbnRlZCBhcyB1bnNpZ25lZCBpbnRlZ2Vycy5cbiAqXG4gKiAqKk5PVEUqKiBVc2VyIGNvZGUgc2hvdWxkIG5vdCBpbnZva2UgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS5cbiAqIFVzZSB0aGUgY29udGFpbmVyIHtAbGluayBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkRmllbGR9IGhlbHBlclxuICogbWV0aG9kLlxuICpcbiAqICoqTk9URSoqIEJpdEZpZWxkIGluc3RhbmNlcyBhcmUgbm90IGluc3RhbmNlcyBvZiB7QGxpbmsgTGF5b3V0fVxuICogc2luY2Uge0BsaW5rIExheW91dCNzcGFufHNwYW59IG1lYXN1cmVzIDgtYml0IHVuaXRzLlxuICpcbiAqIEBwYXJhbSB7Qml0U3RydWN0dXJlfSBjb250YWluZXIgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBCaXRGaWVsZCNjb250YWluZXJ8Y29udGFpbmVyfS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYml0cyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKi9cbmNsYXNzIEJpdEZpZWxkIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIGJpdHMsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKGNvbnRhaW5lciBpbnN0YW5jZW9mIEJpdFN0cnVjdHVyZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbnRhaW5lciBtdXN0IGJlIGEgQml0U3RydWN0dXJlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghTnVtYmVyLmlzSW50ZWdlcihiaXRzKSkgfHwgKDAgPj0gYml0cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JpdHMgbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxCaXRzID0gOCAqIGNvbnRhaW5lci5zcGFuO1xuICAgICAgICBjb25zdCB1c2VkQml0cyA9IGNvbnRhaW5lci5maWVsZHMucmVkdWNlKChzdW0sIGZkKSA9PiBzdW0gKyBmZC5iaXRzLCAwKTtcbiAgICAgICAgaWYgKChiaXRzICsgdXNlZEJpdHMpID4gdG90YWxCaXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpdHMgdG9vIGxvbmcgZm9yIHNwYW4gcmVtYWluZGVyICgnXG4gICAgICAgICAgICAgICAgKyAodG90YWxCaXRzIC0gdXNlZEJpdHMpICsgJyBvZiAnXG4gICAgICAgICAgICAgICAgKyB0b3RhbEJpdHMgKyAnIHJlbWFpbiknKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogVGhlIHtAbGluayBCaXRTdHJ1Y3R1cmV9IGluc3RhbmNlIHRvIHdoaWNoIHRoaXMgYml0IGZpZWxkXG4gICAgICAgICAqIGJlbG9uZ3MuICovXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAvKiogVGhlIHNwYW4gb2YgdGhpcyB2YWx1ZSBpbiBiaXRzLiAqL1xuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgICAgICAvKiogQSBtYXNrIG9mIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9IGJpdHMgaXNvbGF0aW5nIHZhbHVlIGJpdHNcbiAgICAgICAgICogdGhhdCBmaXQgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhhdCBpcywgaXQgbWFza3MgYSB2YWx1ZSB0aGF0IGhhcyBub3QgeWV0IGJlZW4gc2hpZnRlZCBpbnRvXG4gICAgICAgICAqIHBvc2l0aW9uIHdpdGhpbiBpdHMgY29udGFpbmluZyBwYWNrZWQgaW50ZWdlci4gKi9cbiAgICAgICAgdGhpcy52YWx1ZU1hc2sgPSAoMSA8PCBiaXRzKSAtIDE7XG4gICAgICAgIGlmICgzMiA9PT0gYml0cykgeyAvLyBzaGlmdGVkIHZhbHVlIG91dCBvZiByYW5nZVxuICAgICAgICAgICAgdGhpcy52YWx1ZU1hc2sgPSAweEZGRkZGRkZGO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSB2YWx1ZSB3aXRoaW4gdGhlIGNvbnRhaW5pbmcgcGFja2VkIHVuc2lnbmVkXG4gICAgICAgICAqIGludGVnZXIuICBUaGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBwYWNrZWQgdmFsdWUgaXMgYXRcbiAgICAgICAgICogb2Zmc2V0IHplcm8sIHJlZ2FyZGxlc3Mgb2YgYml0IG9yZGVyaW5nIHVzZWQuICovXG4gICAgICAgIHRoaXMuc3RhcnQgPSB1c2VkQml0cztcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLm1zYikge1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHRvdGFsQml0cyAtIHVzZWRCaXRzIC0gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvKiogQSBtYXNrIG9mIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9IGlzb2xhdGluZyB0aGUgZmllbGQgdmFsdWVcbiAgICAgICAgICogd2l0aGluIHRoZSBjb250YWluaW5nIHBhY2tlZCB1bnNpZ25lZCBpbnRlZ2VyLiAqL1xuICAgICAgICB0aGlzLndvcmRNYXNrID0gZml4Qml0d2lzZVJlc3VsdCh0aGlzLnZhbHVlTWFzayA8PCB0aGlzLnN0YXJ0KTtcbiAgICAgICAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIHVzZWQgd2hlbiB0aGlzIGJpdGZpZWxkIGlzIHJlcHJlc2VudGVkIGluIGFuXG4gICAgICAgICAqIE9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogSW50ZW5kZWQgdG8gYmUgZnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8ge0BsaW5rXG4gICAgICAgICAqIExheW91dCNwcm9wZXJ0eX0uXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGxlZnQgdW5kZWZpbmVkIHRoZSBjb3JyZXNwb25kaW5nIHNwYW4gb2YgYml0cyB3aWxsIGJlXG4gICAgICAgICAqIHRyZWF0ZWQgYXMgcGFkZGluZzogaXQgd2lsbCBub3QgYmUgbXV0YXRlZCBieSB7QGxpbmtcbiAgICAgICAgICogTGF5b3V0I2VuY29kZXxlbmNvZGV9IG5vciByZXByZXNlbnRlZCBhcyBhIHByb3BlcnR5IGluIHRoZVxuICAgICAgICAgKiBkZWNvZGVkIE9iamVjdC4gKi9cbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIH1cbiAgICAvKiogU3RvcmUgYSB2YWx1ZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHN1YnNlcXVlbmNlIG9mIHRoZSBjb250YWluaW5nXG4gICAgICogYml0IGZpZWxkLiAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgd29yZCA9IHRoaXMuY29udGFpbmVyLl9wYWNrZWRHZXRWYWx1ZSgpO1xuICAgICAgICBjb25zdCB3b3JkVmFsdWUgPSBmaXhCaXR3aXNlUmVzdWx0KHdvcmQgJiB0aGlzLndvcmRNYXNrKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB3b3JkVmFsdWUgPj4+IHRoaXMuc3RhcnQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIFN0b3JlIGEgdmFsdWUgaW50byB0aGUgY29ycmVzcG9uZGluZyBzdWJzZXF1ZW5jZSBvZiB0aGUgY29udGFpbmluZ1xuICAgICAqIGJpdCBmaWVsZC5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIFRoaXMgaXMgbm90IGEgc3BlY2lhbGl6YXRpb24gb2Yge0BsaW5rXG4gICAgICogTGF5b3V0I2VuY29kZXxMYXlvdXQuZW5jb2RlfSBhbmQgdGhlcmUgaXMgbm8gcmV0dXJuIHZhbHVlLiAqL1xuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICAgfHwgIU51bWJlci5pc0ludGVnZXIodmFsdWUpXG4gICAgICAgICAgICB8fCAodmFsdWUgIT09IGZpeEJpdHdpc2VSZXN1bHQodmFsdWUgJiB0aGlzLnZhbHVlTWFzaykpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5hbWVXaXRoUHJvcGVydHkoJ0JpdEZpZWxkLmVuY29kZScsIHRoaXMpXG4gICAgICAgICAgICAgICAgKyAnIHZhbHVlIG11c3QgYmUgaW50ZWdlciBub3QgZXhjZWVkaW5nICcgKyB0aGlzLnZhbHVlTWFzayk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29yZCA9IHRoaXMuY29udGFpbmVyLl9wYWNrZWRHZXRWYWx1ZSgpO1xuICAgICAgICBjb25zdCB3b3JkVmFsdWUgPSBmaXhCaXR3aXNlUmVzdWx0KHZhbHVlIDw8IHRoaXMuc3RhcnQpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5fcGFja2VkU2V0VmFsdWUoZml4Qml0d2lzZVJlc3VsdCh3b3JkICYgfnRoaXMud29yZE1hc2spXG4gICAgICAgICAgICB8IHdvcmRWYWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5CaXRGaWVsZCA9IEJpdEZpZWxkO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaW5nbGUgYml0IHdpdGhpbiBhIHtAbGluayBCaXRTdHJ1Y3R1cmV9IGFzIGFcbiAqIEphdmFTY3JpcHQgYm9vbGVhbi5cbiAqXG4gKiAqKk5PVEUqKiBVc2VyIGNvZGUgc2hvdWxkIG5vdCBpbnZva2UgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS5cbiAqIFVzZSB0aGUgY29udGFpbmVyIHtAbGluayBCaXRTdHJ1Y3R1cmUjYWRkQm9vbGVhbnxhZGRCb29sZWFufSBoZWxwZXJcbiAqIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge0JpdFN0cnVjdHVyZX0gY29udGFpbmVyIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQml0RmllbGQjY29udGFpbmVyfGNvbnRhaW5lcn0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7Qml0RmllbGR9XG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWV4dGVuZC1uYXRpdmUgKi9cbmNsYXNzIEJvb2xlYW4gZXh0ZW5kcyBCaXRGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihjb250YWluZXIsIDEsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIE92ZXJyaWRlIHtAbGluayBCaXRGaWVsZCNkZWNvZGV8ZGVjb2RlfSBmb3Ige0BsaW5rIEJvb2xlYW58Qm9vbGVhbn0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAhIXN1cGVyLmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQml0RmllbGQgcmVxdWlyZXMgaW50ZWdlciB2YWx1ZXNcbiAgICAgICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Cb29sZWFuID0gQm9vbGVhbjtcbi8qIGVzbGludC1lbmFibGUgbm8tZXh0ZW5kLW5hdGl2ZSAqL1xuLyoqXG4gKiBDb250YWluIGEgZml4ZWQtbGVuZ3RoIGJsb2NrIG9mIGFyYml0cmFyeSBkYXRhLCByZXByZXNlbnRlZCBhcyBhXG4gKiBVaW50OEFycmF5LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYmxvYnxibG9ifVxuICpcbiAqIEBwYXJhbSB7KE51bWJlcnxFeHRlcm5hbExheW91dCl9IGxlbmd0aCAtIGluaXRpYWxpemVzIHtAbGlua1xuICogQmxvYiNsZW5ndGh8bGVuZ3RofS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEJsb2IgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEoKChsZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkgJiYgbGVuZ3RoLmlzQ291bnQoKSlcbiAgICAgICAgICAgIHx8IChOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkgJiYgKDAgPD0gbGVuZ3RoKSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsZW5ndGggbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyICdcbiAgICAgICAgICAgICAgICArICdvciBhbiB1bnNpZ25lZCBpbnRlZ2VyIEV4dGVybmFsTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAtMTtcbiAgICAgICAgaWYgKCEobGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpKSB7XG4gICAgICAgICAgICBzcGFuID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIGJsb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWF5IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIG9yIGFuIGluc3RhbmNlIG9mIHtAbGlua1xuICAgICAgICAgKiBFeHRlcm5hbExheW91dH0gdGhhdCBzYXRpc2ZpZXMge0BsaW5rXG4gICAgICAgICAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudCgpfS4gKi9cbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgICAgICBsZXQgc3BhbiA9IHRoaXMuc3BhbjtcbiAgICAgICAgaWYgKDAgPiBzcGFuKSB7XG4gICAgICAgICAgICBzcGFuID0gdGhpcy5sZW5ndGguZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgc3BhbiA9IHRoaXMuc3BhbjtcbiAgICAgICAgaWYgKDAgPiBzcGFuKSB7XG4gICAgICAgICAgICBzcGFuID0gdGhpcy5sZW5ndGguZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5zbGljZShvZmZzZXQsIG9mZnNldCArIHNwYW4pO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCbG9ifS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIElmIHtAbGluayBMYXlvdXQjY291bnR8Y291bnR9IGlzIGFuIGluc3RhbmNlIG9mIHtAbGlua1xuICAgICAqIEV4dGVybmFsTGF5b3V0fSB0aGVuIHRoZSBsZW5ndGggb2YgYHNyY2Agd2lsbCBiZSBlbmNvZGVkIGFzIHRoZVxuICAgICAqIGNvdW50IGFmdGVyIGBzcmNgIGlzIGVuY29kZWQuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBzcGFuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICAgICAgICBzcGFuID0gc3JjLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzcmMgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHNwYW4gPT09IHNyYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5hbWVXaXRoUHJvcGVydHkoJ0Jsb2IuZW5jb2RlJywgdGhpcylcbiAgICAgICAgICAgICAgICArICcgcmVxdWlyZXMgKGxlbmd0aCAnICsgc3BhbiArICcpIFVpbnQ4QXJyYXkgYXMgc3JjJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvZmZzZXQgKyBzcGFuKSA+IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5jb2Rpbmcgb3ZlcnJ1bnMgVWludDhBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNyY0J1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihzcmMpO1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGUoc3JjQnVmZmVyLnRvU3RyaW5nKCdoZXgnKSwgb2Zmc2V0LCBzcGFuLCAnaGV4Jyk7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aC5lbmNvZGUoc3BhbiwgYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLkJsb2IgPSBCbG9iO1xuLyoqXG4gKiBDb250YWluIGEgYE5VTGAtdGVybWluYXRlZCBVVEY4IHN0cmluZy5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmNzdHJ8Y3N0cn1cbiAqXG4gKiAqKk5PVEUqKiBBbnkgVVRGOCBzdHJpbmcgdGhhdCBpbmNvcnBvcmF0ZXMgYSB6ZXJvLXZhbHVlZCBieXRlIHdpbGxcbiAqIG5vdCBiZSBjb3JyZWN0bHkgZGVjb2RlZCBieSB0aGlzIGxheW91dC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIENTdHJpbmcgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgICAgICBsZXQgaWR4ID0gb2Zmc2V0O1xuICAgICAgICB3aGlsZSAoKGlkeCA8IGIubGVuZ3RoKSAmJiAoMCAhPT0gYltpZHhdKSkge1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDEgKyBpZHggLSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGFuID0gdGhpcy5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzcGFuIC0gMSkudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIC8qIE11c3QgZm9yY2UgdGhpcyB0byBhIHN0cmluZywgbGVzdCBpdCBiZSBhIG51bWJlciBhbmQgdGhlXG4gICAgICAgICAqIFwidXRmOC1lbmNvZGluZ1wiIGJlbG93IGFjdHVhbGx5IGFsbG9jYXRlIGEgYnVmZmVyIG9mIGxlbmd0aFxuICAgICAgICAgKiBzcmMgKi9cbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2Ygc3JjKSB7XG4gICAgICAgICAgICBzcmMgPSBTdHJpbmcoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmNiID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oc3JjLCAndXRmOCcpO1xuICAgICAgICBjb25zdCBzcGFuID0gc3JjYi5sZW5ndGg7XG4gICAgICAgIGlmICgob2Zmc2V0ICsgc3BhbikgPiBiLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuY29kaW5nIG92ZXJydW5zIEJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgc3JjYi5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyW29mZnNldCArIHNwYW5dID0gMDtcbiAgICAgICAgcmV0dXJuIHNwYW4gKyAxO1xuICAgIH1cbn1cbmV4cG9ydHMuQ1N0cmluZyA9IENTdHJpbmc7XG4vKipcbiAqIENvbnRhaW4gYSBVVEY4IHN0cmluZyB3aXRoIGltcGxpY2l0IGxlbmd0aC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnV0Zjh8dXRmOH1cbiAqXG4gKiAqKk5PVEUqKiBCZWNhdXNlIHRoZSBsZW5ndGggaXMgaW1wbGljaXQgaW4gdGhlIHNpemUgb2YgdGhlIGJ1ZmZlclxuICogdGhpcyBsYXlvdXQgc2hvdWxkIGJlIHVzZWQgb25seSBpbiBpc29sYXRpb24sIG9yIGluIGEgc2l0dWF0aW9uXG4gKiB3aGVyZSB0aGUgbGVuZ3RoIGNhbiBiZSBleHByZXNzZWQgYnkgb3BlcmF0aW5nIG9uIGEgc2xpY2Ugb2YgdGhlXG4gKiBjb250YWluaW5nIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW21heFNwYW5dIC0gdGhlIG1heGltdW0gbGVuZ3RoIGFsbG93ZWQgZm9yIGVuY29kZWRcbiAqIHN0cmluZyBjb250ZW50LiAgSWYgbm90IHByb3ZpZGVkIHRoZXJlIGlzIG5vIGJvdW5kIG9uIHRoZSBhbGxvd2VkXG4gKiBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVVRGOCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IobWF4U3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCgnc3RyaW5nJyA9PT0gdHlwZW9mIG1heFNwYW4pICYmICh1bmRlZmluZWQgPT09IHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBtYXhTcGFuO1xuICAgICAgICAgICAgbWF4U3BhbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBtYXhTcGFuKSB7XG4gICAgICAgICAgICBtYXhTcGFuID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4U3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heFNwYW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBtYXhpbXVtIHNwYW4gb2YgdGhlIGxheW91dCBpbiBieXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogUG9zaXRpdmUgdmFsdWVzIGFyZSBnZW5lcmFsbHkgZXhwZWN0ZWQuICBaZXJvIGlzIGFibm9ybWFsLlxuICAgICAgICAgKiBBdHRlbXB0cyB0byBlbmNvZGUgb3IgZGVjb2RlIGEgdmFsdWUgdGhhdCBleGNlZWRzIHRoaXMgbGVuZ3RoXG4gICAgICAgICAqIHdpbGwgdGhyb3cgYSBgUmFuZ2VFcnJvcmAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgbmVnYXRpdmUgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgbm8gYm91bmQgb24gdGhlIGxlbmd0aFxuICAgICAgICAgKiBvZiB0aGUgY29udGVudC4gKi9cbiAgICAgICAgdGhpcy5tYXhTcGFuID0gbWF4U3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIG9mZnNldDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCgwIDw9IHRoaXMubWF4U3BhbilcbiAgICAgICAgICAgICYmICh0aGlzLm1heFNwYW4gPCBzcGFuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RleHQgbGVuZ3RoIGV4Y2VlZHMgbWF4U3BhbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzcGFuKS50b1N0cmluZygndXRmLTgnKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgLyogTXVzdCBmb3JjZSB0aGlzIHRvIGEgc3RyaW5nLCBsZXN0IGl0IGJlIGEgbnVtYmVyIGFuZCB0aGVcbiAgICAgICAgICogXCJ1dGY4LWVuY29kaW5nXCIgYmVsb3cgYWN0dWFsbHkgYWxsb2NhdGUgYSBidWZmZXIgb2YgbGVuZ3RoXG4gICAgICAgICAqIHNyYyAqL1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzcmMpIHtcbiAgICAgICAgICAgIHNyYyA9IFN0cmluZyhzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNyY2IgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShzcmMsICd1dGY4Jyk7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBzcmNiLmxlbmd0aDtcbiAgICAgICAgaWYgKCgwIDw9IHRoaXMubWF4U3BhbilcbiAgICAgICAgICAgICYmICh0aGlzLm1heFNwYW4gPCBzcGFuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RleHQgbGVuZ3RoIGV4Y2VlZHMgbWF4U3BhbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob2Zmc2V0ICsgc3BhbikgPiBiLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuY29kaW5nIG92ZXJydW5zIEJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIHNyY2IuY29weSh1aW50OEFycmF5VG9CdWZmZXIoYiksIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuVVRGOCA9IFVURjg7XG4vKipcbiAqIENvbnRhaW4gYSBjb25zdGFudCB2YWx1ZS5cbiAqXG4gKiBUaGlzIGxheW91dCBtYXkgYmUgdXNlZCBpbiBjYXNlcyB3aGVyZSBhIEphdmFTY3JpcHQgdmFsdWUgY2FuIGJlXG4gKiBpbmZlcnJlZCB3aXRob3V0IGFuIGV4cHJlc3Npb24gaW4gdGhlIGJpbmFyeSBlbmNvZGluZy4gIEFuIGV4YW1wbGVcbiAqIHdvdWxkIGJlIGEge0BsaW5rIFZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXR9IHdoZXJlIHRoZSBjb250ZW50XG4gKiBpcyBpbXBsaWVkIGJ5IHRoZSB1bmlvbiB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIENvbnN0YW50I3ZhbHVlfHZhbHVlfS4gIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QgKG9yIGFycmF5KSBhbmRcbiAqIHRoZSBhcHBsaWNhdGlvbiBpbnRlbmRzIHRoZSBvYmplY3QgdG8gcmVtYWluIHVuY2hhbmdlZCByZWdhcmRsZXNzXG4gKiBvZiB3aGF0IGlzIGRvbmUgdG8gdmFsdWVzIGRlY29kZWQgYnkgdGhpcyBsYXlvdXQsIHRoZSB2YWx1ZSBzaG91bGRcbiAqIGJlIGZyb3plbiBwcmlvciBwYXNzaW5nIGl0IHRvIHRoaXMgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBDb25zdGFudCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDAsIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSB2YWx1ZSBwcm9kdWNlZCBieSB0aGlzIGNvbnN0YW50IHdoZW4gdGhlIGxheW91dCBpcyB7QGxpbmtcbiAgICAgICAgICogQ29uc3RhbnQjZGVjb2RlfGRlY29kZWR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgSmF2YVNjcmlwdCB2YWx1ZSBpbmNsdWRpbmcgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBpc1xuICAgICAgICAgKiBwZXJtaXR0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqV0FSTklORyoqIElmIGB2YWx1ZWAgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3RvciB3YXMgbm90XG4gICAgICAgICAqIGZyb3plbiwgaXQgaXMgcG9zc2libGUgZm9yIHVzZXJzIG9mIGRlY29kZWQgdmFsdWVzIHRvIGNoYW5nZVxuICAgICAgICAgKiB0aGUgY29udGVudCBvZiB0aGUgdmFsdWUuICovXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgLyogQ29uc3RhbnRzIHRha2Ugbm8gc3BhY2UgKi9cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZXhwb3J0cy5Db25zdGFudCA9IENvbnN0YW50O1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBHcmVlZHlDb3VudH0uICovXG5leHBvcnRzLmdyZWVkeSA9ICgoZWxlbWVudFNwYW4sIHByb3BlcnR5KSA9PiBuZXcgR3JlZWR5Q291bnQoZWxlbWVudFNwYW4sIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE9mZnNldExheW91dH0uICovXG5leHBvcnRzLm9mZnNldCA9ICgobGF5b3V0LCBvZmZzZXQsIHByb3BlcnR5KSA9PiBuZXcgT2Zmc2V0TGF5b3V0KGxheW91dCwgb2Zmc2V0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fHVuc2lnbmVkIGludCBsYXlvdXRzfSBzcGFubmluZyBvbmVcbiAqIGJ5dGUuICovXG5leHBvcnRzLnU4ID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoMSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuZXhwb3J0cy51MTYgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCgyLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMudTI0ID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoMywgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbmV4cG9ydHMudTMyID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoNCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbmV4cG9ydHMudTQwID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoNSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy51NDggPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCg2LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFyVUludDY0fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50XG4gKiBsYXlvdXRzfSBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5udTY0ID0gKChwcm9wZXJ0eSkgPT4gbmV3IE5lYXJVSW50NjQocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuZXhwb3J0cy51MTZiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoMiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnUyNGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSgzLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy51MzJiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoNCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbmV4cG9ydHMudTQwYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDUsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMudTQ4YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDYsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJVSW50NjRCRXxiaWctZW5kaWFuIHVuc2lnbmVkIGludFxuICogbGF5b3V0c30gaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbmV4cG9ydHMubnU2NGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IE5lYXJVSW50NjRCRShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8c2lnbmVkIGludCBsYXlvdXRzfSBzcGFubmluZyBvbmVcbiAqIGJ5dGUuICovXG5leHBvcnRzLnM4ID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCgxLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnMxNiA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoMiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnMyNCA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoMywgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbmV4cG9ydHMuczMyID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCg0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDAgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDUsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMuczQ4ID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCg2LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFySW50NjR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5uczY0ID0gKChwcm9wZXJ0eSkgPT4gbmV3IE5lYXJJbnQ2NChwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnMxNmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDIsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBJbnRCRSgzLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMzJiZSA9ICgocHJvcGVydHkpID0+IG5ldyBJbnRCRSg0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDBiZSA9ICgocHJvcGVydHkpID0+IG5ldyBJbnRCRSg1LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnM0OGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDYsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJJbnQ2NEJFfGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbmV4cG9ydHMubnM2NGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IE5lYXJJbnQ2NEJFKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEZsb2F0fGxpdHRsZS1lbmRpYW4gMzItYml0IGZsb2F0aW5nIHBvaW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmYzMiA9ICgocHJvcGVydHkpID0+IG5ldyBGbG9hdChwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBGbG9hdEJFfGJpZy1lbmRpYW4gMzItYml0IGZsb2F0aW5nIHBvaW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmYzMmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEZsb2F0QkUocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRG91YmxlfGxpdHRsZS1lbmRpYW4gNjQtYml0IGZsb2F0aW5nIHBvaW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmY2NCA9ICgocHJvcGVydHkpID0+IG5ldyBEb3VibGUocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRG91YmxlQkV8YmlnLWVuZGlhbiA2NC1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjY0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgRG91YmxlQkUocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgU3RydWN0dXJlfSB2YWx1ZXMuICovXG5leHBvcnRzLnN0cnVjdCA9ICgoZmllbGRzLCBwcm9wZXJ0eSwgZGVjb2RlUHJlZml4ZXMpID0+IG5ldyBTdHJ1Y3R1cmUoZmllbGRzLCBwcm9wZXJ0eSwgZGVjb2RlUHJlZml4ZXMpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQml0U3RydWN0dXJlfSB2YWx1ZXMuICovXG5leHBvcnRzLmJpdHMgPSAoKHdvcmQsIG1zYiwgcHJvcGVydHkpID0+IG5ldyBCaXRTdHJ1Y3R1cmUod29yZCwgbXNiLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBTZXF1ZW5jZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5zZXEgPSAoKGVsZW1lbnRMYXlvdXQsIGNvdW50LCBwcm9wZXJ0eSkgPT4gbmV3IFNlcXVlbmNlKGVsZW1lbnRMYXlvdXQsIGNvdW50LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVbmlvbn0gdmFsdWVzLiAqL1xuZXhwb3J0cy51bmlvbiA9ICgoZGlzY3IsIGRlZmF1bHRMYXlvdXQsIHByb3BlcnR5KSA9PiBuZXcgVW5pb24oZGlzY3IsIGRlZmF1bHRMYXlvdXQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcn0gdmFsdWVzLiAqL1xuZXhwb3J0cy51bmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSAoKGxheW91dCwgcHJvcGVydHkpID0+IG5ldyBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IobGF5b3V0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBCbG9ifSB2YWx1ZXMuICovXG5leHBvcnRzLmJsb2IgPSAoKGxlbmd0aCwgcHJvcGVydHkpID0+IG5ldyBCbG9iKGxlbmd0aCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQ1N0cmluZ30gdmFsdWVzLiAqL1xuZXhwb3J0cy5jc3RyID0gKChwcm9wZXJ0eSkgPT4gbmV3IENTdHJpbmcocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVVRGOH0gdmFsdWVzLiAqL1xuZXhwb3J0cy51dGY4ID0gKChtYXhTcGFuLCBwcm9wZXJ0eSkgPT4gbmV3IFVURjgobWF4U3BhbiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQ29uc3RhbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuY29uc3RhbnQgPSAoKHZhbHVlLCBwcm9wZXJ0eSkgPT4gbmV3IENvbnN0YW50KHZhbHVlLCBwcm9wZXJ0eSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGF5b3V0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInMxNiIsInM4IiwibnU2NGJlIiwidTQ4YmUiLCJ1NDBiZSIsInUzMmJlIiwidTI0YmUiLCJ1MTZiZSIsIm51NjQiLCJ1NDgiLCJ1NDAiLCJ1MzIiLCJ1MjQiLCJ1MTYiLCJ1OCIsIm9mZnNldCIsImdyZWVkeSIsIkNvbnN0YW50IiwiVVRGOCIsIkNTdHJpbmciLCJCbG9iIiwiQm9vbGVhbiIsIkJpdEZpZWxkIiwiQml0U3RydWN0dXJlIiwiVmFyaWFudExheW91dCIsIlVuaW9uIiwiVW5pb25MYXlvdXREaXNjcmltaW5hdG9yIiwiVW5pb25EaXNjcmltaW5hdG9yIiwiU3RydWN0dXJlIiwiU2VxdWVuY2UiLCJEb3VibGVCRSIsIkRvdWJsZSIsIkZsb2F0QkUiLCJGbG9hdCIsIk5lYXJJbnQ2NEJFIiwiTmVhckludDY0IiwiTmVhclVJbnQ2NEJFIiwiTmVhclVJbnQ2NCIsIkludEJFIiwiSW50IiwiVUludEJFIiwiVUludCIsIk9mZnNldExheW91dCIsIkdyZWVkeUNvdW50IiwiRXh0ZXJuYWxMYXlvdXQiLCJiaW5kQ29uc3RydWN0b3JMYXlvdXQiLCJuYW1lV2l0aFByb3BlcnR5IiwiTGF5b3V0IiwidWludDhBcnJheVRvQnVmZmVyIiwiY2hlY2tVaW50OEFycmF5IiwiY29uc3RhbnQiLCJ1dGY4IiwiY3N0ciIsImJsb2IiLCJ1bmlvbkxheW91dERpc2NyaW1pbmF0b3IiLCJ1bmlvbiIsInNlcSIsImJpdHMiLCJzdHJ1Y3QiLCJmNjRiZSIsImY2NCIsImYzMmJlIiwiZjMyIiwibnM2NGJlIiwiczQ4YmUiLCJzNDBiZSIsInMzMmJlIiwiczI0YmUiLCJzMTZiZSIsIm5zNjQiLCJzNDgiLCJzNDAiLCJzMzIiLCJzMjQiLCJidWZmZXJfMSIsInJlcXVpcmUiLCJiIiwiVWludDhBcnJheSIsIlR5cGVFcnJvciIsIkJ1ZmZlciIsImZyb20iLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwibGVuZ3RoIiwiY29uc3RydWN0b3IiLCJzcGFuIiwicHJvcGVydHkiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJtYWtlRGVzdGluYXRpb25PYmplY3QiLCJnZXRTcGFuIiwiUmFuZ2VFcnJvciIsInJlcGxpY2F0ZSIsInJ2IiwiY3JlYXRlIiwicHJvdG90eXBlIiwiYXNzaWduIiwiZnJvbUFycmF5IiwidmFsdWVzIiwidW5kZWZpbmVkIiwibmFtZSIsImxvIiwiQ2xhc3MiLCJsYXlvdXQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJFcnJvciIsImxheW91dF8iLCJib3VuZENvbnN0cnVjdG9yXyIsImVuY29kZSIsIndyaXRhYmxlIiwiZGVjb2RlIiwiaXNDb3VudCIsImVsZW1lbnRTcGFuIiwicmVtIiwiTWF0aCIsImZsb29yIiwic3JjIiwicmVhZFVJbnRMRSIsIndyaXRlVUludExFIiwicmVhZFVJbnRCRSIsIndyaXRlVUludEJFIiwicmVhZEludExFIiwid3JpdGVJbnRMRSIsInJlYWRJbnRCRSIsIndyaXRlSW50QkUiLCJWMkUzMiIsInBvdyIsImRpdm1vZEludDY0IiwiaGkzMiIsImxvMzIiLCJyb3VuZGVkSW50NjQiLCJyZWFkVUludDMyTEUiLCJzcGxpdCIsIndyaXRlVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJ3cml0ZVVJbnQzMkJFIiwicmVhZEludDMyTEUiLCJ3cml0ZUludDMyTEUiLCJyZWFkSW50MzJCRSIsIndyaXRlSW50MzJCRSIsInJlYWRGbG9hdExFIiwid3JpdGVGbG9hdExFIiwicmVhZEZsb2F0QkUiLCJ3cml0ZUZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJ3cml0ZURvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwid3JpdGVEb3VibGVCRSIsImVsZW1lbnRMYXlvdXQiLCJjb3VudCIsImlkeCIsImkiLCJwdXNoIiwiZWxvIiwicmVkdWNlIiwidiIsImZpZWxkcyIsImRlY29kZVByZWZpeGVzIiwiQXJyYXkiLCJpc0FycmF5IiwiYWNjIiwiZmQiLCJlIiwiZnNwIiwiZGVzdCIsImZpcnN0T2Zmc2V0IiwibGFzdE9mZnNldCIsImxhc3RXcm90ZSIsImZ2Iiwic2hpZnQiLCJsYXlvdXRGb3IiLCJvZmZzZXRPZiIsImRpc2NyIiwiZGVmYXVsdExheW91dCIsImRpc2NyaW1pbmF0b3IiLCJ1c2VzUHJlZml4RGlzY3JpbWluYXRvciIsInJlZ2lzdHJ5IiwiYm91bmRHZXRTb3VyY2VWYXJpYW50IiwiZGVmYXVsdEdldFNvdXJjZVZhcmlhbnQiLCJiaW5kIiwiZ2V0U291cmNlVmFyaWFudCIsImNvbmZpZ0dldFNvdXJjZVZhcmlhbnQiLCJnc3YiLCJ2bG8iLCJnZXRWYXJpYW50IiwidGFnIiwiZGxvIiwiY2xvIiwiY29udGVudE9mZnNldCIsImFkZFZhcmlhbnQiLCJ2YXJpYW50IiwidmIiLCJmaXhCaXR3aXNlUmVzdWx0Iiwid29yZCIsIm1zYiIsIl9wYWNrZWRTZXRWYWx1ZSIsIl9wYWNrZWRHZXRWYWx1ZSIsImFkZEZpZWxkIiwiYmYiLCJhZGRCb29sZWFuIiwiZmllbGRGb3IiLCJjb250YWluZXIiLCJ0b3RhbEJpdHMiLCJ1c2VkQml0cyIsInN1bSIsInZhbHVlTWFzayIsInN0YXJ0Iiwid29yZE1hc2siLCJ3b3JkVmFsdWUiLCJzbGljZSIsInNyY0J1ZmZlciIsIndyaXRlIiwidG9TdHJpbmciLCJTdHJpbmciLCJzcmNiIiwiY29weSIsIm1heFNwYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/buffer-layout/lib/Layout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/@solana/web3.js/lib/index.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AddressLookupTableAccount: () => (/* binding */ AddressLookupTableAccount),\n/* harmony export */   AddressLookupTableInstruction: () => (/* binding */ AddressLookupTableInstruction),\n/* harmony export */   AddressLookupTableProgram: () => (/* binding */ AddressLookupTableProgram),\n/* harmony export */   Authorized: () => (/* binding */ Authorized),\n/* harmony export */   BLOCKHASH_CACHE_TIMEOUT_MS: () => (/* binding */ BLOCKHASH_CACHE_TIMEOUT_MS),\n/* harmony export */   BPF_LOADER_DEPRECATED_PROGRAM_ID: () => (/* binding */ BPF_LOADER_DEPRECATED_PROGRAM_ID),\n/* harmony export */   BPF_LOADER_PROGRAM_ID: () => (/* binding */ BPF_LOADER_PROGRAM_ID),\n/* harmony export */   BpfLoader: () => (/* binding */ BpfLoader),\n/* harmony export */   COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => (/* binding */ COMPUTE_BUDGET_INSTRUCTION_LAYOUTS),\n/* harmony export */   ComputeBudgetInstruction: () => (/* binding */ ComputeBudgetInstruction),\n/* harmony export */   ComputeBudgetProgram: () => (/* binding */ ComputeBudgetProgram),\n/* harmony export */   Connection: () => (/* binding */ Connection),\n/* harmony export */   Ed25519Program: () => (/* binding */ Ed25519Program),\n/* harmony export */   Enum: () => (/* binding */ Enum),\n/* harmony export */   EpochSchedule: () => (/* binding */ EpochSchedule),\n/* harmony export */   FeeCalculatorLayout: () => (/* binding */ FeeCalculatorLayout),\n/* harmony export */   Keypair: () => (/* binding */ Keypair),\n/* harmony export */   LAMPORTS_PER_SOL: () => (/* binding */ LAMPORTS_PER_SOL),\n/* harmony export */   LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => (/* binding */ LOOKUP_TABLE_INSTRUCTION_LAYOUTS),\n/* harmony export */   Loader: () => (/* binding */ Loader),\n/* harmony export */   Lockup: () => (/* binding */ Lockup),\n/* harmony export */   MAX_SEED_LENGTH: () => (/* binding */ MAX_SEED_LENGTH),\n/* harmony export */   Message: () => (/* binding */ Message),\n/* harmony export */   MessageAccountKeys: () => (/* binding */ MessageAccountKeys),\n/* harmony export */   MessageV0: () => (/* binding */ MessageV0),\n/* harmony export */   NONCE_ACCOUNT_LENGTH: () => (/* binding */ NONCE_ACCOUNT_LENGTH),\n/* harmony export */   NonceAccount: () => (/* binding */ NonceAccount),\n/* harmony export */   PACKET_DATA_SIZE: () => (/* binding */ PACKET_DATA_SIZE),\n/* harmony export */   PUBLIC_KEY_LENGTH: () => (/* binding */ PUBLIC_KEY_LENGTH),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   SIGNATURE_LENGTH_IN_BYTES: () => (/* binding */ SIGNATURE_LENGTH_IN_BYTES),\n/* harmony export */   SOLANA_SCHEMA: () => (/* binding */ SOLANA_SCHEMA),\n/* harmony export */   STAKE_CONFIG_ID: () => (/* binding */ STAKE_CONFIG_ID),\n/* harmony export */   STAKE_INSTRUCTION_LAYOUTS: () => (/* binding */ STAKE_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSTEM_INSTRUCTION_LAYOUTS: () => (/* binding */ SYSTEM_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSVAR_CLOCK_PUBKEY: () => (/* binding */ SYSVAR_CLOCK_PUBKEY),\n/* harmony export */   SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => (/* binding */ SYSVAR_EPOCH_SCHEDULE_PUBKEY),\n/* harmony export */   SYSVAR_INSTRUCTIONS_PUBKEY: () => (/* binding */ SYSVAR_INSTRUCTIONS_PUBKEY),\n/* harmony export */   SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => (/* binding */ SYSVAR_RECENT_BLOCKHASHES_PUBKEY),\n/* harmony export */   SYSVAR_RENT_PUBKEY: () => (/* binding */ SYSVAR_RENT_PUBKEY),\n/* harmony export */   SYSVAR_REWARDS_PUBKEY: () => (/* binding */ SYSVAR_REWARDS_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HASHES_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HASHES_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HISTORY_PUBKEY),\n/* harmony export */   SYSVAR_STAKE_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_STAKE_HISTORY_PUBKEY),\n/* harmony export */   Secp256k1Program: () => (/* binding */ Secp256k1Program),\n/* harmony export */   SendTransactionError: () => (/* binding */ SendTransactionError),\n/* harmony export */   SolanaJSONRPCError: () => (/* binding */ SolanaJSONRPCError),\n/* harmony export */   SolanaJSONRPCErrorCode: () => (/* binding */ SolanaJSONRPCErrorCode),\n/* harmony export */   StakeAuthorizationLayout: () => (/* binding */ StakeAuthorizationLayout),\n/* harmony export */   StakeInstruction: () => (/* binding */ StakeInstruction),\n/* harmony export */   StakeProgram: () => (/* binding */ StakeProgram),\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   SystemInstruction: () => (/* binding */ SystemInstruction),\n/* harmony export */   SystemProgram: () => (/* binding */ SystemProgram),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   TransactionExpiredBlockheightExceededError: () => (/* binding */ TransactionExpiredBlockheightExceededError),\n/* harmony export */   TransactionExpiredNonceInvalidError: () => (/* binding */ TransactionExpiredNonceInvalidError),\n/* harmony export */   TransactionExpiredTimeoutError: () => (/* binding */ TransactionExpiredTimeoutError),\n/* harmony export */   TransactionInstruction: () => (/* binding */ TransactionInstruction),\n/* harmony export */   TransactionMessage: () => (/* binding */ TransactionMessage),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   VALIDATOR_INFO_KEY: () => (/* binding */ VALIDATOR_INFO_KEY),\n/* harmony export */   VERSION_PREFIX_MASK: () => (/* binding */ VERSION_PREFIX_MASK),\n/* harmony export */   VOTE_PROGRAM_ID: () => (/* binding */ VOTE_PROGRAM_ID),\n/* harmony export */   ValidatorInfo: () => (/* binding */ ValidatorInfo),\n/* harmony export */   VersionedMessage: () => (/* binding */ VersionedMessage),\n/* harmony export */   VersionedTransaction: () => (/* binding */ VersionedTransaction),\n/* harmony export */   VoteAccount: () => (/* binding */ VoteAccount),\n/* harmony export */   VoteAuthorizationLayout: () => (/* binding */ VoteAuthorizationLayout),\n/* harmony export */   VoteInit: () => (/* binding */ VoteInit),\n/* harmony export */   VoteInstruction: () => (/* binding */ VoteInstruction),\n/* harmony export */   VoteProgram: () => (/* binding */ VoteProgram),\n/* harmony export */   clusterApiUrl: () => (/* binding */ clusterApiUrl),\n/* harmony export */   sendAndConfirmRawTransaction: () => (/* binding */ sendAndConfirmRawTransaction),\n/* harmony export */   sendAndConfirmTransaction: () => (/* binding */ sendAndConfirmTransaction)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\n/* harmony import */ var _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/buffer-layout */ \"(ssr)/./node_modules/@solana/buffer-layout/lib/Layout.js\");\n/* harmony import */ var _solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @solana/codecs-numbers */ \"(ssr)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! jayson/lib/client/browser */ \"(ssr)/./node_modules/jayson/lib/client/browser/index.js\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! node-fetch */ \"(ssr)/./node_modules/node-fetch/lib/index.mjs\");\n/* harmony import */ var rpc_websockets__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rpc-websockets */ \"(ssr)/./node_modules/rpc-websockets/dist/index.mjs\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/secp256k1.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */ /**\n * Ed25519 Keypair\n */ const generatePrivateKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.utils.randomPrivateKey;\nconst generateKeypair = ()=>{\n    const privateScalar = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.utils.randomPrivateKey();\n    const publicKey = getPublicKey(privateScalar);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(privateScalar);\n    secretKey.set(publicKey, 32);\n    return {\n        publicKey,\n        secretKey\n    };\n};\nconst getPublicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n    try {\n        _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.ExtendedPoint.fromHex(publicKey);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nconst sign = (message, secretKey)=>_noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.sign(message, secretKey.slice(0, 32));\nconst verify = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.verify;\nconst toBuffer = (arr)=>{\n    if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(arr)) {\n        return arr;\n    } else if (arr instanceof Uint8Array) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    } else {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);\n    }\n};\n// Class wrapping a plain object\nclass Struct {\n    constructor(properties){\n        Object.assign(this, properties);\n    }\n    encode() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_3__.serialize)(SOLANA_SCHEMA, this));\n    }\n    static decode(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserialize)(SOLANA_SCHEMA, this, data);\n    }\n    static decodeUnchecked(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserializeUnchecked)(SOLANA_SCHEMA, this, data);\n    }\n}\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nclass Enum extends Struct {\n    constructor(properties){\n        super(properties);\n        this.enum = \"\";\n        if (Object.keys(properties).length !== 1) {\n            throw new Error(\"Enum can only take single value\");\n        }\n        Object.keys(properties).map((key)=>{\n            this.enum = key;\n        });\n    }\n}\nconst SOLANA_SCHEMA = new Map();\nvar _PublicKey;\n/**\n * Maximum length of derived pubkey seed\n */ const MAX_SEED_LENGTH = 32;\n/**\n * Size of public key in bytes\n */ const PUBLIC_KEY_LENGTH = 32;\n/**\n * Value to be converted into public key\n */ /**\n * JSON object representation of PublicKey class\n */ function isPublicKeyData(value) {\n    return value._bn !== undefined;\n}\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n/**\n * A public key\n */ class PublicKey extends Struct {\n    /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */ constructor(value){\n        super({});\n        /** @internal */ this._bn = void 0;\n        if (isPublicKeyData(value)) {\n            this._bn = value._bn;\n        } else {\n            if (typeof value === \"string\") {\n                // assume base 58 encoding by default\n                const decoded = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(value);\n                if (decoded.length != PUBLIC_KEY_LENGTH) {\n                    throw new Error(`Invalid public key input`);\n                }\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(decoded);\n            } else {\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(value);\n            }\n            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n                throw new Error(`Invalid public key input`);\n            }\n        }\n    }\n    /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */ static unique() {\n        const key = new PublicKey(uniquePublicKeyCounter);\n        uniquePublicKeyCounter += 1;\n        return new PublicKey(key.toBuffer());\n    }\n    /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */ /**\n   * Checks if two publicKeys are equal\n   */ equals(publicKey) {\n        return this._bn.eq(publicKey._bn);\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toBase58() {\n        return bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(this.toBytes());\n    }\n    toJSON() {\n        return this.toBase58();\n    }\n    /**\n   * Return the byte array representation of the public key in big endian\n   */ toBytes() {\n        const buf = this.toBuffer();\n        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    /**\n   * Return the Buffer representation of the public key in big endian\n   */ toBuffer() {\n        const b = this._bn.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer);\n        if (b.length === PUBLIC_KEY_LENGTH) {\n            return b;\n        }\n        const zeroPad = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(32);\n        b.copy(zeroPad, 32 - b.length);\n        return zeroPad;\n    }\n    get [Symbol.toStringTag]() {\n        return `PublicKey(${this.toString()})`;\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toString() {\n        return this.toBase58();\n    }\n    /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */ /* eslint-disable require-await */ static async createWithSeed(fromPublicKey, seed, programId) {\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            fromPublicKey.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(seed),\n            programId.toBuffer()\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_12__.sha256)(buffer);\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Derive a program address from seeds and a program ID.\n   */ /* eslint-disable require-await */ static createProgramAddressSync(seeds, programId) {\n        let buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        seeds.forEach(function(seed) {\n            if (seed.length > MAX_SEED_LENGTH) {\n                throw new TypeError(`Max seed length exceeded`);\n            }\n            buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n                buffer,\n                toBuffer(seed)\n            ]);\n        });\n        buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            buffer,\n            programId.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(\"ProgramDerivedAddress\")\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_12__.sha256)(buffer);\n        if (isOnCurve(publicKeyBytes)) {\n            throw new Error(`Invalid seeds, address must fall off the curve`);\n        }\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */ /* eslint-disable require-await */ static async createProgramAddress(seeds, programId) {\n        return this.createProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */ static findProgramAddressSync(seeds, programId) {\n        let nonce = 255;\n        let address;\n        while(nonce != 0){\n            try {\n                const seedsWithNonce = seeds.concat(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                    nonce\n                ]));\n                address = this.createProgramAddressSync(seedsWithNonce, programId);\n            } catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n                nonce--;\n                continue;\n            }\n            return [\n                address,\n                nonce\n            ];\n        }\n        throw new Error(`Unable to find a viable program address nonce`);\n    }\n    /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */ static async findProgramAddress(seeds, programId) {\n        return this.findProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Check that a pubkey is on the ed25519 curve.\n   */ static isOnCurve(pubkeyData) {\n        const pubkey = new PublicKey(pubkeyData);\n        return isOnCurve(pubkey.toBytes());\n    }\n}\n_PublicKey = PublicKey;\nPublicKey.default = new _PublicKey(\"11111111111111111111111111111111\");\nSOLANA_SCHEMA.set(PublicKey, {\n    kind: \"struct\",\n    fields: [\n        [\n            \"_bn\",\n            \"u256\"\n        ]\n    ]\n});\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */ class Account {\n    /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */ constructor(secretKey){\n        /** @internal */ this._publicKey = void 0;\n        /** @internal */ this._secretKey = void 0;\n        if (secretKey) {\n            const secretKeyBuffer = toBuffer(secretKey);\n            if (secretKey.length !== 64) {\n                throw new Error(\"bad secret key size\");\n            }\n            this._publicKey = secretKeyBuffer.slice(32, 64);\n            this._secretKey = secretKeyBuffer.slice(0, 32);\n        } else {\n            this._secretKey = toBuffer(generatePrivateKey());\n            this._publicKey = toBuffer(getPublicKey(this._secretKey));\n        }\n    }\n    /**\n   * The public key for this account\n   */ get publicKey() {\n        return new PublicKey(this._publicKey);\n    }\n    /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */ get secretKey() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            this._secretKey,\n            this._publicKey\n        ], 64);\n    }\n}\nconst BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey(\"BPFLoader1111111111111111111111111111111111\");\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */ const PACKET_DATA_SIZE = 1280 - 40 - 8;\nconst VERSION_PREFIX_MASK = 0x7f;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nclass TransactionExpiredBlockheightExceededError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: block height exceeded.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, \"name\", {\n    value: \"TransactionExpiredBlockheightExceededError\"\n});\nclass TransactionExpiredTimeoutError extends Error {\n    constructor(signature, timeoutSeconds){\n        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + \"unknown if it succeeded or failed. Check signature \" + `${signature} using the Solana Explorer or CLI tools.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, \"name\", {\n    value: \"TransactionExpiredTimeoutError\"\n});\nclass TransactionExpiredNonceInvalidError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, \"name\", {\n    value: \"TransactionExpiredNonceInvalidError\"\n});\nclass MessageAccountKeys {\n    constructor(staticAccountKeys, accountKeysFromLookups){\n        this.staticAccountKeys = void 0;\n        this.accountKeysFromLookups = void 0;\n        this.staticAccountKeys = staticAccountKeys;\n        this.accountKeysFromLookups = accountKeysFromLookups;\n    }\n    keySegments() {\n        const keySegments = [\n            this.staticAccountKeys\n        ];\n        if (this.accountKeysFromLookups) {\n            keySegments.push(this.accountKeysFromLookups.writable);\n            keySegments.push(this.accountKeysFromLookups.readonly);\n        }\n        return keySegments;\n    }\n    get(index) {\n        for (const keySegment of this.keySegments()){\n            if (index < keySegment.length) {\n                return keySegment[index];\n            } else {\n                index -= keySegment.length;\n            }\n        }\n        return;\n    }\n    get length() {\n        return this.keySegments().flat().length;\n    }\n    compileInstructions(instructions) {\n        // Bail early if any account indexes would overflow a u8\n        const U8_MAX = 255;\n        if (this.length > U8_MAX + 1) {\n            throw new Error(\"Account index overflow encountered during compilation\");\n        }\n        const keyIndexMap = new Map();\n        this.keySegments().flat().forEach((key, index)=>{\n            keyIndexMap.set(key.toBase58(), index);\n        });\n        const findKeyIndex = (key)=>{\n            const keyIndex = keyIndexMap.get(key.toBase58());\n            if (keyIndex === undefined) throw new Error(\"Encountered an unknown instruction account key during compilation\");\n            return keyIndex;\n        };\n        return instructions.map((instruction)=>{\n            return {\n                programIdIndex: findKeyIndex(instruction.programId),\n                accountKeyIndexes: instruction.keys.map((meta)=>findKeyIndex(meta.pubkey)),\n                data: instruction.data\n            };\n        });\n    }\n}\n/**\n * Layout for a public key\n */ const publicKey = (property = \"publicKey\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(32, property);\n};\n/**\n * Layout for a signature\n */ const signature = (property = \"signature\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */ const rustString = (property = \"string\")=>{\n    const rsl = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"length\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"lengthPadding\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"chars\")\n    ], property);\n    const _decode = rsl.decode.bind(rsl);\n    const _encode = rsl.encode.bind(rsl);\n    const rslShim = rsl;\n    rslShim.decode = (b, offset)=>{\n        const data = _decode(b, offset);\n        return data[\"chars\"].toString();\n    };\n    rslShim.encode = (str, b, offset)=>{\n        const data = {\n            chars: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\")\n        };\n        return _encode(data, b, offset);\n    };\n    rslShim.alloc = (str)=>{\n        return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\").length;\n    };\n    return rslShim;\n};\n/**\n * Layout for an Authorized object\n */ const authorized = (property = \"authorized\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"staker\"),\n        publicKey(\"withdrawer\")\n    ], property);\n};\n/**\n * Layout for a Lockup object\n */ const lockup = (property = \"lockup\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"unixTimestamp\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"epoch\"),\n        publicKey(\"custodian\")\n    ], property);\n};\n/**\n *  Layout for a VoteInit object\n */ const voteInit = (property = \"voteInit\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"nodePubkey\"),\n        publicKey(\"authorizedVoter\"),\n        publicKey(\"authorizedWithdrawer\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\")\n    ], property);\n};\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */ const voteAuthorizeWithSeedArgs = (property = \"voteAuthorizeWithSeedArgs\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\"),\n        publicKey(\"currentAuthorityDerivedKeyOwnerPubkey\"),\n        rustString(\"currentAuthorityDerivedKeySeed\"),\n        publicKey(\"newAuthorized\")\n    ], property);\n};\nfunction getAlloc(type, fields) {\n    const getItemAlloc = (item)=>{\n        if (item.span >= 0) {\n            return item.span;\n        } else if (typeof item.alloc === \"function\") {\n            return item.alloc(fields[item.property]);\n        } else if (\"count\" in item && \"elementLayout\" in item) {\n            const field = fields[item.property];\n            if (Array.isArray(field)) {\n                return field.length * getItemAlloc(item.elementLayout);\n            }\n        } else if (\"fields\" in item) {\n            // This is a `Structure` whose size needs to be recursively measured.\n            return getAlloc({\n                layout: item\n            }, fields[item.property]);\n        }\n        // Couldn't determine allocated size of layout\n        return 0;\n    };\n    let alloc = 0;\n    type.layout.fields.forEach((item)=>{\n        alloc += getItemAlloc(item);\n    });\n    return alloc;\n}\nfunction decodeLength(bytes) {\n    let len = 0;\n    let size = 0;\n    for(;;){\n        let elem = bytes.shift();\n        len |= (elem & 0x7f) << size * 7;\n        size += 1;\n        if ((elem & 0x80) === 0) {\n            break;\n        }\n    }\n    return len;\n}\nfunction encodeLength(bytes, len) {\n    let rem_len = len;\n    for(;;){\n        let elem = rem_len & 0x7f;\n        rem_len >>= 7;\n        if (rem_len == 0) {\n            bytes.push(elem);\n            break;\n        } else {\n            elem |= 0x80;\n            bytes.push(elem);\n        }\n    }\n}\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nclass CompiledKeys {\n    constructor(payer, keyMetaMap){\n        this.payer = void 0;\n        this.keyMetaMap = void 0;\n        this.payer = payer;\n        this.keyMetaMap = keyMetaMap;\n    }\n    static compile(instructions, payer) {\n        const keyMetaMap = new Map();\n        const getOrInsertDefault = (pubkey)=>{\n            const address = pubkey.toBase58();\n            let keyMeta = keyMetaMap.get(address);\n            if (keyMeta === undefined) {\n                keyMeta = {\n                    isSigner: false,\n                    isWritable: false,\n                    isInvoked: false\n                };\n                keyMetaMap.set(address, keyMeta);\n            }\n            return keyMeta;\n        };\n        const payerKeyMeta = getOrInsertDefault(payer);\n        payerKeyMeta.isSigner = true;\n        payerKeyMeta.isWritable = true;\n        for (const ix of instructions){\n            getOrInsertDefault(ix.programId).isInvoked = true;\n            for (const accountMeta of ix.keys){\n                const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n                keyMeta.isSigner ||= accountMeta.isSigner;\n                keyMeta.isWritable ||= accountMeta.isWritable;\n            }\n        }\n        return new CompiledKeys(payer, keyMetaMap);\n    }\n    getMessageComponents() {\n        const mapEntries = [\n            ...this.keyMetaMap.entries()\n        ];\n        assert(mapEntries.length <= 256, \"Max static account keys length exceeded\");\n        const writableSigners = mapEntries.filter(([, meta])=>meta.isSigner && meta.isWritable);\n        const readonlySigners = mapEntries.filter(([, meta])=>meta.isSigner && !meta.isWritable);\n        const writableNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && meta.isWritable);\n        const readonlyNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && !meta.isWritable);\n        const header = {\n            numRequiredSignatures: writableSigners.length + readonlySigners.length,\n            numReadonlySignedAccounts: readonlySigners.length,\n            numReadonlyUnsignedAccounts: readonlyNonSigners.length\n        };\n        // sanity checks\n        {\n            assert(writableSigners.length > 0, \"Expected at least one writable signer key\");\n            const [payerAddress] = writableSigners[0];\n            assert(payerAddress === this.payer.toBase58(), \"Expected first writable signer key to be the fee payer\");\n        }\n        const staticAccountKeys = [\n            ...writableSigners.map(([address])=>new PublicKey(address)),\n            ...readonlySigners.map(([address])=>new PublicKey(address)),\n            ...writableNonSigners.map(([address])=>new PublicKey(address)),\n            ...readonlyNonSigners.map(([address])=>new PublicKey(address))\n        ];\n        return [\n            header,\n            staticAccountKeys\n        ];\n    }\n    extractTableLookup(lookupTable) {\n        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n        // Don't extract lookup if no keys were found\n        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n            return;\n        }\n        return [\n            {\n                accountKey: lookupTable.key,\n                writableIndexes,\n                readonlyIndexes\n            },\n            {\n                writable: drainedWritableKeys,\n                readonly: drainedReadonlyKeys\n            }\n        ];\n    }\n    /** @internal */ drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n        const lookupTableIndexes = new Array();\n        const drainedKeys = new Array();\n        for (const [address, keyMeta] of this.keyMetaMap.entries()){\n            if (keyMetaFilter(keyMeta)) {\n                const key = new PublicKey(address);\n                const lookupTableIndex = lookupTableEntries.findIndex((entry)=>entry.equals(key));\n                if (lookupTableIndex >= 0) {\n                    assert(lookupTableIndex < 256, \"Max lookup table index exceeded\");\n                    lookupTableIndexes.push(lookupTableIndex);\n                    drainedKeys.push(key);\n                    this.keyMetaMap.delete(address);\n                }\n            }\n        }\n        return [\n            lookupTableIndexes,\n            drainedKeys\n        ];\n    }\n}\nconst END_OF_BUFFER_ERROR_MESSAGE = \"Reached end of buffer unexpectedly\";\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */ function guardedShift(byteArray) {\n    if (byteArray.length === 0) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.shift();\n}\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */ function guardedSplice(byteArray, ...args) {\n    const [start] = args;\n    if (args.length === 2 // Implies that `deleteCount` was supplied\n     ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.splice(...args);\n}\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */ /**\n * Message constructor arguments\n */ /**\n * List of instructions to be processed atomically\n */ class Message {\n    constructor(args){\n        this.header = void 0;\n        this.accountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.instructions = void 0;\n        this.indexToProgramIds = new Map();\n        this.header = args.header;\n        this.accountKeys = args.accountKeys.map((account)=>new PublicKey(account));\n        this.recentBlockhash = args.recentBlockhash;\n        this.instructions = args.instructions;\n        this.instructions.forEach((ix)=>this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n    }\n    get version() {\n        return \"legacy\";\n    }\n    get staticAccountKeys() {\n        return this.accountKeys;\n    }\n    get compiledInstructions() {\n        return this.instructions.map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accountKeyIndexes: ix.accounts,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n            }));\n    }\n    get addressTableLookups() {\n        return [];\n    }\n    getAccountKeys() {\n        return new MessageAccountKeys(this.staticAccountKeys);\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys);\n        const instructions = accountKeys.compileInstructions(args.instructions).map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accounts: ix.accountKeyIndexes,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(ix.data)\n            }));\n        return new Message({\n            header,\n            accountKeys: staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            instructions\n        });\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    isProgramId(index) {\n        return this.indexToProgramIds.has(index);\n    }\n    programIds() {\n        return [\n            ...this.indexToProgramIds.values()\n        ];\n    }\n    nonProgramIds() {\n        return this.accountKeys.filter((_, index)=>!this.isProgramId(index));\n    }\n    serialize() {\n        const numKeys = this.accountKeys.length;\n        let keyCount = [];\n        encodeLength(keyCount, numKeys);\n        const instructions = this.instructions.map((instruction)=>{\n            const { accounts, programIdIndex } = instruction;\n            const data = Array.from(bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data));\n            let keyIndicesCount = [];\n            encodeLength(keyIndicesCount, accounts.length);\n            let dataCount = [];\n            encodeLength(dataCount, data.length);\n            return {\n                programIdIndex,\n                keyIndicesCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyIndicesCount),\n                keyIndices: accounts,\n                dataLength: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataCount),\n                data\n            };\n        });\n        let instructionCount = [];\n        encodeLength(instructionCount, instructions.length);\n        let instructionBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(PACKET_DATA_SIZE);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(instructionCount).copy(instructionBuffer);\n        let instructionBufferLength = instructionCount.length;\n        instructions.forEach((instruction)=>{\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.keyIndicesCount.length, \"keyIndicesCount\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"keyIndex\"), instruction.keyIndices.length, \"keyIndices\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.dataLength.length, \"dataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"userdatum\"), instruction.data.length, \"data\")\n            ]);\n            const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n            instructionBufferLength += length;\n        });\n        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n        const signDataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numRequiredSignatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlySignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlyUnsignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(keyCount.length, \"keyCount\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(\"key\"), numKeys, \"keys\"),\n            publicKey(\"recentBlockhash\")\n        ]);\n        const transaction = {\n            numRequiredSignatures: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numRequiredSignatures\n            ]),\n            numReadonlySignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlySignedAccounts\n            ]),\n            numReadonlyUnsignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlyUnsignedAccounts\n            ]),\n            keyCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyCount),\n            keys: this.accountKeys.map((key)=>toBuffer(key.toBytes())),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash)\n        };\n        let signData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(2048);\n        const length = signDataLayout.encode(transaction, signData);\n        instructionBuffer.copy(signData, length);\n        return signData.slice(0, length + instructionBuffer.length);\n    }\n    /**\n   * Decode a compiled message into a Message object.\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const numRequiredSignatures = guardedShift(byteArray);\n        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n            throw new Error(\"Versioned messages must be deserialized with VersionedMessage.deserialize()\");\n        }\n        const numReadonlySignedAccounts = guardedShift(byteArray);\n        const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n        const accountCount = decodeLength(byteArray);\n        let accountKeys = [];\n        for(let i = 0; i < accountCount; i++){\n            const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n            accountKeys.push(new PublicKey(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(account)));\n        }\n        const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n        const instructionCount = decodeLength(byteArray);\n        let instructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountCount = decodeLength(byteArray);\n            const accounts = guardedSplice(byteArray, 0, accountCount);\n            const dataLength = decodeLength(byteArray);\n            const dataSlice = guardedSplice(byteArray, 0, dataLength);\n            const data = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataSlice));\n            instructions.push({\n                programIdIndex,\n                accounts,\n                data\n            });\n        }\n        const messageArgs = {\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(recentBlockhash)),\n            accountKeys,\n            instructions\n        };\n        return new Message(messageArgs);\n    }\n}\n/**\n * Message constructor arguments\n */ class MessageV0 {\n    constructor(args){\n        this.header = void 0;\n        this.staticAccountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.compiledInstructions = void 0;\n        this.addressTableLookups = void 0;\n        this.header = args.header;\n        this.staticAccountKeys = args.staticAccountKeys;\n        this.recentBlockhash = args.recentBlockhash;\n        this.compiledInstructions = args.compiledInstructions;\n        this.addressTableLookups = args.addressTableLookups;\n    }\n    get version() {\n        return 0;\n    }\n    get numAccountKeysFromLookups() {\n        let count = 0;\n        for (const lookup of this.addressTableLookups){\n            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n        }\n        return count;\n    }\n    getAccountKeys(args) {\n        let accountKeysFromLookups;\n        if (args && \"accountKeysFromLookups\" in args && args.accountKeysFromLookups) {\n            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n                throw new Error(\"Failed to get account keys because of a mismatch in the number of account keys from lookups\");\n            }\n            accountKeysFromLookups = args.accountKeysFromLookups;\n        } else if (args && \"addressLookupTableAccounts\" in args && args.addressLookupTableAccounts) {\n            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n        } else if (this.addressTableLookups.length > 0) {\n            throw new Error(\"Failed to get account keys because address table lookups were not resolved\");\n        }\n        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        const numStaticAccountKeys = this.staticAccountKeys.length;\n        if (index >= numStaticAccountKeys) {\n            const lookupAccountKeysIndex = index - numStaticAccountKeys;\n            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup)=>count + lookup.writableIndexes.length, 0);\n            return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n        } else if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    resolveAddressTableLookups(addressLookupTableAccounts) {\n        const accountKeysFromLookups = {\n            writable: [],\n            readonly: []\n        };\n        for (const tableLookup of this.addressTableLookups){\n            const tableAccount = addressLookupTableAccounts.find((account)=>account.key.equals(tableLookup.accountKey));\n            if (!tableAccount) {\n                throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);\n            }\n            for (const index of tableLookup.writableIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n            for (const index of tableLookup.readonlyIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n        }\n        return accountKeysFromLookups;\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const addressTableLookups = new Array();\n        const accountKeysFromLookups = {\n            writable: new Array(),\n            readonly: new Array()\n        };\n        const lookupTableAccounts = args.addressLookupTableAccounts || [];\n        for (const lookupTable of lookupTableAccounts){\n            const extractResult = compiledKeys.extractTableLookup(lookupTable);\n            if (extractResult !== undefined) {\n                const [addressTableLookup, { writable, readonly }] = extractResult;\n                addressTableLookups.push(addressTableLookup);\n                accountKeysFromLookups.writable.push(...writable);\n                accountKeysFromLookups.readonly.push(...readonly);\n            }\n        }\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n        const compiledInstructions = accountKeys.compileInstructions(args.instructions);\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n    serialize() {\n        const encodedStaticAccountKeysLength = Array();\n        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n        const serializedInstructions = this.serializeInstructions();\n        const encodedInstructionsLength = Array();\n        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n        const serializedAddressTableLookups = this.serializeAddressTableLookups();\n        const encodedAddressTableLookupsLength = Array();\n        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n        const messageLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"prefix\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numRequiredSignatures\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlySignedAccounts\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlyUnsignedAccounts\")\n            ], \"header\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedStaticAccountKeysLength.length, \"staticAccountKeysLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), this.staticAccountKeys.length, \"staticAccountKeys\"),\n            publicKey(\"recentBlockhash\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedInstructionsLength.length, \"instructionsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedInstructions.length, \"serializedInstructions\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAddressTableLookupsLength.length, \"addressTableLookupsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedAddressTableLookups.length, \"serializedAddressTableLookups\")\n        ]);\n        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n        const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n        const serializedMessageLength = messageLayout.encode({\n            prefix: MESSAGE_VERSION_0_PREFIX,\n            header: this.header,\n            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n            staticAccountKeys: this.staticAccountKeys.map((key)=>key.toBytes()),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash),\n            instructionsLength: new Uint8Array(encodedInstructionsLength),\n            serializedInstructions,\n            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n            serializedAddressTableLookups\n        }, serializedMessage);\n        return serializedMessage.slice(0, serializedMessageLength);\n    }\n    serializeInstructions() {\n        let serializedLength = 0;\n        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n        for (const instruction of this.compiledInstructions){\n            const encodedAccountKeyIndexesLength = Array();\n            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n            const encodedDataLength = Array();\n            encodeLength(encodedDataLength, instruction.data.length);\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAccountKeyIndexesLength.length, \"encodedAccountKeyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), instruction.accountKeyIndexes.length, \"accountKeyIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedDataLength.length, \"encodedDataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.data.length, \"data\")\n            ]);\n            serializedLength += instructionLayout.encode({\n                programIdIndex: instruction.programIdIndex,\n                encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n                accountKeyIndexes: instruction.accountKeyIndexes,\n                encodedDataLength: new Uint8Array(encodedDataLength),\n                data: instruction.data\n            }, serializedInstructions, serializedLength);\n        }\n        return serializedInstructions.slice(0, serializedLength);\n    }\n    serializeAddressTableLookups() {\n        let serializedLength = 0;\n        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n        for (const lookup of this.addressTableLookups){\n            const encodedWritableIndexesLength = Array();\n            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n            const encodedReadonlyIndexesLength = Array();\n            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n            const addressTableLookupLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                publicKey(\"accountKey\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedWritableIndexesLength.length, \"encodedWritableIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.writableIndexes.length, \"writableIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedReadonlyIndexesLength.length, \"encodedReadonlyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.readonlyIndexes.length, \"readonlyIndexes\")\n            ]);\n            serializedLength += addressTableLookupLayout.encode({\n                accountKey: lookup.accountKey.toBytes(),\n                encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n                writableIndexes: lookup.writableIndexes,\n                encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n                readonlyIndexes: lookup.readonlyIndexes\n            }, serializedAddressTableLookups, serializedLength);\n        }\n        return serializedAddressTableLookups.slice(0, serializedLength);\n    }\n    static deserialize(serializedMessage) {\n        let byteArray = [\n            ...serializedMessage\n        ];\n        const prefix = guardedShift(byteArray);\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);\n        const version = maskedPrefix;\n        assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);\n        const header = {\n            numRequiredSignatures: guardedShift(byteArray),\n            numReadonlySignedAccounts: guardedShift(byteArray),\n            numReadonlyUnsignedAccounts: guardedShift(byteArray)\n        };\n        const staticAccountKeys = [];\n        const staticAccountKeysLength = decodeLength(byteArray);\n        for(let i = 0; i < staticAccountKeysLength; i++){\n            staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));\n        }\n        const recentBlockhash = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n        const instructionCount = decodeLength(byteArray);\n        const compiledInstructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountKeyIndexesLength = decodeLength(byteArray);\n            const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);\n            const dataLength = decodeLength(byteArray);\n            const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n            compiledInstructions.push({\n                programIdIndex,\n                accountKeyIndexes,\n                data\n            });\n        }\n        const addressTableLookupsCount = decodeLength(byteArray);\n        const addressTableLookups = [];\n        for(let i = 0; i < addressTableLookupsCount; i++){\n            const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const writableIndexesLength = decodeLength(byteArray);\n            const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);\n            const readonlyIndexesLength = decodeLength(byteArray);\n            const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);\n            addressTableLookups.push({\n                accountKey,\n                writableIndexes,\n                readonlyIndexes\n            });\n        }\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n}\n// eslint-disable-next-line no-redeclare\nconst VersionedMessage = {\n    deserializeMessageVersion (serializedMessage) {\n        const prefix = serializedMessage[0];\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        // if the highest bit of the prefix is not set, the message is not versioned\n        if (maskedPrefix === prefix) {\n            return \"legacy\";\n        }\n        // the lower 7 bits of the prefix indicate the message version\n        return maskedPrefix;\n    },\n    deserialize: (serializedMessage)=>{\n        const version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n        if (version === \"legacy\") {\n            return Message.from(serializedMessage);\n        }\n        if (version === 0) {\n            return MessageV0.deserialize(serializedMessage);\n        } else {\n            throw new Error(`Transaction message version ${version} deserialization is not supported`);\n        }\n    }\n};\n/** @internal */ /**\n * Transaction signature as base-58 encoded string\n */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {\n    TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n    TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n    TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n    TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n    return TransactionStatus;\n}({});\n/**\n * Default (empty) signature\n */ const DEFAULT_SIGNATURE = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n/**\n * Account metadata used to define instructions\n */ /**\n * List of TransactionInstruction object fields that may be initialized at construction\n */ /**\n * Configuration object for Transaction.serialize()\n */ /**\n * @internal\n */ /**\n * Transaction Instruction class\n */ class TransactionInstruction {\n    constructor(opts){\n        /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */ this.keys = void 0;\n        /**\n     * Program Id to execute\n     */ this.programId = void 0;\n        /**\n     * Program input\n     */ this.data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        this.programId = opts.programId;\n        this.keys = opts.keys;\n        if (opts.data) {\n            this.data = opts.data;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            keys: this.keys.map(({ pubkey, isSigner, isWritable })=>({\n                    pubkey: pubkey.toJSON(),\n                    isSigner,\n                    isWritable\n                })),\n            programId: this.programId.toJSON(),\n            data: [\n                ...this.data\n            ]\n        };\n    }\n}\n/**\n * Pair of signature and corresponding public key\n */ /**\n * List of Transaction object fields that may be initialized at construction\n */ // For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */ /**\n * Use these options to construct a durable nonce transaction.\n */ /**\n * Nonce information to be used to build an offline Transaction.\n */ /**\n * @internal\n */ /**\n * Transaction class\n */ class Transaction {\n    /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */ get signature() {\n        if (this.signatures.length > 0) {\n            return this.signatures[0].signature;\n        }\n        return null;\n    }\n    /**\n   * The transaction fee payer\n   */ // Construct a transaction with a blockhash and lastValidBlockHeight\n    // Construct a transaction using a durable nonce\n    /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */ /**\n   * Construct an empty Transaction\n   */ constructor(opts){\n        /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */ this.signatures = [];\n        this.feePayer = void 0;\n        /**\n     * The instructions to atomically execute\n     */ this.instructions = [];\n        /**\n     * A recent transaction id. Must be populated by the caller\n     */ this.recentBlockhash = void 0;\n        /**\n     * the last block chain can advance to before tx is declared expired\n     * */ this.lastValidBlockHeight = void 0;\n        /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */ this.nonceInfo = void 0;\n        /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */ this.minNonceContextSlot = void 0;\n        /**\n     * @internal\n     */ this._message = void 0;\n        /**\n     * @internal\n     */ this._json = void 0;\n        if (!opts) {\n            return;\n        }\n        if (opts.feePayer) {\n            this.feePayer = opts.feePayer;\n        }\n        if (opts.signatures) {\n            this.signatures = opts.signatures;\n        }\n        if (Object.prototype.hasOwnProperty.call(opts, \"nonceInfo\")) {\n            const { minContextSlot, nonceInfo } = opts;\n            this.minNonceContextSlot = minContextSlot;\n            this.nonceInfo = nonceInfo;\n        } else if (Object.prototype.hasOwnProperty.call(opts, \"lastValidBlockHeight\")) {\n            const { blockhash, lastValidBlockHeight } = opts;\n            this.recentBlockhash = blockhash;\n            this.lastValidBlockHeight = lastValidBlockHeight;\n        } else {\n            const { recentBlockhash, nonceInfo } = opts;\n            if (nonceInfo) {\n                this.nonceInfo = nonceInfo;\n            }\n            this.recentBlockhash = recentBlockhash;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            recentBlockhash: this.recentBlockhash || null,\n            feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n            nonceInfo: this.nonceInfo ? {\n                nonce: this.nonceInfo.nonce,\n                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n            } : null,\n            instructions: this.instructions.map((instruction)=>instruction.toJSON()),\n            signers: this.signatures.map(({ publicKey })=>{\n                return publicKey.toJSON();\n            })\n        };\n    }\n    /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */ add(...items) {\n        if (items.length === 0) {\n            throw new Error(\"No instructions\");\n        }\n        items.forEach((item)=>{\n            if (\"instructions\" in item) {\n                this.instructions = this.instructions.concat(item.instructions);\n            } else if (\"data\" in item && \"programId\" in item && \"keys\" in item) {\n                this.instructions.push(item);\n            } else {\n                this.instructions.push(new TransactionInstruction(item));\n            }\n        });\n        return this;\n    }\n    /**\n   * Compile transaction data\n   */ compileMessage() {\n        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n            return this._message;\n        }\n        let recentBlockhash;\n        let instructions;\n        if (this.nonceInfo) {\n            recentBlockhash = this.nonceInfo.nonce;\n            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n                instructions = [\n                    this.nonceInfo.nonceInstruction,\n                    ...this.instructions\n                ];\n            } else {\n                instructions = this.instructions;\n            }\n        } else {\n            recentBlockhash = this.recentBlockhash;\n            instructions = this.instructions;\n        }\n        if (!recentBlockhash) {\n            throw new Error(\"Transaction recentBlockhash required\");\n        }\n        if (instructions.length < 1) {\n            console.warn(\"No instructions provided\");\n        }\n        let feePayer;\n        if (this.feePayer) {\n            feePayer = this.feePayer;\n        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n            // Use implicit fee payer\n            feePayer = this.signatures[0].publicKey;\n        } else {\n            throw new Error(\"Transaction fee payer required\");\n        }\n        for(let i = 0; i < instructions.length; i++){\n            if (instructions[i].programId === undefined) {\n                throw new Error(`Transaction instruction index ${i} has undefined program id`);\n            }\n        }\n        const programIds = [];\n        const accountMetas = [];\n        instructions.forEach((instruction)=>{\n            instruction.keys.forEach((accountMeta)=>{\n                accountMetas.push({\n                    ...accountMeta\n                });\n            });\n            const programId = instruction.programId.toString();\n            if (!programIds.includes(programId)) {\n                programIds.push(programId);\n            }\n        });\n        // Append programID account metas\n        programIds.forEach((programId)=>{\n            accountMetas.push({\n                pubkey: new PublicKey(programId),\n                isSigner: false,\n                isWritable: false\n            });\n        });\n        // Cull duplicate account metas\n        const uniqueMetas = [];\n        accountMetas.forEach((accountMeta)=>{\n            const pubkeyString = accountMeta.pubkey.toString();\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.toString() === pubkeyString;\n            });\n            if (uniqueIndex > -1) {\n                uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n                uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n            } else {\n                uniqueMetas.push(accountMeta);\n            }\n        });\n        // Sort. Prioritizing first by signer, then by writable\n        uniqueMetas.sort(function(x, y) {\n            if (x.isSigner !== y.isSigner) {\n                // Signers always come before non-signers\n                return x.isSigner ? -1 : 1;\n            }\n            if (x.isWritable !== y.isWritable) {\n                // Writable accounts always come before read-only accounts\n                return x.isWritable ? -1 : 1;\n            }\n            // Otherwise, sort by pubkey, stringwise.\n            const options = {\n                localeMatcher: \"best fit\",\n                usage: \"sort\",\n                sensitivity: \"variant\",\n                ignorePunctuation: false,\n                numeric: false,\n                caseFirst: \"lower\"\n            };\n            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), \"en\", options);\n        });\n        // Move fee payer to the front\n        const feePayerIndex = uniqueMetas.findIndex((x)=>{\n            return x.pubkey.equals(feePayer);\n        });\n        if (feePayerIndex > -1) {\n            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n            payerMeta.isSigner = true;\n            payerMeta.isWritable = true;\n            uniqueMetas.unshift(payerMeta);\n        } else {\n            uniqueMetas.unshift({\n                pubkey: feePayer,\n                isSigner: true,\n                isWritable: true\n            });\n        }\n        // Disallow unknown signers\n        for (const signature of this.signatures){\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.equals(signature.publicKey);\n            });\n            if (uniqueIndex > -1) {\n                if (!uniqueMetas[uniqueIndex].isSigner) {\n                    uniqueMetas[uniqueIndex].isSigner = true;\n                    console.warn(\"Transaction references a signature that is unnecessary, \" + \"only the fee payer and instruction signer accounts should sign a transaction. \" + \"This behavior is deprecated and will throw an error in the next major version release.\");\n                }\n            } else {\n                throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n            }\n        }\n        let numRequiredSignatures = 0;\n        let numReadonlySignedAccounts = 0;\n        let numReadonlyUnsignedAccounts = 0;\n        // Split out signing from non-signing keys and count header values\n        const signedKeys = [];\n        const unsignedKeys = [];\n        uniqueMetas.forEach(({ pubkey, isSigner, isWritable })=>{\n            if (isSigner) {\n                signedKeys.push(pubkey.toString());\n                numRequiredSignatures += 1;\n                if (!isWritable) {\n                    numReadonlySignedAccounts += 1;\n                }\n            } else {\n                unsignedKeys.push(pubkey.toString());\n                if (!isWritable) {\n                    numReadonlyUnsignedAccounts += 1;\n                }\n            }\n        });\n        const accountKeys = signedKeys.concat(unsignedKeys);\n        const compiledInstructions = instructions.map((instruction)=>{\n            const { data, programId } = instruction;\n            return {\n                programIdIndex: accountKeys.indexOf(programId.toString()),\n                accounts: instruction.keys.map((meta)=>accountKeys.indexOf(meta.pubkey.toString())),\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(data)\n            };\n        });\n        compiledInstructions.forEach((instruction)=>{\n            assert(instruction.programIdIndex >= 0);\n            instruction.accounts.forEach((keyIndex)=>assert(keyIndex >= 0));\n        });\n        return new Message({\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            accountKeys,\n            recentBlockhash,\n            instructions: compiledInstructions\n        });\n    }\n    /**\n   * @internal\n   */ _compile() {\n        const message = this.compileMessage();\n        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n        if (this.signatures.length === signedKeys.length) {\n            const valid = this.signatures.every((pair, index)=>{\n                return signedKeys[index].equals(pair.publicKey);\n            });\n            if (valid) return message;\n        }\n        this.signatures = signedKeys.map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n        return message;\n    }\n    /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */ serializeMessage() {\n        return this._compile().serialize();\n    }\n    /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */ async getEstimatedFee(connection) {\n        return (await connection.getFeeForMessage(this.compileMessage())).value;\n    }\n    /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */ setSigners(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        const seen = new Set();\n        this.signatures = signers.filter((publicKey)=>{\n            const key = publicKey.toString();\n            if (seen.has(key)) {\n                return false;\n            } else {\n                seen.add(key);\n                return true;\n            }\n        }).map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n    }\n    /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ sign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        this.signatures = uniqueSigners.map((signer)=>({\n                signature: null,\n                publicKey: signer.publicKey\n            }));\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ partialSign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * @internal\n   */ _partialSign(message, ...signers) {\n        const signData = message.serialize();\n        signers.forEach((signer)=>{\n            const signature = sign(signData, signer.secretKey);\n            this._addSignature(signer.publicKey, toBuffer(signature));\n        });\n    }\n    /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */ addSignature(pubkey, signature) {\n        this._compile(); // Ensure signatures array is populated\n        this._addSignature(pubkey, signature);\n    }\n    /**\n   * @internal\n   */ _addSignature(pubkey, signature) {\n        assert(signature.length === 64);\n        const index = this.signatures.findIndex((sigpair)=>pubkey.equals(sigpair.publicKey));\n        if (index < 0) {\n            throw new Error(`unknown signer: ${pubkey.toString()}`);\n        }\n        this.signatures[index].signature = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature);\n    }\n    /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */ verifySignatures(requireAllSignatures = true) {\n        const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n        return !signatureErrors;\n    }\n    /**\n   * @internal\n   */ _getMessageSignednessErrors(message, requireAllSignatures) {\n        const errors = {};\n        for (const { signature, publicKey } of this.signatures){\n            if (signature === null) {\n                if (requireAllSignatures) {\n                    (errors.missing ||= []).push(publicKey);\n                }\n            } else {\n                if (!verify(signature, message, publicKey.toBytes())) {\n                    (errors.invalid ||= []).push(publicKey);\n                }\n            }\n        }\n        return errors.invalid || errors.missing ? errors : undefined;\n    }\n    /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */ serialize(config) {\n        const { requireAllSignatures, verifySignatures } = Object.assign({\n            requireAllSignatures: true,\n            verifySignatures: true\n        }, config);\n        const signData = this.serializeMessage();\n        if (verifySignatures) {\n            const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n            if (sigErrors) {\n                let errorMessage = \"Signature verification failed.\";\n                if (sigErrors.invalid) {\n                    errorMessage += `\\nInvalid signature for public key${sigErrors.invalid.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.invalid.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                if (sigErrors.missing) {\n                    errorMessage += `\\nMissing signature for public key${sigErrors.missing.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.missing.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                throw new Error(errorMessage);\n            }\n        }\n        return this._serialize(signData);\n    }\n    /**\n   * @internal\n   */ _serialize(signData) {\n        const { signatures } = this;\n        const signatureCount = [];\n        encodeLength(signatureCount, signatures.length);\n        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n        const wireTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(transactionLength);\n        assert(signatures.length < 256);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signatureCount).copy(wireTransaction, 0);\n        signatures.forEach(({ signature }, index)=>{\n            if (signature !== null) {\n                assert(signature.length === 64, `signature has invalid length`);\n                buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n            }\n        });\n        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n        assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n        return wireTransaction;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get keys() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].keys.map((keyObj)=>keyObj.pubkey);\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get programId() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].programId;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get data() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].data;\n    }\n    /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const signatureCount = decodeLength(byteArray);\n        let signatures = [];\n        for(let i = 0; i < signatureCount; i++){\n            const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n            signatures.push(bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature)));\n        }\n        return Transaction.populate(Message.from(byteArray), signatures);\n    }\n    /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */ static populate(message, signatures = []) {\n        const transaction = new Transaction();\n        transaction.recentBlockhash = message.recentBlockhash;\n        if (message.header.numRequiredSignatures > 0) {\n            transaction.feePayer = message.accountKeys[0];\n        }\n        signatures.forEach((signature, index)=>{\n            const sigPubkeyPair = {\n                signature: signature == bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(DEFAULT_SIGNATURE) ? null : bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(signature),\n                publicKey: message.accountKeys[index]\n            };\n            transaction.signatures.push(sigPubkeyPair);\n        });\n        message.instructions.forEach((instruction)=>{\n            const keys = instruction.accounts.map((account)=>{\n                const pubkey = message.accountKeys[account];\n                return {\n                    pubkey,\n                    isSigner: transaction.signatures.some((keyObj)=>keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n                    isWritable: message.isAccountWritable(account)\n                };\n            });\n            transaction.instructions.push(new TransactionInstruction({\n                keys,\n                programId: message.accountKeys[instruction.programIdIndex],\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data)\n            }));\n        });\n        transaction._message = message;\n        transaction._json = transaction.toJSON();\n        return transaction;\n    }\n}\nclass TransactionMessage {\n    constructor(args){\n        this.payerKey = void 0;\n        this.instructions = void 0;\n        this.recentBlockhash = void 0;\n        this.payerKey = args.payerKey;\n        this.instructions = args.instructions;\n        this.recentBlockhash = args.recentBlockhash;\n    }\n    static decompile(message, args) {\n        const { header, compiledInstructions, recentBlockhash } = message;\n        const { numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts } = header;\n        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n        assert(numWritableSignedAccounts > 0, \"Message header is invalid\");\n        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n        assert(numWritableUnsignedAccounts >= 0, \"Message header is invalid\");\n        const accountKeys = message.getAccountKeys(args);\n        const payerKey = accountKeys.get(0);\n        if (payerKey === undefined) {\n            throw new Error(\"Failed to decompile message because no account keys were found\");\n        }\n        const instructions = [];\n        for (const compiledIx of compiledInstructions){\n            const keys = [];\n            for (const keyIndex of compiledIx.accountKeyIndexes){\n                const pubkey = accountKeys.get(keyIndex);\n                if (pubkey === undefined) {\n                    throw new Error(`Failed to find key for account key index ${keyIndex}`);\n                }\n                const isSigner = keyIndex < numRequiredSignatures;\n                let isWritable;\n                if (isSigner) {\n                    isWritable = keyIndex < numWritableSignedAccounts;\n                } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n                    isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n                } else {\n                    isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n                    accountKeys.accountKeysFromLookups.writable.length;\n                }\n                keys.push({\n                    pubkey,\n                    isSigner: keyIndex < header.numRequiredSignatures,\n                    isWritable\n                });\n            }\n            const programId = accountKeys.get(compiledIx.programIdIndex);\n            if (programId === undefined) {\n                throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);\n            }\n            instructions.push(new TransactionInstruction({\n                programId,\n                data: toBuffer(compiledIx.data),\n                keys\n            }));\n        }\n        return new TransactionMessage({\n            payerKey,\n            instructions,\n            recentBlockhash\n        });\n    }\n    compileToLegacyMessage() {\n        return Message.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions\n        });\n    }\n    compileToV0Message(addressLookupTableAccounts) {\n        return MessageV0.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions,\n            addressLookupTableAccounts\n        });\n    }\n}\n/**\n * Versioned transaction class\n */ class VersionedTransaction {\n    get version() {\n        return this.message.version;\n    }\n    constructor(message, signatures){\n        this.signatures = void 0;\n        this.message = void 0;\n        if (signatures !== undefined) {\n            assert(signatures.length === message.header.numRequiredSignatures, \"Expected signatures length to be equal to the number of required signatures\");\n            this.signatures = signatures;\n        } else {\n            const defaultSignatures = [];\n            for(let i = 0; i < message.header.numRequiredSignatures; i++){\n                defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n            }\n            this.signatures = defaultSignatures;\n        }\n        this.message = message;\n    }\n    serialize() {\n        const serializedMessage = this.message.serialize();\n        const encodedSignaturesLength = Array();\n        encodeLength(encodedSignaturesLength, this.signatures.length);\n        const transactionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedSignaturesLength.length, \"encodedSignaturesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(signature(), this.signatures.length, \"signatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedMessage.length, \"serializedMessage\")\n        ]);\n        const serializedTransaction = new Uint8Array(2048);\n        const serializedTransactionLength = transactionLayout.encode({\n            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n            signatures: this.signatures,\n            serializedMessage\n        }, serializedTransaction);\n        return serializedTransaction.slice(0, serializedTransactionLength);\n    }\n    static deserialize(serializedTransaction) {\n        let byteArray = [\n            ...serializedTransaction\n        ];\n        const signatures = [];\n        const signaturesLength = decodeLength(byteArray);\n        for(let i = 0; i < signaturesLength; i++){\n            signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));\n        }\n        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n        return new VersionedTransaction(message, signatures);\n    }\n    sign(signers) {\n        const messageData = this.message.serialize();\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        for (const signer of signers){\n            const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(signer.publicKey));\n            assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);\n            this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n        }\n    }\n    addSignature(publicKey, signature) {\n        assert(signature.byteLength === 64, \"Signature must be 64 bytes long\");\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(publicKey));\n        assert(signerIndex >= 0, `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`);\n        this.signatures[signerIndex] = signature;\n    }\n}\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n/**\n * @internal\n */ const NUM_TICKS_PER_SECOND = 160;\n/**\n * @internal\n */ const DEFAULT_TICKS_PER_SLOT = 64;\n/**\n * @internal\n */ const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n/**\n * @internal\n */ const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey(\"SysvarC1ock11111111111111111111111111111111\");\nconst SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey(\"SysvarEpochSchedu1e111111111111111111111111\");\nconst SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey(\"Sysvar1nstructions1111111111111111111111111\");\nconst SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\"SysvarRecentB1ockHashes11111111111111111111\");\nconst SYSVAR_RENT_PUBKEY = new PublicKey(\"SysvarRent111111111111111111111111111111111\");\nconst SYSVAR_REWARDS_PUBKEY = new PublicKey(\"SysvarRewards111111111111111111111111111111\");\nconst SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey(\"SysvarS1otHashes111111111111111111111111111\");\nconst SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey(\"SysvarS1otHistory11111111111111111111111111\");\nconst SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\"SysvarStakeHistory1111111111111111111111111\");\nclass SendTransactionError extends Error {\n    constructor({ action, signature, transactionMessage, logs }){\n        const maybeLogsOutput = logs ? `Logs: \\n${JSON.stringify(logs.slice(-10), null, 2)}. ` : \"\";\n        const guideText = \"\\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.\";\n        let message;\n        switch(action){\n            case \"send\":\n                message = `Transaction ${signature} resulted in an error. \\n` + `${transactionMessage}. ` + maybeLogsOutput + guideText;\n                break;\n            case \"simulate\":\n                message = `Simulation failed. \\nMessage: ${transactionMessage}. \\n` + maybeLogsOutput + guideText;\n                break;\n            default:\n                {\n                    message = `Unknown action '${((a)=>a)(action)}'`;\n                }\n        }\n        super(message);\n        this.signature = void 0;\n        this.transactionMessage = void 0;\n        this.transactionLogs = void 0;\n        this.signature = signature;\n        this.transactionMessage = transactionMessage;\n        this.transactionLogs = logs ? logs : undefined;\n    }\n    get transactionError() {\n        return {\n            message: this.transactionMessage,\n            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined\n        };\n    }\n    /* @deprecated Use `await getLogs()` instead */ get logs() {\n        const cachedLogs = this.transactionLogs;\n        if (cachedLogs != null && typeof cachedLogs === \"object\" && \"then\" in cachedLogs) {\n            return undefined;\n        }\n        return cachedLogs;\n    }\n    async getLogs(connection) {\n        if (!Array.isArray(this.transactionLogs)) {\n            this.transactionLogs = new Promise((resolve, reject)=>{\n                connection.getTransaction(this.signature).then((tx)=>{\n                    if (tx && tx.meta && tx.meta.logMessages) {\n                        const logs = tx.meta.logMessages;\n                        this.transactionLogs = logs;\n                        resolve(logs);\n                    } else {\n                        reject(new Error(\"Log messages not found\"));\n                    }\n                }).catch(reject);\n            });\n        }\n        return await this.transactionLogs;\n    }\n}\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaJSONRPCErrorCode = {\n    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n    JSON_RPC_SCAN_ERROR: -32012,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nclass SolanaJSONRPCError extends Error {\n    constructor({ code, message, data }, customMessage){\n        super(customMessage != null ? `${customMessage}: ${message}` : message);\n        this.code = void 0;\n        this.data = void 0;\n        this.code = code;\n        this.data = data;\n        this.name = \"SolanaJSONRPCError\";\n    }\n}\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ async function sendAndConfirmTransaction(connection, transaction, signers, options) {\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        maxRetries: options.maxRetries,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n    let status;\n    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            signature: signature,\n            blockhash: transaction.recentBlockhash,\n            lastValidBlockHeight: transaction.lastValidBlockHeight\n        }, options && options.commitment)).value;\n    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n        const { nonceInstruction } = transaction.nonceInfo;\n        const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            minContextSlot: transaction.minNonceContextSlot,\n            nonceAccountPubkey,\n            nonceValue: transaction.nonceInfo.nonce,\n            signature\n        }, options && options.commitment)).value;\n    } else {\n        if (options?.abortSignal != null) {\n            console.warn(\"sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was \" + \"supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` \" + \"or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.\");\n        }\n        status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n    }\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: \"send\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n// zzz\nfunction sleep(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n/**\n * @internal\n */ /**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */ function encodeData(type, fields) {\n    const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n    const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(allocLength);\n    const layoutFields = Object.assign({\n        instruction: type.index\n    }, fields);\n    type.layout.encode(layoutFields, data);\n    return data;\n}\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */ function decodeData$1(type, buffer) {\n    let data;\n    try {\n        data = type.layout.decode(buffer);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (data.instruction !== type.index) {\n        throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);\n    }\n    return data;\n}\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */ const FeeCalculatorLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lamportsPerSignature\");\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */ const NonceAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"version\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"state\"),\n    publicKey(\"authorizedPubkey\"),\n    publicKey(\"nonce\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        FeeCalculatorLayout\n    ], \"feeCalculator\")\n]);\nconst NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */ /**\n * NonceAccount class\n */ class NonceAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.authorizedPubkey = void 0;\n        this.nonce = void 0;\n        this.feeCalculator = void 0;\n        this.authorizedPubkey = args.authorizedPubkey;\n        this.nonce = args.nonce;\n        this.feeCalculator = args.feeCalculator;\n    }\n    /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */ static fromAccountData(buffer) {\n        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n        return new NonceAccount({\n            authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n            nonce: new PublicKey(nonceAccount.nonce).toString(),\n            feeCalculator: nonceAccount.feeCalculator\n        });\n    }\n}\nfunction u64(property) {\n    const layout = (0,_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob)(8 /* bytes */ , property);\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    const bigIntLayout = layout;\n    const codec = (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_13__.getU64Codec)();\n    bigIntLayout.decode = (buffer, offset)=>{\n        const src = decode(buffer, offset);\n        return codec.decode(src);\n    };\n    bigIntLayout.encode = (bigInt, buffer, offset)=>{\n        const src = codec.encode(bigInt);\n        return encode(src, buffer, offset);\n    };\n    return bigIntLayout;\n}\n/**\n * Create account system transaction params\n */ /**\n * Transfer system transaction params\n */ /**\n * Assign system transaction params\n */ /**\n * Create account with seed system transaction params\n */ /**\n * Create nonce account system transaction params\n */ /**\n * Create nonce account with seed system transaction params\n */ /**\n * Initialize nonce account system instruction params\n */ /**\n * Advance nonce account system instruction params\n */ /**\n * Withdraw nonce account system transaction params\n */ /**\n * Authorize nonce account system transaction params\n */ /**\n * Allocate account system transaction params\n */ /**\n * Allocate account with seed system transaction params\n */ /**\n * Assign account with seed system transaction params\n */ /**\n * Transfer with seed system transaction params\n */ /** Decoded transfer system transaction instruction */ /** Decoded transferWithSeed system transaction instruction */ /**\n * System Instruction class\n */ class SystemInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a system instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a SystemInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */ static decodeCreateAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */ static decodeTransfer(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */ static decodeTransferWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            basePubkey: instruction.keys[1].pubkey,\n            toPubkey: instruction.keys[2].pubkey,\n            lamports,\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */ static decodeAllocate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { space } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            space\n        };\n    }\n    /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */ static decodeAllocateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */ static decodeAssign(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */ static decodeAssignWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */ static decodeCreateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { base, seed, lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */ static decodeNonceInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */ static decodeNonceAdvance(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */ static decodeNonceWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */ static decodeNonceAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[1].pubkey,\n            newAuthorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(SystemProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not SystemProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid SystemInstructionType's\n */ /**\n * An enumeration of valid system InstructionType's\n * @internal\n */ const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n    Create: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Assign: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Transfer: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\")\n        ])\n    },\n    CreateWithSeed: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AdvanceNonceAccount: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    WithdrawNonceAccount: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    InitializeNonceAccount: {\n        index: 6,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    AuthorizeNonceAccount: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    Allocate: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\")\n        ])\n    },\n    AllocateWithSeed: {\n        index: 9,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AssignWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    TransferWithSeed: {\n        index: 11,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    UpgradeNonceAccount: {\n        index: 12,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\n/**\n * Factory class for transactions to interact with the System program\n */ class SystemProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the System program\n   */ /**\n   * Generate a transaction instruction that creates a new account\n   */ static createAccount(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n        const data = encodeData(type, {\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.newAccountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */ static transfer(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports)\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that assigns an account to a program\n   */ static assign(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n            data = encodeData(type, {\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */ static createAccountWithSeed(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n        const data = encodeData(type, {\n            base: toBuffer(params.basePubkey.toBuffer()),\n            seed: params.seed,\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        let keys = [\n            {\n                pubkey: params.fromPubkey,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: params.newAccountPubkey,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        if (!params.basePubkey.equals(params.fromPubkey)) {\n            keys.push({\n                pubkey: params.basePubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that creates a new Nonce account\n   */ static createNonceAccount(params) {\n        const transaction = new Transaction();\n        if (\"basePubkey\" in params && \"seed\" in params) {\n            transaction.add(SystemProgram.createAccountWithSeed({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                basePubkey: params.basePubkey,\n                seed: params.seed,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        } else {\n            transaction.add(SystemProgram.createAccount({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        }\n        const initParams = {\n            noncePubkey: params.noncePubkey,\n            authorizedPubkey: params.authorizedPubkey\n        };\n        transaction.add(this.nonceInitialize(initParams));\n        return transaction;\n    }\n    /**\n   * Generate an instruction to initialize a Nonce account\n   */ static nonceInitialize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.authorizedPubkey.toBuffer())\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */ static nonceAdvance(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n        const data = encodeData(type);\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */ static nonceWithdraw(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n        const data = encodeData(type, {\n            lamports: params.lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */ static nonceAuthorize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */ static allocate(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                space: params.space,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n            data = encodeData(type, {\n                space: params.space\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nSystemProgram.programId = new PublicKey(\"11111111111111111111111111111111\");\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n/**\n * Program loader interface\n */ class Loader {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Amount of program data placed in each load Transaction\n   */ /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return 2 * // Every transaction requires two signatures (payer + program)\n        (Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction\n        1 // Add one for Finalize transaction\n        );\n    }\n    /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static async load(connection, payer, program, programId, data) {\n        {\n            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n            // Fetch program account info to check if it has already been created\n            const programInfo = await connection.getAccountInfo(program.publicKey, \"confirmed\");\n            let transaction = null;\n            if (programInfo !== null) {\n                if (programInfo.executable) {\n                    console.error(\"Program load failed, account is already executable\");\n                    return false;\n                }\n                if (programInfo.data.length !== data.length) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.allocate({\n                        accountPubkey: program.publicKey,\n                        space: data.length\n                    }));\n                }\n                if (!programInfo.owner.equals(programId)) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.assign({\n                        accountPubkey: program.publicKey,\n                        programId\n                    }));\n                }\n                if (programInfo.lamports < balanceNeeded) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.transfer({\n                        fromPubkey: payer.publicKey,\n                        toPubkey: program.publicKey,\n                        lamports: balanceNeeded - programInfo.lamports\n                    }));\n                }\n            } else {\n                transaction = new Transaction().add(SystemProgram.createAccount({\n                    fromPubkey: payer.publicKey,\n                    newAccountPubkey: program.publicKey,\n                    lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n                    space: data.length,\n                    programId\n                }));\n            }\n            // If the account is already created correctly, skip this step\n            // and proceed directly to loading instructions\n            if (transaction !== null) {\n                await sendAndConfirmTransaction(connection, transaction, [\n                    payer,\n                    program\n                ], {\n                    commitment: \"confirmed\"\n                });\n            }\n        }\n        const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"offset\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLengthPadding\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"byte\"), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"bytes\")\n        ]);\n        const chunkSize = Loader.chunkSize;\n        let offset = 0;\n        let array = data;\n        let transactions = [];\n        while(array.length > 0){\n            const bytes = array.slice(0, chunkSize);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(chunkSize + 16);\n            dataLayout.encode({\n                instruction: 0,\n                // Load instruction\n                offset,\n                bytes: bytes,\n                bytesLength: 0,\n                bytesLengthPadding: 0\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId,\n                data\n            });\n            transactions.push(sendAndConfirmTransaction(connection, transaction, [\n                payer,\n                program\n            ], {\n                commitment: \"confirmed\"\n            }));\n            // Delay between sends in an attempt to reduce rate limit errors\n            if (connection._rpcEndpoint.includes(\"solana.com\")) {\n                const REQUESTS_PER_SECOND = 4;\n                await sleep(1000 / REQUESTS_PER_SECOND);\n            }\n            offset += chunkSize;\n            array = array.slice(chunkSize);\n        }\n        await Promise.all(transactions);\n        // Finalize the account loaded with program data for execution\n        {\n            const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n            ]);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(dataLayout.span);\n            dataLayout.encode({\n                instruction: 1 // Finalize instruction\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: SYSVAR_RENT_PUBKEY,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId,\n                data\n            });\n            const deployCommitment = \"processed\";\n            const finalizeSignature = await connection.sendTransaction(transaction, [\n                payer,\n                program\n            ], {\n                preflightCommitment: deployCommitment\n            });\n            const { context, value } = await connection.confirmTransaction({\n                signature: finalizeSignature,\n                lastValidBlockHeight: transaction.lastValidBlockHeight,\n                blockhash: transaction.recentBlockhash\n            }, deployCommitment);\n            if (value.err) {\n                throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);\n            }\n            // We prevent programs from being usable until the slot after their deployment.\n            // See https://github.com/solana-labs/solana/pull/29654\n            while(true // eslint-disable-line no-constant-condition\n            ){\n                try {\n                    const currentSlot = await connection.getSlot({\n                        commitment: deployCommitment\n                    });\n                    if (currentSlot > context.slot) {\n                        break;\n                    }\n                } catch  {\n                /* empty */ }\n                await new Promise((resolve)=>setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n            }\n        }\n        // success\n        return true;\n    }\n}\nLoader.chunkSize = CHUNK_SIZE;\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */ const BPF_LOADER_PROGRAM_ID = new PublicKey(\"BPFLoader2111111111111111111111111111111111\");\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */ class BpfLoader {\n    /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return Loader.getMinNumSignatures(dataLength);\n    }\n    /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static load(connection, payer, program, elf, loaderProgramId) {\n        return Loader.load(connection, payer, program, loaderProgramId, elf);\n    }\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar agentkeepalive = {\n    exports: {}\n};\n/**\n * Helpers.\n */ var ms;\nvar hasRequiredMs;\nfunction requireMs() {\n    if (hasRequiredMs) return ms;\n    hasRequiredMs = 1;\n    var s = 1000;\n    var m = s * 60;\n    var h = m * 60;\n    var d = h * 24;\n    var w = d * 7;\n    var y = d * 365.25;\n    /**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} [options]\n\t * @throws {Error} throw an error if val is not a non-empty string or a number\n\t * @return {String|Number}\n\t * @api public\n\t */ ms = function(val, options) {\n        options = options || {};\n        var type = typeof val;\n        if (type === \"string\" && val.length > 0) {\n            return parse(val);\n        } else if (type === \"number\" && isFinite(val)) {\n            return options.long ? fmtLong(val) : fmtShort(val);\n        }\n        throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val));\n    };\n    /**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */ function parse(str) {\n        str = String(str);\n        if (str.length > 100) {\n            return;\n        }\n        var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n        if (!match) {\n            return;\n        }\n        var n = parseFloat(match[1]);\n        var type = (match[2] || \"ms\").toLowerCase();\n        switch(type){\n            case \"years\":\n            case \"year\":\n            case \"yrs\":\n            case \"yr\":\n            case \"y\":\n                return n * y;\n            case \"weeks\":\n            case \"week\":\n            case \"w\":\n                return n * w;\n            case \"days\":\n            case \"day\":\n            case \"d\":\n                return n * d;\n            case \"hours\":\n            case \"hour\":\n            case \"hrs\":\n            case \"hr\":\n            case \"h\":\n                return n * h;\n            case \"minutes\":\n            case \"minute\":\n            case \"mins\":\n            case \"min\":\n            case \"m\":\n                return n * m;\n            case \"seconds\":\n            case \"second\":\n            case \"secs\":\n            case \"sec\":\n            case \"s\":\n                return n * s;\n            case \"milliseconds\":\n            case \"millisecond\":\n            case \"msecs\":\n            case \"msec\":\n            case \"ms\":\n                return n;\n            default:\n                return undefined;\n        }\n    }\n    /**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */ function fmtShort(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n            return Math.round(ms / d) + \"d\";\n        }\n        if (msAbs >= h) {\n            return Math.round(ms / h) + \"h\";\n        }\n        if (msAbs >= m) {\n            return Math.round(ms / m) + \"m\";\n        }\n        if (msAbs >= s) {\n            return Math.round(ms / s) + \"s\";\n        }\n        return ms + \"ms\";\n    }\n    /**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */ function fmtLong(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n            return plural(ms, msAbs, d, \"day\");\n        }\n        if (msAbs >= h) {\n            return plural(ms, msAbs, h, \"hour\");\n        }\n        if (msAbs >= m) {\n            return plural(ms, msAbs, m, \"minute\");\n        }\n        if (msAbs >= s) {\n            return plural(ms, msAbs, s, \"second\");\n        }\n        return ms + \" ms\";\n    }\n    /**\n\t * Pluralization helper.\n\t */ function plural(ms, msAbs, n, name) {\n        var isPlural = msAbs >= n * 1.5;\n        return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n    }\n    return ms;\n}\n/*!\n * humanize-ms - index.js\n * Copyright(c) 2014 dead_horse <dead_horse@qq.com>\n * MIT Licensed\n */ var humanizeMs;\nvar hasRequiredHumanizeMs;\nfunction requireHumanizeMs() {\n    if (hasRequiredHumanizeMs) return humanizeMs;\n    hasRequiredHumanizeMs = 1;\n    /**\n\t * Module dependencies.\n\t */ var util = (util__WEBPACK_IMPORTED_MODULE_5___default());\n    var ms = /*@__PURE__*/ requireMs();\n    humanizeMs = function(t) {\n        if (typeof t === \"number\") return t;\n        var r = ms(t);\n        if (r === undefined) {\n            var err = new Error(util.format(\"humanize-ms(%j) result undefined\", t));\n            console.warn(err.stack);\n        }\n        return r;\n    };\n    return humanizeMs;\n}\nvar constants;\nvar hasRequiredConstants;\nfunction requireConstants() {\n    if (hasRequiredConstants) return constants;\n    hasRequiredConstants = 1;\n    constants = {\n        // agent\n        CURRENT_ID: Symbol(\"agentkeepalive#currentId\"),\n        CREATE_ID: Symbol(\"agentkeepalive#createId\"),\n        INIT_SOCKET: Symbol(\"agentkeepalive#initSocket\"),\n        CREATE_HTTPS_CONNECTION: Symbol(\"agentkeepalive#createHttpsConnection\"),\n        // socket\n        SOCKET_CREATED_TIME: Symbol(\"agentkeepalive#socketCreatedTime\"),\n        SOCKET_NAME: Symbol(\"agentkeepalive#socketName\"),\n        SOCKET_REQUEST_COUNT: Symbol(\"agentkeepalive#socketRequestCount\"),\n        SOCKET_REQUEST_FINISHED_COUNT: Symbol(\"agentkeepalive#socketRequestFinishedCount\")\n    };\n    return constants;\n}\nvar agent;\nvar hasRequiredAgent;\nfunction requireAgent() {\n    if (hasRequiredAgent) return agent;\n    hasRequiredAgent = 1;\n    const OriginalAgent = (http__WEBPACK_IMPORTED_MODULE_6___default().Agent);\n    const ms = /*@__PURE__*/ requireHumanizeMs();\n    const debug = util__WEBPACK_IMPORTED_MODULE_5___default().debuglog(\"agentkeepalive\");\n    const { INIT_SOCKET, CURRENT_ID, CREATE_ID, SOCKET_CREATED_TIME, SOCKET_NAME, SOCKET_REQUEST_COUNT, SOCKET_REQUEST_FINISHED_COUNT } = /*@__PURE__*/ requireConstants();\n    // OriginalAgent come from\n    // - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js\n    // - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js\n    // node <= 10\n    let defaultTimeoutListenerCount = 1;\n    const majorVersion = parseInt(process.version.split(\".\", 1)[0].substring(1));\n    if (majorVersion >= 11 && majorVersion <= 12) {\n        defaultTimeoutListenerCount = 2;\n    } else if (majorVersion >= 13) {\n        defaultTimeoutListenerCount = 3;\n    }\n    function deprecate(message) {\n        console.log(\"[agentkeepalive:deprecated] %s\", message);\n    }\n    class Agent extends OriginalAgent {\n        constructor(options){\n            options = options || {};\n            options.keepAlive = options.keepAlive !== false;\n            // default is keep-alive and 4s free socket timeout\n            // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83\n            if (options.freeSocketTimeout === undefined) {\n                options.freeSocketTimeout = 4000;\n            }\n            // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`\n            if (options.keepAliveTimeout) {\n                deprecate(\"options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n                options.freeSocketTimeout = options.keepAliveTimeout;\n                delete options.keepAliveTimeout;\n            }\n            // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`\n            if (options.freeSocketKeepAliveTimeout) {\n                deprecate(\"options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n                options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;\n                delete options.freeSocketKeepAliveTimeout;\n            }\n            // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.\n            // By default is double free socket timeout.\n            if (options.timeout === undefined) {\n                // make sure socket default inactivity timeout >= 8s\n                options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);\n            }\n            // support humanize format\n            options.timeout = ms(options.timeout);\n            options.freeSocketTimeout = ms(options.freeSocketTimeout);\n            options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;\n            super(options);\n            this[CURRENT_ID] = 0;\n            // create socket success counter\n            this.createSocketCount = 0;\n            this.createSocketCountLastCheck = 0;\n            this.createSocketErrorCount = 0;\n            this.createSocketErrorCountLastCheck = 0;\n            this.closeSocketCount = 0;\n            this.closeSocketCountLastCheck = 0;\n            // socket error event count\n            this.errorSocketCount = 0;\n            this.errorSocketCountLastCheck = 0;\n            // request finished counter\n            this.requestCount = 0;\n            this.requestCountLastCheck = 0;\n            // including free socket timeout counter\n            this.timeoutSocketCount = 0;\n            this.timeoutSocketCountLastCheck = 0;\n            this.on(\"free\", (socket)=>{\n                // https://github.com/nodejs/node/pull/32000\n                // Node.js native agent will check socket timeout eqs agent.options.timeout.\n                // Use the ttl or freeSocketTimeout to overwrite.\n                const timeout = this.calcSocketTimeout(socket);\n                if (timeout > 0 && socket.timeout !== timeout) {\n                    socket.setTimeout(timeout);\n                }\n            });\n        }\n        get freeSocketKeepAliveTimeout() {\n            deprecate(\"agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead\");\n            return this.options.freeSocketTimeout;\n        }\n        get timeout() {\n            deprecate(\"agent.timeout is deprecated, please use agent.options.timeout instead\");\n            return this.options.timeout;\n        }\n        get socketActiveTTL() {\n            deprecate(\"agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead\");\n            return this.options.socketActiveTTL;\n        }\n        calcSocketTimeout(socket) {\n            /**\n\t     * return <= 0: should free socket\n\t     * return > 0: should update socket timeout\n\t     * return undefined: not find custom timeout\n\t     */ let freeSocketTimeout = this.options.freeSocketTimeout;\n            const socketActiveTTL = this.options.socketActiveTTL;\n            if (socketActiveTTL) {\n                // check socketActiveTTL\n                const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];\n                const diff = socketActiveTTL - aliveTime;\n                if (diff <= 0) {\n                    return diff;\n                }\n                if (freeSocketTimeout && diff < freeSocketTimeout) {\n                    freeSocketTimeout = diff;\n                }\n            }\n            // set freeSocketTimeout\n            if (freeSocketTimeout) {\n                // set free keepalive timer\n                // try to use socket custom freeSocketTimeout first, support headers['keep-alive']\n                // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498\n                const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;\n                return customFreeSocketTimeout || freeSocketTimeout;\n            }\n        }\n        keepSocketAlive(socket) {\n            const result = super.keepSocketAlive(socket);\n            // should not keepAlive, do nothing\n            if (!result) return result;\n            const customTimeout = this.calcSocketTimeout(socket);\n            if (typeof customTimeout === \"undefined\") {\n                return true;\n            }\n            if (customTimeout <= 0) {\n                debug(\"%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);\n                return false;\n            }\n            if (socket.timeout !== customTimeout) {\n                socket.setTimeout(customTimeout);\n            }\n            return true;\n        }\n        // only call on addRequest\n        reuseSocket(...args) {\n            // reuseSocket(socket, req)\n            super.reuseSocket(...args);\n            const socket = args[0];\n            const req = args[1];\n            req.reusedSocket = true;\n            const agentTimeout = this.options.timeout;\n            if (getSocketTimeout(socket) !== agentTimeout) {\n                // reset timeout before use\n                socket.setTimeout(agentTimeout);\n                debug(\"%s reset timeout to %sms\", socket[SOCKET_NAME], agentTimeout);\n            }\n            socket[SOCKET_REQUEST_COUNT]++;\n            debug(\"%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));\n        }\n        [CREATE_ID]() {\n            const id = this[CURRENT_ID]++;\n            if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;\n            return id;\n        }\n        [INIT_SOCKET](socket, options) {\n            // bugfix here.\n            // https on node 8, 10 won't set agent.options.timeout by default\n            // TODO: need to fix on node itself\n            if (options.timeout) {\n                const timeout = getSocketTimeout(socket);\n                if (!timeout) {\n                    socket.setTimeout(options.timeout);\n                }\n            }\n            if (this.options.keepAlive) {\n                // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/\n                // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html\n                socket.setNoDelay(true);\n            }\n            this.createSocketCount++;\n            if (this.options.socketActiveTTL) {\n                socket[SOCKET_CREATED_TIME] = Date.now();\n            }\n            // don't show the hole '-----BEGIN CERTIFICATE----' key string\n            socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split(\"-----BEGIN\", 1)[0];\n            socket[SOCKET_REQUEST_COUNT] = 1;\n            socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;\n            installListeners(this, socket, options);\n        }\n        createConnection(options, oncreate) {\n            let called = false;\n            const onNewCreate = (err, socket)=>{\n                if (called) return;\n                called = true;\n                if (err) {\n                    this.createSocketErrorCount++;\n                    return oncreate(err);\n                }\n                this[INIT_SOCKET](socket, options);\n                oncreate(err, socket);\n            };\n            const newSocket = super.createConnection(options, onNewCreate);\n            if (newSocket) onNewCreate(null, newSocket);\n            return newSocket;\n        }\n        get statusChanged() {\n            const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;\n            if (changed) {\n                this.createSocketCountLastCheck = this.createSocketCount;\n                this.createSocketErrorCountLastCheck = this.createSocketErrorCount;\n                this.closeSocketCountLastCheck = this.closeSocketCount;\n                this.errorSocketCountLastCheck = this.errorSocketCount;\n                this.timeoutSocketCountLastCheck = this.timeoutSocketCount;\n                this.requestCountLastCheck = this.requestCount;\n            }\n            return changed;\n        }\n        getCurrentStatus() {\n            return {\n                createSocketCount: this.createSocketCount,\n                createSocketErrorCount: this.createSocketErrorCount,\n                closeSocketCount: this.closeSocketCount,\n                errorSocketCount: this.errorSocketCount,\n                timeoutSocketCount: this.timeoutSocketCount,\n                requestCount: this.requestCount,\n                freeSockets: inspect(this.freeSockets),\n                sockets: inspect(this.sockets),\n                requests: inspect(this.requests)\n            };\n        }\n    }\n    // node 8 don't has timeout attribute on socket\n    // https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\n    function getSocketTimeout(socket) {\n        return socket.timeout || socket._idleTimeout;\n    }\n    function installListeners(agent, socket, options) {\n        debug(\"%s create, timeout %sms\", socket[SOCKET_NAME], getSocketTimeout(socket));\n        // listener socket events: close, timeout, error, free\n        function onFree() {\n            // create and socket.emit('free') logic\n            // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311\n            // no req on the socket, it should be the new socket\n            if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;\n            socket[SOCKET_REQUEST_FINISHED_COUNT]++;\n            agent.requestCount++;\n            debug(\"%s(requests: %s, finished: %s) free\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            // should reuse on pedding requests?\n            const name = agent.getName(options);\n            if (socket.writable && agent.requests[name] && agent.requests[name].length) {\n                // will be reuse on agent free listener\n                socket[SOCKET_REQUEST_COUNT]++;\n                debug(\"%s(requests: %s, finished: %s) will be reuse on agent free event\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            }\n        }\n        socket.on(\"free\", onFree);\n        function onClose(isError) {\n            debug(\"%s(requests: %s, finished: %s) close, isError: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);\n            agent.closeSocketCount++;\n        }\n        socket.on(\"close\", onClose);\n        // start socket timeout handler\n        function onTimeout() {\n            // onTimeout and emitRequestTimeout(_http_client.js)\n            // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711\n            const listenerCount = socket.listeners(\"timeout\").length;\n            // node <= 10, default listenerCount is 1, onTimeout\n            // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout\n            // node >= 13, default listenerCount is 3, onTimeout,\n            //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)\n            //   and emitRequestTimeout\n            const timeout = getSocketTimeout(socket);\n            const req = socket._httpMessage;\n            const reqTimeoutListenerCount = req && req.listeners(\"timeout\").length || 0;\n            debug(\"%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);\n            if (debug.enabled) {\n                debug(\"timeout listeners: %s\", socket.listeners(\"timeout\").map((f)=>f.name).join(\", \"));\n            }\n            agent.timeoutSocketCount++;\n            const name = agent.getName(options);\n            if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {\n                // free socket timeout, destroy quietly\n                socket.destroy();\n                // Remove it from freeSockets list immediately to prevent new requests\n                // from being sent through this socket.\n                agent.removeSocket(socket, options);\n                debug(\"%s is free, destroy quietly\", socket[SOCKET_NAME]);\n            } else {\n                // if there is no any request socket timeout handler,\n                // agent need to handle socket timeout itself.\n                //\n                // custom request socket timeout handle logic must follow these rules:\n                //  1. Destroy socket first\n                //  2. Must emit socket 'agentRemove' event tell agent remove socket\n                //     from freeSockets list immediately.\n                //     Otherise you may be get 'socket hang up' error when reuse\n                //     free socket and timeout happen in the same time.\n                if (reqTimeoutListenerCount === 0) {\n                    const error = new Error(\"Socket timeout\");\n                    error.code = \"ERR_SOCKET_TIMEOUT\";\n                    error.timeout = timeout;\n                    // must manually call socket.end() or socket.destroy() to end the connection.\n                    // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback\n                    socket.destroy(error);\n                    agent.removeSocket(socket, options);\n                    debug(\"%s destroy with timeout error\", socket[SOCKET_NAME]);\n                }\n            }\n        }\n        socket.on(\"timeout\", onTimeout);\n        function onError(err) {\n            const listenerCount = socket.listeners(\"error\").length;\n            debug(\"%s(requests: %s, finished: %s) error: %s, listenerCount: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);\n            agent.errorSocketCount++;\n            if (listenerCount === 1) {\n                // if socket don't contain error event handler, don't catch it, emit it again\n                debug(\"%s emit uncaught error event\", socket[SOCKET_NAME]);\n                socket.removeListener(\"error\", onError);\n                socket.emit(\"error\", err);\n            }\n        }\n        socket.on(\"error\", onError);\n        function onRemove() {\n            debug(\"%s(requests: %s, finished: %s) agentRemove\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            // We need this function for cases like HTTP 'upgrade'\n            // (defined by WebSockets) where we need to remove a socket from the\n            // pool because it'll be locked up indefinitely\n            socket.removeListener(\"close\", onClose);\n            socket.removeListener(\"error\", onError);\n            socket.removeListener(\"free\", onFree);\n            socket.removeListener(\"timeout\", onTimeout);\n            socket.removeListener(\"agentRemove\", onRemove);\n        }\n        socket.on(\"agentRemove\", onRemove);\n    }\n    agent = Agent;\n    function inspect(obj) {\n        const res = {};\n        for(const key in obj){\n            res[key] = obj[key].length;\n        }\n        return res;\n    }\n    return agent;\n}\nvar https_agent;\nvar hasRequiredHttps_agent;\nfunction requireHttps_agent() {\n    if (hasRequiredHttps_agent) return https_agent;\n    hasRequiredHttps_agent = 1;\n    const OriginalHttpsAgent = (https__WEBPACK_IMPORTED_MODULE_7___default().Agent);\n    const HttpAgent = /*@__PURE__*/ requireAgent();\n    const { INIT_SOCKET, CREATE_HTTPS_CONNECTION } = /*@__PURE__*/ requireConstants();\n    class HttpsAgent extends HttpAgent {\n        constructor(options){\n            super(options);\n            this.defaultPort = 443;\n            this.protocol = \"https:\";\n            this.maxCachedSessions = this.options.maxCachedSessions;\n            /* istanbul ignore next */ if (this.maxCachedSessions === undefined) {\n                this.maxCachedSessions = 100;\n            }\n            this._sessionCache = {\n                map: {},\n                list: []\n            };\n        }\n        createConnection(options, oncreate) {\n            const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);\n            this[INIT_SOCKET](socket, options);\n            return socket;\n        }\n    }\n    // https://github.com/nodejs/node/blob/master/lib/https.js#L89\n    HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;\n    [\n        \"getName\",\n        \"_getSession\",\n        \"_cacheSession\",\n        // https://github.com/nodejs/node/pull/4982\n        \"_evictSession\"\n    ].forEach(function(method) {\n        /* istanbul ignore next */ if (typeof OriginalHttpsAgent.prototype[method] === \"function\") {\n            HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];\n        }\n    });\n    https_agent = HttpsAgent;\n    return https_agent;\n}\nvar hasRequiredAgentkeepalive;\nfunction requireAgentkeepalive() {\n    if (hasRequiredAgentkeepalive) return agentkeepalive.exports;\n    hasRequiredAgentkeepalive = 1;\n    agentkeepalive.exports = /*@__PURE__*/ requireAgent();\n    agentkeepalive.exports.HttpsAgent = /*@__PURE__*/ requireHttps_agent();\n    agentkeepalive.exports.constants = /*@__PURE__*/ requireConstants();\n    return agentkeepalive.exports;\n}\nvar agentkeepaliveExports = /*@__PURE__*/ requireAgentkeepalive();\nvar HttpKeepAliveAgent = /*@__PURE__*/ getDefaultExportFromCjs(agentkeepaliveExports);\nvar fastStableStringify$1;\nvar hasRequiredFastStableStringify;\nfunction requireFastStableStringify() {\n    if (hasRequiredFastStableStringify) return fastStableStringify$1;\n    hasRequiredFastStableStringify = 1;\n    var objToString = Object.prototype.toString;\n    var objKeys = Object.keys || function(obj) {\n        var keys = [];\n        for(var name in obj){\n            keys.push(name);\n        }\n        return keys;\n    };\n    function stringify(val, isArrayProp) {\n        var i, max, str, keys, key, propVal, toStr;\n        if (val === true) {\n            return \"true\";\n        }\n        if (val === false) {\n            return \"false\";\n        }\n        switch(typeof val){\n            case \"object\":\n                if (val === null) {\n                    return null;\n                } else if (val.toJSON && typeof val.toJSON === \"function\") {\n                    return stringify(val.toJSON(), isArrayProp);\n                } else {\n                    toStr = objToString.call(val);\n                    if (toStr === \"[object Array]\") {\n                        str = \"[\";\n                        max = val.length - 1;\n                        for(i = 0; i < max; i++){\n                            str += stringify(val[i], true) + \",\";\n                        }\n                        if (max > -1) {\n                            str += stringify(val[i], true);\n                        }\n                        return str + \"]\";\n                    } else if (toStr === \"[object Object]\") {\n                        // only object is left\n                        keys = objKeys(val).sort();\n                        max = keys.length;\n                        str = \"\";\n                        i = 0;\n                        while(i < max){\n                            key = keys[i];\n                            propVal = stringify(val[key], false);\n                            if (propVal !== undefined) {\n                                if (str) {\n                                    str += \",\";\n                                }\n                                str += JSON.stringify(key) + \":\" + propVal;\n                            }\n                            i++;\n                        }\n                        return \"{\" + str + \"}\";\n                    } else {\n                        return JSON.stringify(val);\n                    }\n                }\n            case \"function\":\n            case \"undefined\":\n                return isArrayProp ? null : undefined;\n            case \"string\":\n                return JSON.stringify(val);\n            default:\n                return isFinite(val) ? val : null;\n        }\n    }\n    fastStableStringify$1 = function(val) {\n        var returnVal = stringify(val, false);\n        if (returnVal !== undefined) {\n            return \"\" + returnVal;\n        }\n    };\n    return fastStableStringify$1;\n}\nvar fastStableStringifyExports = /*@__PURE__*/ requireFastStableStringify();\nvar fastStableStringify = /*@__PURE__*/ getDefaultExportFromCjs(fastStableStringifyExports);\nconst MINIMUM_SLOT_PER_EPOCH = 32;\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n    let trailingZeros = 0;\n    while(n > 1){\n        n /= 2;\n        trailingZeros++;\n    }\n    return trailingZeros;\n}\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n    if (n === 0) return 1;\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    n |= n >> 32;\n    return n + 1;\n}\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */ class EpochSchedule {\n    constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot){\n        /** The maximum number of slots in each epoch */ this.slotsPerEpoch = void 0;\n        /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */ this.leaderScheduleSlotOffset = void 0;\n        /** Indicates whether epochs start short and grow */ this.warmup = void 0;\n        /** The first epoch with `slotsPerEpoch` slots */ this.firstNormalEpoch = void 0;\n        /** The first slot of `firstNormalEpoch` */ this.firstNormalSlot = void 0;\n        this.slotsPerEpoch = slotsPerEpoch;\n        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n        this.warmup = warmup;\n        this.firstNormalEpoch = firstNormalEpoch;\n        this.firstNormalSlot = firstNormalSlot;\n    }\n    getEpoch(slot) {\n        return this.getEpochAndSlotIndex(slot)[0];\n    }\n    getEpochAndSlotIndex(slot) {\n        if (slot < this.firstNormalSlot) {\n            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n            const epochLen = this.getSlotsInEpoch(epoch);\n            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n            return [\n                epoch,\n                slotIndex\n            ];\n        } else {\n            const normalSlotIndex = slot - this.firstNormalSlot;\n            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n            const epoch = this.firstNormalEpoch + normalEpochIndex;\n            const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n            return [\n                epoch,\n                slotIndex\n            ];\n        }\n    }\n    getFirstSlotInEpoch(epoch) {\n        if (epoch <= this.firstNormalEpoch) {\n            return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n        } else {\n            return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n        }\n    }\n    getLastSlotInEpoch(epoch) {\n        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n    }\n    getSlotsInEpoch(epoch) {\n        if (epoch < this.firstNormalEpoch) {\n            return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n        } else {\n            return this.slotsPerEpoch;\n        }\n    }\n}\nvar fetchImpl = typeof globalThis.fetch === \"function\" ? // The Fetch API is supported experimentally in Node 17.5+ and natively in Node 18+.\nglobalThis.fetch : // Otherwise use the polyfill.\nasync function(input, init) {\n    const processedInput = typeof input === \"string\" && input.slice(0, 2) === \"//\" ? \"https:\" + input : input;\n    return await node_fetch__WEBPACK_IMPORTED_MODULE_9__[\"default\"](processedInput, init);\n};\nclass RpcWebSocketClient extends rpc_websockets__WEBPACK_IMPORTED_MODULE_10__.CommonClient {\n    constructor(address, options, generate_request_id){\n        const webSocketFactory = (url)=>{\n            const rpc = (0,rpc_websockets__WEBPACK_IMPORTED_MODULE_10__.WebSocket)(url, {\n                autoconnect: true,\n                max_reconnects: 5,\n                reconnect: true,\n                reconnect_interval: 1000,\n                ...options\n            });\n            if (\"socket\" in rpc) {\n                this.underlyingSocket = rpc.socket;\n            } else {\n                this.underlyingSocket = rpc;\n            }\n            return rpc;\n        };\n        super(webSocketFactory, address, options, generate_request_id);\n        this.underlyingSocket = void 0;\n    }\n    call(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.call(...args);\n        }\n        return Promise.reject(new Error(\"Tried to call a JSON-RPC method `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n    notify(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.notify(...args);\n        }\n        return Promise.reject(new Error(\"Tried to send a JSON-RPC notification `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n}\n/**\n * @internal\n */ /**\n * Decode account data buffer using an AccountType\n * @internal\n */ function decodeData(type, data) {\n    let decoded;\n    try {\n        decoded = type.layout.decode(data);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (decoded.typeIndex !== type.index) {\n        throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);\n    }\n    return decoded;\n}\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\nclass AddressLookupTableAccount {\n    constructor(args){\n        this.key = void 0;\n        this.state = void 0;\n        this.key = args.key;\n        this.state = args.state;\n    }\n    isActive() {\n        const U64_MAX = BigInt(\"0xffffffffffffffff\");\n        return this.state.deactivationSlot === U64_MAX;\n    }\n    static deserialize(accountData) {\n        const meta = decodeData(LookupTableMetaLayout, accountData);\n        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n        assert(serializedAddressesLen >= 0, \"lookup table is invalid\");\n        assert(serializedAddressesLen % 32 === 0, \"lookup table is invalid\");\n        const numSerializedAddresses = serializedAddressesLen / 32;\n        const { addresses } = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), numSerializedAddresses, \"addresses\")\n        ]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));\n        return {\n            deactivationSlot: meta.deactivationSlot,\n            lastExtendedSlot: meta.lastExtendedSlot,\n            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n            authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n            addresses: addresses.map((address)=>new PublicKey(address))\n        };\n    }\n}\nconst LookupTableMetaLayout = {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"typeIndex\"),\n        u64(\"deactivationSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lastExtendedSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"lastExtendedStartIndex\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(),\n        // option\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), -1), \"authority\")\n    ])\n};\nconst URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n    const matches = endpoint.match(URL_RE);\n    if (matches == null) {\n        throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n    }\n    const [_, // eslint-disable-line @typescript-eslint/no-unused-vars\n    hostish, portWithColon, rest] = matches;\n    const protocol = endpoint.startsWith(\"https:\") ? \"wss:\" : \"ws:\";\n    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n    const websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n    // we're directly trying to connect to agave-validator's ws listening port.\n    // When the endpoint omits the port, we're connecting to the protocol\n    // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n    // proxy which manages WebSocket upgrade and backend port redirection.\n    startPort == null ? \"\" : `:${startPort + 1}`;\n    return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\nconst PublicKeyFromString = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(PublicKey), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (value)=>new PublicKey(value));\nconst RawAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"base64\")\n]);\nconst BufferFromRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), RawAccountDataResult, (value)=>buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value[0], \"base64\"));\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */ const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */ /**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */ /**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */ /**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */ /**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */ /**\n * @internal\n */ /**\n * Extra contextual information for RPC responses\n */ /**\n * Options for sending transactions\n */ /**\n * Options for confirming transactions\n */ /**\n * Options for getConfirmedSignaturesForAddress2\n */ /**\n * Options for getSignaturesForAddress\n */ /**\n * RPC Response with extra contextual information\n */ /**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */ /**\n * A strategy for confirming durable nonce transactions.\n */ /**\n * Properties shared by all transaction confirmation strategies\n */ /**\n * This type represents all transaction confirmation strategies\n */ /* @internal */ function assertEndpointUrl(putativeUrl) {\n    if (/^https?:/.test(putativeUrl) === false) {\n        throw new TypeError(\"Endpoint URL must start with `http:` or `https:`.\");\n    }\n    return putativeUrl;\n}\n/** @internal */ function extractCommitmentFromConfig(commitmentOrConfig) {\n    let commitment;\n    let config;\n    if (typeof commitmentOrConfig === \"string\") {\n        commitment = commitmentOrConfig;\n    } else if (commitmentOrConfig) {\n        const { commitment: specifiedCommitment, ...specifiedConfig } = commitmentOrConfig;\n        commitment = specifiedCommitment;\n        config = specifiedConfig;\n    }\n    return {\n        commitment,\n        config\n    };\n}\n/**\n * @internal\n */ function applyDefaultMemcmpEncodingToFilters(filters) {\n    return filters.map((filter)=>\"memcmp\" in filter ? {\n            ...filter,\n            memcmp: {\n                ...filter.memcmp,\n                encoding: filter.memcmp.encoding ?? \"base58\"\n            }\n        } : filter);\n}\n/**\n * @internal\n */ function createRpcResult(result) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            result\n        }),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            error: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n                code: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n                message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n                data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.any)())\n            })\n        })\n    ]);\n}\nconst UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)());\n/**\n * @internal\n */ function jsonRpcResult(schema) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)(createRpcResult(schema), UnknownRpcResult, (value)=>{\n        if (\"error\" in value) {\n            return value;\n        } else {\n            return {\n                ...value,\n                result: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value.result, schema)\n            };\n        }\n    });\n}\n/**\n * @internal\n */ function jsonRpcResultAndContext(value) {\n    return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        value\n    }));\n}\n/**\n * @internal\n */ function notificationResultAndContext(value) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        value\n    });\n}\n/**\n * @internal\n */ function versionedMessageFromResponse(version, response) {\n    if (version === 0) {\n        return new MessageV0({\n            header: response.header,\n            staticAccountKeys: response.accountKeys.map((accountKey)=>new PublicKey(accountKey)),\n            recentBlockhash: response.recentBlockhash,\n            compiledInstructions: response.instructions.map((ix)=>({\n                    programIdIndex: ix.programIdIndex,\n                    accountKeyIndexes: ix.accounts,\n                    data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n                })),\n            addressTableLookups: response.addressTableLookups\n        });\n    } else {\n        return new Message(response);\n    }\n}\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ // Deprecated as of v1.5.5\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ /**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */ /**\n * Configuration object for changing `getAccountInfo` query behavior\n */ /**\n * Configuration object for changing `getBalance` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */ /**\n * Configuration object for changing `getBlockHeight` query behavior\n */ /**\n * Configuration object for changing `getEpochInfo` query behavior\n */ /**\n * Configuration object for changing `getInflationReward` query behavior\n */ /**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */ /**\n * Configuration object for changing `isBlockhashValid` query behavior\n */ /**\n * Configuration object for changing `getSlot` query behavior\n */ /**\n * Configuration object for changing `getSlotLeader` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getLargestAccounts` query behavior\n */ /**\n * Configuration object for changing `getSupply` request behavior\n */ /**\n * Configuration object for changing query behavior\n */ /**\n * Information describing a cluster node\n */ /**\n * Information describing a vote account\n */ /**\n * A collection of cluster vote accounts\n */ /**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */ const GetInflationGovernorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    foundationTerm: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    initial: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    taper: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    terminal: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * The inflation reward for an epoch\n */ /**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */ const GetInflationRewardResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    effectiveSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n}))));\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */ /**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    prioritizationFee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    validator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Information about the current epoch\n */ const GetEpochInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slotIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slotsInEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    absoluteSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    transactionCount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst GetEpochScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slotsPerEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    leaderScheduleSlotOffset: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    warmup: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    firstNormalEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    firstNormalSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */ const GetLeaderScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n/**\n * Transaction error or null\n */ const TransactionErrorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({}),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n]));\n/**\n * Signature status for a transaction\n */ const SignatureStatusResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult\n});\n/**\n * Transaction signature received notification\n */ const SignatureReceivedResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"receivedSignature\");\n/**\n * Version info for a node\n */ const VersionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    \"solana-core\": (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    \"feature-set\": (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst ParsedInstructionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString,\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)()\n});\nconst PartiallyDecodedInstructionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    programId: PublicKeyFromString,\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n});\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({}),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    ])),\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())),\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n    }))))),\n    unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    returnData: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"base64\")\n        ])\n    }))),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n            ParsedInstructionStruct,\n            PartiallyDecodedInstructionStruct\n        ]))\n    }))))\n}));\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */ /**\n * Collection of addresses loaded by a transaction using address table lookups\n */ /**\n * Metadata for a parsed transaction on the ledger\n */ /**\n * Metadata for a confirmed transaction on the ledger\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction message from the RPC API\n */ /**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */ /**\n * A partially decoded transaction instruction\n */ /**\n * A parsed transaction message account\n */ /**\n * A parsed transaction instruction\n */ /**\n * A parsed address table lookup\n */ /**\n * A parsed transaction message\n */ /**\n * A parsed transaction\n */ /**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */ /**\n * A parsed transaction on the ledger with meta\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A block with parsed transactions\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */ /**\n * A Block on the ledger with signatures only\n */ /**\n * recent block production information\n */ /**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */ const BlockProductionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    byIdentity: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    range: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        firstSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        lastSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n}));\n/**\n * A performance sample\n */ function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n    const fetch = customFetch ? customFetch : fetchImpl;\n    let agent;\n    {\n        if (httpAgent == null) {\n            {\n                const agentOptions = {\n                    // One second fewer than the Solana RPC's keepalive timeout.\n                    // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889\n                    freeSocketTimeout: 19000,\n                    keepAlive: true,\n                    maxSockets: 25\n                };\n                if (url.startsWith(\"https:\")) {\n                    agent = new agentkeepaliveExports.HttpsAgent(agentOptions);\n                } else {\n                    agent = new HttpKeepAliveAgent(agentOptions);\n                }\n            }\n        } else {\n            if (httpAgent !== false) {\n                const isHttps = url.startsWith(\"https:\");\n                if (isHttps && !(httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_7__.Agent)) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `https.Agent`. You have, instead, supplied an \" + \"`http.Agent` through `httpAgent`.\");\n                } else if (!isHttps && httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_7__.Agent) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `http.Agent`. You have, instead, supplied an \" + \"`https.Agent` through `httpAgent`.\");\n                }\n                agent = httpAgent;\n            }\n        }\n    }\n    let fetchWithMiddleware;\n    if (fetchMiddleware) {\n        fetchWithMiddleware = async (info, init)=>{\n            const modifiedFetchArgs = await new Promise((resolve, reject)=>{\n                try {\n                    fetchMiddleware(info, init, (modifiedInfo, modifiedInit)=>resolve([\n                            modifiedInfo,\n                            modifiedInit\n                        ]));\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            return await fetch(...modifiedFetchArgs);\n        };\n    }\n    const clientBrowser = new (jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8___default())(async (request, callback)=>{\n        const options = {\n            method: \"POST\",\n            body: request,\n            agent,\n            headers: Object.assign({\n                \"Content-Type\": \"application/json\"\n            }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n        };\n        try {\n            let too_many_requests_retries = 5;\n            let res;\n            let waitTime = 500;\n            for(;;){\n                if (fetchWithMiddleware) {\n                    res = await fetchWithMiddleware(url, options);\n                } else {\n                    res = await fetch(url, options);\n                }\n                if (res.status !== 429 /* Too many requests */ ) {\n                    break;\n                }\n                if (disableRetryOnRateLimit === true) {\n                    break;\n                }\n                too_many_requests_retries -= 1;\n                if (too_many_requests_retries === 0) {\n                    break;\n                }\n                console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);\n                await sleep(waitTime);\n                waitTime *= 2;\n            }\n            const text = await res.text();\n            if (res.ok) {\n                callback(null, text);\n            } else {\n                callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n            }\n        } catch (err) {\n            if (err instanceof Error) callback(err);\n        }\n    }, {});\n    return clientBrowser;\n}\nfunction createRpcRequest(client) {\n    return (method, args)=>{\n        return new Promise((resolve, reject)=>{\n            client.request(method, args, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\nfunction createRpcBatchRequest(client) {\n    return (requests)=>{\n        return new Promise((resolve, reject)=>{\n            // Do nothing if requests is empty\n            if (requests.length === 0) resolve([]);\n            const batch = requests.map((params)=>{\n                return client.request(params.methodName, params.args);\n            });\n            client.request(batch, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */ const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */ const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */ const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */ const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */ const SlotRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)());\n/**\n * Supply\n */ /**\n * Expected JSON RPC response for the \"getSupply\" message\n */ const GetSupplyRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    circulating: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    nonCirculating: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    nonCirculatingAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)\n}));\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */ /**\n * Expected JSON RPC structure for token amounts\n */ const TokenAmountResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\n/**\n * Token address and balance.\n */ /**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */ const GetTokenLargestAccountsResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    address: PublicKeyFromString,\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n})));\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */ const GetTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: BufferFromRawAccountData,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\nconst ParsedAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n    space: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */ const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: ParsedAccountDataResult,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\n/**\n * Pair of an account address and its balance\n */ /**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */ const GetLargestAccountsRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    address: PublicKeyFromString\n})));\n/**\n * @internal\n */ const AccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    data: BufferFromRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * @internal\n */ const KeyedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\nconst ParsedOrRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer),\n    ParsedAccountDataResult\n]), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    RawAccountDataResult,\n    ParsedAccountDataResult\n]), (value)=>{\n    if (Array.isArray(value)) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, BufferFromRawAccountData);\n    } else {\n        return value;\n    }\n});\n/**\n * @internal\n */ const ParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    data: ParsedOrRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\nconst KeyedParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: ParsedAccountInfoResult\n});\n/**\n * @internal\n */ const StakeActivationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    state: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"active\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"inactive\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"activating\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"deactivating\")\n    ]),\n    active: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    inactive: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */ const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n})));\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */ const GetSignaturesForAddressRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n})));\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */ const AccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext(AccountInfoResult)\n});\n/**\n * @internal\n */ const ProgramAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */ const ProgramAccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n/**\n * @internal\n */ const SlotInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    root: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */ const SlotNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: SlotInfoResult\n});\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */ /**\n * @internal\n */ const SlotUpdateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"firstShredReceived\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"completed\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"optimisticConfirmation\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"root\")\n        ]),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"createdBank\"),\n        parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"frozen\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        stats: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            numTransactionEntries: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numSuccessfulTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numFailedTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            maxTransactionsPerEntry: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        })\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"dead\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        err: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    })\n]);\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */ const SlotUpdateNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: SlotUpdateResult\n});\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */ const SignatureNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        SignatureStatusResult,\n        SignatureReceivedResult\n    ]))\n});\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */ const RootNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\nconst ContactInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    gossip: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    tpu: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    rpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\nconst VoteAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    votePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    nodePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    activatedStake: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    epochVoteAccount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    epochCredits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    ])),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    lastVote: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rootSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */ const GetVoteAccounts = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    current: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(VoteAccountInfoResult),\n    delinquent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(VoteAccountInfoResult)\n}));\nconst ConfirmationStatus = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"processed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"confirmed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"finalized\")\n]);\nconst SignatureStatusResponse = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    confirmations: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    err: TransactionErrorResult,\n    confirmationStatus: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(ConfirmationStatus)\n});\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */ const GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(SignatureStatusResponse)));\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */ const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)());\nconst AddressTableLookupStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountKey: PublicKeyFromString,\n    writableIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    readonlyIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst ConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        header: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            numRequiredSignatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numReadonlySignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numReadonlyUnsignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        })),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AddressTableLookupStruct))\n    })\n});\nconst AnnotatedAccountKey = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    signer: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    source: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"transaction\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"lookupTable\")\n    ]))\n});\nconst ConfirmedTransactionAccountsModeResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AnnotatedAccountKey),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\nconst ParsedInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString\n});\nconst RawInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString\n});\nconst InstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    RawInstructionResult,\n    ParsedInstructionResult\n]);\nconst UnknownInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n        program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    })\n]);\nconst ParsedOrRawInstruction = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)(InstructionResult, UnknownInstructionResult, (value)=>{\n    if (\"accounts\" in value) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, RawInstructionResult);\n    } else {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, ParsedInstructionResult);\n    }\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AnnotatedAccountKey),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ParsedOrRawInstruction),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AddressTableLookupStruct)))\n    })\n});\nconst TokenBalanceResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    mint: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    uiTokenAmount: TokenAmountResult\n});\nconst LoadedAddressesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    readonly: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)\n});\n/**\n * @internal\n */ const ConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }))\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    costUnits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ParsedOrRawInstruction)\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    costUnits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst TransactionVersionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(0),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"legacy\")\n]);\n/** @internal */ const RewardsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    rewardType: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n});\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */ const GetNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */ const GetAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */ const GetParsedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ParsedConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */ const GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */ const GetParsedNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */ const GetConfirmedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockSignaturesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */ const GetTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    transaction: ConfirmedTransactionResult,\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */ const GetParsedTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transaction: ParsedConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */ const GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    lastValidBlockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */ const IsBlockhashValidRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)());\nconst PerfSampleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    numTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    numSlots: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    samplePeriodSecs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */ const GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PerfSampleResult));\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */ const GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */ const RequestAirdropRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)());\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */ const SendTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)());\n/**\n * Information about the latest slot being processed by a node\n */ /**\n * Parsed account data\n */ /**\n * Stake Activation data\n */ /**\n * Data slice argument for getProgramAccounts\n */ /**\n * Memory comparison filter for getProgramAccounts\n */ /**\n * Data size comparison filter for getProgramAccounts\n */ /**\n * A filter object for getProgramAccounts\n */ /**\n * Configuration object for getProgramAccounts requests\n */ /**\n * Configuration object for getParsedProgramAccounts\n */ /**\n * Configuration object for getMultipleAccounts\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getNonce`\n */ /**\n * Configuration object for `getNonceAndContext`\n */ /**\n * Information describing an account\n */ /**\n * Account information identified by pubkey\n */ /**\n * Callback function for account change notifications\n */ /**\n * Callback function for program account change notifications\n */ /**\n * Callback function for slot change notifications\n */ /**\n * Callback function for slot update notifications\n */ /**\n * Callback function for signature status notifications\n */ /**\n * Signature status notification with transaction result\n */ /**\n * Signature received notification\n */ /**\n * Callback function for signature notifications\n */ /**\n * Signature subscription options\n */ /**\n * Callback function for root change notifications\n */ /**\n * @internal\n */ const LogsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n});\n/**\n * Logs result.\n */ /**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */ const LogsNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    result: notificationResultAndContext(LogsResult),\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Filter for log subscriptions.\n */ /**\n * Callback function for log notifications.\n */ /**\n * Signature result\n */ /**\n * Transaction error\n */ /**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */ /**\n * Signature status\n */ /**\n * A confirmed signature with its status\n */ /**\n * An object defining headers to be passed to the RPC server\n */ /**\n * The type of the JavaScript `fetch()` API\n */ /**\n * A callback used to augment the outgoing HTTP request\n */ /**\n * Configuration for instantiating a Connection\n */ /** @internal */ const COMMON_HTTP_HEADERS = {\n    \"solana-client\": `js/${\"1.0.0-maintenance\"}`\n};\n/**\n * A connection to a fullnode JSON RPC endpoint\n */ class Connection {\n    /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */ constructor(endpoint, _commitmentOrConfig){\n        /** @internal */ this._commitment = void 0;\n        /** @internal */ this._confirmTransactionInitialTimeout = void 0;\n        /** @internal */ this._rpcEndpoint = void 0;\n        /** @internal */ this._rpcWsEndpoint = void 0;\n        /** @internal */ this._rpcClient = void 0;\n        /** @internal */ this._rpcRequest = void 0;\n        /** @internal */ this._rpcBatchRequest = void 0;\n        /** @internal */ this._rpcWebSocket = void 0;\n        /** @internal */ this._rpcWebSocketConnected = false;\n        /** @internal */ this._rpcWebSocketHeartbeat = null;\n        /** @internal */ this._rpcWebSocketIdleTimeout = null;\n        /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */ this._rpcWebSocketGeneration = 0;\n        /** @internal */ this._disableBlockhashCaching = false;\n        /** @internal */ this._pollingBlockhash = false;\n        /** @internal */ this._blockhashInfo = {\n            latestBlockhash: null,\n            lastFetch: 0,\n            transactionSignatures: [],\n            simulatedSignatures: []\n        };\n        /** @internal */ this._nextClientSubscriptionId = 0;\n        /** @internal */ this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionHashByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionStateChangeCallbacksByHash = {};\n        /** @internal */ this._subscriptionCallbacksByServerSubscriptionId = {};\n        /** @internal */ this._subscriptionsByHash = {};\n        /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */ /** @internal */ this._subscriptionsAutoDisposedByRpc = new Set();\n        /*\n     * Returns the current block height of the node\n     */ this.getBlockHeight = (()=>{\n            const requestPromises = {};\n            return async (commitmentOrConfig)=>{\n                const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n                const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n                const requestHash = fastStableStringify(args);\n                requestPromises[requestHash] = requestPromises[requestHash] ?? (async ()=>{\n                    try {\n                        const unsafeRes = await this._rpcRequest(\"getBlockHeight\", args);\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n                        if (\"error\" in res) {\n                            throw new SolanaJSONRPCError(res.error, \"failed to get block height information\");\n                        }\n                        return res.result;\n                    } finally{\n                        delete requestPromises[requestHash];\n                    }\n                })();\n                return await requestPromises[requestHash];\n            };\n        })();\n        let wsEndpoint;\n        let httpHeaders;\n        let fetch;\n        let fetchMiddleware;\n        let disableRetryOnRateLimit;\n        let httpAgent;\n        if (_commitmentOrConfig && typeof _commitmentOrConfig === \"string\") {\n            this._commitment = _commitmentOrConfig;\n        } else if (_commitmentOrConfig) {\n            this._commitment = _commitmentOrConfig.commitment;\n            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n            wsEndpoint = _commitmentOrConfig.wsEndpoint;\n            httpHeaders = _commitmentOrConfig.httpHeaders;\n            fetch = _commitmentOrConfig.fetch;\n            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n            httpAgent = _commitmentOrConfig.httpAgent;\n        }\n        this._rpcEndpoint = assertEndpointUrl(endpoint);\n        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n        this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n        this._rpcRequest = createRpcRequest(this._rpcClient);\n        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n            autoconnect: false,\n            max_reconnects: Infinity\n        });\n        this._rpcWebSocket.on(\"open\", this._wsOnOpen.bind(this));\n        this._rpcWebSocket.on(\"error\", this._wsOnError.bind(this));\n        this._rpcWebSocket.on(\"close\", this._wsOnClose.bind(this));\n        this._rpcWebSocket.on(\"accountNotification\", this._wsOnAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"programNotification\", this._wsOnProgramAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"slotNotification\", this._wsOnSlotNotification.bind(this));\n        this._rpcWebSocket.on(\"slotsUpdatesNotification\", this._wsOnSlotUpdatesNotification.bind(this));\n        this._rpcWebSocket.on(\"signatureNotification\", this._wsOnSignatureNotification.bind(this));\n        this._rpcWebSocket.on(\"rootNotification\", this._wsOnRootNotification.bind(this));\n        this._rpcWebSocket.on(\"logsNotification\", this._wsOnLogsNotification.bind(this));\n    }\n    /**\n   * The default commitment used for requests\n   */ get commitment() {\n        return this._commitment;\n    }\n    /**\n   * The RPC endpoint\n   */ get rpcEndpoint() {\n        return this._rpcEndpoint;\n    }\n    /**\n   * Fetch the balance for the specified public key, return with context\n   */ async getBalanceAndContext(publicKey, commitmentOrConfig) {\n        /** @internal */ const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the balance for the specified public key\n   */ async getBalance(publicKey, commitmentOrConfig) {\n        return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get balance of account \" + publicKey.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Fetch the estimated production time of a block\n   */ async getBlockTime(slot) {\n        const unsafeRes = await this._rpcRequest(\"getBlockTime\", [\n            slot\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */ async getMinimumLedgerSlot() {\n        const unsafeRes = await this._rpcRequest(\"minimumLedgerSlot\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get minimum ledger slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */ async getFirstAvailableBlock() {\n        const unsafeRes = await this._rpcRequest(\"getFirstAvailableBlock\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SlotRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get first available block\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch information about the current supply\n   */ async getSupply(config) {\n        let configArg = {};\n        if (typeof config === \"string\") {\n            configArg = {\n                commitment: config\n            };\n        } else if (config) {\n            configArg = {\n                ...config,\n                commitment: config && config.commitment || this.commitment\n            };\n        } else {\n            configArg = {\n                commitment: this.commitment\n            };\n        }\n        const unsafeRes = await this._rpcRequest(\"getSupply\", [\n            configArg\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSupplyRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current supply of a token mint\n   */ async getTokenSupply(tokenMintAddress, commitment) {\n        const args = this._buildArgs([\n            tokenMintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenSupply\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current balance of a token account\n   */ async getTokenAccountBalance(tokenAddress, commitment) {\n        const args = this._buildArgs([\n            tokenAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token account balance\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */ async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */ async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest accounts with their current balances\n   */ async getLargestAccounts(config) {\n        const arg = {\n            ...config,\n            commitment: config && config.commitment || this.commitment\n        };\n        const args = arg.filter || arg.commitment ? [\n            arg\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLargestAccountsRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */ async getTokenLargestAccounts(mintAddress, commitment) {\n        const args = this._buildArgs([\n            mintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTokenLargestAccountsResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key, return with context\n   */ async getAccountInfoAndContext(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(AccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed account info for the specified public key\n   */ async getParsedAccountInfo(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key\n   */ async getAccountInfo(publicKey, commitmentOrConfig) {\n        try {\n            const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get info about account \" + publicKey.toBase58() + \": \" + e);\n        }\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleParsedAccounts(publicKeys, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedAccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(AccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */ async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {\n        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n        return res.value;\n    }\n    /**\n   * Returns epoch activation information for a stake account that has been delegated\n   *\n   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.\n   */ async getStakeActivation(publicKey, commitmentOrConfig, epoch) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getStakeActivation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(StakeActivationResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const { encoding, ...configWithoutEncoding } = config || {};\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, encoding || \"base64\", {\n            ...configWithoutEncoding,\n            ...configWithoutEncoding.filters ? {\n                filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)\n            } : null\n        });\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const baseSchema = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(KeyedAccountInfoResult);\n        const res = configWithoutEncoding.withContext === true ? (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(baseSchema)) : (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(baseSchema));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */ async getParsedProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(KeyedParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async confirmTransaction(strategy, commitment) {\n        let rawSignature;\n        if (typeof strategy == \"string\") {\n            rawSignature = strategy;\n        } else {\n            const config = strategy;\n            if (config.abortSignal?.aborted) {\n                return Promise.reject(config.abortSignal.reason);\n            }\n            rawSignature = config.signature;\n        }\n        let decodedSignature;\n        try {\n            decodedSignature = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(rawSignature);\n        } catch (err) {\n            throw new Error(\"signature must be base58 encoded: \" + rawSignature);\n        }\n        assert(decodedSignature.length === 64, \"signature has invalid length\");\n        if (typeof strategy === \"string\") {\n            return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n                commitment: commitment || this.commitment,\n                signature: rawSignature\n            });\n        } else if (\"lastValidBlockHeight\" in strategy) {\n            return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        } else {\n            return await this.confirmTransactionUsingDurableNonceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        }\n    }\n    getCancellationPromise(signal) {\n        return new Promise((_, reject)=>{\n            if (signal == null) {\n                return;\n            }\n            if (signal.aborted) {\n                reject(signal.reason);\n            } else {\n                signal.addEventListener(\"abort\", ()=>{\n                    reject(signal.reason);\n                });\n            }\n        });\n    }\n    getTransactionConfirmationPromise({ commitment, signature }) {\n        let signatureSubscriptionId;\n        let disposeSignatureSubscriptionStateChangeObserver;\n        let done = false;\n        const confirmationPromise = new Promise((resolve, reject)=>{\n            try {\n                signatureSubscriptionId = this.onSignature(signature, (result, context)=>{\n                    signatureSubscriptionId = undefined;\n                    const response = {\n                        context,\n                        value: result\n                    };\n                    resolve({\n                        __type: TransactionStatus.PROCESSED,\n                        response\n                    });\n                }, commitment);\n                const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup)=>{\n                    if (signatureSubscriptionId == null) {\n                        resolveSubscriptionSetup();\n                    } else {\n                        disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState)=>{\n                            if (nextState === \"subscribed\") {\n                                resolveSubscriptionSetup();\n                            }\n                        });\n                    }\n                });\n                (async ()=>{\n                    await subscriptionSetupPromise;\n                    if (done) return;\n                    const response = await this.getSignatureStatus(signature);\n                    if (done) return;\n                    if (response == null) {\n                        return;\n                    }\n                    const { context, value } = response;\n                    if (value == null) {\n                        return;\n                    }\n                    if (value?.err) {\n                        reject(value.err);\n                    } else {\n                        switch(commitment){\n                            case \"confirmed\":\n                            case \"single\":\n                            case \"singleGossip\":\n                                {\n                                    if (value.confirmationStatus === \"processed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            case \"finalized\":\n                            case \"max\":\n                            case \"root\":\n                                {\n                                    if (value.confirmationStatus === \"processed\" || value.confirmationStatus === \"confirmed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            // exhaust enums to ensure full coverage\n                            case \"processed\":\n                            case \"recent\":\n                        }\n                        done = true;\n                        resolve({\n                            __type: TransactionStatus.PROCESSED,\n                            response: {\n                                context,\n                                value\n                            }\n                        });\n                    }\n                })();\n            } catch (err) {\n                reject(err);\n            }\n        });\n        const abortConfirmation = ()=>{\n            if (disposeSignatureSubscriptionStateChangeObserver) {\n                disposeSignatureSubscriptionStateChangeObserver();\n                disposeSignatureSubscriptionStateChangeObserver = undefined;\n            }\n            if (signatureSubscriptionId != null) {\n                this.removeSignatureListener(signatureSubscriptionId);\n                signatureSubscriptionId = undefined;\n            }\n        };\n        return {\n            abortConfirmation,\n            confirmationPromise\n        };\n    }\n    async confirmTransactionUsingBlockHeightExceedanceStrategy({ commitment, strategy: { abortSignal, lastValidBlockHeight, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            const checkBlockHeight = async ()=>{\n                try {\n                    const blockHeight = await this.getBlockHeight(commitment);\n                    return blockHeight;\n                } catch (_e) {\n                    return -1;\n                }\n            };\n            (async ()=>{\n                let currentBlockHeight = await checkBlockHeight();\n                if (done) return;\n                while(currentBlockHeight <= lastValidBlockHeight){\n                    await sleep(1000);\n                    if (done) return;\n                    currentBlockHeight = await checkBlockHeight();\n                    if (done) return;\n                }\n                resolve({\n                    __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n                });\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredBlockheightExceededError(signature);\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingDurableNonceStrategy({ commitment, strategy: { abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            let currentNonceValue = nonceValue;\n            let lastCheckedSlot = null;\n            const getCurrentNonceValue = async ()=>{\n                try {\n                    const { context, value: nonceAccount } = await this.getNonceAndContext(nonceAccountPubkey, {\n                        commitment,\n                        minContextSlot\n                    });\n                    lastCheckedSlot = context.slot;\n                    return nonceAccount?.nonce;\n                } catch (e) {\n                    // If for whatever reason we can't reach/read the nonce\n                    // account, just keep using the last-known value.\n                    return currentNonceValue;\n                }\n            };\n            (async ()=>{\n                currentNonceValue = await getCurrentNonceValue();\n                if (done) return;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    if (nonceValue !== currentNonceValue) {\n                        resolve({\n                            __type: TransactionStatus.NONCE_INVALID,\n                            slotInWhichNonceDidAdvance: lastCheckedSlot\n                        });\n                        return;\n                    }\n                    await sleep(2000);\n                    if (done) return;\n                    currentNonceValue = await getCurrentNonceValue();\n                    if (done) return;\n                }\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                // Double check that the transaction is indeed unconfirmed.\n                let signatureStatus;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    const status = await this.getSignatureStatus(signature);\n                    if (status == null) {\n                        break;\n                    }\n                    if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {\n                        await sleep(400);\n                        continue;\n                    }\n                    signatureStatus = status;\n                    break;\n                }\n                if (signatureStatus?.value) {\n                    const commitmentForStatus = commitment || \"finalized\";\n                    const { confirmationStatus } = signatureStatus.value;\n                    switch(commitmentForStatus){\n                        case \"processed\":\n                        case \"recent\":\n                            if (confirmationStatus !== \"processed\" && confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"confirmed\":\n                        case \"single\":\n                        case \"singleGossip\":\n                            if (confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"finalized\":\n                        case \"max\":\n                        case \"root\":\n                            if (confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        default:\n                            // Exhaustive switch.\n                            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                            ((_)=>{})(commitmentForStatus);\n                    }\n                    result = {\n                        context: signatureStatus.context,\n                        value: {\n                            err: signatureStatus.value.err\n                        }\n                    };\n                } else {\n                    throw new TransactionExpiredNonceInvalidError(signature);\n                }\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingLegacyTimeoutStrategy({ commitment, signature }) {\n        let timeoutId;\n        const expiryPromise = new Promise((resolve)=>{\n            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n            switch(commitment){\n                case \"processed\":\n                case \"recent\":\n                case \"single\":\n                case \"confirmed\":\n                case \"singleGossip\":\n                    {\n                        timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n                        break;\n                    }\n            }\n            timeoutId = setTimeout(()=>resolve({\n                    __type: TransactionStatus.TIMED_OUT,\n                    timeoutMs\n                }), timeoutMs);\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        let result;\n        try {\n            const outcome = await Promise.race([\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n            }\n        } finally{\n            clearTimeout(timeoutId);\n            abortConfirmation();\n        }\n        return result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getClusterNodes() {\n        const unsafeRes = await this._rpcRequest(\"getClusterNodes\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ContactInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get cluster nodes\");\n        }\n        return res.result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getVoteAccounts(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getVoteAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetVoteAccounts);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get vote accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot that the node is processing\n   */ async getSlot(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlot\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot leader of the cluster\n   */ async getSlotLeader(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlotLeader\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leader\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */ async getSlotLeaders(startSlot, limit) {\n        const args = [\n            startSlot,\n            limit\n        ];\n        const unsafeRes = await this._rpcRequest(\"getSlotLeaders\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leaders\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current status of a signature\n   */ async getSignatureStatus(signature, config) {\n        const { context, value: values } = await this.getSignatureStatuses([\n            signature\n        ], config);\n        assert(values.length === 1);\n        const value = values[0];\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the current statuses of a batch of signatures\n   */ async getSignatureStatuses(signatures, config) {\n        const params = [\n            signatures\n        ];\n        if (config) {\n            params.push(config);\n        }\n        const unsafeRes = await this._rpcRequest(\"getSignatureStatuses\", params);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSignatureStatusesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signature status\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current transaction count of the cluster\n   */ async getTransactionCount(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransactionCount\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction count\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.\n   */ async getTotalSupply(commitment) {\n        const result = await this.getSupply({\n            commitment,\n            excludeNonCirculatingAccountsList: true\n        });\n        return result.value.total;\n    }\n    /**\n   * Fetch the cluster InflationGovernor parameters\n   */ async getInflationGovernor(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getInflationGovernor\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationGovernorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */ async getInflationReward(addresses, epoch, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            addresses.map((pubkey)=>pubkey.toBase58())\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getInflationReward\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationRewardResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation reward\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the specific inflation values for the current epoch\n   */ async getInflationRate() {\n        const unsafeRes = await this._rpcRequest(\"getInflationRate\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationRateRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation rate\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Info parameters\n   */ async getEpochInfo(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getEpochInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetEpochInfoRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch info\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Schedule parameters\n   */ async getEpochSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getEpochSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetEpochScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch schedule\");\n        }\n        const epochSchedule = res.result;\n        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);\n    }\n    /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */ async getLeaderSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getLeaderSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLeaderScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get leader schedule\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */ async getMinimumBalanceForRentExemption(dataLength, commitment) {\n        const args = this._buildArgs([\n            dataLength\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getMinimumBalanceForRentExemption\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n        if (\"error\" in res) {\n            console.warn(\"Unable to fetch minimum balance for rent exemption\");\n            return 0;\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhashAndContext(commitment) {\n        const { context, value: { blockhash } } = await this.getLatestBlockhashAndContext(commitment);\n        const feeCalculator = {\n            get lamportsPerSignature () {\n                throw new Error(\"The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is \" + \"no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee \" + \"for a given message.\");\n            },\n            toJSON () {\n                return {};\n            }\n        };\n        return {\n            context,\n            value: {\n                blockhash,\n                feeCalculator\n            }\n        };\n    }\n    /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */ async getRecentPerformanceSamples(limit) {\n        const unsafeRes = await this._rpcRequest(\"getRecentPerformanceSamples\", limit ? [\n            limit\n        ] : []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent performance samples\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.\n   */ async getFeeCalculatorForBlockhash(blockhash, commitment) {\n        const args = this._buildArgs([\n            blockhash\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeCalculatorForBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetFeeCalculatorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee calculator\");\n        }\n        const { context, value } = res.result;\n        return {\n            context,\n            value: value !== null ? value.feeCalculator : null\n        };\n    }\n    /**\n   * Fetch the fee for a message from the cluster, return with context\n   */ async getFeeForMessage(message, commitment) {\n        const wireMessage = toBuffer(message.serialize()).toString(\"base64\");\n        const args = this._buildArgs([\n            wireMessage\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeForMessage\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee for message\");\n        }\n        if (res.result === null) {\n            throw new Error(\"invalid blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */ async getRecentPrioritizationFees(config) {\n        const accounts = config?.lockedWritableAccounts?.map((key)=>key.toBase58());\n        const args = accounts?.length ? [\n            accounts\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getRecentPrioritizationFees\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent prioritization fees\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhash(commitment) {\n        try {\n            const res = await this.getRecentBlockhashAndContext(commitment);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhash(commitmentOrConfig) {\n        try {\n            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhashAndContext(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getLatestBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLatestBlockhashRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get latest blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns whether a blockhash is still valid or not\n   */ async isBlockhashValid(blockhash, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgs([\n            blockhash\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"isBlockhashValid\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, IsBlockhashValidRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to determine if the blockhash `\" + blockhash + \"`is valid\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the node version\n   */ async getVersion() {\n        const unsafeRes = await this._rpcRequest(\"getVersion\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(VersionResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get version\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the genesis hash\n   */ async getGenesisHash() {\n        const unsafeRes = await this._rpcRequest(\"getGenesisHash\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get genesis hash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        const { result } = res;\n                        return result ? {\n                            ...result,\n                            transactions: result.transactions.map(({ transaction, meta, version })=>({\n                                    meta,\n                                    transaction: {\n                                        ...transaction,\n                                        message: versionedMessageFromResponse(version, transaction.message)\n                                    },\n                                    version\n                                }))\n                        } : null;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get confirmed block\");\n        }\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getParsedBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get block\");\n        }\n    }\n    /*\n   * Returns recent block production information from the current or previous epoch\n   */ async getBlockProduction(configOrCommitment) {\n        let extra;\n        let commitment;\n        if (typeof configOrCommitment === \"string\") {\n            commitment = configOrCommitment;\n        } else if (configOrCommitment) {\n            const { commitment: c, ...rest } = configOrCommitment;\n            commitment = c;\n            extra = rest;\n        }\n        const args = this._buildArgs([], commitment, \"base64\", extra);\n        const unsafeRes = await this._rpcRequest(\"getBlockProduction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, BlockProductionResponseStruct);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block production information\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransaction(signature, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        return {\n            ...result,\n            transaction: {\n                ...result.transaction,\n                message: versionedMessageFromResponse(result.version, result.transaction.message)\n            }\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */ async getParsedTransaction(signature, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */ async getParsedTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\", config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, undefined /* encoding */ , config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            const result = res.result;\n            if (!result) return result;\n            return {\n                ...result,\n                transaction: {\n                    ...result.transaction,\n                    message: versionedMessageFromResponse(result.version, result.transaction.message)\n                }\n            };\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.\n   */ async getConfirmedBlock(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetConfirmedBlockRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        const block = {\n            ...result,\n            transactions: result.transactions.map(({ transaction, meta })=>{\n                const message = new Message(transaction.message);\n                return {\n                    meta,\n                    transaction: {\n                        ...transaction,\n                        message\n                    }\n                };\n            })\n        };\n        return {\n            ...block,\n            transactions: block.transactions.map(({ transaction, meta })=>{\n                return {\n                    meta,\n                    transaction: Transaction.populate(transaction.message, transaction.signatures)\n                };\n            })\n        };\n    }\n    /**\n   * Fetch confirmed blocks between two slots\n   */ async getBlocks(startSlot, endSlot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [\n            startSlot,\n            endSlot\n        ] : [\n            startSlot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlocks\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get blocks\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */ async getBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.\n   */ async getConfirmedBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.\n   */ async getConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        const message = new Message(result.transaction.message);\n        const signatures = result.transaction.signatures;\n        return {\n            ...result,\n            transaction: Transaction.populate(message, signatures)\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.\n   */ async getParsedConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.\n   */ async getParsedConfirmedTransactions(signatures, commitment) {\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\");\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */ async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {\n        let options = {};\n        let firstAvailableBlock = await this.getFirstAvailableBlock();\n        while(!(\"until\" in options)){\n            startSlot--;\n            if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(startSlot, \"finalized\");\n                if (block.signatures.length > 0) {\n                    options.until = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        let highestConfirmedRoot = await this.getSlot(\"finalized\");\n        while(!(\"before\" in options)){\n            endSlot++;\n            if (endSlot > highestConfirmedRoot) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(endSlot);\n                if (block.signatures.length > 0) {\n                    options.before = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);\n        return confirmedSignatureInfo.map((info)=>info.signature);\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.\n   */ async getConfirmedSignaturesForAddress2(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedSignaturesForAddress2\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed signatures for address\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */ async getSignaturesForAddress(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getSignaturesForAddress\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSignaturesForAddressRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signatures for address\");\n        }\n        return res.result;\n    }\n    async getAddressLookupTable(accountKey, config) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(accountKey, config);\n        let value = null;\n        if (accountInfo !== null) {\n            value = new AddressLookupTableAccount({\n                key: accountKey,\n                state: AddressLookupTableAccount.deserialize(accountInfo.data)\n            });\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */ async getNonceAndContext(nonceAccount, commitmentOrConfig) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n        let value = null;\n        if (accountInfo !== null) {\n            value = NonceAccount.fromAccountData(accountInfo.data);\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster\n   */ async getNonce(nonceAccount, commitmentOrConfig) {\n        return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get nonce for account \" + nonceAccount.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */ async requestAirdrop(to, lamports) {\n        const unsafeRes = await this._rpcRequest(\"requestAirdrop\", [\n            to.toBase58(),\n            lamports\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, RequestAirdropRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ async _blockhashWithExpiryBlockHeight(disableCache) {\n        if (!disableCache) {\n            // Wait for polling to finish\n            while(this._pollingBlockhash){\n                await sleep(100);\n            }\n            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n            if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n                return this._blockhashInfo.latestBlockhash;\n            }\n        }\n        return await this._pollNewBlockhash();\n    }\n    /**\n   * @internal\n   */ async _pollNewBlockhash() {\n        this._pollingBlockhash = true;\n        try {\n            const startTime = Date.now();\n            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n            for(let i = 0; i < 50; i++){\n                const latestBlockhash = await this.getLatestBlockhash(\"finalized\");\n                if (cachedBlockhash !== latestBlockhash.blockhash) {\n                    this._blockhashInfo = {\n                        latestBlockhash,\n                        lastFetch: Date.now(),\n                        transactionSignatures: [],\n                        simulatedSignatures: []\n                    };\n                    return latestBlockhash;\n                }\n                // Sleep for approximately half a slot\n                await sleep(MS_PER_SLOT / 2);\n            }\n            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);\n        } finally{\n            this._pollingBlockhash = false;\n        }\n    }\n    /**\n   * get the stake minimum delegation\n   */ async getStakeMinimumDelegation(config) {\n        const { commitment, config: configArg } = extractCommitmentFromConfig(config);\n        const args = this._buildArgs([], commitment, \"base64\", configArg);\n        const unsafeRes = await this._rpcRequest(\"getStakeMinimumDelegation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);\n        }\n        return res.result;\n    }\n    /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */ /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {\n        if (\"message\" in transactionOrMessage) {\n            const versionedTx = transactionOrMessage;\n            const wireTransaction = versionedTx.serialize();\n            const encodedTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(wireTransaction).toString(\"base64\");\n            if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const config = configOrSigners || {};\n            config.encoding = \"base64\";\n            if (!(\"commitment\" in config)) {\n                config.commitment = this.commitment;\n            }\n            if (configOrSigners && typeof configOrSigners === \"object\" && \"innerInstructions\" in configOrSigners) {\n                config.innerInstructions = configOrSigners.innerInstructions;\n            }\n            const args = [\n                encodedTransaction,\n                config\n            ];\n            const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n            if (\"error\" in res) {\n                throw new Error(\"failed to simulate transaction: \" + res.error.message);\n            }\n            return res.result;\n        }\n        let transaction;\n        if (transactionOrMessage instanceof Transaction) {\n            let originalTx = transactionOrMessage;\n            transaction = new Transaction();\n            transaction.feePayer = originalTx.feePayer;\n            transaction.instructions = transactionOrMessage.instructions;\n            transaction.nonceInfo = originalTx.nonceInfo;\n            transaction.signatures = originalTx.signatures;\n        } else {\n            transaction = Transaction.populate(transactionOrMessage);\n            // HACK: this function relies on mutating the populated transaction\n            transaction._message = transaction._json = undefined;\n        }\n        if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = configOrSigners;\n        if (transaction.nonceInfo && signers) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                if (!signers) break;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.simulatedSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const message = transaction._compile();\n        const signData = message.serialize();\n        const wireTransaction = transaction._serialize(signData);\n        const encodedTransaction = wireTransaction.toString(\"base64\");\n        const config = {\n            encoding: \"base64\",\n            commitment: this.commitment\n        };\n        if (includeAccounts) {\n            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key)=>key.toBase58());\n            config[\"accounts\"] = {\n                encoding: \"base64\",\n                addresses\n            };\n        }\n        if (signers) {\n            config.sigVerify = true;\n        }\n        if (configOrSigners && typeof configOrSigners === \"object\" && \"innerInstructions\" in configOrSigners) {\n            config.innerInstructions = configOrSigners.innerInstructions;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n        if (\"error\" in res) {\n            let logs;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n                if (logs && Array.isArray(logs)) {\n                    const traceIndent = \"\\n    \";\n                    const logTrace = traceIndent + logs.join(traceIndent);\n                    console.error(res.error.message, logTrace);\n                }\n            }\n            throw new SendTransactionError({\n                action: \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */ /**\n   * Send a signed transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Sign and send a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async sendTransaction(transaction, signersOrOptions, options) {\n        if (\"version\" in transaction) {\n            if (signersOrOptions && Array.isArray(signersOrOptions)) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const wireTransaction = transaction.serialize();\n            return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n        }\n        if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = signersOrOptions;\n        if (transaction.nonceInfo) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.transactionSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const wireTransaction = transaction.serialize();\n        return await this.sendRawTransaction(wireTransaction, options);\n    }\n    /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */ async sendRawTransaction(rawTransaction, options) {\n        const encodedTransaction = toBuffer(rawTransaction).toString(\"base64\");\n        const result = await this.sendEncodedTransaction(encodedTransaction, options);\n        return result;\n    }\n    /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */ async sendEncodedTransaction(encodedTransaction, options) {\n        const config = {\n            encoding: \"base64\"\n        };\n        const skipPreflight = options && options.skipPreflight;\n        const preflightCommitment = skipPreflight === true ? \"processed\" // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n         : options && options.preflightCommitment || this.commitment;\n        if (options && options.maxRetries != null) {\n            config.maxRetries = options.maxRetries;\n        }\n        if (options && options.minContextSlot != null) {\n            config.minContextSlot = options.minContextSlot;\n        }\n        if (skipPreflight) {\n            config.skipPreflight = skipPreflight;\n        }\n        if (preflightCommitment) {\n            config.preflightCommitment = preflightCommitment;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"sendTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SendTransactionRpcResult);\n        if (\"error\" in res) {\n            let logs = undefined;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n            }\n            throw new SendTransactionError({\n                action: skipPreflight ? \"send\" : \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ _wsOnOpen() {\n        this._rpcWebSocketConnected = true;\n        this._rpcWebSocketHeartbeat = setInterval(()=>{\n            // Ping server every 5s to prevent idle timeouts\n            (async ()=>{\n                try {\n                    await this._rpcWebSocket.notify(\"ping\");\n                // eslint-disable-next-line no-empty\n                } catch  {}\n            })();\n        }, 5000);\n        this._updateSubscriptions();\n    }\n    /**\n   * @internal\n   */ _wsOnError(err) {\n        this._rpcWebSocketConnected = false;\n        console.error(\"ws error:\", err.message);\n    }\n    /**\n   * @internal\n   */ _wsOnClose(code) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n        if (this._rpcWebSocketIdleTimeout) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n        }\n        if (this._rpcWebSocketHeartbeat) {\n            clearInterval(this._rpcWebSocketHeartbeat);\n            this._rpcWebSocketHeartbeat = null;\n        }\n        if (code === 1000) {\n            // explicit close, check if any subscriptions have been made since close\n            this._updateSubscriptions();\n            return;\n        }\n        // implicit close, prepare subscriptions for auto-reconnect\n        this._subscriptionCallbacksByServerSubscriptionId = {};\n        Object.entries(this._subscriptionsByHash).forEach(([hash, subscription])=>{\n            this._setSubscription(hash, {\n                ...subscription,\n                state: \"pending\"\n            });\n        });\n    }\n    /**\n   * @internal\n   */ _setSubscription(hash, nextSubscription) {\n        const prevState = this._subscriptionsByHash[hash]?.state;\n        this._subscriptionsByHash[hash] = nextSubscription;\n        if (prevState !== nextSubscription.state) {\n            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n            if (stateChangeCallbacks) {\n                stateChangeCallbacks.forEach((cb)=>{\n                    try {\n                        cb(nextSubscription.state);\n                    // eslint-disable-next-line no-empty\n                    } catch  {}\n                });\n            }\n        }\n    }\n    /**\n   * @internal\n   */ _onSubscriptionStateChange(clientSubscriptionId, callback) {\n        const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n        if (hash == null) {\n            return ()=>{};\n        }\n        const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set();\n        stateChangeCallbacks.add(callback);\n        return ()=>{\n            stateChangeCallbacks.delete(callback);\n            if (stateChangeCallbacks.size === 0) {\n                delete this._subscriptionStateChangeCallbacksByHash[hash];\n            }\n        };\n    }\n    /**\n   * @internal\n   */ async _updateSubscriptions() {\n        if (Object.keys(this._subscriptionsByHash).length === 0) {\n            if (this._rpcWebSocketConnected) {\n                this._rpcWebSocketConnected = false;\n                this._rpcWebSocketIdleTimeout = setTimeout(()=>{\n                    this._rpcWebSocketIdleTimeout = null;\n                    try {\n                        this._rpcWebSocket.close();\n                    } catch (err) {\n                        // swallow error if socket has already been closed.\n                        if (err instanceof Error) {\n                            console.log(`Error when closing socket connection: ${err.message}`);\n                        }\n                    }\n                }, 500);\n            }\n            return;\n        }\n        if (this._rpcWebSocketIdleTimeout !== null) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n            this._rpcWebSocketConnected = true;\n        }\n        if (!this._rpcWebSocketConnected) {\n            this._rpcWebSocket.connect();\n            return;\n        }\n        const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n        const isCurrentConnectionStillActive = ()=>{\n            return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n        };\n        await Promise.all(// Don't be tempted to change this to `Object.entries`. We call\n        // `_updateSubscriptions` recursively when processing the state,\n        // so it's important that we look up the *current* version of\n        // each subscription, every time we process a hash.\n        Object.keys(this._subscriptionsByHash).map(async (hash)=>{\n            const subscription = this._subscriptionsByHash[hash];\n            if (subscription === undefined) {\n                // This entry has since been deleted. Skip.\n                return;\n            }\n            switch(subscription.state){\n                case \"pending\":\n                case \"unsubscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        /**\n             * You can end up here when:\n             *\n             * - a subscription has recently unsubscribed\n             *   without having new callbacks added to it\n             *   while the unsubscribe was in flight, or\n             * - when a pending subscription has its\n             *   listeners removed before a request was\n             *   sent to the server.\n             *\n             * Being that nobody is interested in this\n             * subscription any longer, delete it.\n             */ delete this._subscriptionsByHash[hash];\n                        if (subscription.state === \"unsubscribed\") {\n                            delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n                        }\n                        await this._updateSubscriptions();\n                        return;\n                    }\n                    await (async ()=>{\n                        const { args, method } = subscription;\n                        try {\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"subscribing\"\n                            });\n                            const serverSubscriptionId = await this._rpcWebSocket.call(method, args);\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                serverSubscriptionId,\n                                state: \"subscribed\"\n                            });\n                            this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n                            await this._updateSubscriptions();\n                        } catch (e) {\n                            console.error(`Received ${e instanceof Error ? \"\" : \"JSON-RPC \"}error calling \\`${method}\\``, {\n                                args,\n                                error: e\n                            });\n                            if (!isCurrentConnectionStillActive()) {\n                                return;\n                            }\n                            // TODO: Maybe add an 'errored' state or a retry limit?\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"pending\"\n                            });\n                            await this._updateSubscriptions();\n                        }\n                    })();\n                    break;\n                case \"subscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        // By the time we successfully set up a subscription\n                        // with the server, the client stopped caring about it.\n                        // Tear it down now.\n                        await (async ()=>{\n                            const { serverSubscriptionId, unsubscribeMethod } = subscription;\n                            if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                                /**\n                 * Special case.\n                 * If we're dealing with a subscription that has been auto-\n                 * disposed by the RPC, then we can skip the RPC call to\n                 * tear down the subscription here.\n                 *\n                 * NOTE: There is a proposal to eliminate this special case, here:\n                 * https://github.com/solana-labs/solana/issues/18892\n                 */ this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n                            } else {\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                try {\n                                    await this._rpcWebSocket.call(unsubscribeMethod, [\n                                        serverSubscriptionId\n                                    ]);\n                                } catch (e) {\n                                    if (e instanceof Error) {\n                                        console.error(`${unsubscribeMethod} error:`, e.message);\n                                    }\n                                    if (!isCurrentConnectionStillActive()) {\n                                        return;\n                                    }\n                                    // TODO: Maybe add an 'errored' state or a retry limit?\n                                    this._setSubscription(hash, {\n                                        ...subscription,\n                                        state: \"subscribed\"\n                                    });\n                                    await this._updateSubscriptions();\n                                    return;\n                                }\n                            }\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"unsubscribed\"\n                            });\n                            await this._updateSubscriptions();\n                        })();\n                    }\n                    break;\n            }\n        }));\n    }\n    /**\n   * @internal\n   */ _handleServerNotification(serverSubscriptionId, callbackArgs) {\n        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n        if (callbacks === undefined) {\n            return;\n        }\n        callbacks.forEach((cb)=>{\n            try {\n                cb(// I failed to find a way to convince TypeScript that `cb` is of type\n                // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n                // See https://github.com/microsoft/TypeScript/issues/47615\n                // @ts-ignore\n                ...callbackArgs);\n            } catch (e) {\n                console.error(e);\n            }\n        });\n    }\n    /**\n   * @internal\n   */ _wsOnAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, AccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _makeSubscription(subscriptionConfig, /**\n   * When preparing `args` for a call to `_makeSubscription`, be sure\n   * to carefully apply a default `commitment` property, if necessary.\n   *\n   * - If the user supplied a `commitment` use that.\n   * - Otherwise, if the `Connection::commitment` is set, use that.\n   * - Otherwise, set it to the RPC server default: `finalized`.\n   *\n   * This is extremely important to ensure that these two fundamentally\n   * identical subscriptions produce the same identifying hash:\n   *\n   * - A subscription made without specifying a commitment.\n   * - A subscription made where the commitment specified is the same\n   *   as the default applied to the subscription above.\n   *\n   * Example; these two subscriptions must produce the same hash:\n   *\n   * - An `accountSubscribe` subscription for `'PUBKEY'`\n   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n   *   `'finalized'`.\n   *\n   * See the 'making a subscription with defaulted params omitted' test\n   * in `connection-subscriptions.ts` for more.\n   */ args) {\n        const clientSubscriptionId = this._nextClientSubscriptionId++;\n        const hash = fastStableStringify([\n            subscriptionConfig.method,\n            args\n        ]);\n        const existingSubscription = this._subscriptionsByHash[hash];\n        if (existingSubscription === undefined) {\n            this._subscriptionsByHash[hash] = {\n                ...subscriptionConfig,\n                args,\n                callbacks: new Set([\n                    subscriptionConfig.callback\n                ]),\n                state: \"pending\"\n            };\n        } else {\n            existingSubscription.callbacks.add(subscriptionConfig.callback);\n        }\n        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async ()=>{\n            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n            const subscription = this._subscriptionsByHash[hash];\n            assert(subscription !== undefined, `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`);\n            subscription.callbacks.delete(subscriptionConfig.callback);\n            await this._updateSubscriptions();\n        };\n        this._updateSubscriptions();\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */ /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    onAccountChange(publicKey, callback, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\", config);\n        return this._makeSubscription({\n            callback,\n            method: \"accountSubscribe\",\n            unsubscribeMethod: \"accountUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"account change\");\n    }\n    /**\n   * @internal\n   */ _wsOnProgramAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, ProgramAccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            {\n                accountId: result.value.pubkey,\n                accountInfo: result.value.account\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */ /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\" /* encoding */ , config ? config : maybeFilters ? {\n            filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)\n        } : undefined /* extra */ );\n        return this._makeSubscription({\n            callback,\n            method: \"programSubscribe\",\n            unsubscribeMethod: \"programUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeProgramAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"program account change\");\n    }\n    /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */ onLogs(filter, callback, commitment) {\n        const args = this._buildArgs([\n            typeof filter === \"object\" ? {\n                mentions: [\n                    filter.toString()\n                ]\n            } : filter\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        return this._makeSubscription({\n            callback,\n            method: \"logsSubscribe\",\n            unsubscribeMethod: \"logsUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */ async removeOnLogsListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"logs\");\n    }\n    /**\n   * @internal\n   */ _wsOnLogsNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, LogsNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _wsOnSlotNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SlotNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */ onSlotChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotSubscribe\",\n            unsubscribeMethod: \"slotUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot change\");\n    }\n    /**\n   * @internal\n   */ _wsOnSlotUpdatesNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SlotUpdateNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */ onSlotUpdate(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotsUpdatesSubscribe\",\n            unsubscribeMethod: \"slotsUpdatesUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotUpdateListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot update\");\n    }\n    /**\n   * @internal\n   */ async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {\n        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n        if (dispose) {\n            await dispose();\n        } else {\n            console.warn(\"Ignored unsubscribe request because an active subscription with id \" + `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` + \"could not be found.\");\n        }\n    }\n    _buildArgs(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment || encoding || extra) {\n            let options = {};\n            if (encoding) {\n                options.encoding = encoding;\n            }\n            if (commitment) {\n                options.commitment = commitment;\n            }\n            if (extra) {\n                options = Object.assign(options, extra);\n            }\n            args.push(options);\n        }\n        return args;\n    }\n    /**\n   * @internal\n   */ _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment && ![\n            \"confirmed\",\n            \"finalized\"\n        ].includes(commitment)) {\n            throw new Error(\"Using Connection with default commitment: `\" + this._commitment + \"`, but method requires at least `confirmed`\");\n        }\n        return this._buildArgs(args, override, encoding, extra);\n    }\n    /**\n   * @internal\n   */ _wsOnSignatureNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SignatureNotificationResult);\n        if (result.value !== \"receivedSignature\") {\n            /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */ this._subscriptionsAutoDisposedByRpc.add(subscription);\n        }\n        this._handleServerNotification(subscription, result.value === \"receivedSignature\" ? [\n            {\n                type: \"received\"\n            },\n            result.context\n        ] : [\n            {\n                type: \"status\",\n                result: result.value\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */ onSignature(signature, callback, commitment) {\n        const args = this._buildArgs([\n            signature\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                if (notification.type === \"status\") {\n                    callback(notification.result, context);\n                    // Signatures subscriptions are auto-removed by the RPC service\n                    // so no need to explicitly send an unsubscribe message.\n                    try {\n                        this.removeSignatureListener(clientSubscriptionId);\n                    // eslint-disable-next-line no-empty\n                    } catch (_err) {\n                    // Already removed.\n                    }\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */ onSignatureWithOptions(signature, callback, options) {\n        const { commitment, ...extra } = {\n            ...options,\n            commitment: options && options.commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        };\n        const args = this._buildArgs([\n            signature\n        ], commitment, undefined /* encoding */ , extra);\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                callback(notification, context);\n                // Signatures subscriptions are auto-removed by the RPC service\n                // so no need to explicitly send an unsubscribe message.\n                try {\n                    this.removeSignatureListener(clientSubscriptionId);\n                // eslint-disable-next-line no-empty\n                } catch (_err) {\n                // Already removed.\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSignatureListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"signature result\");\n    }\n    /**\n   * @internal\n   */ _wsOnRootNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, RootNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */ onRootChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"rootSubscribe\",\n            unsubscribeMethod: \"rootUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeRootChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"root change\");\n    }\n}\n/**\n * Keypair signer interface\n */ /**\n * An account keypair used for signing transactions.\n */ class Keypair {\n    /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */ constructor(keypair){\n        this._keypair = void 0;\n        this._keypair = keypair ?? generateKeypair();\n    }\n    /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */ static generate() {\n        return new Keypair(generateKeypair());\n    }\n    /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSecretKey(secretKey, options) {\n        if (secretKey.byteLength !== 64) {\n            throw new Error(\"bad secret key size\");\n        }\n        const publicKey = secretKey.slice(32, 64);\n        if (!options || !options.skipValidation) {\n            const privateScalar = secretKey.slice(0, 32);\n            const computedPublicKey = getPublicKey(privateScalar);\n            for(let ii = 0; ii < 32; ii++){\n                if (publicKey[ii] !== computedPublicKey[ii]) {\n                    throw new Error(\"provided secretKey is invalid\");\n                }\n            }\n        }\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSeed(seed) {\n        const publicKey = getPublicKey(seed);\n        const secretKey = new Uint8Array(64);\n        secretKey.set(seed);\n        secretKey.set(publicKey, 32);\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */ get publicKey() {\n        return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */ get secretKey() {\n        return new Uint8Array(this._keypair.secretKey);\n    }\n}\n/**\n * An enumeration of valid LookupTableInstructionType's\n */ /**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */ const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n    CreateLookupTable: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"recentSlot\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"bumpSeed\")\n        ])\n    },\n    FreezeLookupTable: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    ExtendLookupTable: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"addresses\")\n        ])\n    },\n    DeactivateLookupTable: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    CloseLookupTable: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\nclass AddressLookupTableInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const index = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == index) {\n                type = layoutType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Invalid Instruction. Should be a LookupTable Instruction\");\n        }\n        return type;\n    }\n    static decodeCreateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 4);\n        const { recentSlot } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);\n        return {\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys[2].pubkey,\n            recentSlot: Number(recentSlot)\n        };\n    }\n    static decodeExtendLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        if (instruction.keys.length < 2) {\n            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);\n        }\n        const { addresses } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n            addresses: addresses.map((buffer)=>new PublicKey(buffer))\n        };\n    }\n    static decodeCloseLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 3);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            recipient: instruction.keys[2].pubkey\n        };\n    }\n    static decodeFreezeLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    static decodeDeactivateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(AddressLookupTableProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not AddressLookupTable Program\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeysLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\nclass AddressLookupTableProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    static createLookupTable(params) {\n        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([\n            params.authority.toBuffer(),\n            (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_13__.getU64Encoder)().encode(params.recentSlot)\n        ], this.programId);\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n        const data = encodeData(type, {\n            recentSlot: BigInt(params.recentSlot),\n            bumpSeed: bumpSeed\n        });\n        const keys = [\n            {\n                pubkey: lookupTableAddress,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        return [\n            new TransactionInstruction({\n                programId: this.programId,\n                keys: keys,\n                data: data\n            }),\n            lookupTableAddress\n        ];\n    }\n    static freezeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static extendLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n        const data = encodeData(type, {\n            addresses: params.addresses.map((addr)=>addr.toBytes())\n        });\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (params.payer) {\n            keys.push({\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            }, {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static deactivateLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static closeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.recipient,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n}\nAddressLookupTableProgram.programId = new PublicKey(\"AddressLookupTab1e1111111111111111111111111\");\n/**\n * Compute Budget Instruction class\n */ class ComputeBudgetInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a ComputeBudgetInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestUnits(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units, additionalFee } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);\n        return {\n            units,\n            additionalFee\n        };\n    }\n    /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestHeapFrame(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { bytes } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);\n        return {\n            bytes\n        };\n    }\n    /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitLimit(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);\n        return {\n            units\n        };\n    }\n    /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitPrice(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { microLamports } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);\n        return {\n            microLamports\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(ComputeBudgetProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not ComputeBudgetProgram\");\n        }\n    }\n}\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */ /**\n * Request units instruction params\n */ /**\n * Request heap frame instruction params\n */ /**\n * Set compute unit limit instruction params\n */ /**\n * Set compute unit price instruction params\n */ /**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */ const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n    RequestUnits: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"additionalFee\")\n        ])\n    },\n    RequestHeapFrame: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytes\")\n        ])\n    },\n    SetComputeUnitLimit: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\")\n        ])\n    },\n    SetComputeUnitPrice: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            u64(\"microLamports\")\n        ])\n    }\n});\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */ class ComputeBudgetProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Compute Budget program\n   */ /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */ static requestUnits(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static requestHeapFrame(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitLimit(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitPrice(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n        const data = encodeData(type, {\n            microLamports: BigInt(params.microLamports)\n        });\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n}\nComputeBudgetProgram.programId = new PublicKey(\"ComputeBudget111111111111111111111111111111\");\nconst PRIVATE_KEY_BYTES$1 = 64;\nconst PUBLIC_KEY_BYTES$1 = 32;\nconst SIGNATURE_BYTES = 64;\n/**\n * Params for creating an ed25519 instruction using a public key\n */ /**\n * Params for creating an ed25519 instruction using a private key\n */ const ED25519_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"padding\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageInstructionIndex\")\n]);\nclass Ed25519Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the ed25519 program\n   */ /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, instructionIndex } = params;\n        assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);\n        assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n        const signatureOffset = publicKeyOffset + publicKey.length;\n        const messageDataOffset = signatureOffset + signature.length;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(messageDataOffset + message.length);\n        const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n         : instructionIndex;\n        ED25519_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            padding: 0,\n            signatureOffset,\n            signatureInstructionIndex: index,\n            publicKeyOffset,\n            publicKeyInstructionIndex: index,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: index\n        }, instructionData);\n        instructionData.fill(publicKey, publicKeyOffset);\n        instructionData.fill(signature, signatureOffset);\n        instructionData.fill(message, messageDataOffset);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Ed25519Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey, message, instructionIndex } = params;\n        assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n        try {\n            const keypair = Keypair.fromSecretKey(privateKey);\n            const publicKey = keypair.publicKey.toBytes();\n            const signature = sign(message, keypair.secretKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nEd25519Program.programId = new PublicKey(\"Ed25519SigVerify111111111111111111111111111\");\nconst ecdsaSign = (msgHash, privKey)=>{\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.sign(msgHash, privKey);\n    return [\n        signature.toCompactRawBytes(),\n        signature.recovery\n    ];\n};\n_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.utils.isValidPrivateKey;\nconst publicKeyCreate = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.getPublicKey;\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n/**\n * Params for creating an secp256k1 instruction using a public key\n */ /**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */ /**\n * Params for creating an secp256k1 instruction using a private key\n */ const SECP256K1_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"ethAddressOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"ethAddressInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"messageInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(20, \"ethAddress\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, \"signature\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"recoveryId\")\n]);\nclass Secp256k1Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the secp256k1 program\n   */ /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */ static publicKeyToEthAddress(publicKey) {\n        assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);\n        try {\n            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__.keccak_256)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);\n        } catch (error) {\n            throw new Error(`Error constructing Ethereum address: ${error}`);\n        }\n    }\n    /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, recoveryId, instructionIndex } = params;\n        return Secp256k1Program.createInstructionWithEthAddress({\n            ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n            message,\n            signature,\n            recoveryId,\n            instructionIndex\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */ static createInstructionWithEthAddress(params) {\n        const { ethAddress: rawAddress, message, signature, recoveryId, instructionIndex = 0 } = params;\n        let ethAddress;\n        if (typeof rawAddress === \"string\") {\n            if (rawAddress.startsWith(\"0x\")) {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress.substr(2), \"hex\");\n            } else {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress, \"hex\");\n            }\n        } else {\n            ethAddress = rawAddress;\n        }\n        assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n        const ethAddressOffset = dataStart;\n        const signatureOffset = dataStart + ethAddress.length;\n        const messageDataOffset = signatureOffset + signature.length + 1;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n        SECP256K1_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            signatureOffset,\n            signatureInstructionIndex: instructionIndex,\n            ethAddressOffset,\n            ethAddressInstructionIndex: instructionIndex,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: instructionIndex,\n            signature: toBuffer(signature),\n            ethAddress: toBuffer(ethAddress),\n            recoveryId\n        }, instructionData);\n        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Secp256k1Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey: pkey, message, instructionIndex } = params;\n        assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n        try {\n            const privateKey = toBuffer(pkey);\n            const publicKey = publicKeyCreate(privateKey, false).slice(1); // throw away leading byte\n            const messageHash = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__.keccak_256)(toBuffer(message)));\n            const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                recoveryId,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nSecp256k1Program.programId = new PublicKey(\"KeccakSecp256k11111111111111111111111111111\");\nvar _Lockup;\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */ const STAKE_CONFIG_ID = new PublicKey(\"StakeConfig11111111111111111111111111111111\");\n/**\n * Stake account authority info\n */ class Authorized {\n    /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */ constructor(staker, withdrawer){\n        /** stake authority */ this.staker = void 0;\n        /** withdraw authority */ this.withdrawer = void 0;\n        this.staker = staker;\n        this.withdrawer = withdrawer;\n    }\n}\n/**\n * Stake account lockup info\n */ class Lockup {\n    /**\n   * Create a new Lockup object\n   */ constructor(unixTimestamp, epoch, custodian){\n        /** Unix timestamp of lockup expiration */ this.unixTimestamp = void 0;\n        /** Epoch of lockup expiration */ this.epoch = void 0;\n        /** Lockup custodian authority */ this.custodian = void 0;\n        this.unixTimestamp = unixTimestamp;\n        this.epoch = epoch;\n        this.custodian = custodian;\n    }\n}\n_Lockup = Lockup;\nLockup.default = new _Lockup(0, 0, PublicKey.default);\n/**\n * Create stake account transaction params\n */ /**\n * Create stake account with seed transaction params\n */ /**\n * Initialize stake instruction params\n */ /**\n * Delegate stake instruction params\n */ /**\n * Authorize stake instruction params\n */ /**\n * Authorize stake instruction params using a derived key\n */ /**\n * Split stake instruction params\n */ /**\n * Split with seed transaction params\n */ /**\n * Withdraw stake instruction params\n */ /**\n * Deactivate stake instruction params\n */ /**\n * Merge stake instruction params\n */ /**\n * Stake Instruction class\n */ class StakeInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a StakeInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */ static decodeInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized, lockup } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n            lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n        };\n    }\n    /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */ static decodeDelegate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 6);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            votePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[5].pubkey\n        };\n    }\n    /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, stakeAuthorizationType } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { newAuthorized, stakeAuthorizationType, authoritySeed, authorityOwner } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorityBase: instruction.keys[1].pubkey,\n            authoritySeed: authoritySeed,\n            authorityOwner: new PublicKey(authorityOwner),\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */ static decodeSplit(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            splitStakePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */ static decodeMerge(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            sourceStakePubKey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n        if (instruction.keys.length > 5) {\n            o.custodianPubkey = instruction.keys[5].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */ static decodeDeactivate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(StakeProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not StakeProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid StakeInstructionType's\n */ /**\n * An enumeration of valid stake InstructionType's\n * @internal\n */ const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n    Initialize: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            authorized(),\n            lockup()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\")\n        ])\n    },\n    Delegate: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Split: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Withdraw: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Deactivate: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Merge: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\"),\n            rustString(\"authoritySeed\"),\n            publicKey(\"authorityOwner\")\n        ])\n    }\n});\n/**\n * Stake authorization type\n */ /**\n * An enumeration of valid StakeAuthorizationLayout's\n */ const StakeAuthorizationLayout = Object.freeze({\n    Staker: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Stake program\n */ class StakeProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Stake program\n   */ /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */ static initialize(params) {\n        const { stakePubkey, authorized, lockup: maybeLockup } = params;\n        const lockup = maybeLockup || Lockup.default;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n        const data = encodeData(type, {\n            authorized: {\n                staker: toBuffer(authorized.staker.toBuffer()),\n                withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n            },\n            lockup: {\n                unixTimestamp: lockup.unixTimestamp,\n                epoch: lockup.epoch,\n                custodian: toBuffer(lockup.custodian.toBuffer())\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */ static createAccountWithSeed(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccountWithSeed({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            basePubkey: params.basePubkey,\n            seed: params.seed,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */ static delegate(params) {\n        const { stakePubkey, authorizedPubkey, votePubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: STAKE_CONFIG_ID,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorize(params) {\n        const { stakePubkey, authorizedPubkey, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorizeWithSeed(params) {\n        const { stakePubkey, authorityBase, authoritySeed, authorityOwner, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index,\n            authoritySeed: authoritySeed,\n            authorityOwner: toBuffer(authorityOwner.toBuffer())\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorityBase,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * @internal\n   */ static splitInstruction(params) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, lamports } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n        const data = encodeData(type, {\n            lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: splitStakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */ static split(params, // Compute the cost of allocating the new stake account in lamports\n    rentExemptReserve) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.authorizedPubkey,\n            newAccountPubkey: params.splitStakePubkey,\n            lamports: rentExemptReserve,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.splitInstruction(params));\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */ static splitWithSeed(params, // If this stake account is new, compute the cost of allocating it in lamports\n    rentExemptReserve) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, basePubkey, seed, lamports } = params;\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.allocate({\n            accountPubkey: splitStakePubkey,\n            basePubkey,\n            seed,\n            space: this.space,\n            programId: this.programId\n        }));\n        if (rentExemptReserve && rentExemptReserve > 0) {\n            transaction.add(SystemProgram.transfer({\n                fromPubkey: params.authorizedPubkey,\n                toPubkey: splitStakePubkey,\n                lamports: rentExemptReserve\n            }));\n        }\n        return transaction.add(this.splitInstruction({\n            stakePubkey,\n            authorizedPubkey,\n            splitStakePubkey,\n            lamports\n        }));\n    }\n    /**\n   * Generate a Transaction that merges Stake accounts.\n   */ static merge(params) {\n        const { stakePubkey, sourceStakePubKey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: sourceStakePubKey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */ static withdraw(params) {\n        const { stakePubkey, authorizedPubkey, toPubkey, lamports, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */ static deactivate(params) {\n        const { stakePubkey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n}\nStakeProgram.programId = new PublicKey(\"Stake11111111111111111111111111111111111111\");\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeStateV2::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n */ StakeProgram.space = 200;\n/**\n * Vote account info\n */ class VoteInit {\n    /** [0, 100] */ constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission){\n        this.nodePubkey = void 0;\n        this.authorizedVoter = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.nodePubkey = nodePubkey;\n        this.authorizedVoter = authorizedVoter;\n        this.authorizedWithdrawer = authorizedWithdrawer;\n        this.commission = commission;\n    }\n}\n/**\n * Create vote account transaction params\n */ /**\n * InitializeAccount instruction params\n */ /**\n * Authorize instruction params\n */ /**\n * AuthorizeWithSeed instruction params\n */ /**\n * Withdraw from vote account transaction params\n */ /**\n * Update validator identity (node pubkey) vote account instruction params.\n */ /**\n * Vote Instruction class\n */ class VoteInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a VoteInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */ static decodeInitializeAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 4);\n        const { voteInit } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            nodePubkey: instruction.keys[3].pubkey,\n            voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, voteAuthorizationType } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            }\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { voteAuthorizeWithSeedArgs: { currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorized, voteAuthorizationType } } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        return {\n            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n            currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            },\n            votePubkey: instruction.keys[0].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n            lamports,\n            toPubkey: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(VoteProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not VoteProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid VoteInstructionType's\n */ /** @internal */ const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n    InitializeAccount: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteInit()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\")\n        ])\n    },\n    Withdraw: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    UpdateValidatorIdentity: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteAuthorizeWithSeedArgs()\n        ])\n    }\n});\n/**\n * VoteAuthorize type\n */ /**\n * An enumeration of valid VoteAuthorization layouts.\n */ const VoteAuthorizationLayout = Object.freeze({\n    Voter: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Vote program\n */ class VoteProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Vote program\n   */ /**\n   * Generate an Initialize instruction.\n   */ static initializeAccount(params) {\n        const { votePubkey, nodePubkey, voteInit } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n        const data = encodeData(type, {\n            voteInit: {\n                nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n                authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n                authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n                commission: voteInit.commission\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: nodePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction that creates a new Vote account.\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.votePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.initializeAccount({\n            votePubkey: params.votePubkey,\n            nodePubkey: params.voteInit.nodePubkey,\n            voteInit: params.voteInit\n        }));\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */ static authorize(params) {\n        const { votePubkey, authorizedPubkey, newAuthorizedPubkey, voteAuthorizationType } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            voteAuthorizationType: voteAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */ static authorizeWithSeed(params) {\n        const { currentAuthorityDerivedKeyBasePubkey, currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorizedPubkey, voteAuthorizationType, votePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            voteAuthorizeWithSeedArgs: {\n                currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n                currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n                voteAuthorizationType: voteAuthorizationType.index\n            }\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: currentAuthorityDerivedKeyBasePubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw from a Vote account.\n   */ static withdraw(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, lamports, toPubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */ static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n            throw new Error(\"Withdraw will leave vote account with insufficient funds.\");\n        }\n        return VoteProgram.withdraw(params);\n    }\n    /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */ static updateValidatorIdentity(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, nodePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: nodePubkey,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nVoteProgram.programId = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */ VoteProgram.space = 3762;\nconst VALIDATOR_INFO_KEY = new PublicKey(\"Va1idator1nfo111111111111111111111111111111\");\n/**\n * @internal\n */ /**\n * Info used to identity validators.\n */ const InfoString = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    name: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    website: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    details: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    iconUrl: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    keybaseUsername: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\n/**\n * ValidatorInfo class\n */ class ValidatorInfo {\n    /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */ constructor(key, info){\n        /**\n     * validator public key\n     */ this.key = void 0;\n        /**\n     * validator information\n     */ this.info = void 0;\n        this.key = key;\n        this.info = info;\n    }\n    /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */ static fromConfigData(buffer) {\n        let byteArray = [\n            ...buffer\n        ];\n        const configKeyCount = decodeLength(byteArray);\n        if (configKeyCount !== 2) return null;\n        const configKeys = [];\n        for(let i = 0; i < 2; i++){\n            const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const isSigner = guardedShift(byteArray) === 1;\n            configKeys.push({\n                publicKey,\n                isSigner\n            });\n        }\n        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n            if (configKeys[1].isSigner) {\n                const rawInfo = rustString().decode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(byteArray));\n                const info = JSON.parse(rawInfo);\n                (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.assert)(info, InfoString);\n                return new ValidatorInfo(configKeys[1].publicKey, info);\n            }\n        }\n        return null;\n    }\n}\nconst VOTE_PROGRAM_ID = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * History of how many credits earned by the end of each epoch\n */ /**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */ const VoteAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    publicKey(\"nodePubkey\"),\n    publicKey(\"authorizedWithdrawer\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // votes.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"confirmationCount\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"votes\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"rootSlotValid\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"rootSlot\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // authorizedVoters.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        publicKey(\"authorizedVoter\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"authorizedVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            publicKey(\"authorizedPubkey\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epochOfLastAuthorizedSwitch\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"targetEpoch\")\n        ]), 32, \"buf\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"idx\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"isEmpty\")\n    ], \"priorVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // epochCredits.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"credits\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"prevCredits\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"epochCredits\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"timestamp\")\n    ], \"lastTimestamp\")\n]);\n/**\n * VoteAccount class\n */ class VoteAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.nodePubkey = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.rootSlot = void 0;\n        this.votes = void 0;\n        this.authorizedVoters = void 0;\n        this.priorVoters = void 0;\n        this.epochCredits = void 0;\n        this.lastTimestamp = void 0;\n        this.nodePubkey = args.nodePubkey;\n        this.authorizedWithdrawer = args.authorizedWithdrawer;\n        this.commission = args.commission;\n        this.rootSlot = args.rootSlot;\n        this.votes = args.votes;\n        this.authorizedVoters = args.authorizedVoters;\n        this.priorVoters = args.priorVoters;\n        this.epochCredits = args.epochCredits;\n        this.lastTimestamp = args.lastTimestamp;\n    }\n    /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */ static fromAccountData(buffer) {\n        const versionOffset = 4;\n        const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n        let rootSlot = va.rootSlot;\n        if (!va.rootSlotValid) {\n            rootSlot = null;\n        }\n        return new VoteAccount({\n            nodePubkey: new PublicKey(va.nodePubkey),\n            authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n            commission: va.commission,\n            votes: va.votes,\n            rootSlot,\n            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n            priorVoters: getPriorVoters(va.priorVoters),\n            epochCredits: va.epochCredits,\n            lastTimestamp: va.lastTimestamp\n        });\n    }\n}\nfunction parseAuthorizedVoter({ authorizedVoter, epoch }) {\n    return {\n        epoch,\n        authorizedVoter: new PublicKey(authorizedVoter)\n    };\n}\nfunction parsePriorVoters({ authorizedPubkey, epochOfLastAuthorizedSwitch, targetEpoch }) {\n    return {\n        authorizedPubkey: new PublicKey(authorizedPubkey),\n        epochOfLastAuthorizedSwitch,\n        targetEpoch\n    };\n}\nfunction getPriorVoters({ buf, idx, isEmpty }) {\n    if (isEmpty) {\n        return [];\n    }\n    return [\n        ...buf.slice(idx + 1).map(parsePriorVoters),\n        ...buf.slice(0, idx).map(parsePriorVoters)\n    ];\n}\nconst endpoint = {\n    http: {\n        devnet: \"http://api.devnet.solana.com\",\n        testnet: \"http://api.testnet.solana.com\",\n        \"mainnet-beta\": \"http://api.mainnet-beta.solana.com/\"\n    },\n    https: {\n        devnet: \"https://api.devnet.solana.com\",\n        testnet: \"https://api.testnet.solana.com\",\n        \"mainnet-beta\": \"https://api.mainnet-beta.solana.com/\"\n    }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */ function clusterApiUrl(cluster, tls) {\n    const key = tls === false ? \"http\" : \"https\";\n    if (!cluster) {\n        return endpoint[key][\"devnet\"];\n    }\n    const url = endpoint[key][cluster];\n    if (!url) {\n        throw new Error(`Unknown ${key} cluster: ${cluster}`);\n    }\n    return url;\n}\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ /**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */ // eslint-disable-next-line no-redeclare\n// eslint-disable-next-line no-redeclare\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n    let confirmationStrategy;\n    let options;\n    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"lastValidBlockHeight\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"nonceValue\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else {\n        options = confirmationStrategyOrConfirmOptions;\n    }\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n    const commitment = options && options.commitment;\n    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n    const status = (await confirmationPromise).value;\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: sendOptions?.skipPreflight ? \"send\" : \"simulate\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n/**\n * There are 1-billion lamports in one SOL\n */ const LAMPORTS_PER_SOL = 1000000000;\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL2xpYi9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnQztBQUNnQjtBQUN6QjtBQUNDO0FBQ3NCO0FBQ3VCO0FBQ2Y7QUFDVDtBQUN1QjtBQUN0QztBQUNFO0FBQ1k7QUFDc0k7QUFDaEk7QUFDVjtBQUNpQjtBQUNUO0FBQ0k7QUFFcEQ7Ozs7Q0FJQyxHQUVEOztDQUVDLEdBRUQsTUFBTXdDLHFCQUFxQnZDLDJEQUFPQSxDQUFDd0MsS0FBSyxDQUFDQyxnQkFBZ0I7QUFDekQsTUFBTUMsa0JBQWtCO0lBQ3RCLE1BQU1DLGdCQUFnQjNDLDJEQUFPQSxDQUFDd0MsS0FBSyxDQUFDQyxnQkFBZ0I7SUFDcEQsTUFBTUcsWUFBWUMsYUFBYUY7SUFDL0IsTUFBTUcsWUFBWSxJQUFJQyxXQUFXO0lBQ2pDRCxVQUFVRSxHQUFHLENBQUNMO0lBQ2RHLFVBQVVFLEdBQUcsQ0FBQ0osV0FBVztJQUN6QixPQUFPO1FBQ0xBO1FBQ0FFO0lBQ0Y7QUFDRjtBQUNBLE1BQU1ELGVBQWU3QywyREFBT0EsQ0FBQzZDLFlBQVk7QUFDekMsU0FBU0ksVUFBVUwsU0FBUztJQUMxQixJQUFJO1FBQ0Y1QywyREFBT0EsQ0FBQ2tELGFBQWEsQ0FBQ0MsT0FBTyxDQUFDUDtRQUM5QixPQUFPO0lBQ1QsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFDQSxNQUFNUSxPQUFPLENBQUNDLFNBQVNQLFlBQWM5QywyREFBT0EsQ0FBQ29ELElBQUksQ0FBQ0MsU0FBU1AsVUFBVVEsS0FBSyxDQUFDLEdBQUc7QUFDOUUsTUFBTUMsU0FBU3ZELDJEQUFPQSxDQUFDdUQsTUFBTTtBQUU3QixNQUFNQyxXQUFXQyxDQUFBQTtJQUNmLElBQUkxRCww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QVdBO2dCQUNYNlQsb0JBQW9CLENBQUMsU0FBUyxFQUFFOUYsS0FBS0MsU0FBUyxDQUFDMEksUUFBUSxDQUFDLENBQUM7WUFDM0Q7UUFDRjtRQUNBLE1BQU0sSUFBSXRhLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTRELFVBQVUsU0FBUyxFQUFFK04sS0FBS0MsU0FBUyxDQUFDMEksUUFBUSxDQUFDLENBQUM7SUFDbkY7SUFDQSxPQUFPMVc7QUFDVDtBQUVBOztDQUVDLEdBQ0QsTUFBTXMyQyxtQkFBbUI7QUFFNmdELENBQ3RpRCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbGliL2luZGV4LmVzbS5qcz84ZmE3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgeyBlZDI1NTE5IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5JztcbmltcG9ydCBCTiBmcm9tICdibi5qcyc7XG5pbXBvcnQgYnM1OCBmcm9tICdiczU4JztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIGRlc2VyaWFsaXplVW5jaGVja2VkIH0gZnJvbSAnYm9yc2gnO1xuaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQgeyBibG9iIH0gZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcbmltcG9ydCB7IGdldFU2NENvZGVjLCBnZXRVNjRFbmNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtbnVtYmVycyc7XG5pbXBvcnQgcmVxdWlyZSQkMCBmcm9tICd1dGlsJztcbmltcG9ydCByZXF1aXJlJCQwJDEgZnJvbSAnaHR0cCc7XG5pbXBvcnQgcmVxdWlyZSQkMCQyLCB7IEFnZW50IH0gZnJvbSAnaHR0cHMnO1xuaW1wb3J0IHsgY29lcmNlLCBpbnN0YW5jZSwgc3RyaW5nLCB0dXBsZSwgbGl0ZXJhbCwgdW5rbm93biwgdHlwZSwgbnVtYmVyLCBhcnJheSwgbnVsbGFibGUsIG9wdGlvbmFsLCBib29sZWFuLCByZWNvcmQsIHVuaW9uLCBjcmVhdGUsIGFueSwgYXNzZXJ0IGFzIGFzc2VydCQxIH0gZnJvbSAnc3VwZXJzdHJ1Y3QnO1xuaW1wb3J0IFJwY0NsaWVudCBmcm9tICdqYXlzb24vbGliL2NsaWVudC9icm93c2VyJztcbmltcG9ydCAqIGFzIG5vZGVGZXRjaCBmcm9tICdub2RlLWZldGNoJztcbmltcG9ydCB7IENvbW1vbkNsaWVudCwgV2ViU29ja2V0IH0gZnJvbSAncnBjLXdlYnNvY2tldHMnO1xuaW1wb3J0IHsga2VjY2FrXzI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMyc7XG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5cbi8qKlxuICogQSA2NCBieXRlIHNlY3JldCBrZXksIHRoZSBmaXJzdCAzMiBieXRlcyBvZiB3aGljaCBpcyB0aGVcbiAqIHByaXZhdGUgc2NhbGFyIGFuZCB0aGUgbGFzdCAzMiBieXRlcyBpcyB0aGUgcHVibGljIGtleS5cbiAqIFJlYWQgbW9yZTogaHR0cHM6Ly9ibG9nLm1vemlsbGEub3JnL3dhcm5lci8yMDExLzExLzI5L2VkMjU1MTkta2V5cy9cbiAqL1xuXG4vKipcbiAqIEVkMjU1MTkgS2V5cGFpclxuICovXG5cbmNvbnN0IGdlbmVyYXRlUHJpdmF0ZUtleSA9IGVkMjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleTtcbmNvbnN0IGdlbmVyYXRlS2V5cGFpciA9ICgpID0+IHtcbiAgY29uc3QgcHJpdmF0ZVNjYWxhciA9IGVkMjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkocHJpdmF0ZVNjYWxhcik7XG4gIGNvbnN0IHNlY3JldEtleSA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgc2VjcmV0S2V5LnNldChwcml2YXRlU2NhbGFyKTtcbiAgc2VjcmV0S2V5LnNldChwdWJsaWNLZXksIDMyKTtcbiAgcmV0dXJuIHtcbiAgICBwdWJsaWNLZXksXG4gICAgc2VjcmV0S2V5XG4gIH07XG59O1xuY29uc3QgZ2V0UHVibGljS2V5ID0gZWQyNTUxOS5nZXRQdWJsaWNLZXk7XG5mdW5jdGlvbiBpc09uQ3VydmUocHVibGljS2V5KSB7XG4gIHRyeSB7XG4gICAgZWQyNTUxOS5FeHRlbmRlZFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jb25zdCBzaWduID0gKG1lc3NhZ2UsIHNlY3JldEtleSkgPT4gZWQyNTUxOS5zaWduKG1lc3NhZ2UsIHNlY3JldEtleS5zbGljZSgwLCAzMikpO1xuY29uc3QgdmVyaWZ5ID0gZWQyNTUxOS52ZXJpZnk7XG5cbmNvbnN0IHRvQnVmZmVyID0gYXJyID0+IHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhcnIpKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIGlmIChhcnIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycik7XG4gIH1cbn07XG5cbi8vIENsYXNzIHdyYXBwaW5nIGEgcGxhaW4gb2JqZWN0XG5jbGFzcyBTdHJ1Y3Qge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgfVxuICBlbmNvZGUoKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZShTT0xBTkFfU0NIRU1BLCB0aGlzKSk7XG4gIH1cbiAgc3RhdGljIGRlY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplKFNPTEFOQV9TQ0hFTUEsIHRoaXMsIGRhdGEpO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVVbmNoZWNrZWQoZGF0YSkge1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZVVuY2hlY2tlZChTT0xBTkFfU0NIRU1BLCB0aGlzLCBkYXRhKTtcbiAgfVxufVxuXG4vLyBDbGFzcyByZXByZXNlbnRpbmcgYSBSdXN0LWNvbXBhdGlibGUgZW51bSwgc2luY2UgZW51bXMgYXJlIG9ubHkgc3RyaW5ncyBvclxuLy8gbnVtYmVycyBpbiBwdXJlIEpTXG5jbGFzcyBFbnVtIGV4dGVuZHMgU3RydWN0IHtcbiAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgIHN1cGVyKHByb3BlcnRpZXMpO1xuICAgIHRoaXMuZW51bSA9ICcnO1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW51bSBjYW4gb25seSB0YWtlIHNpbmdsZSB2YWx1ZScpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5tYXAoa2V5ID0+IHtcbiAgICAgIHRoaXMuZW51bSA9IGtleTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgU09MQU5BX1NDSEVNQSA9IG5ldyBNYXAoKTtcblxudmFyIF9QdWJsaWNLZXk7XG5cbi8qKlxuICogTWF4aW11bSBsZW5ndGggb2YgZGVyaXZlZCBwdWJrZXkgc2VlZFxuICovXG5jb25zdCBNQVhfU0VFRF9MRU5HVEggPSAzMjtcblxuLyoqXG4gKiBTaXplIG9mIHB1YmxpYyBrZXkgaW4gYnl0ZXNcbiAqL1xuY29uc3QgUFVCTElDX0tFWV9MRU5HVEggPSAzMjtcblxuLyoqXG4gKiBWYWx1ZSB0byBiZSBjb252ZXJ0ZWQgaW50byBwdWJsaWMga2V5XG4gKi9cblxuLyoqXG4gKiBKU09OIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBQdWJsaWNLZXkgY2xhc3NcbiAqL1xuXG5mdW5jdGlvbiBpc1B1YmxpY0tleURhdGEodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLl9ibiAhPT0gdW5kZWZpbmVkO1xufVxuXG4vLyBsb2NhbCBjb3VudGVyIHVzZWQgYnkgUHVibGljS2V5LnVuaXF1ZSgpXG5sZXQgdW5pcXVlUHVibGljS2V5Q291bnRlciA9IDE7XG5cbi8qKlxuICogQSBwdWJsaWMga2V5XG4gKi9cbmNsYXNzIFB1YmxpY0tleSBleHRlbmRzIFN0cnVjdCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUHVibGljS2V5IG9iamVjdFxuICAgKiBAcGFyYW0gdmFsdWUgZWQyNTUxOSBwdWJsaWMga2V5IGFzIGJ1ZmZlciBvciBiYXNlLTU4IGVuY29kZWQgc3RyaW5nXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKHt9KTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fYm4gPSB2b2lkIDA7XG4gICAgaWYgKGlzUHVibGljS2V5RGF0YSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX2JuID0gdmFsdWUuX2JuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBhc3N1bWUgYmFzZSA1OCBlbmNvZGluZyBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBiczU4LmRlY29kZSh2YWx1ZSk7XG4gICAgICAgIGlmIChkZWNvZGVkLmxlbmd0aCAhPSBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMga2V5IGlucHV0YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYm4gPSBuZXcgQk4oZGVjb2RlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ibiA9IG5ldyBCTih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fYm4uYnl0ZUxlbmd0aCgpID4gUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyBrZXkgaW5wdXRgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHVuaXF1ZSBQdWJsaWNLZXkgZm9yIHRlc3RzIGFuZCBiZW5jaG1hcmtzIHVzaW5nIGEgY291bnRlclxuICAgKi9cbiAgc3RhdGljIHVuaXF1ZSgpIHtcbiAgICBjb25zdCBrZXkgPSBuZXcgUHVibGljS2V5KHVuaXF1ZVB1YmxpY0tleUNvdW50ZXIpO1xuICAgIHVuaXF1ZVB1YmxpY0tleUNvdW50ZXIgKz0gMTtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShrZXkudG9CdWZmZXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBwdWJsaWMga2V5IHZhbHVlLiBUaGUgYmFzZTU4LWVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGlzIGFsbCBvbmVzIChhcyBzZWVuIGJlbG93KVxuICAgKiBUaGUgdW5kZXJseWluZyBCTiBudW1iZXIgaXMgMzIgYnl0ZXMgdGhhdCBhcmUgYWxsIHplcm9zXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdHdvIHB1YmxpY0tleXMgYXJlIGVxdWFsXG4gICAqL1xuICBlcXVhbHMocHVibGljS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2JuLmVxKHB1YmxpY0tleS5fYm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYmFzZS01OCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgKi9cbiAgdG9CYXNlNTgoKSB7XG4gICAgcmV0dXJuIGJzNTguZW5jb2RlKHRoaXMudG9CeXRlcygpKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CYXNlNTgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJ5dGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXkgaW4gYmlnIGVuZGlhblxuICAgKi9cbiAgdG9CeXRlcygpIHtcbiAgICBjb25zdCBidWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBCdWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXkgaW4gYmlnIGVuZGlhblxuICAgKi9cbiAgdG9CdWZmZXIoKSB7XG4gICAgY29uc3QgYiA9IHRoaXMuX2JuLnRvQXJyYXlMaWtlKEJ1ZmZlcik7XG4gICAgaWYgKGIubGVuZ3RoID09PSBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGNvbnN0IHplcm9QYWQgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICAgIGIuY29weSh6ZXJvUGFkLCAzMiAtIGIubGVuZ3RoKTtcbiAgICByZXR1cm4gemVyb1BhZDtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIGBQdWJsaWNLZXkoJHt0aGlzLnRvU3RyaW5nKCl9KWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBiYXNlLTU4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50b0Jhc2U1OCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZSBhIHB1YmxpYyBrZXkgZnJvbSBhbm90aGVyIGtleSwgYSBzZWVkLCBhbmQgYSBwcm9ncmFtIElELlxuICAgKiBUaGUgcHJvZ3JhbSBJRCB3aWxsIGFsc28gc2VydmUgYXMgdGhlIG93bmVyIG9mIHRoZSBwdWJsaWMga2V5LCBnaXZpbmdcbiAgICogaXQgcGVybWlzc2lvbiB0byB3cml0ZSBkYXRhIHRvIHRoZSBhY2NvdW50LlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hd2FpdCAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlV2l0aFNlZWQoZnJvbVB1YmxpY0tleSwgc2VlZCwgcHJvZ3JhbUlkKSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbZnJvbVB1YmxpY0tleS50b0J1ZmZlcigpLCBCdWZmZXIuZnJvbShzZWVkKSwgcHJvZ3JhbUlkLnRvQnVmZmVyKCldKTtcbiAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IHNoYTI1NihidWZmZXIpO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBwcm9ncmFtIGFkZHJlc3MgZnJvbSBzZWVkcyBhbmQgYSBwcm9ncmFtIElELlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hd2FpdCAqL1xuICBzdGF0aWMgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICBsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIHNlZWRzLmZvckVhY2goZnVuY3Rpb24gKHNlZWQpIHtcbiAgICAgIGlmIChzZWVkLmxlbmd0aCA+IE1BWF9TRUVEX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNYXggc2VlZCBsZW5ndGggZXhjZWVkZWRgKTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgdG9CdWZmZXIoc2VlZCldKTtcbiAgICB9KTtcbiAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIHByb2dyYW1JZC50b0J1ZmZlcigpLCBCdWZmZXIuZnJvbSgnUHJvZ3JhbURlcml2ZWRBZGRyZXNzJyldKTtcbiAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IHNoYTI1NihidWZmZXIpO1xuICAgIGlmIChpc09uQ3VydmUocHVibGljS2V5Qnl0ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VlZHMsIGFkZHJlc3MgbXVzdCBmYWxsIG9mZiB0aGUgY3VydmVgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocHVibGljS2V5Qnl0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jIHZlcnNpb24gb2YgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jXG4gICAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGNyZWF0ZVByb2dyYW1BZGRyZXNzU3luY30gaW5zdGVhZFxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hd2FpdCAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlUHJvZ3JhbUFkZHJlc3Moc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGEgdmFsaWQgcHJvZ3JhbSBhZGRyZXNzXG4gICAqXG4gICAqIFZhbGlkIHByb2dyYW0gYWRkcmVzc2VzIG11c3QgZmFsbCBvZmYgdGhlIGVkMjU1MTkgY3VydmUuICBUaGlzIGZ1bmN0aW9uXG4gICAqIGl0ZXJhdGVzIGEgbm9uY2UgdW50aWwgaXQgZmluZHMgb25lIHRoYXQgd2hlbiBjb21iaW5lZCB3aXRoIHRoZSBzZWVkc1xuICAgKiByZXN1bHRzIGluIGEgdmFsaWQgcHJvZ3JhbSBhZGRyZXNzLlxuICAgKi9cbiAgc3RhdGljIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIGxldCBub25jZSA9IDI1NTtcbiAgICBsZXQgYWRkcmVzcztcbiAgICB3aGlsZSAobm9uY2UgIT0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2VlZHNXaXRoTm9uY2UgPSBzZWVkcy5jb25jYXQoQnVmZmVyLmZyb20oW25vbmNlXSkpO1xuICAgICAgICBhZGRyZXNzID0gdGhpcy5jcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHNXaXRoTm9uY2UsIHByb2dyYW1JZCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBub25jZS0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbYWRkcmVzcywgbm9uY2VdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGEgdmlhYmxlIHByb2dyYW0gYWRkcmVzcyBub25jZWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jIHZlcnNpb24gb2YgZmluZFByb2dyYW1BZGRyZXNzU3luY1xuICAgKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZmluZFByb2dyYW1BZGRyZXNzKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoYXQgYSBwdWJrZXkgaXMgb24gdGhlIGVkMjU1MTkgY3VydmUuXG4gICAqL1xuICBzdGF0aWMgaXNPbkN1cnZlKHB1YmtleURhdGEpIHtcbiAgICBjb25zdCBwdWJrZXkgPSBuZXcgUHVibGljS2V5KHB1YmtleURhdGEpO1xuICAgIHJldHVybiBpc09uQ3VydmUocHVia2V5LnRvQnl0ZXMoKSk7XG4gIH1cbn1cbl9QdWJsaWNLZXkgPSBQdWJsaWNLZXk7XG5QdWJsaWNLZXkuZGVmYXVsdCA9IG5ldyBfUHVibGljS2V5KCcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuU09MQU5BX1NDSEVNQS5zZXQoUHVibGljS2V5LCB7XG4gIGtpbmQ6ICdzdHJ1Y3QnLFxuICBmaWVsZHM6IFtbJ19ibicsICd1MjU2J11dXG59KTtcblxuLyoqXG4gKiBBbiBhY2NvdW50IGtleSBwYWlyIChwdWJsaWMgYW5kIHNlY3JldCBrZXlzKS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2MS4xMC4wLCBwbGVhc2UgdXNlIHtAbGluayBLZXlwYWlyfSBpbnN0ZWFkLlxuICovXG5jbGFzcyBBY2NvdW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBY2NvdW50IG9iamVjdFxuICAgKlxuICAgKiBJZiB0aGUgc2VjcmV0S2V5IHBhcmFtZXRlciBpcyBub3QgcHJvdmlkZWQgYSBuZXcga2V5IHBhaXIgaXMgcmFuZG9tbHlcbiAgICogY3JlYXRlZCBmb3IgdGhlIGFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIHNlY3JldEtleSBTZWNyZXQga2V5IGZvciB0aGUgYWNjb3VudFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2VjcmV0S2V5KSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc2VjcmV0S2V5ID0gdm9pZCAwO1xuICAgIGlmIChzZWNyZXRLZXkpIHtcbiAgICAgIGNvbnN0IHNlY3JldEtleUJ1ZmZlciA9IHRvQnVmZmVyKHNlY3JldEtleSk7XG4gICAgICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wdWJsaWNLZXkgPSBzZWNyZXRLZXlCdWZmZXIuc2xpY2UoMzIsIDY0KTtcbiAgICAgIHRoaXMuX3NlY3JldEtleSA9IHNlY3JldEtleUJ1ZmZlci5zbGljZSgwLCAzMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NlY3JldEtleSA9IHRvQnVmZmVyKGdlbmVyYXRlUHJpdmF0ZUtleSgpKTtcbiAgICAgIHRoaXMuX3B1YmxpY0tleSA9IHRvQnVmZmVyKGdldFB1YmxpY0tleSh0aGlzLl9zZWNyZXRLZXkpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgZm9yIHRoaXMgYWNjb3VudFxuICAgKi9cbiAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleSh0aGlzLl9wdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSAqKnVuZW5jcnlwdGVkKiogc2VjcmV0IGtleSBmb3IgdGhpcyBhY2NvdW50LiBUaGUgZmlyc3QgMzIgYnl0ZXNcbiAgICogaXMgdGhlIHByaXZhdGUgc2NhbGFyIGFuZCB0aGUgbGFzdCAzMiBieXRlcyBpcyB0aGUgcHVibGljIGtleS5cbiAgICogUmVhZCBtb3JlOiBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2FybmVyLzIwMTEvMTEvMjkvZWQyNTUxOS1rZXlzL1xuICAgKi9cbiAgZ2V0IHNlY3JldEtleSgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdGhpcy5fc2VjcmV0S2V5LCB0aGlzLl9wdWJsaWNLZXldLCA2NCk7XG4gIH1cbn1cblxuY29uc3QgQlBGX0xPQURFUl9ERVBSRUNBVEVEX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KCdCUEZMb2FkZXIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogTWF4aW11bSBvdmVyLXRoZS13aXJlIHNpemUgb2YgYSBUcmFuc2FjdGlvblxuICpcbiAqIDEyODAgaXMgSVB2NiBtaW5pbXVtIE1UVVxuICogNDAgYnl0ZXMgaXMgdGhlIHNpemUgb2YgdGhlIElQdjYgaGVhZGVyXG4gKiA4IGJ5dGVzIGlzIHRoZSBzaXplIG9mIHRoZSBmcmFnbWVudCBoZWFkZXJcbiAqL1xuY29uc3QgUEFDS0VUX0RBVEFfU0laRSA9IDEyODAgLSA0MCAtIDg7XG5jb25zdCBWRVJTSU9OX1BSRUZJWF9NQVNLID0gMHg3ZjtcbmNvbnN0IFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMgPSA2NDtcblxuY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUpIHtcbiAgICBzdXBlcihgU2lnbmF0dXJlICR7c2lnbmF0dXJlfSBoYXMgZXhwaXJlZDogYmxvY2sgaGVpZ2h0IGV4Y2VlZGVkLmApO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdm9pZCAwO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yJ1xufSk7XG5jbGFzcyBUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSwgdGltZW91dFNlY29uZHMpIHtcbiAgICBzdXBlcihgVHJhbnNhY3Rpb24gd2FzIG5vdCBjb25maXJtZWQgaW4gJHt0aW1lb3V0U2Vjb25kcy50b0ZpeGVkKDIpfSBzZWNvbmRzLiBJdCBpcyBgICsgJ3Vua25vd24gaWYgaXQgc3VjY2VlZGVkIG9yIGZhaWxlZC4gQ2hlY2sgc2lnbmF0dXJlICcgKyBgJHtzaWduYXR1cmV9IHVzaW5nIHRoZSBTb2xhbmEgRXhwbG9yZXIgb3IgQ0xJIHRvb2xzLmApO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdm9pZCAwO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yJ1xufSk7XG5jbGFzcyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlKSB7XG4gICAgc3VwZXIoYFNpZ25hdHVyZSAke3NpZ25hdHVyZX0gaGFzIGV4cGlyZWQ6IHRoZSBub25jZSBpcyBubyBsb25nZXIgdmFsaWQuYCk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yJ1xufSk7XG5cbmNsYXNzIE1lc3NhZ2VBY2NvdW50S2V5cyB7XG4gIGNvbnN0cnVjdG9yKHN0YXRpY0FjY291bnRLZXlzLCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzKSB7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IHN0YXRpY0FjY291bnRLZXlzO1xuICAgIHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IGFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gIH1cbiAga2V5U2VnbWVudHMoKSB7XG4gICAgY29uc3Qga2V5U2VnbWVudHMgPSBbdGhpcy5zdGF0aWNBY2NvdW50S2V5c107XG4gICAgaWYgKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgICAga2V5U2VnbWVudHMucHVzaCh0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUpO1xuICAgICAga2V5U2VnbWVudHMucHVzaCh0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5U2VnbWVudHM7XG4gIH1cbiAgZ2V0KGluZGV4KSB7XG4gICAgZm9yIChjb25zdCBrZXlTZWdtZW50IG9mIHRoaXMua2V5U2VnbWVudHMoKSkge1xuICAgICAgaWYgKGluZGV4IDwga2V5U2VnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGtleVNlZ21lbnRbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggLT0ga2V5U2VnbWVudC5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmtleVNlZ21lbnRzKCkuZmxhdCgpLmxlbmd0aDtcbiAgfVxuICBjb21waWxlSW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucykge1xuICAgIC8vIEJhaWwgZWFybHkgaWYgYW55IGFjY291bnQgaW5kZXhlcyB3b3VsZCBvdmVyZmxvdyBhIHU4XG4gICAgY29uc3QgVThfTUFYID0gMjU1O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IFU4X01BWCArIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBpbmRleCBvdmVyZmxvdyBlbmNvdW50ZXJlZCBkdXJpbmcgY29tcGlsYXRpb24nKTtcbiAgICB9XG4gICAgY29uc3Qga2V5SW5kZXhNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5rZXlTZWdtZW50cygpLmZsYXQoKS5mb3JFYWNoKChrZXksIGluZGV4KSA9PiB7XG4gICAgICBrZXlJbmRleE1hcC5zZXQoa2V5LnRvQmFzZTU4KCksIGluZGV4KTtcbiAgICB9KTtcbiAgICBjb25zdCBmaW5kS2V5SW5kZXggPSBrZXkgPT4ge1xuICAgICAgY29uc3Qga2V5SW5kZXggPSBrZXlJbmRleE1hcC5nZXQoa2V5LnRvQmFzZTU4KCkpO1xuICAgICAgaWYgKGtleUluZGV4ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignRW5jb3VudGVyZWQgYW4gdW5rbm93biBpbnN0cnVjdGlvbiBhY2NvdW50IGtleSBkdXJpbmcgY29tcGlsYXRpb24nKTtcbiAgICAgIHJldHVybiBrZXlJbmRleDtcbiAgICB9O1xuICAgIHJldHVybiBpbnN0cnVjdGlvbnMubWFwKGluc3RydWN0aW9uID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBmaW5kS2V5SW5kZXgoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKSxcbiAgICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGluc3RydWN0aW9uLmtleXMubWFwKG1ldGEgPT4gZmluZEtleUluZGV4KG1ldGEucHVia2V5KSksXG4gICAgICAgIGRhdGE6IGluc3RydWN0aW9uLmRhdGFcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgcHVibGljIGtleVxuICovXG5jb25zdCBwdWJsaWNLZXkgPSAocHJvcGVydHkgPSAncHVibGljS2V5JykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LmJsb2IoMzIsIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIHNpZ25hdHVyZVxuICovXG5jb25zdCBzaWduYXR1cmUgPSAocHJvcGVydHkgPSAnc2lnbmF0dXJlJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LmJsb2IoNjQsIHByb3BlcnR5KTtcbn07XG4vKipcbiAqIExheW91dCBmb3IgYSBSdXN0IFN0cmluZyB0eXBlXG4gKi9cbmNvbnN0IHJ1c3RTdHJpbmcgPSAocHJvcGVydHkgPSAnc3RyaW5nJykgPT4ge1xuICBjb25zdCByc2wgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdsZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnUzMignbGVuZ3RoUGFkZGluZycpLCBCdWZmZXJMYXlvdXQuYmxvYihCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnY2hhcnMnKV0sIHByb3BlcnR5KTtcbiAgY29uc3QgX2RlY29kZSA9IHJzbC5kZWNvZGUuYmluZChyc2wpO1xuICBjb25zdCBfZW5jb2RlID0gcnNsLmVuY29kZS5iaW5kKHJzbCk7XG4gIGNvbnN0IHJzbFNoaW0gPSByc2w7XG4gIHJzbFNoaW0uZGVjb2RlID0gKGIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBfZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgcmV0dXJuIGRhdGFbJ2NoYXJzJ10udG9TdHJpbmcoKTtcbiAgfTtcbiAgcnNsU2hpbS5lbmNvZGUgPSAoc3RyLCBiLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgY2hhcnM6IEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKVxuICAgIH07XG4gICAgcmV0dXJuIF9lbmNvZGUoZGF0YSwgYiwgb2Zmc2V0KTtcbiAgfTtcbiAgcnNsU2hpbS5hbGxvYyA9IHN0ciA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlckxheW91dC51MzIoKS5zcGFuICsgQnVmZmVyTGF5b3V0LnUzMigpLnNwYW4gKyBCdWZmZXIuZnJvbShzdHIsICd1dGY4JykubGVuZ3RoO1xuICB9O1xuICByZXR1cm4gcnNsU2hpbTtcbn07XG5cbi8qKlxuICogTGF5b3V0IGZvciBhbiBBdXRob3JpemVkIG9iamVjdFxuICovXG5jb25zdCBhdXRob3JpemVkID0gKHByb3BlcnR5ID0gJ2F1dGhvcml6ZWQnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ3N0YWtlcicpLCBwdWJsaWNLZXkoJ3dpdGhkcmF3ZXInKV0sIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIExvY2t1cCBvYmplY3RcbiAqL1xuY29uc3QgbG9ja3VwID0gKHByb3BlcnR5ID0gJ2xvY2t1cCcpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5uczY0KCd1bml4VGltZXN0YW1wJyksIEJ1ZmZlckxheW91dC5uczY0KCdlcG9jaCcpLCBwdWJsaWNLZXkoJ2N1c3RvZGlhbicpXSwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiAgTGF5b3V0IGZvciBhIFZvdGVJbml0IG9iamVjdFxuICovXG5jb25zdCB2b3RlSW5pdCA9IChwcm9wZXJ0eSA9ICd2b3RlSW5pdCcpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnbm9kZVB1YmtleScpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRWb3RlcicpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRXaXRoZHJhd2VyJyksIEJ1ZmZlckxheW91dC51OCgnY29tbWlzc2lvbicpXSwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiAgTGF5b3V0IGZvciBhIFZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3Mgb2JqZWN0XG4gKi9cbmNvbnN0IHZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MgPSAocHJvcGVydHkgPSAndm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncycpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ3ZvdGVBdXRob3JpemF0aW9uVHlwZScpLCBwdWJsaWNLZXkoJ2N1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXknKSwgcnVzdFN0cmluZygnY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpXSwgcHJvcGVydHkpO1xufTtcbmZ1bmN0aW9uIGdldEFsbG9jKHR5cGUsIGZpZWxkcykge1xuICBjb25zdCBnZXRJdGVtQWxsb2MgPSBpdGVtID0+IHtcbiAgICBpZiAoaXRlbS5zcGFuID49IDApIHtcbiAgICAgIHJldHVybiBpdGVtLnNwYW47XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbS5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZW0uYWxsb2MoZmllbGRzW2l0ZW0ucHJvcGVydHldKTtcbiAgICB9IGVsc2UgaWYgKCdjb3VudCcgaW4gaXRlbSAmJiAnZWxlbWVudExheW91dCcgaW4gaXRlbSkge1xuICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNbaXRlbS5wcm9wZXJ0eV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLmxlbmd0aCAqIGdldEl0ZW1BbGxvYyhpdGVtLmVsZW1lbnRMYXlvdXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJ2ZpZWxkcycgaW4gaXRlbSkge1xuICAgICAgLy8gVGhpcyBpcyBhIGBTdHJ1Y3R1cmVgIHdob3NlIHNpemUgbmVlZHMgdG8gYmUgcmVjdXJzaXZlbHkgbWVhc3VyZWQuXG4gICAgICByZXR1cm4gZ2V0QWxsb2Moe1xuICAgICAgICBsYXlvdXQ6IGl0ZW1cbiAgICAgIH0sIGZpZWxkc1tpdGVtLnByb3BlcnR5XSk7XG4gICAgfVxuICAgIC8vIENvdWxkbid0IGRldGVybWluZSBhbGxvY2F0ZWQgc2l6ZSBvZiBsYXlvdXRcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgbGV0IGFsbG9jID0gMDtcbiAgdHlwZS5sYXlvdXQuZmllbGRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgYWxsb2MgKz0gZ2V0SXRlbUFsbG9jKGl0ZW0pO1xuICB9KTtcbiAgcmV0dXJuIGFsbG9jO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVMZW5ndGgoYnl0ZXMpIHtcbiAgbGV0IGxlbiA9IDA7XG4gIGxldCBzaXplID0gMDtcbiAgZm9yICg7Oykge1xuICAgIGxldCBlbGVtID0gYnl0ZXMuc2hpZnQoKTtcbiAgICBsZW4gfD0gKGVsZW0gJiAweDdmKSA8PCBzaXplICogNztcbiAgICBzaXplICs9IDE7XG4gICAgaWYgKChlbGVtICYgMHg4MCkgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuO1xufVxuZnVuY3Rpb24gZW5jb2RlTGVuZ3RoKGJ5dGVzLCBsZW4pIHtcbiAgbGV0IHJlbV9sZW4gPSBsZW47XG4gIGZvciAoOzspIHtcbiAgICBsZXQgZWxlbSA9IHJlbV9sZW4gJiAweDdmO1xuICAgIHJlbV9sZW4gPj49IDc7XG4gICAgaWYgKHJlbV9sZW4gPT0gMCkge1xuICAgICAgYnl0ZXMucHVzaChlbGVtKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtIHw9IDB4ODA7XG4gICAgICBieXRlcy5wdXNoKGVsZW0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cbn1cblxuY2xhc3MgQ29tcGlsZWRLZXlzIHtcbiAgY29uc3RydWN0b3IocGF5ZXIsIGtleU1ldGFNYXApIHtcbiAgICB0aGlzLnBheWVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5TWV0YU1hcCA9IHZvaWQgMDtcbiAgICB0aGlzLnBheWVyID0gcGF5ZXI7XG4gICAgdGhpcy5rZXlNZXRhTWFwID0ga2V5TWV0YU1hcDtcbiAgfVxuICBzdGF0aWMgY29tcGlsZShpbnN0cnVjdGlvbnMsIHBheWVyKSB7XG4gICAgY29uc3Qga2V5TWV0YU1hcCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBnZXRPckluc2VydERlZmF1bHQgPSBwdWJrZXkgPT4ge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHB1YmtleS50b0Jhc2U1OCgpO1xuICAgICAgbGV0IGtleU1ldGEgPSBrZXlNZXRhTWFwLmdldChhZGRyZXNzKTtcbiAgICAgIGlmIChrZXlNZXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5TWV0YSA9IHtcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgaXNJbnZva2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBrZXlNZXRhTWFwLnNldChhZGRyZXNzLCBrZXlNZXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlNZXRhO1xuICAgIH07XG4gICAgY29uc3QgcGF5ZXJLZXlNZXRhID0gZ2V0T3JJbnNlcnREZWZhdWx0KHBheWVyKTtcbiAgICBwYXllcktleU1ldGEuaXNTaWduZXIgPSB0cnVlO1xuICAgIHBheWVyS2V5TWV0YS5pc1dyaXRhYmxlID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGl4IG9mIGluc3RydWN0aW9ucykge1xuICAgICAgZ2V0T3JJbnNlcnREZWZhdWx0KGl4LnByb2dyYW1JZCkuaXNJbnZva2VkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgYWNjb3VudE1ldGEgb2YgaXgua2V5cykge1xuICAgICAgICBjb25zdCBrZXlNZXRhID0gZ2V0T3JJbnNlcnREZWZhdWx0KGFjY291bnRNZXRhLnB1YmtleSk7XG4gICAgICAgIGtleU1ldGEuaXNTaWduZXIgfHw9IGFjY291bnRNZXRhLmlzU2lnbmVyO1xuICAgICAgICBrZXlNZXRhLmlzV3JpdGFibGUgfHw9IGFjY291bnRNZXRhLmlzV3JpdGFibGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29tcGlsZWRLZXlzKHBheWVyLCBrZXlNZXRhTWFwKTtcbiAgfVxuICBnZXRNZXNzYWdlQ29tcG9uZW50cygpIHtcbiAgICBjb25zdCBtYXBFbnRyaWVzID0gWy4uLnRoaXMua2V5TWV0YU1hcC5lbnRyaWVzKCldO1xuICAgIGFzc2VydChtYXBFbnRyaWVzLmxlbmd0aCA8PSAyNTYsICdNYXggc3RhdGljIGFjY291bnQga2V5cyBsZW5ndGggZXhjZWVkZWQnKTtcbiAgICBjb25zdCB3cml0YWJsZVNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+IG1ldGEuaXNTaWduZXIgJiYgbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCByZWFkb25seVNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+IG1ldGEuaXNTaWduZXIgJiYgIW1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3Qgd3JpdGFibGVOb25TaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiAhbWV0YS5pc1NpZ25lciAmJiBtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IHJlYWRvbmx5Tm9uU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gIW1ldGEuaXNTaWduZXIgJiYgIW1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgaGVhZGVyID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiB3cml0YWJsZVNpZ25lcnMubGVuZ3RoICsgcmVhZG9ubHlTaWduZXJzLmxlbmd0aCxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IHJlYWRvbmx5U2lnbmVycy5sZW5ndGgsXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IHJlYWRvbmx5Tm9uU2lnbmVycy5sZW5ndGhcbiAgICB9O1xuXG4gICAgLy8gc2FuaXR5IGNoZWNrc1xuICAgIHtcbiAgICAgIGFzc2VydCh3cml0YWJsZVNpZ25lcnMubGVuZ3RoID4gMCwgJ0V4cGVjdGVkIGF0IGxlYXN0IG9uZSB3cml0YWJsZSBzaWduZXIga2V5Jyk7XG4gICAgICBjb25zdCBbcGF5ZXJBZGRyZXNzXSA9IHdyaXRhYmxlU2lnbmVyc1swXTtcbiAgICAgIGFzc2VydChwYXllckFkZHJlc3MgPT09IHRoaXMucGF5ZXIudG9CYXNlNTgoKSwgJ0V4cGVjdGVkIGZpcnN0IHdyaXRhYmxlIHNpZ25lciBrZXkgdG8gYmUgdGhlIGZlZSBwYXllcicpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5cyA9IFsuLi53cml0YWJsZVNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLCAuLi5yZWFkb25seVNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLCAuLi53cml0YWJsZU5vblNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLCAuLi5yZWFkb25seU5vblNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpXTtcbiAgICByZXR1cm4gW2hlYWRlciwgc3RhdGljQWNjb3VudEtleXNdO1xuICB9XG4gIGV4dHJhY3RUYWJsZUxvb2t1cChsb29rdXBUYWJsZSkge1xuICAgIGNvbnN0IFt3cml0YWJsZUluZGV4ZXMsIGRyYWluZWRXcml0YWJsZUtleXNdID0gdGhpcy5kcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUobG9va3VwVGFibGUuc3RhdGUuYWRkcmVzc2VzLCBrZXlNZXRhID0+ICFrZXlNZXRhLmlzU2lnbmVyICYmICFrZXlNZXRhLmlzSW52b2tlZCAmJiBrZXlNZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IFtyZWFkb25seUluZGV4ZXMsIGRyYWluZWRSZWFkb25seUtleXNdID0gdGhpcy5kcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUobG9va3VwVGFibGUuc3RhdGUuYWRkcmVzc2VzLCBrZXlNZXRhID0+ICFrZXlNZXRhLmlzU2lnbmVyICYmICFrZXlNZXRhLmlzSW52b2tlZCAmJiAha2V5TWV0YS5pc1dyaXRhYmxlKTtcblxuICAgIC8vIERvbid0IGV4dHJhY3QgbG9va3VwIGlmIG5vIGtleXMgd2VyZSBmb3VuZFxuICAgIGlmICh3cml0YWJsZUluZGV4ZXMubGVuZ3RoID09PSAwICYmIHJlYWRvbmx5SW5kZXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIFt7XG4gICAgICBhY2NvdW50S2V5OiBsb29rdXBUYWJsZS5rZXksXG4gICAgICB3cml0YWJsZUluZGV4ZXMsXG4gICAgICByZWFkb25seUluZGV4ZXNcbiAgICB9LCB7XG4gICAgICB3cml0YWJsZTogZHJhaW5lZFdyaXRhYmxlS2V5cyxcbiAgICAgIHJlYWRvbmx5OiBkcmFpbmVkUmVhZG9ubHlLZXlzXG4gICAgfV07XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZUVudHJpZXMsIGtleU1ldGFGaWx0ZXIpIHtcbiAgICBjb25zdCBsb29rdXBUYWJsZUluZGV4ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBkcmFpbmVkS2V5cyA9IG5ldyBBcnJheSgpO1xuICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIGtleU1ldGFdIG9mIHRoaXMua2V5TWV0YU1hcC5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChrZXlNZXRhRmlsdGVyKGtleU1ldGEpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBQdWJsaWNLZXkoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IGxvb2t1cFRhYmxlSW5kZXggPSBsb29rdXBUYWJsZUVudHJpZXMuZmluZEluZGV4KGVudHJ5ID0+IGVudHJ5LmVxdWFscyhrZXkpKTtcbiAgICAgICAgaWYgKGxvb2t1cFRhYmxlSW5kZXggPj0gMCkge1xuICAgICAgICAgIGFzc2VydChsb29rdXBUYWJsZUluZGV4IDwgMjU2LCAnTWF4IGxvb2t1cCB0YWJsZSBpbmRleCBleGNlZWRlZCcpO1xuICAgICAgICAgIGxvb2t1cFRhYmxlSW5kZXhlcy5wdXNoKGxvb2t1cFRhYmxlSW5kZXgpO1xuICAgICAgICAgIGRyYWluZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICB0aGlzLmtleU1ldGFNYXAuZGVsZXRlKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbG9va3VwVGFibGVJbmRleGVzLCBkcmFpbmVkS2V5c107XG4gIH1cbn1cblxuY29uc3QgRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFID0gJ1JlYWNoZWQgZW5kIG9mIGJ1ZmZlciB1bmV4cGVjdGVkbHknO1xuXG4vKipcbiAqIERlbGVnYXRlcyB0byBgQXJyYXkjc2hpZnRgLCBidXQgdGhyb3dzIGlmIHRoZSBhcnJheSBpcyB6ZXJvLWxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSkge1xuICBpZiAoYnl0ZUFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXkuc2hpZnQoKTtcbn1cblxuLyoqXG4gKiBEZWxlZ2F0ZXMgdG8gYEFycmF5I3NwbGljZWAsIGJ1dCB0aHJvd3MgaWYgdGhlIHNlY3Rpb24gYmVpbmcgc3BsaWNlZCBvdXQgZXh0ZW5kcyBwYXN0IHRoZSBlbmQgb2ZcbiAqIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIC4uLmFyZ3MpIHtcbiAgY29uc3QgW3N0YXJ0XSA9IGFyZ3M7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMiAvLyBJbXBsaWVzIHRoYXQgYGRlbGV0ZUNvdW50YCB3YXMgc3VwcGxpZWRcbiAgPyBzdGFydCArIChhcmdzWzFdID8/IDApID4gYnl0ZUFycmF5Lmxlbmd0aCA6IHN0YXJ0ID49IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5LnNwbGljZSguLi5hcmdzKTtcbn1cblxuLyoqXG4gKiBBbiBpbnN0cnVjdGlvbiB0byBleGVjdXRlIGJ5IGEgcHJvZ3JhbVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9ncmFtSWRJbmRleFxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gYWNjb3VudHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkYXRhXG4gKi9cblxuLyoqXG4gKiBNZXNzYWdlIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBpbnN0cnVjdGlvbnMgdG8gYmUgcHJvY2Vzc2VkIGF0b21pY2FsbHlcbiAqL1xuY2xhc3MgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmhlYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmFjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5oZWFkZXIgPSBhcmdzLmhlYWRlcjtcbiAgICB0aGlzLmFjY291bnRLZXlzID0gYXJncy5hY2NvdW50S2V5cy5tYXAoYWNjb3VudCA9PiBuZXcgUHVibGljS2V5KGFjY291bnQpKTtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGFyZ3MucmVjZW50QmxvY2toYXNoO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gYXJncy5pbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMuZm9yRWFjaChpeCA9PiB0aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnNldChpeC5wcm9ncmFtSWRJbmRleCwgdGhpcy5hY2NvdW50S2V5c1tpeC5wcm9ncmFtSWRJbmRleF0pKTtcbiAgfVxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gJ2xlZ2FjeSc7XG4gIH1cbiAgZ2V0IHN0YXRpY0FjY291bnRLZXlzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzO1xuICB9XG4gIGdldCBjb21waWxlZEluc3RydWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnMubWFwKGl4ID0+ICh7XG4gICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICBhY2NvdW50S2V5SW5kZXhlczogaXguYWNjb3VudHMsXG4gICAgICBkYXRhOiBiczU4LmRlY29kZShpeC5kYXRhKVxuICAgIH0pKTtcbiAgfVxuICBnZXQgYWRkcmVzc1RhYmxlTG9va3VwcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0QWNjb3VudEtleXMoKSB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlQWNjb3VudEtleXModGhpcy5zdGF0aWNBY2NvdW50S2V5cyk7XG4gIH1cbiAgc3RhdGljIGNvbXBpbGUoYXJncykge1xuICAgIGNvbnN0IGNvbXBpbGVkS2V5cyA9IENvbXBpbGVkS2V5cy5jb21waWxlKGFyZ3MuaW5zdHJ1Y3Rpb25zLCBhcmdzLnBheWVyS2V5KTtcbiAgICBjb25zdCBbaGVhZGVyLCBzdGF0aWNBY2NvdW50S2V5c10gPSBjb21waWxlZEtleXMuZ2V0TWVzc2FnZUNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IG5ldyBNZXNzYWdlQWNjb3VudEtleXMoc3RhdGljQWNjb3VudEtleXMpO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IGFjY291bnRLZXlzLmNvbXBpbGVJbnN0cnVjdGlvbnMoYXJncy5pbnN0cnVjdGlvbnMpLm1hcChpeCA9PiAoe1xuICAgICAgcHJvZ3JhbUlkSW5kZXg6IGl4LnByb2dyYW1JZEluZGV4LFxuICAgICAgYWNjb3VudHM6IGl4LmFjY291bnRLZXlJbmRleGVzLFxuICAgICAgZGF0YTogYnM1OC5lbmNvZGUoaXguZGF0YSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKHtcbiAgICAgIGhlYWRlcixcbiAgICAgIGFjY291bnRLZXlzOiBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYXJncy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnNcbiAgICB9KTtcbiAgfVxuICBpc0FjY291bnRTaWduZXIoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPCB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gIH1cbiAgaXNBY2NvdW50V3JpdGFibGUoaW5kZXgpIHtcbiAgICBjb25zdCBudW1TaWduZWRBY2NvdW50cyA9IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCB1bnNpZ25lZEFjY291bnRJbmRleCA9IGluZGV4IC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1VbnNpZ25lZEFjY291bnRzID0gdGhpcy5hY2NvdW50S2V5cy5sZW5ndGggLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA9IG51bVVuc2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gdW5zaWduZWRBY2NvdW50SW5kZXggPCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPSBudW1TaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gaW5kZXggPCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzO1xuICAgIH1cbiAgfVxuICBpc1Byb2dyYW1JZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4VG9Qcm9ncmFtSWRzLmhhcyhpbmRleCk7XG4gIH1cbiAgcHJvZ3JhbUlkcygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuaW5kZXhUb1Byb2dyYW1JZHMudmFsdWVzKCldO1xuICB9XG4gIG5vblByb2dyYW1JZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudEtleXMuZmlsdGVyKChfLCBpbmRleCkgPT4gIXRoaXMuaXNQcm9ncmFtSWQoaW5kZXgpKTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3QgbnVtS2V5cyA9IHRoaXMuYWNjb3VudEtleXMubGVuZ3RoO1xuICAgIGxldCBrZXlDb3VudCA9IFtdO1xuICAgIGVuY29kZUxlbmd0aChrZXlDb3VudCwgbnVtS2V5cyk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnMubWFwKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIHByb2dyYW1JZEluZGV4XG4gICAgICB9ID0gaW5zdHJ1Y3Rpb247XG4gICAgICBjb25zdCBkYXRhID0gQXJyYXkuZnJvbShiczU4LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKSk7XG4gICAgICBsZXQga2V5SW5kaWNlc0NvdW50ID0gW107XG4gICAgICBlbmNvZGVMZW5ndGgoa2V5SW5kaWNlc0NvdW50LCBhY2NvdW50cy5sZW5ndGgpO1xuICAgICAgbGV0IGRhdGFDb3VudCA9IFtdO1xuICAgICAgZW5jb2RlTGVuZ3RoKGRhdGFDb3VudCwgZGF0YS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGtleUluZGljZXNDb3VudDogQnVmZmVyLmZyb20oa2V5SW5kaWNlc0NvdW50KSxcbiAgICAgICAga2V5SW5kaWNlczogYWNjb3VudHMsXG4gICAgICAgIGRhdGFMZW5ndGg6IEJ1ZmZlci5mcm9tKGRhdGFDb3VudCksXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbGV0IGluc3RydWN0aW9uQ291bnQgPSBbXTtcbiAgICBlbmNvZGVMZW5ndGgoaW5zdHJ1Y3Rpb25Db3VudCwgaW5zdHJ1Y3Rpb25zLmxlbmd0aCk7XG4gICAgbGV0IGluc3RydWN0aW9uQnVmZmVyID0gQnVmZmVyLmFsbG9jKFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIEJ1ZmZlci5mcm9tKGluc3RydWN0aW9uQ291bnQpLmNvcHkoaW5zdHJ1Y3Rpb25CdWZmZXIpO1xuICAgIGxldCBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCA9IGluc3RydWN0aW9uQ291bnQubGVuZ3RoO1xuICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdwcm9ncmFtSWRJbmRleCcpLCBCdWZmZXJMYXlvdXQuYmxvYihpbnN0cnVjdGlvbi5rZXlJbmRpY2VzQ291bnQubGVuZ3RoLCAna2V5SW5kaWNlc0NvdW50JyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCdrZXlJbmRleCcpLCBpbnN0cnVjdGlvbi5rZXlJbmRpY2VzLmxlbmd0aCwgJ2tleUluZGljZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoaW5zdHJ1Y3Rpb24uZGF0YUxlbmd0aC5sZW5ndGgsICdkYXRhTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCd1c2VyZGF0dW0nKSwgaW5zdHJ1Y3Rpb24uZGF0YS5sZW5ndGgsICdkYXRhJyldKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGluc3RydWN0aW9uTGF5b3V0LmVuY29kZShpbnN0cnVjdGlvbiwgaW5zdHJ1Y3Rpb25CdWZmZXIsIGluc3RydWN0aW9uQnVmZmVyTGVuZ3RoKTtcbiAgICAgIGluc3RydWN0aW9uQnVmZmVyTGVuZ3RoICs9IGxlbmd0aDtcbiAgICB9KTtcbiAgICBpbnN0cnVjdGlvbkJ1ZmZlciA9IGluc3RydWN0aW9uQnVmZmVyLnNsaWNlKDAsIGluc3RydWN0aW9uQnVmZmVyTGVuZ3RoKTtcbiAgICBjb25zdCBzaWduRGF0YUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5ibG9iKDEsICdudW1SZXF1aXJlZFNpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoMSwgJ251bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoMSwgJ251bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cycpLCBCdWZmZXJMYXlvdXQuYmxvYihrZXlDb3VudC5sZW5ndGgsICdrZXlDb3VudCcpLCBCdWZmZXJMYXlvdXQuc2VxKHB1YmxpY0tleSgna2V5JyksIG51bUtleXMsICdrZXlzJyksIHB1YmxpY0tleSgncmVjZW50QmxvY2toYXNoJyldKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogQnVmZmVyLmZyb20oW3RoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlc10pLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogQnVmZmVyLmZyb20oW3RoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHNdKSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogQnVmZmVyLmZyb20oW3RoaXMuaGVhZGVyLm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50c10pLFxuICAgICAga2V5Q291bnQ6IEJ1ZmZlci5mcm9tKGtleUNvdW50KSxcbiAgICAgIGtleXM6IHRoaXMuYWNjb3VudEtleXMubWFwKGtleSA9PiB0b0J1ZmZlcihrZXkudG9CeXRlcygpKSksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGJzNTguZGVjb2RlKHRoaXMucmVjZW50QmxvY2toYXNoKVxuICAgIH07XG4gICAgbGV0IHNpZ25EYXRhID0gQnVmZmVyLmFsbG9jKDIwNDgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IHNpZ25EYXRhTGF5b3V0LmVuY29kZSh0cmFuc2FjdGlvbiwgc2lnbkRhdGEpO1xuICAgIGluc3RydWN0aW9uQnVmZmVyLmNvcHkoc2lnbkRhdGEsIGxlbmd0aCk7XG4gICAgcmV0dXJuIHNpZ25EYXRhLnNsaWNlKDAsIGxlbmd0aCArIGluc3RydWN0aW9uQnVmZmVyLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgY29tcGlsZWQgbWVzc2FnZSBpbnRvIGEgTWVzc2FnZSBvYmplY3QuXG4gICAqL1xuICBzdGF0aWMgZnJvbShidWZmZXIpIHtcbiAgICAvLyBTbGljZSB1cCB3aXJlIGRhdGFcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLmJ1ZmZlcl07XG4gICAgY29uc3QgbnVtUmVxdWlyZWRTaWduYXR1cmVzID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgaWYgKG51bVJlcXVpcmVkU2lnbmF0dXJlcyAhPT0gKG51bVJlcXVpcmVkU2lnbmF0dXJlcyAmIFZFUlNJT05fUFJFRklYX01BU0spKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnNpb25lZCBtZXNzYWdlcyBtdXN0IGJlIGRlc2VyaWFsaXplZCB3aXRoIFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemUoKScpO1xuICAgIH1cbiAgICBjb25zdCBudW1SZWFkb25seVNpZ25lZEFjY291bnRzID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgY29uc3QgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgY29uc3QgYWNjb3VudENvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgbGV0IGFjY291bnRLZXlzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY2NvdW50Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYWNjb3VudCA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCk7XG4gICAgICBhY2NvdW50S2V5cy5wdXNoKG5ldyBQdWJsaWNLZXkoQnVmZmVyLmZyb20oYWNjb3VudCkpKTtcbiAgICB9XG4gICAgY29uc3QgcmVjZW50QmxvY2toYXNoID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgbGV0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25Db3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm9ncmFtSWRJbmRleCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudENvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50cyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBhY2NvdW50Q291bnQpO1xuICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgZGF0YVNsaWNlID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGRhdGFMZW5ndGgpO1xuICAgICAgY29uc3QgZGF0YSA9IGJzNTguZW5jb2RlKEJ1ZmZlci5mcm9tKGRhdGFTbGljZSkpO1xuICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWRJbmRleCxcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlQXJncyA9IHtcbiAgICAgIGhlYWRlcjoge1xuICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMsXG4gICAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50c1xuICAgICAgfSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYnM1OC5lbmNvZGUoQnVmZmVyLmZyb20ocmVjZW50QmxvY2toYXNoKSksXG4gICAgICBhY2NvdW50S2V5cyxcbiAgICAgIGluc3RydWN0aW9uc1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKG1lc3NhZ2VBcmdzKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgY29uc3RydWN0b3IgYXJndW1lbnRzXG4gKi9cblxuY2xhc3MgTWVzc2FnZVYwIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuaGVhZGVyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDA7XG4gICAgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWFkZXIgPSBhcmdzLmhlYWRlcjtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gYXJncy5zdGF0aWNBY2NvdW50S2V5cztcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGFyZ3MucmVjZW50QmxvY2toYXNoO1xuICAgIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBhcmdzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zO1xuICAgIHRoaXMuYWRkcmVzc1RhYmxlTG9va3VwcyA9IGFyZ3MuYWRkcmVzc1RhYmxlTG9va3VwcztcbiAgfVxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgbnVtQWNjb3VudEtleXNGcm9tTG9va3VwcygpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgbG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY291bnQgKz0gbG9va3VwLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGggKyBsb29rdXAud3JpdGFibGVJbmRleGVzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIGdldEFjY291bnRLZXlzKGFyZ3MpIHtcbiAgICBsZXQgYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgICBpZiAoYXJncyAmJiAnYWNjb3VudEtleXNGcm9tTG9va3VwcycgaW4gYXJncyAmJiBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMpIHtcbiAgICAgIGlmICh0aGlzLm51bUFjY291bnRLZXlzRnJvbUxvb2t1cHMgIT0gYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlLmxlbmd0aCArIGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IGFjY291bnQga2V5cyBiZWNhdXNlIG9mIGEgbWlzbWF0Y2ggaW4gdGhlIG51bWJlciBvZiBhY2NvdW50IGtleXMgZnJvbSBsb29rdXBzJyk7XG4gICAgICB9XG4gICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICAgIH0gZWxzZSBpZiAoYXJncyAmJiAnYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMnIGluIGFyZ3MgJiYgYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cykge1xuICAgICAgYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHRoaXMucmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMoYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IGFjY291bnQga2V5cyBiZWNhdXNlIGFkZHJlc3MgdGFibGUgbG9va3VwcyB3ZXJlIG5vdCByZXNvbHZlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyh0aGlzLnN0YXRpY0FjY291bnRLZXlzLCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzKTtcbiAgfVxuICBpc0FjY291bnRTaWduZXIoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPCB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gIH1cbiAgaXNBY2NvdW50V3JpdGFibGUoaW5kZXgpIHtcbiAgICBjb25zdCBudW1TaWduZWRBY2NvdW50cyA9IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgICBjb25zdCBudW1TdGF0aWNBY2NvdW50S2V5cyA9IHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoO1xuICAgIGlmIChpbmRleCA+PSBudW1TdGF0aWNBY2NvdW50S2V5cykge1xuICAgICAgY29uc3QgbG9va3VwQWNjb3VudEtleXNJbmRleCA9IGluZGV4IC0gbnVtU3RhdGljQWNjb3VudEtleXM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZUxvb2t1cEFjY291bnRLZXlzID0gdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzLnJlZHVjZSgoY291bnQsIGxvb2t1cCkgPT4gY291bnQgKyBsb29rdXAud3JpdGFibGVJbmRleGVzLmxlbmd0aCwgMCk7XG4gICAgICByZXR1cm4gbG9va3VwQWNjb3VudEtleXNJbmRleCA8IG51bVdyaXRhYmxlTG9va3VwQWNjb3VudEtleXM7XG4gICAgfSBlbHNlIGlmIChpbmRleCA+PSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHVuc2lnbmVkQWNjb3VudEluZGV4ID0gaW5kZXggLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgIGNvbnN0IG51bVVuc2lnbmVkQWNjb3VudHMgPSBudW1TdGF0aWNBY2NvdW50S2V5cyAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbnVtVW5zaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiB1bnNpZ25lZEFjY291bnRJbmRleCA8IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA9IG51bVNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiBpbmRleCA8IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHM7XG4gICAgfVxuICB9XG4gIHJlc29sdmVBZGRyZXNzVGFibGVMb29rdXBzKGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgY29uc3QgYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHtcbiAgICAgIHdyaXRhYmxlOiBbXSxcbiAgICAgIHJlYWRvbmx5OiBbXVxuICAgIH07XG4gICAgZm9yIChjb25zdCB0YWJsZUxvb2t1cCBvZiB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMpIHtcbiAgICAgIGNvbnN0IHRhYmxlQWNjb3VudCA9IGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzLmZpbmQoYWNjb3VudCA9PiBhY2NvdW50LmtleS5lcXVhbHModGFibGVMb29rdXAuYWNjb3VudEtleSkpO1xuICAgICAgaWYgKCF0YWJsZUFjY291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGxvb2t1cCB0YWJsZSBhY2NvdW50IGZvciB0YWJsZSBrZXkgJHt0YWJsZUxvb2t1cC5hY2NvdW50S2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRhYmxlTG9va3VwLndyaXRhYmxlSW5kZXhlcykge1xuICAgICAgICBpZiAoaW5kZXggPCB0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUucHVzaCh0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGZvciBpbmRleCAke2luZGV4fSBpbiBhZGRyZXNzIGxvb2t1cCB0YWJsZSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbmRleCBvZiB0YWJsZUxvb2t1cC5yZWFkb25seUluZGV4ZXMpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgdGFibGVBY2NvdW50LnN0YXRlLmFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5LnB1c2godGFibGVBY2NvdW50LnN0YXRlLmFkZHJlc3Nlc1tpbmRleF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYWRkcmVzcyBmb3IgaW5kZXggJHtpbmRleH0gaW4gYWRkcmVzcyBsb29rdXAgdGFibGUgJHt0YWJsZUxvb2t1cC5hY2NvdW50S2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gIH1cbiAgc3RhdGljIGNvbXBpbGUoYXJncykge1xuICAgIGNvbnN0IGNvbXBpbGVkS2V5cyA9IENvbXBpbGVkS2V5cy5jb21waWxlKGFyZ3MuaW5zdHJ1Y3Rpb25zLCBhcmdzLnBheWVyS2V5KTtcbiAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBzID0gbmV3IEFycmF5KCk7XG4gICAgY29uc3QgYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHtcbiAgICAgIHdyaXRhYmxlOiBuZXcgQXJyYXkoKSxcbiAgICAgIHJlYWRvbmx5OiBuZXcgQXJyYXkoKVxuICAgIH07XG4gICAgY29uc3QgbG9va3VwVGFibGVBY2NvdW50cyA9IGFyZ3MuYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMgfHwgW107XG4gICAgZm9yIChjb25zdCBsb29rdXBUYWJsZSBvZiBsb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgICBjb25zdCBleHRyYWN0UmVzdWx0ID0gY29tcGlsZWRLZXlzLmV4dHJhY3RUYWJsZUxvb2t1cChsb29rdXBUYWJsZSk7XG4gICAgICBpZiAoZXh0cmFjdFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IFthZGRyZXNzVGFibGVMb29rdXAsIHtcbiAgICAgICAgICB3cml0YWJsZSxcbiAgICAgICAgICByZWFkb25seVxuICAgICAgICB9XSA9IGV4dHJhY3RSZXN1bHQ7XG4gICAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHMucHVzaChhZGRyZXNzVGFibGVMb29rdXApO1xuICAgICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlLnB1c2goLi4ud3JpdGFibGUpO1xuICAgICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5LnB1c2goLi4ucmVhZG9ubHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBbaGVhZGVyLCBzdGF0aWNBY2NvdW50S2V5c10gPSBjb21waWxlZEtleXMuZ2V0TWVzc2FnZUNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IG5ldyBNZXNzYWdlQWNjb3VudEtleXMoc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpO1xuICAgIGNvbnN0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gYWNjb3VudEtleXMuY29tcGlsZUluc3RydWN0aW9ucyhhcmdzLmluc3RydWN0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlVjAoe1xuICAgICAgaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGFyZ3MucmVjZW50QmxvY2toYXNoLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMsXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSk7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCA9IEFycmF5KCk7XG4gICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCwgdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMgPSB0aGlzLnNlcmlhbGl6ZUluc3RydWN0aW9ucygpO1xuICAgIGNvbnN0IGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoLCB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMgPSB0aGlzLnNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMoKTtcbiAgICBjb25zdCBlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoLCB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoKTtcbiAgICBjb25zdCBtZXNzYWdlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdwcmVmaXgnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdudW1SZXF1aXJlZFNpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0LnU4KCdudW1SZWFkb25seVNpZ25lZEFjY291bnRzJyksIEJ1ZmZlckxheW91dC51OCgnbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzJyldLCAnaGVhZGVyJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aC5sZW5ndGgsICdzdGF0aWNBY2NvdW50S2V5c0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKHB1YmxpY0tleSgpLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCwgJ3N0YXRpY0FjY291bnRLZXlzJyksIHB1YmxpY0tleSgncmVjZW50QmxvY2toYXNoJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgubGVuZ3RoLCAnaW5zdHJ1Y3Rpb25zTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5ibG9iKHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMubGVuZ3RoLCAnc2VyaWFsaXplZEluc3RydWN0aW9ucycpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aC5sZW5ndGgsICdhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5ibG9iKHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLmxlbmd0aCwgJ3NlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzJyldKTtcbiAgICBjb25zdCBzZXJpYWxpemVkTWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIGNvbnN0IE1FU1NBR0VfVkVSU0lPTl8wX1BSRUZJWCA9IDEgPDwgNztcbiAgICBjb25zdCBzZXJpYWxpemVkTWVzc2FnZUxlbmd0aCA9IG1lc3NhZ2VMYXlvdXQuZW5jb2RlKHtcbiAgICAgIHByZWZpeDogTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYLFxuICAgICAgaGVhZGVyOiB0aGlzLmhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgpLFxuICAgICAgc3RhdGljQWNjb3VudEtleXM6IHRoaXMuc3RhdGljQWNjb3VudEtleXMubWFwKGtleSA9PiBrZXkudG9CeXRlcygpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYnM1OC5kZWNvZGUodGhpcy5yZWNlbnRCbG9ja2hhc2gpLFxuICAgICAgaW5zdHJ1Y3Rpb25zTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoKSxcbiAgICAgIHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMsXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCksXG4gICAgICBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0sIHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZE1lc3NhZ2Uuc2xpY2UoMCwgc2VyaWFsaXplZE1lc3NhZ2VMZW5ndGgpO1xuICB9XG4gIHNlcmlhbGl6ZUluc3RydWN0aW9ucygpIHtcbiAgICBsZXQgc2VyaWFsaXplZExlbmd0aCA9IDA7XG4gICAgY29uc3Qgc2VyaWFsaXplZEluc3RydWN0aW9ucyA9IG5ldyBVaW50OEFycmF5KFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucykge1xuICAgICAgY29uc3QgZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgsIGluc3RydWN0aW9uLmFjY291bnRLZXlJbmRleGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBlbmNvZGVkRGF0YUxlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZERhdGFMZW5ndGgsIGluc3RydWN0aW9uLmRhdGEubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdwcm9ncmFtSWRJbmRleCcpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCksIGluc3RydWN0aW9uLmFjY291bnRLZXlJbmRleGVzLmxlbmd0aCwgJ2FjY291bnRLZXlJbmRleGVzJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWREYXRhTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWREYXRhTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5ibG9iKGluc3RydWN0aW9uLmRhdGEubGVuZ3RoLCAnZGF0YScpXSk7XG4gICAgICBzZXJpYWxpemVkTGVuZ3RoICs9IGluc3RydWN0aW9uTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleCxcbiAgICAgICAgZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICAgIGVuY29kZWREYXRhTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkRGF0YUxlbmd0aCksXG4gICAgICAgIGRhdGE6IGluc3RydWN0aW9uLmRhdGFcbiAgICAgIH0sIHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZEluc3RydWN0aW9ucy5zbGljZSgwLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgfVxuICBzZXJpYWxpemVBZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgIGxldCBzZXJpYWxpemVkTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyA9IG5ldyBVaW50OEFycmF5KFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIGZvciAoY29uc3QgbG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY29uc3QgZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCwgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCwgbG9va3VwLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3VwTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdhY2NvdW50S2V5JyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgpLCBsb29rdXAud3JpdGFibGVJbmRleGVzLmxlbmd0aCwgJ3dyaXRhYmxlSW5kZXhlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoKSwgbG9va3VwLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGgsICdyZWFkb25seUluZGV4ZXMnKV0pO1xuICAgICAgc2VyaWFsaXplZExlbmd0aCArPSBhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgYWNjb3VudEtleTogbG9va3VwLmFjY291bnRLZXkudG9CeXRlcygpLFxuICAgICAgICBlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoKSxcbiAgICAgICAgd3JpdGFibGVJbmRleGVzOiBsb29rdXAud3JpdGFibGVJbmRleGVzLFxuICAgICAgICBlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoKSxcbiAgICAgICAgcmVhZG9ubHlJbmRleGVzOiBsb29rdXAucmVhZG9ubHlJbmRleGVzXG4gICAgICB9LCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3Vwcywgc2VyaWFsaXplZExlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3Vwcy5zbGljZSgwLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoc2VyaWFsaXplZE1lc3NhZ2UpIHtcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLnNlcmlhbGl6ZWRNZXNzYWdlXTtcbiAgICBjb25zdCBwcmVmaXggPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBtYXNrZWRQcmVmaXggPSBwcmVmaXggJiBWRVJTSU9OX1BSRUZJWF9NQVNLO1xuICAgIGFzc2VydChwcmVmaXggIT09IG1hc2tlZFByZWZpeCwgYEV4cGVjdGVkIHZlcnNpb25lZCBtZXNzYWdlIGJ1dCByZWNlaXZlZCBsZWdhY3kgbWVzc2FnZWApO1xuICAgIGNvbnN0IHZlcnNpb24gPSBtYXNrZWRQcmVmaXg7XG4gICAgYXNzZXJ0KHZlcnNpb24gPT09IDAsIGBFeHBlY3RlZCB2ZXJzaW9uZWQgbWVzc2FnZSB3aXRoIHZlcnNpb24gMCBidXQgZm91bmQgdmVyc2lvbiAke3ZlcnNpb259YCk7XG4gICAgY29uc3QgaGVhZGVyID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KVxuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQWNjb3VudEtleXMgPSBbXTtcbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGljQWNjb3VudEtleXNMZW5ndGg7IGkrKykge1xuICAgICAgc3RhdGljQWNjb3VudEtleXMucHVzaChuZXcgUHVibGljS2V5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpKTtcbiAgICB9XG4gICAgY29uc3QgcmVjZW50QmxvY2toYXNoID0gYnM1OC5lbmNvZGUoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25Db3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHByb2dyYW1JZEluZGV4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50S2V5SW5kZXhlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudEtleUluZGV4ZXMgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgYWNjb3VudEtleUluZGV4ZXNMZW5ndGgpO1xuICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBkYXRhTGVuZ3RoKSk7XG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3Vwc0NvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3VwcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzc1RhYmxlTG9va3Vwc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFjY291bnRLZXkgPSBuZXcgUHVibGljS2V5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgICAgY29uc3Qgd3JpdGFibGVJbmRleGVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCB3cml0YWJsZUluZGV4ZXMgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgd3JpdGFibGVJbmRleGVzTGVuZ3RoKTtcbiAgICAgIGNvbnN0IHJlYWRvbmx5SW5kZXhlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgcmVhZG9ubHlJbmRleGVzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIHJlYWRvbmx5SW5kZXhlc0xlbmd0aCk7XG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzLnB1c2goe1xuICAgICAgICBhY2NvdW50S2V5LFxuICAgICAgICB3cml0YWJsZUluZGV4ZXMsXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWVzc2FnZVYwKHtcbiAgICAgIGhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMsXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuY29uc3QgVmVyc2lvbmVkTWVzc2FnZSA9IHtcbiAgZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbihzZXJpYWxpemVkTWVzc2FnZSkge1xuICAgIGNvbnN0IHByZWZpeCA9IHNlcmlhbGl6ZWRNZXNzYWdlWzBdO1xuICAgIGNvbnN0IG1hc2tlZFByZWZpeCA9IHByZWZpeCAmIFZFUlNJT05fUFJFRklYX01BU0s7XG5cbiAgICAvLyBpZiB0aGUgaGlnaGVzdCBiaXQgb2YgdGhlIHByZWZpeCBpcyBub3Qgc2V0LCB0aGUgbWVzc2FnZSBpcyBub3QgdmVyc2lvbmVkXG4gICAgaWYgKG1hc2tlZFByZWZpeCA9PT0gcHJlZml4KSB7XG4gICAgICByZXR1cm4gJ2xlZ2FjeSc7XG4gICAgfVxuXG4gICAgLy8gdGhlIGxvd2VyIDcgYml0cyBvZiB0aGUgcHJlZml4IGluZGljYXRlIHRoZSBtZXNzYWdlIHZlcnNpb25cbiAgICByZXR1cm4gbWFza2VkUHJlZml4O1xuICB9LFxuICBkZXNlcmlhbGl6ZTogc2VyaWFsaXplZE1lc3NhZ2UgPT4ge1xuICAgIGNvbnN0IHZlcnNpb24gPSBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24oc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIGlmICh2ZXJzaW9uID09PSAnbGVnYWN5Jykge1xuICAgICAgcmV0dXJuIE1lc3NhZ2UuZnJvbShzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gTWVzc2FnZVYwLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBtZXNzYWdlIHZlcnNpb24gJHt2ZXJzaW9ufSBkZXNlcmlhbGl6YXRpb24gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfVxufTtcblxuLyoqIEBpbnRlcm5hbCAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSBhcyBiYXNlLTU4IGVuY29kZWQgc3RyaW5nXG4gKi9cblxubGV0IFRyYW5zYWN0aW9uU3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChUcmFuc2FjdGlvblN0YXR1cykge1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIkJMT0NLSEVJR0hUX0VYQ0VFREVEXCJdID0gMF0gPSBcIkJMT0NLSEVJR0hUX0VYQ0VFREVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiUFJPQ0VTU0VEXCJdID0gMV0gPSBcIlBST0NFU1NFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIlRJTUVEX09VVFwiXSA9IDJdID0gXCJUSU1FRF9PVVRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJOT05DRV9JTlZBTElEXCJdID0gM10gPSBcIk5PTkNFX0lOVkFMSURcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uU3RhdHVzO1xufSh7fSk7XG5cbi8qKlxuICogRGVmYXVsdCAoZW1wdHkpIHNpZ25hdHVyZVxuICovXG5jb25zdCBERUZBVUxUX1NJR05BVFVSRSA9IEJ1ZmZlci5hbGxvYyhTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKS5maWxsKDApO1xuXG4vKipcbiAqIEFjY291bnQgbWV0YWRhdGEgdXNlZCB0byBkZWZpbmUgaW5zdHJ1Y3Rpb25zXG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gb2JqZWN0IGZpZWxkcyB0aGF0IG1heSBiZSBpbml0aWFsaXplZCBhdCBjb25zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBUcmFuc2FjdGlvbi5zZXJpYWxpemUoKVxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIC8qKlxuICAgICAqIFB1YmxpYyBrZXlzIHRvIGluY2x1ZGUgaW4gdGhpcyB0cmFuc2FjdGlvblxuICAgICAqIEJvb2xlYW4gcmVwcmVzZW50cyB3aGV0aGVyIHRoaXMgcHVia2V5IG5lZWRzIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgdGhpcy5rZXlzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFByb2dyYW0gSWQgdG8gZXhlY3V0ZVxuICAgICAqL1xuICAgIHRoaXMucHJvZ3JhbUlkID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFByb2dyYW0gaW5wdXRcbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgdGhpcy5wcm9ncmFtSWQgPSBvcHRzLnByb2dyYW1JZDtcbiAgICB0aGlzLmtleXMgPSBvcHRzLmtleXM7XG4gICAgaWYgKG9wdHMuZGF0YSkge1xuICAgICAgdGhpcy5kYXRhID0gb3B0cy5kYXRhO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogdGhpcy5rZXlzLm1hcCgoe1xuICAgICAgICBwdWJrZXksXG4gICAgICAgIGlzU2lnbmVyLFxuICAgICAgICBpc1dyaXRhYmxlXG4gICAgICB9KSA9PiAoe1xuICAgICAgICBwdWJrZXk6IHB1YmtleS50b0pTT04oKSxcbiAgICAgICAgaXNTaWduZXIsXG4gICAgICAgIGlzV3JpdGFibGVcbiAgICAgIH0pKSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQudG9KU09OKCksXG4gICAgICBkYXRhOiBbLi4udGhpcy5kYXRhXVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQYWlyIG9mIHNpZ25hdHVyZSBhbmQgY29ycmVzcG9uZGluZyBwdWJsaWMga2V5XG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIFRyYW5zYWN0aW9uIG9iamVjdCBmaWVsZHMgdGhhdCBtYXkgYmUgaW5pdGlhbGl6ZWQgYXQgY29uc3RydWN0aW9uXG4gKi9cblxuLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk7IGFuIHVuZm9ydHVuYXRlIGNvbnNlcXVlbmNlIG9mIGJlaW5nXG4vLyBmb3JjZWQgdG8gb3Zlci1leHBvcnQgdHlwZXMgYnkgdGhlIGRvY3VtZW50YXRpb24gZ2VuZXJhdG9yLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvcHVsbC8yNTgyMFxuXG4vKipcbiAqIEJsb2NraGFzaC1iYXNlZCB0cmFuc2FjdGlvbnMgaGF2ZSBhIGxpZmV0aW1lIHRoYXQgYXJlIGRlZmluZWQgYnlcbiAqIHRoZSBibG9ja2hhc2ggdGhleSBpbmNsdWRlLiBBbnkgdHJhbnNhY3Rpb24gd2hvc2UgYmxvY2toYXNoIGlzXG4gKiB0b28gb2xkIHdpbGwgYmUgcmVqZWN0ZWQuXG4gKi9cblxuLyoqXG4gKiBVc2UgdGhlc2Ugb3B0aW9ucyB0byBjb25zdHJ1Y3QgYSBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9uLlxuICovXG5cbi8qKlxuICogTm9uY2UgaW5mb3JtYXRpb24gdG8gYmUgdXNlZCB0byBidWlsZCBhbiBvZmZsaW5lIFRyYW5zYWN0aW9uLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgZmlyc3QgKHBheWVyKSBUcmFuc2FjdGlvbiBzaWduYXR1cmVcbiAgICpcbiAgICogQHJldHVybnMge0J1ZmZlciB8IG51bGx9IEJ1ZmZlciBvZiBwYXllcidzIHNpZ25hdHVyZVxuICAgKi9cbiAgZ2V0IHNpZ25hdHVyZSgpIHtcbiAgICBpZiAodGhpcy5zaWduYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZXNbMF0uc2lnbmF0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyXG4gICAqL1xuXG4gIC8vIENvbnN0cnVjdCBhIHRyYW5zYWN0aW9uIHdpdGggYSBibG9ja2hhc2ggYW5kIGxhc3RWYWxpZEJsb2NrSGVpZ2h0XG5cbiAgLy8gQ29uc3RydWN0IGEgdHJhbnNhY3Rpb24gdXNpbmcgYSBkdXJhYmxlIG5vbmNlXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIGBUcmFuc2FjdGlvbkN0b3JGaWVsZHNgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICAgKiBQbGVhc2Ugc3VwcGx5IGEgYFRyYW5zYWN0aW9uQmxvY2toYXNoQ3RvcmAgaW5zdGVhZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBlbXB0eSBUcmFuc2FjdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZXMgZm9yIHRoZSB0cmFuc2FjdGlvbi4gIFR5cGljYWxseSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZVxuICAgICAqIGBzaWduKClgIG1ldGhvZFxuICAgICAqL1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IFtdO1xuICAgIHRoaXMuZmVlUGF5ZXIgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIGluc3RydWN0aW9ucyB0byBhdG9taWNhbGx5IGV4ZWN1dGVcbiAgICAgKi9cbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEEgcmVjZW50IHRyYW5zYWN0aW9uIGlkLiBNdXN0IGJlIHBvcHVsYXRlZCBieSB0aGUgY2FsbGVyXG4gICAgICovXG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogdGhlIGxhc3QgYmxvY2sgY2hhaW4gY2FuIGFkdmFuY2UgdG8gYmVmb3JlIHR4IGlzIGRlY2xhcmVkIGV4cGlyZWRcbiAgICAgKiAqL1xuICAgIHRoaXMubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgTm9uY2UgaW5mb3JtYXRpb24uIElmIHBvcHVsYXRlZCwgdHJhbnNhY3Rpb24gd2lsbCB1c2UgYSBkdXJhYmxlXG4gICAgICogTm9uY2UgaGFzaCBpbnN0ZWFkIG9mIGEgcmVjZW50QmxvY2toYXNoLiBNdXN0IGJlIHBvcHVsYXRlZCBieSB0aGUgY2FsbGVyXG4gICAgICovXG4gICAgdGhpcy5ub25jZUluZm8gPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBpcyBhIG5vbmNlIHRyYW5zYWN0aW9uIHRoaXMgcmVwcmVzZW50cyB0aGUgbWluaW11bSBzbG90IGZyb20gd2hpY2hcbiAgICAgKiB0byBldmFsdWF0ZSBpZiB0aGUgbm9uY2UgaGFzIGFkdmFuY2VkIHdoZW4gYXR0ZW1wdGluZyB0byBjb25maXJtIHRoZVxuICAgICAqIHRyYW5zYWN0aW9uLiBUaGlzIHByb3RlY3RzIGFnYWluc3QgYSBjYXNlIHdoZXJlIHRoZSB0cmFuc2FjdGlvbiBjb25maXJtYXRpb25cbiAgICAgKiBsb2dpYyBsb2FkcyB0aGUgbm9uY2UgYWNjb3VudCBmcm9tIGFuIG9sZCBzbG90IGFuZCBhc3N1bWVzIHRoZSBtaXNtYXRjaCBpblxuICAgICAqIG5vbmNlIHZhbHVlIGltcGxpZXMgdGhhdCB0aGUgbm9uY2UgaGFzIGJlZW4gYWR2YW5jZWQuXG4gICAgICovXG4gICAgdGhpcy5taW5Ob25jZUNvbnRleHRTbG90ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX21lc3NhZ2UgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fanNvbiA9IHZvaWQgMDtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wdHMuZmVlUGF5ZXIpIHtcbiAgICAgIHRoaXMuZmVlUGF5ZXIgPSBvcHRzLmZlZVBheWVyO1xuICAgIH1cbiAgICBpZiAob3B0cy5zaWduYXR1cmVzKSB7XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBvcHRzLnNpZ25hdHVyZXM7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0cywgJ25vbmNlSW5mbycpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1pbkNvbnRleHRTbG90LFxuICAgICAgICBub25jZUluZm9cbiAgICAgIH0gPSBvcHRzO1xuICAgICAgdGhpcy5taW5Ob25jZUNvbnRleHRTbG90ID0gbWluQ29udGV4dFNsb3Q7XG4gICAgICB0aGlzLm5vbmNlSW5mbyA9IG5vbmNlSW5mbztcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRzLCAnbGFzdFZhbGlkQmxvY2tIZWlnaHQnKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBibG9ja2hhc2gsXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0XG4gICAgICB9ID0gb3B0cztcbiAgICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuICAgICAgdGhpcy5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY2VudEJsb2NraGFzaCxcbiAgICAgICAgbm9uY2VJbmZvXG4gICAgICB9ID0gb3B0cztcbiAgICAgIGlmIChub25jZUluZm8pIHtcbiAgICAgICAgdGhpcy5ub25jZUluZm8gPSBub25jZUluZm87XG4gICAgICB9XG4gICAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHJlY2VudEJsb2NraGFzaDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VudEJsb2NraGFzaDogdGhpcy5yZWNlbnRCbG9ja2hhc2ggfHwgbnVsbCxcbiAgICAgIGZlZVBheWVyOiB0aGlzLmZlZVBheWVyID8gdGhpcy5mZWVQYXllci50b0pTT04oKSA6IG51bGwsXG4gICAgICBub25jZUluZm86IHRoaXMubm9uY2VJbmZvID8ge1xuICAgICAgICBub25jZTogdGhpcy5ub25jZUluZm8ubm9uY2UsXG4gICAgICAgIG5vbmNlSW5zdHJ1Y3Rpb246IHRoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24udG9KU09OKClcbiAgICAgIH0gOiBudWxsLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24udG9KU09OKCkpLFxuICAgICAgc2lnbmVyczogdGhpcy5zaWduYXR1cmVzLm1hcCgoe1xuICAgICAgICBwdWJsaWNLZXlcbiAgICAgIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleS50b0pTT04oKTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb25lIG9yIG1vcmUgaW5zdHJ1Y3Rpb25zIHRvIHRoaXMgVHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTwgVHJhbnNhY3Rpb24gfCBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbkN0b3JGaWVsZHMgPn0gaXRlbXMgLSBJbnN0cnVjdGlvbnMgdG8gYWRkIHRvIHRoZSBUcmFuc2FjdGlvblxuICAgKi9cbiAgYWRkKC4uLml0ZW1zKSB7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnN0cnVjdGlvbnMnKTtcbiAgICB9XG4gICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGlmICgnaW5zdHJ1Y3Rpb25zJyBpbiBpdGVtKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnMuY29uY2F0KGl0ZW0uaW5zdHJ1Y3Rpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoJ2RhdGEnIGluIGl0ZW0gJiYgJ3Byb2dyYW1JZCcgaW4gaXRlbSAmJiAna2V5cycgaW4gaXRlbSkge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpdGVtKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGlsZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAqL1xuICBjb21waWxlTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5fbWVzc2FnZSAmJiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKSA9PT0gSlNPTi5zdHJpbmdpZnkodGhpcy5fanNvbikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlO1xuICAgIH1cbiAgICBsZXQgcmVjZW50QmxvY2toYXNoO1xuICAgIGxldCBpbnN0cnVjdGlvbnM7XG4gICAgaWYgKHRoaXMubm9uY2VJbmZvKSB7XG4gICAgICByZWNlbnRCbG9ja2hhc2ggPSB0aGlzLm5vbmNlSW5mby5ub25jZTtcbiAgICAgIGlmICh0aGlzLmluc3RydWN0aW9uc1swXSAhPSB0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uKSB7XG4gICAgICAgIGluc3RydWN0aW9ucyA9IFt0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uLCAuLi50aGlzLmluc3RydWN0aW9uc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVjZW50QmxvY2toYXNoID0gdGhpcy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgICBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucztcbiAgICB9XG4gICAgaWYgKCFyZWNlbnRCbG9ja2hhc2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gcmVjZW50QmxvY2toYXNoIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChpbnN0cnVjdGlvbnMubGVuZ3RoIDwgMSkge1xuICAgICAgY29uc29sZS53YXJuKCdObyBpbnN0cnVjdGlvbnMgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgbGV0IGZlZVBheWVyO1xuICAgIGlmICh0aGlzLmZlZVBheWVyKSB7XG4gICAgICBmZWVQYXllciA9IHRoaXMuZmVlUGF5ZXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID4gMCAmJiB0aGlzLnNpZ25hdHVyZXNbMF0ucHVibGljS2V5KSB7XG4gICAgICAvLyBVc2UgaW1wbGljaXQgZmVlIHBheWVyXG4gICAgICBmZWVQYXllciA9IHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmVlIHBheWVyIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaW5zdHJ1Y3Rpb25zW2ldLnByb2dyYW1JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gaW5kZXggJHtpfSBoYXMgdW5kZWZpbmVkIHByb2dyYW0gaWRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvZ3JhbUlkcyA9IFtdO1xuICAgIGNvbnN0IGFjY291bnRNZXRhcyA9IFtdO1xuICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGluc3RydWN0aW9uLmtleXMuZm9yRWFjaChhY2NvdW50TWV0YSA9PiB7XG4gICAgICAgIGFjY291bnRNZXRhcy5wdXNoKHtcbiAgICAgICAgICAuLi5hY2NvdW50TWV0YVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvZ3JhbUlkID0gaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoIXByb2dyYW1JZHMuaW5jbHVkZXMocHJvZ3JhbUlkKSkge1xuICAgICAgICBwcm9ncmFtSWRzLnB1c2gocHJvZ3JhbUlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEFwcGVuZCBwcm9ncmFtSUQgYWNjb3VudCBtZXRhc1xuICAgIHByb2dyYW1JZHMuZm9yRWFjaChwcm9ncmFtSWQgPT4ge1xuICAgICAgYWNjb3VudE1ldGFzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBDdWxsIGR1cGxpY2F0ZSBhY2NvdW50IG1ldGFzXG4gICAgY29uc3QgdW5pcXVlTWV0YXMgPSBbXTtcbiAgICBhY2NvdW50TWV0YXMuZm9yRWFjaChhY2NvdW50TWV0YSA9PiB7XG4gICAgICBjb25zdCBwdWJrZXlTdHJpbmcgPSBhY2NvdW50TWV0YS5wdWJrZXkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHVuaXF1ZUluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KHggPT4ge1xuICAgICAgICByZXR1cm4geC5wdWJrZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5U3RyaW5nO1xuICAgICAgfSk7XG4gICAgICBpZiAodW5pcXVlSW5kZXggPiAtMSkge1xuICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNXcml0YWJsZSA9IHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1dyaXRhYmxlIHx8IGFjY291bnRNZXRhLmlzV3JpdGFibGU7XG4gICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciA9IHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciB8fCBhY2NvdW50TWV0YS5pc1NpZ25lcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXF1ZU1ldGFzLnB1c2goYWNjb3VudE1ldGEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU29ydC4gUHJpb3JpdGl6aW5nIGZpcnN0IGJ5IHNpZ25lciwgdGhlbiBieSB3cml0YWJsZVxuICAgIHVuaXF1ZU1ldGFzLnNvcnQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICh4LmlzU2lnbmVyICE9PSB5LmlzU2lnbmVyKSB7XG4gICAgICAgIC8vIFNpZ25lcnMgYWx3YXlzIGNvbWUgYmVmb3JlIG5vbi1zaWduZXJzXG4gICAgICAgIHJldHVybiB4LmlzU2lnbmVyID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgaWYgKHguaXNXcml0YWJsZSAhPT0geS5pc1dyaXRhYmxlKSB7XG4gICAgICAgIC8vIFdyaXRhYmxlIGFjY291bnRzIGFsd2F5cyBjb21lIGJlZm9yZSByZWFkLW9ubHkgYWNjb3VudHNcbiAgICAgICAgcmV0dXJuIHguaXNXcml0YWJsZSA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIC8vIE90aGVyd2lzZSwgc29ydCBieSBwdWJrZXksIHN0cmluZ3dpc2UuXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBsb2NhbGVNYXRjaGVyOiAnYmVzdCBmaXQnLFxuICAgICAgICB1c2FnZTogJ3NvcnQnLFxuICAgICAgICBzZW5zaXRpdml0eTogJ3ZhcmlhbnQnLFxuICAgICAgICBpZ25vcmVQdW5jdHVhdGlvbjogZmFsc2UsXG4gICAgICAgIG51bWVyaWM6IGZhbHNlLFxuICAgICAgICBjYXNlRmlyc3Q6ICdsb3dlcidcbiAgICAgIH07XG4gICAgICByZXR1cm4geC5wdWJrZXkudG9CYXNlNTgoKS5sb2NhbGVDb21wYXJlKHkucHVia2V5LnRvQmFzZTU4KCksICdlbicsIG9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgLy8gTW92ZSBmZWUgcGF5ZXIgdG8gdGhlIGZyb250XG4gICAgY29uc3QgZmVlUGF5ZXJJbmRleCA9IHVuaXF1ZU1ldGFzLmZpbmRJbmRleCh4ID0+IHtcbiAgICAgIHJldHVybiB4LnB1YmtleS5lcXVhbHMoZmVlUGF5ZXIpO1xuICAgIH0pO1xuICAgIGlmIChmZWVQYXllckluZGV4ID4gLTEpIHtcbiAgICAgIGNvbnN0IFtwYXllck1ldGFdID0gdW5pcXVlTWV0YXMuc3BsaWNlKGZlZVBheWVySW5kZXgsIDEpO1xuICAgICAgcGF5ZXJNZXRhLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICAgIHBheWVyTWV0YS5pc1dyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHVuaXF1ZU1ldGFzLnVuc2hpZnQocGF5ZXJNZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pcXVlTWV0YXMudW5zaGlmdCh7XG4gICAgICAgIHB1YmtleTogZmVlUGF5ZXIsXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEaXNhbGxvdyB1bmtub3duIHNpZ25lcnNcbiAgICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiB0aGlzLnNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHVuaXF1ZUluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KHggPT4ge1xuICAgICAgICByZXR1cm4geC5wdWJrZXkuZXF1YWxzKHNpZ25hdHVyZS5wdWJsaWNLZXkpO1xuICAgICAgfSk7XG4gICAgICBpZiAodW5pcXVlSW5kZXggPiAtMSkge1xuICAgICAgICBpZiAoIXVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lcikge1xuICAgICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUcmFuc2FjdGlvbiByZWZlcmVuY2VzIGEgc2lnbmF0dXJlIHRoYXQgaXMgdW5uZWNlc3NhcnksICcgKyAnb25seSB0aGUgZmVlIHBheWVyIGFuZCBpbnN0cnVjdGlvbiBzaWduZXIgYWNjb3VudHMgc2hvdWxkIHNpZ24gYSB0cmFuc2FjdGlvbi4gJyArICdUaGlzIGJlaGF2aW9yIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgdGhyb3cgYW4gZXJyb3IgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiByZWxlYXNlLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2lnbmVyOiAke3NpZ25hdHVyZS5wdWJsaWNLZXkudG9TdHJpbmcoKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG51bVJlcXVpcmVkU2lnbmF0dXJlcyA9IDA7XG4gICAgbGV0IG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgPSAwO1xuICAgIGxldCBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgPSAwO1xuXG4gICAgLy8gU3BsaXQgb3V0IHNpZ25pbmcgZnJvbSBub24tc2lnbmluZyBrZXlzIGFuZCBjb3VudCBoZWFkZXIgdmFsdWVzXG4gICAgY29uc3Qgc2lnbmVkS2V5cyA9IFtdO1xuICAgIGNvbnN0IHVuc2lnbmVkS2V5cyA9IFtdO1xuICAgIHVuaXF1ZU1ldGFzLmZvckVhY2goKHtcbiAgICAgIHB1YmtleSxcbiAgICAgIGlzU2lnbmVyLFxuICAgICAgaXNXcml0YWJsZVxuICAgIH0pID0+IHtcbiAgICAgIGlmIChpc1NpZ25lcikge1xuICAgICAgICBzaWduZWRLZXlzLnB1c2gocHVia2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMgKz0gMTtcbiAgICAgICAgaWYgKCFpc1dyaXRhYmxlKSB7XG4gICAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyArPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bnNpZ25lZEtleXMucHVzaChwdWJrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmICghaXNXcml0YWJsZSkge1xuICAgICAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBzaWduZWRLZXlzLmNvbmNhdCh1bnNpZ25lZEtleXMpO1xuICAgIGNvbnN0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHByb2dyYW1JZFxuICAgICAgfSA9IGluc3RydWN0aW9uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGFjY291bnRLZXlzLmluZGV4T2YocHJvZ3JhbUlkLnRvU3RyaW5nKCkpLFxuICAgICAgICBhY2NvdW50czogaW5zdHJ1Y3Rpb24ua2V5cy5tYXAobWV0YSA9PiBhY2NvdW50S2V5cy5pbmRleE9mKG1ldGEucHVia2V5LnRvU3RyaW5nKCkpKSxcbiAgICAgICAgZGF0YTogYnM1OC5lbmNvZGUoZGF0YSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29tcGlsZWRJbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBhc3NlcnQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXggPj0gMCk7XG4gICAgICBpbnN0cnVjdGlvbi5hY2NvdW50cy5mb3JFYWNoKGtleUluZGV4ID0+IGFzc2VydChrZXlJbmRleCA+PSAwKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKHtcbiAgICAgIGhlYWRlcjoge1xuICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMsXG4gICAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50c1xuICAgICAgfSxcbiAgICAgIGFjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiBjb21waWxlZEluc3RydWN0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2NvbXBpbGUoKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuY29tcGlsZU1lc3NhZ2UoKTtcbiAgICBjb25zdCBzaWduZWRLZXlzID0gbWVzc2FnZS5hY2NvdW50S2V5cy5zbGljZSgwLCBtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpO1xuICAgIGlmICh0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID09PSBzaWduZWRLZXlzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLnNpZ25hdHVyZXMuZXZlcnkoKHBhaXIsIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBzaWduZWRLZXlzW2luZGV4XS5lcXVhbHMocGFpci5wdWJsaWNLZXkpO1xuICAgICAgfSk7XG4gICAgICBpZiAodmFsaWQpIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBzaWduZWRLZXlzLm1hcChwdWJsaWNLZXkgPT4gKHtcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHB1YmxpY0tleVxuICAgIH0pKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBidWZmZXIgb2YgdGhlIFRyYW5zYWN0aW9uIGRhdGEgdGhhdCBuZWVkIHRvIGJlIGNvdmVyZWQgYnkgc2lnbmF0dXJlc1xuICAgKi9cbiAgc2VyaWFsaXplTWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcGlsZSgpLnNlcmlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXN0aW1hdGVkIGZlZSBhc3NvY2lhdGVkIHdpdGggYSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb24gQ29ubmVjdGlvbiB0byBSUEMgRW5kcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlciB8IG51bGw+fSBUaGUgZXN0aW1hdGVkIGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBnZXRFc3RpbWF0ZWRGZWUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiAoYXdhaXQgY29ubmVjdGlvbi5nZXRGZWVGb3JNZXNzYWdlKHRoaXMuY29tcGlsZU1lc3NhZ2UoKSkpLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHB1YmxpYyBrZXlzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBzaWduIHRoZSBUcmFuc2FjdGlvbi5cbiAgICogVGhlIGZpcnN0IHNpZ25lciB3aWxsIGJlIHVzZWQgYXMgdGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciBhY2NvdW50LlxuICAgKlxuICAgKiBTaWduYXR1cmVzIGNhbiBiZSBhZGRlZCB3aXRoIGVpdGhlciBgcGFydGlhbFNpZ25gIG9yIGBhZGRTaWduYXR1cmVgXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgdjAuODQuMC4gT25seSB0aGUgZmVlIHBheWVyIG5lZWRzIHRvIGJlXG4gICAqIHNwZWNpZmllZCBhbmQgaXQgY2FuIGJlIHNldCBpbiB0aGUgVHJhbnNhY3Rpb24gY29uc3RydWN0b3Igb3Igd2l0aCB0aGVcbiAgICogYGZlZVBheWVyYCBwcm9wZXJ0eS5cbiAgICovXG4gIHNldFNpZ25lcnMoLi4uc2lnbmVycykge1xuICAgIGlmIChzaWduZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduZXJzJyk7XG4gICAgfVxuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmVycy5maWx0ZXIocHVibGljS2V5ID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IHB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSkubWFwKHB1YmxpY0tleSA9PiAoe1xuICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgcHVibGljS2V5XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gdGhlIFRyYW5zYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBzaWduZXJzLiBNdWx0aXBsZSBzaWduYXR1cmVzIG1heVxuICAgKiBiZSBhcHBsaWVkIHRvIGEgVHJhbnNhY3Rpb24uIFRoZSBmaXJzdCBzaWduYXR1cmUgaXMgY29uc2lkZXJlZCBcInByaW1hcnlcIlxuICAgKiBhbmQgaXMgdXNlZCBpZGVudGlmeSBhbmQgY29uZmlybSB0cmFuc2FjdGlvbnMuXG4gICAqXG4gICAqIElmIHRoZSBUcmFuc2FjdGlvbiBgZmVlUGF5ZXJgIGlzIG5vdCBzZXQsIHRoZSBmaXJzdCBzaWduZXIgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXIgYWNjb3VudC5cbiAgICpcbiAgICogVHJhbnNhY3Rpb24gZmllbGRzIHNob3VsZCBub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgdGhlIGZpcnN0IGNhbGwgdG8gYHNpZ25gLFxuICAgKiBhcyBkb2luZyBzbyBtYXkgaW52YWxpZGF0ZSB0aGUgc2lnbmF0dXJlIGFuZCBjYXVzZSB0aGUgVHJhbnNhY3Rpb24gdG8gYmVcbiAgICogcmVqZWN0ZWQuXG4gICAqXG4gICAqIFRoZSBUcmFuc2FjdGlvbiBtdXN0IGJlIGFzc2lnbmVkIGEgdmFsaWQgYHJlY2VudEJsb2NraGFzaGAgYmVmb3JlIGludm9raW5nIHRoaXMgbWV0aG9kXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8U2lnbmVyPn0gc2lnbmVycyBBcnJheSBvZiBzaWduZXJzIHRoYXQgd2lsbCBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgc2lnbiguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG5cbiAgICAvLyBEZWR1cGUgc2lnbmVyc1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdW5pcXVlU2lnbmVycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHNpZ25lci5wdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgdW5pcXVlU2lnbmVycy5wdXNoKHNpZ25lcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHVuaXF1ZVNpZ25lcnMubWFwKHNpZ25lciA9PiAoe1xuICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgcHVibGljS2V5OiBzaWduZXIucHVibGljS2V5XG4gICAgfSkpO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fcGFydGlhbFNpZ24obWVzc2FnZSwgLi4udW5pcXVlU2lnbmVycyk7XG4gIH1cblxuICAvKipcbiAgICogUGFydGlhbGx5IHNpZ24gYSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgYWNjb3VudHMuIEFsbCBhY2NvdW50cyBtdXN0XG4gICAqIGNvcnJlc3BvbmQgdG8gZWl0aGVyIHRoZSBmZWUgcGF5ZXIgb3IgYSBzaWduZXIgYWNjb3VudCBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogaW5zdHJ1Y3Rpb25zLlxuICAgKlxuICAgKiBBbGwgdGhlIGNhdmVhdHMgZnJvbSB0aGUgYHNpZ25gIG1ldGhvZCBhcHBseSB0byBgcGFydGlhbFNpZ25gXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8U2lnbmVyPn0gc2lnbmVycyBBcnJheSBvZiBzaWduZXJzIHRoYXQgd2lsbCBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgcGFydGlhbFNpZ24oLi4uc2lnbmVycykge1xuICAgIGlmIChzaWduZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduZXJzJyk7XG4gICAgfVxuXG4gICAgLy8gRGVkdXBlIHNpZ25lcnNcbiAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHVuaXF1ZVNpZ25lcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNpZ25lciBvZiBzaWduZXJzKSB7XG4gICAgICBjb25zdCBrZXkgPSBzaWduZXIucHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgIHVuaXF1ZVNpZ25lcnMucHVzaChzaWduZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fY29tcGlsZSgpO1xuICAgIHRoaXMuX3BhcnRpYWxTaWduKG1lc3NhZ2UsIC4uLnVuaXF1ZVNpZ25lcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3BhcnRpYWxTaWduKG1lc3NhZ2UsIC4uLnNpZ25lcnMpIHtcbiAgICBjb25zdCBzaWduRGF0YSA9IG1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgc2lnbmVycy5mb3JFYWNoKHNpZ25lciA9PiB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduKHNpZ25EYXRhLCBzaWduZXIuc2VjcmV0S2V5KTtcbiAgICAgIHRoaXMuX2FkZFNpZ25hdHVyZShzaWduZXIucHVibGljS2V5LCB0b0J1ZmZlcihzaWduYXR1cmUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXh0ZXJuYWxseSBjcmVhdGVkIHNpZ25hdHVyZSB0byBhIHRyYW5zYWN0aW9uLiBUaGUgcHVibGljIGtleVxuICAgKiBtdXN0IGNvcnJlc3BvbmQgdG8gZWl0aGVyIHRoZSBmZWUgcGF5ZXIgb3IgYSBzaWduZXIgYWNjb3VudCBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogaW5zdHJ1Y3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge1B1YmxpY0tleX0gcHVia2V5IFB1YmxpYyBrZXkgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZSBBbiBleHRlcm5hbGx5IGNyZWF0ZWQgc2lnbmF0dXJlIHRvIGFkZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBhZGRTaWduYXR1cmUocHVia2V5LCBzaWduYXR1cmUpIHtcbiAgICB0aGlzLl9jb21waWxlKCk7IC8vIEVuc3VyZSBzaWduYXR1cmVzIGFycmF5IGlzIHBvcHVsYXRlZFxuICAgIHRoaXMuX2FkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfYWRkU2lnbmF0dXJlKHB1YmtleSwgc2lnbmF0dXJlKSB7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZS5sZW5ndGggPT09IDY0KTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc2lnbmF0dXJlcy5maW5kSW5kZXgoc2lncGFpciA9PiBwdWJrZXkuZXF1YWxzKHNpZ3BhaXIucHVibGljS2V5KSk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHNpZ25lcjogJHtwdWJrZXkudG9TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgdGhpcy5zaWduYXR1cmVzW2luZGV4XS5zaWduYXR1cmUgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBzaWduYXR1cmVzIG9mIGEgVHJhbnNhY3Rpb25cbiAgICogT3B0aW9uYWwgcGFyYW1ldGVyIHNwZWNpZmllcyBpZiB3ZSdyZSBleHBlY3RpbmcgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb24gb3IgYSBwYXJ0aWFsbHkgc2lnbmVkIG9uZS5cbiAgICogSWYgbm8gYm9vbGVhbiBpcyBwcm92aWRlZCwgd2UgZXhwZWN0IGEgZnVsbHkgc2lnbmVkIFRyYW5zYWN0aW9uIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVpcmVBbGxTaWduYXR1cmVzPXRydWVdIFJlcXVpcmUgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb25cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZXMocmVxdWlyZUFsbFNpZ25hdHVyZXMgPSB0cnVlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlRXJyb3JzID0gdGhpcy5fZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnModGhpcy5zZXJpYWxpemVNZXNzYWdlKCksIHJlcXVpcmVBbGxTaWduYXR1cmVzKTtcbiAgICByZXR1cm4gIXNpZ25hdHVyZUVycm9ycztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyhtZXNzYWdlLCByZXF1aXJlQWxsU2lnbmF0dXJlcykge1xuICAgIGNvbnN0IGVycm9ycyA9IHt9O1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcHVibGljS2V5XG4gICAgfSBvZiB0aGlzLnNpZ25hdHVyZXMpIHtcbiAgICAgIGlmIChzaWduYXR1cmUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHJlcXVpcmVBbGxTaWduYXR1cmVzKSB7XG4gICAgICAgICAgKGVycm9ycy5taXNzaW5nIHx8PSBbXSkucHVzaChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleS50b0J5dGVzKCkpKSB7XG4gICAgICAgICAgKGVycm9ycy5pbnZhbGlkIHx8PSBbXSkucHVzaChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnMuaW52YWxpZCB8fCBlcnJvcnMubWlzc2luZyA/IGVycm9ycyA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIFRyYW5zYWN0aW9uIGluIHRoZSB3aXJlIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtjb25maWddIENvbmZpZyBvZiB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0J1ZmZlcn0gU2lnbmF0dXJlIG9mIHRyYW5zYWN0aW9uIGluIHdpcmUgZm9ybWF0LlxuICAgKi9cbiAgc2VyaWFsaXplKGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzLFxuICAgICAgdmVyaWZ5U2lnbmF0dXJlc1xuICAgIH0gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiB0cnVlLFxuICAgICAgdmVyaWZ5U2lnbmF0dXJlczogdHJ1ZVxuICAgIH0sIGNvbmZpZyk7XG4gICAgY29uc3Qgc2lnbkRhdGEgPSB0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UoKTtcbiAgICBpZiAodmVyaWZ5U2lnbmF0dXJlcykge1xuICAgICAgY29uc3Qgc2lnRXJyb3JzID0gdGhpcy5fZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnMoc2lnbkRhdGEsIHJlcXVpcmVBbGxTaWduYXR1cmVzKTtcbiAgICAgIGlmIChzaWdFcnJvcnMpIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZC4nO1xuICAgICAgICBpZiAoc2lnRXJyb3JzLmludmFsaWQpIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcbkludmFsaWQgc2lnbmF0dXJlIGZvciBwdWJsaWMga2V5JHtzaWdFcnJvcnMuaW52YWxpZC5sZW5ndGggPT09IDEgPyAnJyA6ICcocyknfSBbXFxgJHtzaWdFcnJvcnMuaW52YWxpZC5tYXAocCA9PiBwLnRvQmFzZTU4KCkpLmpvaW4oJ2AsIGAnKX1cXGBdLmA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ0Vycm9ycy5taXNzaW5nKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGBcXG5NaXNzaW5nIHNpZ25hdHVyZSBmb3IgcHVibGljIGtleSR7c2lnRXJyb3JzLm1pc3NpbmcubGVuZ3RoID09PSAxID8gJycgOiAnKHMpJ30gW1xcYCR7c2lnRXJyb3JzLm1pc3NpbmcubWFwKHAgPT4gcC50b0Jhc2U1OCgpKS5qb2luKCdgLCBgJyl9XFxgXS5gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplKHNpZ25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXJpYWxpemUoc2lnbkRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYXR1cmVzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2lnbmF0dXJlQ291bnQgPSBbXTtcbiAgICBlbmNvZGVMZW5ndGgoc2lnbmF0dXJlQ291bnQsIHNpZ25hdHVyZXMubGVuZ3RoKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkxlbmd0aCA9IHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIHNpZ25hdHVyZXMubGVuZ3RoICogNjQgKyBzaWduRGF0YS5sZW5ndGg7XG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gQnVmZmVyLmFsbG9jKHRyYW5zYWN0aW9uTGVuZ3RoKTtcbiAgICBhc3NlcnQoc2lnbmF0dXJlcy5sZW5ndGggPCAyNTYpO1xuICAgIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZUNvdW50KS5jb3B5KHdpcmVUcmFuc2FjdGlvbiwgMCk7XG4gICAgc2lnbmF0dXJlcy5mb3JFYWNoKCh7XG4gICAgICBzaWduYXR1cmVcbiAgICB9LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKHNpZ25hdHVyZSAhPT0gbnVsbCkge1xuICAgICAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQsIGBzaWduYXR1cmUgaGFzIGludmFsaWQgbGVuZ3RoYCk7XG4gICAgICAgIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkuY29weSh3aXJlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIGluZGV4ICogNjQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNpZ25EYXRhLmNvcHkod2lyZVRyYW5zYWN0aW9uLCBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBzaWduYXR1cmVzLmxlbmd0aCAqIDY0KTtcbiAgICBhc3NlcnQod2lyZVRyYW5zYWN0aW9uLmxlbmd0aCA8PSBQQUNLRVRfREFUQV9TSVpFLCBgVHJhbnNhY3Rpb24gdG9vIGxhcmdlOiAke3dpcmVUcmFuc2FjdGlvbi5sZW5ndGh9ID4gJHtQQUNLRVRfREFUQV9TSVpFfWApO1xuICAgIHJldHVybiB3aXJlVHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQga2V5cygpIHtcbiAgICBhc3NlcnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0ua2V5cy5tYXAoa2V5T2JqID0+IGtleU9iai5wdWJrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IHByb2dyYW1JZCgpIHtcbiAgICBhc3NlcnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0ucHJvZ3JhbUlkO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgYXNzZXJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSB3aXJlIHRyYW5zYWN0aW9uIGludG8gYSBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj59IGJ1ZmZlciBTaWduYXR1cmUgb2Ygd2lyZSBUcmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259IFRyYW5zYWN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2lnbmF0dXJlXG4gICAqL1xuICBzdGF0aWMgZnJvbShidWZmZXIpIHtcbiAgICAvLyBTbGljZSB1cCB3aXJlIGRhdGFcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLmJ1ZmZlcl07XG4gICAgY29uc3Qgc2lnbmF0dXJlQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgc2lnbmF0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlQ291bnQ7IGkrKykge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpO1xuICAgICAgc2lnbmF0dXJlcy5wdXNoKGJzNTguZW5jb2RlKEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uLnBvcHVsYXRlKE1lc3NhZ2UuZnJvbShieXRlQXJyYXkpLCBzaWduYXR1cmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZSBUcmFuc2FjdGlvbiBvYmplY3QgZnJvbSBtZXNzYWdlIGFuZCBzaWduYXR1cmVzXG4gICAqXG4gICAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZSBNZXNzYWdlIG9mIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc2lnbmF0dXJlcyBMaXN0IG9mIHNpZ25hdHVyZXMgdG8gYXNzaWduIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259IFRoZSBwb3B1bGF0ZWQgVHJhbnNhY3Rpb25cbiAgICovXG4gIHN0YXRpYyBwb3B1bGF0ZShtZXNzYWdlLCBzaWduYXR1cmVzID0gW10pIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IG1lc3NhZ2UucmVjZW50QmxvY2toYXNoO1xuICAgIGlmIChtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMgPiAwKSB7XG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IG1lc3NhZ2UuYWNjb3VudEtleXNbMF07XG4gICAgfVxuICAgIHNpZ25hdHVyZXMuZm9yRWFjaCgoc2lnbmF0dXJlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qgc2lnUHVia2V5UGFpciA9IHtcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUgPT0gYnM1OC5lbmNvZGUoREVGQVVMVF9TSUdOQVRVUkUpID8gbnVsbCA6IGJzNTguZGVjb2RlKHNpZ25hdHVyZSksXG4gICAgICAgIHB1YmxpY0tleTogbWVzc2FnZS5hY2NvdW50S2V5c1tpbmRleF1cbiAgICAgIH07XG4gICAgICB0cmFuc2FjdGlvbi5zaWduYXR1cmVzLnB1c2goc2lnUHVia2V5UGFpcik7XG4gICAgfSk7XG4gICAgbWVzc2FnZS5pbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCBrZXlzID0gaW5zdHJ1Y3Rpb24uYWNjb3VudHMubWFwKGFjY291bnQgPT4ge1xuICAgICAgICBjb25zdCBwdWJrZXkgPSBtZXNzYWdlLmFjY291bnRLZXlzW2FjY291bnRdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjogdHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5zb21lKGtleU9iaiA9PiBrZXlPYmoucHVibGljS2V5LnRvU3RyaW5nKCkgPT09IHB1YmtleS50b1N0cmluZygpKSB8fCBtZXNzYWdlLmlzQWNjb3VudFNpZ25lcihhY2NvdW50KSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBtZXNzYWdlLmlzQWNjb3VudFdyaXRhYmxlKGFjY291bnQpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHRyYW5zYWN0aW9uLmluc3RydWN0aW9ucy5wdXNoKG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAga2V5cyxcbiAgICAgICAgcHJvZ3JhbUlkOiBtZXNzYWdlLmFjY291bnRLZXlzW2luc3RydWN0aW9uLnByb2dyYW1JZEluZGV4XSxcbiAgICAgICAgZGF0YTogYnM1OC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSlcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICB0cmFuc2FjdGlvbi5fbWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdHJhbnNhY3Rpb24uX2pzb24gPSB0cmFuc2FjdGlvbi50b0pTT04oKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cbn1cblxuY2xhc3MgVHJhbnNhY3Rpb25NZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMucGF5ZXJLZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDA7XG4gICAgdGhpcy5wYXllcktleSA9IGFyZ3MucGF5ZXJLZXk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBhcmdzLmluc3RydWN0aW9ucztcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGFyZ3MucmVjZW50QmxvY2toYXNoO1xuICB9XG4gIHN0YXRpYyBkZWNvbXBpbGUobWVzc2FnZSwgYXJncykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhlYWRlcixcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgcmVjZW50QmxvY2toYXNoXG4gICAgfSA9IG1lc3NhZ2U7XG4gICAgY29uc3Qge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50c1xuICAgIH0gPSBoZWFkZXI7XG4gICAgY29uc3QgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA9IG51bVJlcXVpcmVkU2lnbmF0dXJlcyAtIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgYXNzZXJ0KG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPiAwLCAnTWVzc2FnZSBoZWFkZXIgaXMgaW52YWxpZCcpO1xuICAgIGNvbnN0IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA9IG1lc3NhZ2Uuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoIC0gbnVtUmVxdWlyZWRTaWduYXR1cmVzIC0gbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgIGFzc2VydChudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPj0gMCwgJ01lc3NhZ2UgaGVhZGVyIGlzIGludmFsaWQnKTtcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IG1lc3NhZ2UuZ2V0QWNjb3VudEtleXMoYXJncyk7XG4gICAgY29uc3QgcGF5ZXJLZXkgPSBhY2NvdW50S2V5cy5nZXQoMCk7XG4gICAgaWYgKHBheWVyS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY29tcGlsZSBtZXNzYWdlIGJlY2F1c2Ugbm8gYWNjb3VudCBrZXlzIHdlcmUgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgZm9yIChjb25zdCBjb21waWxlZEl4IG9mIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleUluZGV4IG9mIGNvbXBpbGVkSXguYWNjb3VudEtleUluZGV4ZXMpIHtcbiAgICAgICAgY29uc3QgcHVia2V5ID0gYWNjb3VudEtleXMuZ2V0KGtleUluZGV4KTtcbiAgICAgICAgaWYgKHB1YmtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBrZXkgZm9yIGFjY291bnQga2V5IGluZGV4ICR7a2V5SW5kZXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNTaWduZXIgPSBrZXlJbmRleCA8IG51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgICAgICAgbGV0IGlzV3JpdGFibGU7XG4gICAgICAgIGlmIChpc1NpZ25lcikge1xuICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCA8IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHM7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5SW5kZXggPCBhY2NvdW50S2V5cy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICBpc1dyaXRhYmxlID0ga2V5SW5kZXggLSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNXcml0YWJsZSA9IGtleUluZGV4IC0gYWNjb3VudEtleXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoIDxcbiAgICAgICAgICAvLyBhY2NvdW50S2V5c0Zyb21Mb29rdXBzIGNhbm5vdCBiZSB1bmRlZmluZWQgYmVjYXVzZSB3ZSBhbHJlYWR5IGZvdW5kIGEgcHVia2V5IGZvciB0aGlzIGluZGV4IGFib3ZlXG4gICAgICAgICAgYWNjb3VudEtleXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IGtleUluZGV4IDwgaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgICBpc1dyaXRhYmxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvZ3JhbUlkID0gYWNjb3VudEtleXMuZ2V0KGNvbXBpbGVkSXgucHJvZ3JhbUlkSW5kZXgpO1xuICAgICAgaWYgKHByb2dyYW1JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgcHJvZ3JhbSBpZCBmb3IgcHJvZ3JhbSBpZCBpbmRleCAke2NvbXBpbGVkSXgucHJvZ3JhbUlkSW5kZXh9YCk7XG4gICAgICB9XG4gICAgICBpbnN0cnVjdGlvbnMucHVzaChuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIHByb2dyYW1JZCxcbiAgICAgICAgZGF0YTogdG9CdWZmZXIoY29tcGlsZWRJeC5kYXRhKSxcbiAgICAgICAga2V5c1xuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uTWVzc2FnZSh7XG4gICAgICBwYXllcktleSxcbiAgICAgIGluc3RydWN0aW9ucyxcbiAgICAgIHJlY2VudEJsb2NraGFzaFxuICAgIH0pO1xuICB9XG4gIGNvbXBpbGVUb0xlZ2FjeU1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIE1lc3NhZ2UuY29tcGlsZSh7XG4gICAgICBwYXllcktleTogdGhpcy5wYXllcktleSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogdGhpcy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgY29tcGlsZVRvVjBNZXNzYWdlKGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgcmV0dXJuIE1lc3NhZ2VWMC5jb21waWxlKHtcbiAgICAgIHBheWVyS2V5OiB0aGlzLnBheWVyS2V5LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnMsXG4gICAgICBhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50c1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVmVyc2lvbmVkIHRyYW5zYWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFZlcnNpb25lZFRyYW5zYWN0aW9uIHtcbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZS52ZXJzaW9uO1xuICB9XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHNpZ25hdHVyZXMpIHtcbiAgICB0aGlzLnNpZ25hdHVyZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5tZXNzYWdlID0gdm9pZCAwO1xuICAgIGlmIChzaWduYXR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFzc2VydChzaWduYXR1cmVzLmxlbmd0aCA9PT0gbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLCAnRXhwZWN0ZWQgc2lnbmF0dXJlcyBsZW5ndGggdG8gYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiByZXF1aXJlZCBzaWduYXR1cmVzJyk7XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBzaWduYXR1cmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZWZhdWx0U2lnbmF0dXJlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7IGkrKykge1xuICAgICAgICBkZWZhdWx0U2lnbmF0dXJlcy5wdXNoKG5ldyBVaW50OEFycmF5KFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IGRlZmF1bHRTaWduYXR1cmVzO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkTWVzc2FnZSA9IHRoaXMubWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBjb25zdCBlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoLCB0aGlzLnNpZ25hdHVyZXMubGVuZ3RoKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5ibG9iKGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRTaWduYXR1cmVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoc2lnbmF0dXJlKCksIHRoaXMuc2lnbmF0dXJlcy5sZW5ndGgsICdzaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC5ibG9iKHNlcmlhbGl6ZWRNZXNzYWdlLmxlbmd0aCwgJ3NlcmlhbGl6ZWRNZXNzYWdlJyldKTtcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBuZXcgVWludDhBcnJheSgyMDQ4KTtcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb25MZW5ndGggPSB0cmFuc2FjdGlvbkxheW91dC5lbmNvZGUoe1xuICAgICAgZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoKSxcbiAgICAgIHNpZ25hdHVyZXM6IHRoaXMuc2lnbmF0dXJlcyxcbiAgICAgIHNlcmlhbGl6ZWRNZXNzYWdlXG4gICAgfSwgc2VyaWFsaXplZFRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZFRyYW5zYWN0aW9uLnNsaWNlKDAsIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbikge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uc2VyaWFsaXplZFRyYW5zYWN0aW9uXTtcbiAgICBjb25zdCBzaWduYXR1cmVzID0gW107XG4gICAgY29uc3Qgc2lnbmF0dXJlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlc0xlbmd0aDsgaSsrKSB7XG4gICAgICBzaWduYXR1cmVzLnB1c2gobmV3IFVpbnQ4QXJyYXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpKSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplKG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheSkpO1xuICAgIHJldHVybiBuZXcgVmVyc2lvbmVkVHJhbnNhY3Rpb24obWVzc2FnZSwgc2lnbmF0dXJlcyk7XG4gIH1cbiAgc2lnbihzaWduZXJzKSB7XG4gICAgY29uc3QgbWVzc2FnZURhdGEgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgc2lnbmVyUHVia2V5cyA9IHRoaXMubWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5zbGljZSgwLCB0aGlzLm1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qgc2lnbmVySW5kZXggPSBzaWduZXJQdWJrZXlzLmZpbmRJbmRleChwdWJrZXkgPT4gcHVia2V5LmVxdWFscyhzaWduZXIucHVibGljS2V5KSk7XG4gICAgICBhc3NlcnQoc2lnbmVySW5kZXggPj0gMCwgYENhbm5vdCBzaWduIHdpdGggbm9uIHNpZ25lciBrZXkgJHtzaWduZXIucHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgICB0aGlzLnNpZ25hdHVyZXNbc2lnbmVySW5kZXhdID0gc2lnbihtZXNzYWdlRGF0YSwgc2lnbmVyLnNlY3JldEtleSk7XG4gICAgfVxuICB9XG4gIGFkZFNpZ25hdHVyZShwdWJsaWNLZXksIHNpZ25hdHVyZSkge1xuICAgIGFzc2VydChzaWduYXR1cmUuYnl0ZUxlbmd0aCA9PT0gNjQsICdTaWduYXR1cmUgbXVzdCBiZSA2NCBieXRlcyBsb25nJyk7XG4gICAgY29uc3Qgc2lnbmVyUHVia2V5cyA9IHRoaXMubWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5zbGljZSgwLCB0aGlzLm1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgY29uc3Qgc2lnbmVySW5kZXggPSBzaWduZXJQdWJrZXlzLmZpbmRJbmRleChwdWJrZXkgPT4gcHVia2V5LmVxdWFscyhwdWJsaWNLZXkpKTtcbiAgICBhc3NlcnQoc2lnbmVySW5kZXggPj0gMCwgYENhbiBub3QgYWRkIHNpZ25hdHVyZTsgXFxgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1cXGAgaXMgbm90IHJlcXVpcmVkIHRvIHNpZ24gdGhpcyB0cmFuc2FjdGlvbmApO1xuICAgIHRoaXMuc2lnbmF0dXJlc1tzaWduZXJJbmRleF0gPSBzaWduYXR1cmU7XG4gIH1cbn1cblxuLy8gVE9ETzogVGhlc2UgY29uc3RhbnRzIHNob3VsZCBiZSByZW1vdmVkIGluIGZhdm9yIG9mIHJlYWRpbmcgdGhlbSBvdXQgb2YgYVxuLy8gU3lzY2FsbCBhY2NvdW50XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE5VTV9USUNLU19QRVJfU0VDT05EID0gMTYwO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBERUZBVUxUX1RJQ0tTX1BFUl9TTE9UID0gNjQ7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE5VTV9TTE9UU19QRVJfU0VDT05EID0gTlVNX1RJQ0tTX1BFUl9TRUNPTkQgLyBERUZBVUxUX1RJQ0tTX1BFUl9TTE9UO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBNU19QRVJfU0xPVCA9IDEwMDAgLyBOVU1fU0xPVFNfUEVSX1NFQ09ORDtcblxuY29uc3QgU1lTVkFSX0NMT0NLX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhckMxb2NrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJFcG9jaFNjaGVkdTFlMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfSU5TVFJVQ1RJT05TX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhcjFuc3RydWN0aW9uczExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmVjZW50QjFvY2tIYXNoZXMxMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1JFTlRfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmVudDExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1JFV0FSRFNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmV3YXJkczExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1NMT1RfSEFTSEVTX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclMxb3RIYXNoZXMxMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUzFvdEhpc3RvcnkxMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyU3Rha2VIaXN0b3J5MTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG5jbGFzcyBTZW5kVHJhbnNhY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGFjdGlvbixcbiAgICBzaWduYXR1cmUsXG4gICAgdHJhbnNhY3Rpb25NZXNzYWdlLFxuICAgIGxvZ3NcbiAgfSkge1xuICAgIGNvbnN0IG1heWJlTG9nc091dHB1dCA9IGxvZ3MgPyBgTG9nczogXFxuJHtKU09OLnN0cmluZ2lmeShsb2dzLnNsaWNlKC0xMCksIG51bGwsIDIpfS4gYCA6ICcnO1xuICAgIGNvbnN0IGd1aWRlVGV4dCA9ICdcXG5DYXRjaCB0aGUgYFNlbmRUcmFuc2FjdGlvbkVycm9yYCBhbmQgY2FsbCBgZ2V0TG9ncygpYCBvbiBpdCBmb3IgZnVsbCBkZXRhaWxzLic7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgJ3NlbmQnOlxuICAgICAgICBtZXNzYWdlID0gYFRyYW5zYWN0aW9uICR7c2lnbmF0dXJlfSByZXN1bHRlZCBpbiBhbiBlcnJvci4gXFxuYCArIGAke3RyYW5zYWN0aW9uTWVzc2FnZX0uIGAgKyBtYXliZUxvZ3NPdXRwdXQgKyBndWlkZVRleHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2ltdWxhdGUnOlxuICAgICAgICBtZXNzYWdlID0gYFNpbXVsYXRpb24gZmFpbGVkLiBcXG5NZXNzYWdlOiAke3RyYW5zYWN0aW9uTWVzc2FnZX0uIFxcbmAgKyBtYXliZUxvZ3NPdXRwdXQgKyBndWlkZVRleHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIG1lc3NhZ2UgPSBgVW5rbm93biBhY3Rpb24gJyR7KGEgPT4gYSkoYWN0aW9uKX0nYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uTWVzc2FnZSA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uTG9ncyA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uTWVzc2FnZSA9IHRyYW5zYWN0aW9uTWVzc2FnZTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uTG9ncyA9IGxvZ3MgPyBsb2dzIDogdW5kZWZpbmVkO1xuICB9XG4gIGdldCB0cmFuc2FjdGlvbkVycm9yKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiB0aGlzLnRyYW5zYWN0aW9uTWVzc2FnZSxcbiAgICAgIGxvZ3M6IEFycmF5LmlzQXJyYXkodGhpcy50cmFuc2FjdGlvbkxvZ3MpID8gdGhpcy50cmFuc2FjdGlvbkxvZ3MgOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgLyogQGRlcHJlY2F0ZWQgVXNlIGBhd2FpdCBnZXRMb2dzKClgIGluc3RlYWQgKi9cbiAgZ2V0IGxvZ3MoKSB7XG4gICAgY29uc3QgY2FjaGVkTG9ncyA9IHRoaXMudHJhbnNhY3Rpb25Mb2dzO1xuICAgIGlmIChjYWNoZWRMb2dzICE9IG51bGwgJiYgdHlwZW9mIGNhY2hlZExvZ3MgPT09ICdvYmplY3QnICYmICd0aGVuJyBpbiBjYWNoZWRMb2dzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkTG9ncztcbiAgfVxuICBhc3luYyBnZXRMb2dzKGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy50cmFuc2FjdGlvbkxvZ3MpKSB7XG4gICAgICB0aGlzLnRyYW5zYWN0aW9uTG9ncyA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29ubmVjdGlvbi5nZXRUcmFuc2FjdGlvbih0aGlzLnNpZ25hdHVyZSkudGhlbih0eCA9PiB7XG4gICAgICAgICAgaWYgKHR4ICYmIHR4Lm1ldGEgJiYgdHgubWV0YS5sb2dNZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgbG9ncyA9IHR4Lm1ldGEubG9nTWVzc2FnZXM7XG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uTG9ncyA9IGxvZ3M7XG4gICAgICAgICAgICByZXNvbHZlKGxvZ3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdMb2cgbWVzc2FnZXMgbm90IGZvdW5kJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2FjdGlvbkxvZ3M7XG4gIH1cbn1cblxuLy8gS2VlcCBpbiBzeW5jIHdpdGggY2xpZW50L3NyYy9ycGNfY3VzdG9tX2Vycm9ycy5yc1xuLy8gVHlwZXNjcmlwdCBgZW51bXNgIHRod2FydCB0cmVlLXNoYWtpbmcuIFNlZSBodHRwczovL2JhcmdzdGVuLm9yZy9qc3RzL2VudW1zL1xuY29uc3QgU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSA9IHtcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVA6IC0zMjAwMSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkU6IC0zMjAwMixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRTogLTMyMDAzLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRTogLTMyMDA0LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFk6IC0zMjAwNSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkU6IC0zMjAwNixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRDogLTMyMDA3LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1Q6IC0zMjAwOCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRDogLTMyMDA5LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYOiAtMzIwMTAsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEU6IC0zMjAxMSxcbiAgSlNPTl9SUENfU0NBTl9FUlJPUjogLTMyMDEyLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSDogLTMyMDEzLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUOiAtMzIwMTQsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OOiAtMzIwMTUsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEOiAtMzIwMTZcbn07XG5jbGFzcyBTb2xhbmFKU09OUlBDRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb2RlLFxuICAgIG1lc3NhZ2UsXG4gICAgZGF0YVxuICB9LCBjdXN0b21NZXNzYWdlKSB7XG4gICAgc3VwZXIoY3VzdG9tTWVzc2FnZSAhPSBudWxsID8gYCR7Y3VzdG9tTWVzc2FnZX06ICR7bWVzc2FnZX1gIDogbWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gdm9pZCAwO1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5uYW1lID0gJ1NvbGFuYUpTT05SUENFcnJvcic7XG4gIH1cbn1cblxuLyoqXG4gKiBTaWduLCBzZW5kIGFuZCBjb25maXJtIGEgdHJhbnNhY3Rpb24uXG4gKlxuICogSWYgYGNvbW1pdG1lbnRgIG9wdGlvbiBpcyBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byAnbWF4JyBjb21taXRtZW50LlxuICpcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8U2lnbmVyPn0gc2lnbmVyc1xuICogQHBhcmFtIHtDb25maXJtT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIHNpZ25lcnMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2VuZE9wdGlvbnMgPSBvcHRpb25zICYmIHtcbiAgICBza2lwUHJlZmxpZ2h0OiBvcHRpb25zLnNraXBQcmVmbGlnaHQsXG4gICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICBtYXhSZXRyaWVzOiBvcHRpb25zLm1heFJldHJpZXMsXG4gICAgbWluQ29udGV4dFNsb3Q6IG9wdGlvbnMubWluQ29udGV4dFNsb3RcbiAgfTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25lcnMsIHNlbmRPcHRpb25zKTtcbiAgbGV0IHN0YXR1cztcbiAgaWYgKHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCAhPSBudWxsICYmIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ICE9IG51bGwpIHtcbiAgICBzdGF0dXMgPSAoYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnM/LmFib3J0U2lnbmFsLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICBibG9ja2hhc2g6IHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodFxuICAgIH0sIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH0gZWxzZSBpZiAodHJhbnNhY3Rpb24ubWluTm9uY2VDb250ZXh0U2xvdCAhPSBudWxsICYmIHRyYW5zYWN0aW9uLm5vbmNlSW5mbyAhPSBudWxsKSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9uY2VJbnN0cnVjdGlvblxuICAgIH0gPSB0cmFuc2FjdGlvbi5ub25jZUluZm87XG4gICAgY29uc3Qgbm9uY2VBY2NvdW50UHVia2V5ID0gbm9uY2VJbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleTtcbiAgICBzdGF0dXMgPSAoYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnM/LmFib3J0U2lnbmFsLFxuICAgICAgbWluQ29udGV4dFNsb3Q6IHRyYW5zYWN0aW9uLm1pbk5vbmNlQ29udGV4dFNsb3QsXG4gICAgICBub25jZUFjY291bnRQdWJrZXksXG4gICAgICBub25jZVZhbHVlOiB0cmFuc2FjdGlvbi5ub25jZUluZm8ubm9uY2UsXG4gICAgICBzaWduYXR1cmVcbiAgICB9LCBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCkpLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRpb25zPy5hYm9ydFNpZ25hbCAhPSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ3NlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oKTogQSB0cmFuc2FjdGlvbiB3aXRoIGEgZGVwcmVjYXRlZCBjb25maXJtYXRpb24gc3RyYXRlZ3kgd2FzICcgKyAnc3VwcGxpZWQgYWxvbmcgd2l0aCBhbiBgYWJvcnRTaWduYWxgLiBPbmx5IHRyYW5zYWN0aW9ucyBoYXZpbmcgYGxhc3RWYWxpZEJsb2NrSGVpZ2h0YCAnICsgJ29yIGEgY29tYmluYXRpb24gb2YgYG5vbmNlSW5mb2AgYW5kIGBtaW5Ob25jZUNvbnRleHRTbG90YCBhcmUgYWJvcnRhYmxlLicpO1xuICAgIH1cbiAgICBzdGF0dXMgPSAoYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCkpLnZhbHVlO1xuICB9XG4gIGlmIChzdGF0dXMuZXJyKSB7XG4gICAgaWYgKHNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3Ioe1xuICAgICAgICBhY3Rpb246ICdzZW5kJyxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgIHRyYW5zYWN0aW9uTWVzc2FnZTogYFN0YXR1czogKCR7SlNPTi5zdHJpbmdpZnkoc3RhdHVzKX0pYFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgKTtcbiAgfVxuICByZXR1cm4gc2lnbmF0dXJlO1xufVxuXG4vLyB6enpcbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFBvcHVsYXRlIGEgYnVmZmVyIG9mIGluc3RydWN0aW9uIGRhdGEgdXNpbmcgYW4gSW5zdHJ1Y3Rpb25UeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZW5jb2RlRGF0YSh0eXBlLCBmaWVsZHMpIHtcbiAgY29uc3QgYWxsb2NMZW5ndGggPSB0eXBlLmxheW91dC5zcGFuID49IDAgPyB0eXBlLmxheW91dC5zcGFuIDogZ2V0QWxsb2ModHlwZSwgZmllbGRzKTtcbiAgY29uc3QgZGF0YSA9IEJ1ZmZlci5hbGxvYyhhbGxvY0xlbmd0aCk7XG4gIGNvbnN0IGxheW91dEZpZWxkcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGluc3RydWN0aW9uOiB0eXBlLmluZGV4XG4gIH0sIGZpZWxkcyk7XG4gIHR5cGUubGF5b3V0LmVuY29kZShsYXlvdXRGaWVsZHMsIGRhdGEpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgaW5zdHJ1Y3Rpb24gZGF0YSBidWZmZXIgdXNpbmcgYW4gSW5zdHJ1Y3Rpb25UeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZGVjb2RlRGF0YSQxKHR5cGUsIGJ1ZmZlcikge1xuICBsZXQgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdHlwZS5sYXlvdXQuZGVjb2RlKGJ1ZmZlcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgJyArIGVycik7XG4gIH1cbiAgaWYgKGRhdGEuaW5zdHJ1Y3Rpb24gIT09IHR5cGUuaW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGluc3RydWN0aW9uIGluZGV4IG1pc21hdGNoICR7ZGF0YS5pbnN0cnVjdGlvbn0gIT0gJHt0eXBlLmluZGV4fWApO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi85MGJlZGQ3ZTA2N2I1YjhmM2RkYmI0NWRhMDBhNGU5Y2FiYjIyYzYyL3Nkay9zcmMvZmVlX2NhbGN1bGF0b3IucnMjTDctTDExXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEZlZUNhbGN1bGF0b3JMYXlvdXQgPSBCdWZmZXJMYXlvdXQubnU2NCgnbGFtcG9ydHNQZXJTaWduYXR1cmUnKTtcblxuLyoqXG4gKiBDYWxjdWxhdG9yIGZvciB0cmFuc2FjdGlvbiBmZWVzLlxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC5cbiAqL1xuXG4vKipcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvMGVhMjg0M2VjOWNkYzUxNzU3MmI4ZTYyYzk1OWY0MWI1NWNmNDQ1My9zZGsvc3JjL25vbmNlX3N0YXRlLnJzI0wyOS1MMzJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTm9uY2VBY2NvdW50TGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMigndmVyc2lvbicpLCBCdWZmZXJMYXlvdXQudTMyKCdzdGF0ZScpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRQdWJrZXknKSwgcHVibGljS2V5KCdub25jZScpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtGZWVDYWxjdWxhdG9yTGF5b3V0XSwgJ2ZlZUNhbGN1bGF0b3InKV0pO1xuY29uc3QgTk9OQ0VfQUNDT1VOVF9MRU5HVEggPSBOb25jZUFjY291bnRMYXlvdXQuc3BhbjtcblxuLyoqXG4gKiBBIGR1cmFibGUgbm9uY2UgaXMgYSAzMiBieXRlIHZhbHVlIGVuY29kZWQgYXMgYSBiYXNlNTggc3RyaW5nLlxuICovXG5cbi8qKlxuICogTm9uY2VBY2NvdW50IGNsYXNzXG4gKi9cbmNsYXNzIE5vbmNlQWNjb3VudCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmF1dGhvcml6ZWRQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5ub25jZSA9IHZvaWQgMDtcbiAgICB0aGlzLmZlZUNhbGN1bGF0b3IgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkUHVia2V5ID0gYXJncy5hdXRob3JpemVkUHVia2V5O1xuICAgIHRoaXMubm9uY2UgPSBhcmdzLm5vbmNlO1xuICAgIHRoaXMuZmVlQ2FsY3VsYXRvciA9IGFyZ3MuZmVlQ2FsY3VsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBOb25jZUFjY291bnQgZnJvbSB0aGUgYWNjb3VudCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIE5vbmNlQWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGZyb21BY2NvdW50RGF0YShidWZmZXIpIHtcbiAgICBjb25zdCBub25jZUFjY291bnQgPSBOb25jZUFjY291bnRMYXlvdXQuZGVjb2RlKHRvQnVmZmVyKGJ1ZmZlciksIDApO1xuICAgIHJldHVybiBuZXcgTm9uY2VBY2NvdW50KHtcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobm9uY2VBY2NvdW50LmF1dGhvcml6ZWRQdWJrZXkpLFxuICAgICAgbm9uY2U6IG5ldyBQdWJsaWNLZXkobm9uY2VBY2NvdW50Lm5vbmNlKS50b1N0cmluZygpLFxuICAgICAgZmVlQ2FsY3VsYXRvcjogbm9uY2VBY2NvdW50LmZlZUNhbGN1bGF0b3JcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1NjQocHJvcGVydHkpIHtcbiAgY29uc3QgbGF5b3V0ID0gYmxvYig4IC8qIGJ5dGVzICovLCBwcm9wZXJ0eSk7XG4gIGNvbnN0IGRlY29kZSA9IGxheW91dC5kZWNvZGUuYmluZChsYXlvdXQpO1xuICBjb25zdCBlbmNvZGUgPSBsYXlvdXQuZW5jb2RlLmJpbmQobGF5b3V0KTtcbiAgY29uc3QgYmlnSW50TGF5b3V0ID0gbGF5b3V0O1xuICBjb25zdCBjb2RlYyA9IGdldFU2NENvZGVjKCk7XG4gIGJpZ0ludExheW91dC5kZWNvZGUgPSAoYnVmZmVyLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBzcmMgPSBkZWNvZGUoYnVmZmVyLCBvZmZzZXQpO1xuICAgIHJldHVybiBjb2RlYy5kZWNvZGUoc3JjKTtcbiAgfTtcbiAgYmlnSW50TGF5b3V0LmVuY29kZSA9IChiaWdJbnQsIGJ1ZmZlciwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3Qgc3JjID0gY29kZWMuZW5jb2RlKGJpZ0ludCk7XG4gICAgcmV0dXJuIGVuY29kZShzcmMsIGJ1ZmZlciwgb2Zmc2V0KTtcbiAgfTtcbiAgcmV0dXJuIGJpZ0ludExheW91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBUcmFuc2ZlciBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBc3NpZ24gc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBub25jZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBub25jZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplIG5vbmNlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQWR2YW5jZSBub25jZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFdpdGhkcmF3IG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXV0aG9yaXplIG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQWxsb2NhdGUgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbGxvY2F0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBc3NpZ24gYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVHJhbnNmZXIgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKiogRGVjb2RlZCB0cmFuc2ZlciBzeXN0ZW0gdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gKi9cblxuLyoqIERlY29kZWQgdHJhbnNmZXJXaXRoU2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gKi9cblxuLyoqXG4gKiBTeXN0ZW0gSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgU3lzdGVtSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBTeXN0ZW1JbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjcmVhdGUgYWNjb3VudCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQ3JlYXRlQWNjb3VudChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHRyYW5zZmVyIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVUcmFuc2ZlcihpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlciwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHRyYW5zZmVyIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlVHJhbnNmZXJXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXJXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFsbG9jYXRlIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBbGxvY2F0ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNwYWNlXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc3BhY2VcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhbGxvY2F0ZSB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFsbG9jYXRlV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBuZXcgUHVibGljS2V5KGJhc2UpLFxuICAgICAgc2VlZCxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhc3NpZ24gc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFzc2lnbihpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFzc2lnbiB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFzc2lnbldpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgYmFzZSxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbldpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBuZXcgUHVibGljS2V5KGJhc2UpLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjcmVhdGUgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUNyZWF0ZVdpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgYmFzZSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBuZXcgUHVibGljS2V5KGJhc2UpLFxuICAgICAgc2VlZCxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2UgaW5pdGlhbGl6ZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VJbml0aWFsaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgYXV0aG9yaXplZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZU5vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG5vbmNlIGFkdmFuY2Ugc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlQWR2YW5jZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BZHZhbmNlTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG5vbmNlIHdpdGhkcmF3IHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNSk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3Tm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s0XS5wdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2UgYXV0aG9yaXplIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZUF1dGhvcml6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dGhvcml6ZWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZU5vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFN5c3RlbVByb2dyYW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlMZW5ndGgoa2V5cywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFN5c3RlbUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBzeXN0ZW0gSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBDcmVhdGU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpLCBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIEFzc2lnbjoge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIFRyYW5zZmVyOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBDcmVhdGVXaXRoU2VlZDoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdiYXNlJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgQWR2YW5jZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIFdpdGhkcmF3Tm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDUsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIEluaXRpYWxpemVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZCcpXSlcbiAgfSxcbiAgQXV0aG9yaXplTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDcsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWQnKV0pXG4gIH0sXG4gIEFsbG9jYXRlOiB7XG4gICAgaW5kZXg6IDgsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKV0pXG4gIH0sXG4gIEFsbG9jYXRlV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogOSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgQXNzaWduV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2Jhc2UnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVHJhbnNmZXJXaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgnbGFtcG9ydHMnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVXBncmFkZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiAxMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgU3lzdGVtIHByb2dyYW1cbiAqL1xuY2xhc3MgU3lzdGVtUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFN5c3RlbSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogcGFyYW1zLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5ld0FjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IHRyYW5zZmVycyBsYW1wb3J0cyBmcm9tIG9uZSBhY2NvdW50IHRvIGFub3RoZXJcbiAgICovXG4gIHN0YXRpYyB0cmFuc2ZlcihwYXJhbXMpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQga2V5cztcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyV2l0aFNlZWQ7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGxhbXBvcnRzOiBCaWdJbnQocGFyYW1zLmxhbXBvcnRzKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBsYW1wb3J0czogQmlnSW50KHBhcmFtcy5sYW1wb3J0cylcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnRvUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGFzc2lnbnMgYW4gYWNjb3VudCB0byBhIHByb2dyYW1cbiAgICovXG4gIHN0YXRpYyBhc3NpZ24ocGFyYW1zKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGtleXM7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ25XaXRoU2VlZDtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgYmFzZTogdG9CdWZmZXIocGFyYW1zLmJhc2VQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IGFjY291bnQgYXRcbiAgICogICBhbiBhZGRyZXNzIGdlbmVyYXRlZCB3aXRoIGBmcm9tYCwgYSBzZWVkLCBhbmQgcHJvZ3JhbUlkXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudFdpdGhTZWVkKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVXaXRoU2VlZDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICBsZXQga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMubmV3QWNjb3VudFB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcbiAgICBpZiAoIXBhcmFtcy5iYXNlUHVia2V5LmVxdWFscyhwYXJhbXMuZnJvbVB1YmtleSkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlTm9uY2VBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMgJiYgJ3NlZWQnIGluIHBhcmFtcykge1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudFdpdGhTZWVkKHtcbiAgICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgYmFzZVB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgICBzcGFjZTogTk9OQ0VfQUNDT1VOVF9MRU5HVEgsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICAgIHNwYWNlOiBOT05DRV9BQ0NPVU5UX0xFTkdUSCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdCBpbml0UGFyYW1zID0ge1xuICAgICAgbm9uY2VQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5XG4gICAgfTtcbiAgICB0cmFuc2FjdGlvbi5hZGQodGhpcy5ub25jZUluaXRpYWxpemUoaW5pdFBhcmFtcykpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBpbnN0cnVjdGlvbiB0byBpbml0aWFsaXplIGEgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIG5vbmNlSW5pdGlhbGl6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZU5vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB0b0J1ZmZlcihwYXJhbXMuYXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gaW5zdHJ1Y3Rpb24gdG8gYWR2YW5jZSB0aGUgbm9uY2UgaW4gYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VBZHZhbmNlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BZHZhbmNlTm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpbnN0cnVjdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCB3aXRoZHJhd3MgbGFtcG9ydHMgZnJvbSBhIE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBub25jZVdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhd05vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMudG9QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyB0aGUgYXV0aG9yaXR5XG4gICAqIG9uIGEgTm9uY2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBub25jZUF1dGhvcml6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplTm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHRvQnVmZmVyKHBhcmFtcy5uZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGFsbG9jYXRlcyBzcGFjZSBpbiBhbiBhY2NvdW50IHdpdGhvdXQgZnVuZGluZ1xuICAgKi9cbiAgc3RhdGljIGFsbG9jYXRlKHBhcmFtcykge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBrZXlzO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGVXaXRoU2VlZDtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgYmFzZTogdG9CdWZmZXIocGFyYW1zLmJhc2VQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBzcGFjZTogcGFyYW1zLnNwYWNlLFxuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGU7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2VcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5TeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8vIEtlZXAgcHJvZ3JhbSBjaHVua3MgdW5kZXIgUEFDS0VUX0RBVEFfU0laRSwgbGVhdmluZyBlbm91Z2ggcm9vbSBmb3IgdGhlXG4vLyByZXN0IG9mIHRoZSBUcmFuc2FjdGlvbiBmaWVsZHNcbi8vXG4vLyBUT0RPOiByZXBsYWNlIDMwMCB3aXRoIGEgcHJvcGVyIGNvbnN0YW50IGZvciB0aGUgc2l6ZSBvZiB0aGUgb3RoZXJcbi8vIFRyYW5zYWN0aW9uIGZpZWxkc1xuY29uc3QgQ0hVTktfU0laRSA9IFBBQ0tFVF9EQVRBX1NJWkUgLSAzMDA7XG5cbi8qKlxuICogUHJvZ3JhbSBsb2FkZXIgaW50ZXJmYWNlXG4gKi9cbmNsYXNzIExvYWRlciB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogQW1vdW50IG9mIHByb2dyYW0gZGF0YSBwbGFjZWQgaW4gZWFjaCBsb2FkIFRyYW5zYWN0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIGxvYWQgYSBwcm9ncmFtIG5vdCBpbmNsdWRpbmdcbiAgICogcmV0cmllc1xuICAgKlxuICAgKiBDYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgdHJhbnNhY3Rpb24gZmVlc1xuICAgKi9cbiAgc3RhdGljIGdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCkge1xuICAgIHJldHVybiAyICogKFxuICAgIC8vIEV2ZXJ5IHRyYW5zYWN0aW9uIHJlcXVpcmVzIHR3byBzaWduYXR1cmVzIChwYXllciArIHByb2dyYW0pXG4gICAgTWF0aC5jZWlsKGRhdGFMZW5ndGggLyBMb2FkZXIuY2h1bmtTaXplKSArIDEgK1xuICAgIC8vIEFkZCBvbmUgZm9yIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgIDEpIC8vIEFkZCBvbmUgZm9yIEZpbmFsaXplIHRyYW5zYWN0aW9uXG4gICAgO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIGEgZ2VuZXJpYyBwcm9ncmFtXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBjb25uZWN0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0gcGF5ZXIgU3lzdGVtIGFjY291bnQgdGhhdCBwYXlzIHRvIGxvYWQgdGhlIHByb2dyYW1cbiAgICogQHBhcmFtIHByb2dyYW0gQWNjb3VudCB0byBsb2FkIHRoZSBwcm9ncmFtIGludG9cbiAgICogQHBhcmFtIHByb2dyYW1JZCBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgbG9hZGVyXG4gICAqIEBwYXJhbSBkYXRhIFByb2dyYW0gb2N0ZXRzXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBwcm9ncmFtIHdhcyBsb2FkZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiBwcm9ncmFtIHdhcyBhbHJlYWR5IGxvYWRlZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGxvYWQoY29ubmVjdGlvbiwgcGF5ZXIsIHByb2dyYW0sIHByb2dyYW1JZCwgZGF0YSkge1xuICAgIHtcbiAgICAgIGNvbnN0IGJhbGFuY2VOZWVkZWQgPSBhd2FpdCBjb25uZWN0aW9uLmdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbihkYXRhLmxlbmd0aCk7XG5cbiAgICAgIC8vIEZldGNoIHByb2dyYW0gYWNjb3VudCBpbmZvIHRvIGNoZWNrIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgY29uc3QgcHJvZ3JhbUluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHByb2dyYW0ucHVibGljS2V5LCAnY29uZmlybWVkJyk7XG4gICAgICBsZXQgdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgaWYgKHByb2dyYW1JbmZvICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChwcm9ncmFtSW5mby5leGVjdXRhYmxlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUHJvZ3JhbSBsb2FkIGZhaWxlZCwgYWNjb3VudCBpcyBhbHJlYWR5IGV4ZWN1dGFibGUnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmRhdGEubGVuZ3RoICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24gfHwgbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uYWxsb2NhdGUoe1xuICAgICAgICAgICAgYWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICBzcGFjZTogZGF0YS5sZW5ndGhcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9ncmFtSW5mby5vd25lci5lcXVhbHMocHJvZ3JhbUlkKSkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24gfHwgbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uYXNzaWduKHtcbiAgICAgICAgICAgIGFjY291bnRQdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgcHJvZ3JhbUlkXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtSW5mby5sYW1wb3J0cyA8IGJhbGFuY2VOZWVkZWQpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uIHx8IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLnRyYW5zZmVyKHtcbiAgICAgICAgICAgIGZyb21QdWJrZXk6IHBheWVyLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHRvUHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgIGxhbXBvcnRzOiBiYWxhbmNlTmVlZGVkIC0gcHJvZ3JhbUluZm8ubGFtcG9ydHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICAgICAgZnJvbVB1YmtleTogcGF5ZXIucHVibGljS2V5LFxuICAgICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgIGxhbXBvcnRzOiBiYWxhbmNlTmVlZGVkID4gMCA/IGJhbGFuY2VOZWVkZWQgOiAxLFxuICAgICAgICAgIHNwYWNlOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBwcm9ncmFtSWRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgYWNjb3VudCBpcyBhbHJlYWR5IGNyZWF0ZWQgY29ycmVjdGx5LCBza2lwIHRoaXMgc3RlcFxuICAgICAgLy8gYW5kIHByb2NlZWQgZGlyZWN0bHkgdG8gbG9hZGluZyBpbnN0cnVjdGlvbnNcbiAgICAgIGlmICh0cmFuc2FjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCBbcGF5ZXIsIHByb2dyYW1dLCB7XG4gICAgICAgICAgY29tbWl0bWVudDogJ2NvbmZpcm1lZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCdvZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXNMZW5ndGhQYWRkaW5nJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCdieXRlJyksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdieXRlcycpXSk7XG4gICAgY29uc3QgY2h1bmtTaXplID0gTG9hZGVyLmNodW5rU2l6ZTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgYXJyYXkgPSBkYXRhO1xuICAgIGxldCB0cmFuc2FjdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoYXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheS5zbGljZSgwLCBjaHVua1NpemUpO1xuICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5hbGxvYyhjaHVua1NpemUgKyAxNik7XG4gICAgICBkYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGluc3RydWN0aW9uOiAwLFxuICAgICAgICAvLyBMb2FkIGluc3RydWN0aW9uXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgYnl0ZXM6IGJ5dGVzLFxuICAgICAgICBieXRlc0xlbmd0aDogMCxcbiAgICAgICAgYnl0ZXNMZW5ndGhQYWRkaW5nOiAwXG4gICAgICB9LCBkYXRhKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfV0sXG4gICAgICAgIHByb2dyYW1JZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgICB0cmFuc2FjdGlvbnMucHVzaChzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCBbcGF5ZXIsIHByb2dyYW1dLCB7XG4gICAgICAgIGNvbW1pdG1lbnQ6ICdjb25maXJtZWQnXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIERlbGF5IGJldHdlZW4gc2VuZHMgaW4gYW4gYXR0ZW1wdCB0byByZWR1Y2UgcmF0ZSBsaW1pdCBlcnJvcnNcbiAgICAgIGlmIChjb25uZWN0aW9uLl9ycGNFbmRwb2ludC5pbmNsdWRlcygnc29sYW5hLmNvbScpKSB7XG4gICAgICAgIGNvbnN0IFJFUVVFU1RTX1BFUl9TRUNPTkQgPSA0O1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDAwIC8gUkVRVUVTVFNfUEVSX1NFQ09ORCk7XG4gICAgICB9XG4gICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xuICAgICAgYXJyYXkgPSBhcnJheS5zbGljZShjaHVua1NpemUpO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0cmFuc2FjdGlvbnMpO1xuXG4gICAgLy8gRmluYWxpemUgdGhlIGFjY291bnQgbG9hZGVkIHdpdGggcHJvZ3JhbSBkYXRhIGZvciBleGVjdXRpb25cbiAgICB7XG4gICAgICBjb25zdCBkYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pO1xuICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5hbGxvYyhkYXRhTGF5b3V0LnNwYW4pO1xuICAgICAgZGF0YUxheW91dC5lbmNvZGUoe1xuICAgICAgICBpbnN0cnVjdGlvbjogMSAvLyBGaW5hbGl6ZSBpbnN0cnVjdGlvblxuICAgICAgfSwgZGF0YSk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICAgIGtleXM6IFt7XG4gICAgICAgICAgcHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfV0sXG4gICAgICAgIHByb2dyYW1JZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgICBjb25zdCBkZXBsb3lDb21taXRtZW50ID0gJ3Byb2Nlc3NlZCc7XG4gICAgICBjb25zdCBmaW5hbGl6ZVNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBbcGF5ZXIsIHByb2dyYW1dLCB7XG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IGRlcGxveUNvbW1pdG1lbnRcbiAgICAgIH0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgICAgc2lnbmF0dXJlOiBmaW5hbGl6ZVNpZ25hdHVyZSxcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxuICAgICAgICBibG9ja2hhc2g6IHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaFxuICAgICAgfSwgZGVwbG95Q29tbWl0bWVudCk7XG4gICAgICBpZiAodmFsdWUuZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gJHtmaW5hbGl6ZVNpZ25hdHVyZX0gZmFpbGVkICgke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0pYCk7XG4gICAgICB9XG4gICAgICAvLyBXZSBwcmV2ZW50IHByb2dyYW1zIGZyb20gYmVpbmcgdXNhYmxlIHVudGlsIHRoZSBzbG90IGFmdGVyIHRoZWlyIGRlcGxveW1lbnQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9wdWxsLzI5NjU0XG4gICAgICB3aGlsZSAodHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFNsb3QgPSBhd2FpdCBjb25uZWN0aW9uLmdldFNsb3Qoe1xuICAgICAgICAgICAgY29tbWl0bWVudDogZGVwbG95Q29tbWl0bWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChjdXJyZW50U2xvdCA+IGNvbnRleHQuc2xvdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvKiBlbXB0eSAqL1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJvdW5kKE1TX1BFUl9TTE9UIC8gMikpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdWNjZXNzXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbkxvYWRlci5jaHVua1NpemUgPSBDSFVOS19TSVpFO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjE3LjIwLlxuICovXG5jb25zdCBCUEZfTE9BREVSX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KCdCUEZMb2FkZXIyMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggYSBwcm9ncmFtIGxvYWRlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjE3LjIwLlxuICovXG5jbGFzcyBCcGZMb2FkZXIge1xuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBsb2FkIGEgcHJvZ3JhbSBub3QgaW5jbHVkaW5nXG4gICAqIHJldHJpZXNcbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRyYW5zYWN0aW9uIGZlZXNcbiAgICovXG4gIHN0YXRpYyBnZXRNaW5OdW1TaWduYXR1cmVzKGRhdGFMZW5ndGgpIHtcbiAgICByZXR1cm4gTG9hZGVyLmdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIFNCRiBwcm9ncmFtXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBjb25uZWN0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0gcGF5ZXIgQWNjb3VudCB0aGF0IHdpbGwgcGF5IHByb2dyYW0gbG9hZGluZyBmZWVzXG4gICAqIEBwYXJhbSBwcm9ncmFtIEFjY291bnQgdG8gbG9hZCB0aGUgcHJvZ3JhbSBpbnRvXG4gICAqIEBwYXJhbSBlbGYgVGhlIGVudGlyZSBFTEYgY29udGFpbmluZyB0aGUgU0JGIHByb2dyYW1cbiAgICogQHBhcmFtIGxvYWRlclByb2dyYW1JZCBUaGUgcHJvZ3JhbSBpZCBvZiB0aGUgQlBGIGxvYWRlciB0byB1c2VcbiAgICogQHJldHVybiB0cnVlIGlmIHByb2dyYW0gd2FzIGxvYWRlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIHByb2dyYW0gd2FzIGFscmVhZHkgbG9hZGVkXG4gICAqL1xuICBzdGF0aWMgbG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgZWxmLCBsb2FkZXJQcm9ncmFtSWQpIHtcbiAgICByZXR1cm4gTG9hZGVyLmxvYWQoY29ubmVjdGlvbiwgcGF5ZXIsIHByb2dyYW0sIGxvYWRlclByb2dyYW1JZCwgZWxmKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgYWdlbnRrZWVwYWxpdmUgPSB7ZXhwb3J0czoge319O1xuXG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIG1zO1xudmFyIGhhc1JlcXVpcmVkTXM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVNcyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZE1zKSByZXR1cm4gbXM7XG5cdGhhc1JlcXVpcmVkTXMgPSAxO1xuXHR2YXIgcyA9IDEwMDA7XG5cdHZhciBtID0gcyAqIDYwO1xuXHR2YXIgaCA9IG0gKiA2MDtcblx0dmFyIGQgPSBoICogMjQ7XG5cdHZhciB3ID0gZCAqIDc7XG5cdHZhciB5ID0gZCAqIDM2NS4yNTtcblxuXHQvKipcblx0ICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cblx0ICpcblx0ICogT3B0aW9uczpcblx0ICpcblx0ICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cblx0ICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG5cdCAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdG1zID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcblx0ICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcblx0ICAgIHJldHVybiBwYXJzZSh2YWwpO1xuXHQgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuXHQgICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG5cdCAgfVxuXHQgIHRocm93IG5ldyBFcnJvcihcblx0ICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuXHQgICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG5cdCAgKTtcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuXHQgIHN0ciA9IFN0cmluZyhzdHIpO1xuXHQgIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcblx0ICAgIHN0clxuXHQgICk7XG5cdCAgaWYgKCFtYXRjaCkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuXHQgIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG5cdCAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICBjYXNlICd5ZWFycyc6XG5cdCAgICBjYXNlICd5ZWFyJzpcblx0ICAgIGNhc2UgJ3lycyc6XG5cdCAgICBjYXNlICd5cic6XG5cdCAgICBjYXNlICd5Jzpcblx0ICAgICAgcmV0dXJuIG4gKiB5O1xuXHQgICAgY2FzZSAnd2Vla3MnOlxuXHQgICAgY2FzZSAnd2Vlayc6XG5cdCAgICBjYXNlICd3Jzpcblx0ICAgICAgcmV0dXJuIG4gKiB3O1xuXHQgICAgY2FzZSAnZGF5cyc6XG5cdCAgICBjYXNlICdkYXknOlxuXHQgICAgY2FzZSAnZCc6XG5cdCAgICAgIHJldHVybiBuICogZDtcblx0ICAgIGNhc2UgJ2hvdXJzJzpcblx0ICAgIGNhc2UgJ2hvdXInOlxuXHQgICAgY2FzZSAnaHJzJzpcblx0ICAgIGNhc2UgJ2hyJzpcblx0ICAgIGNhc2UgJ2gnOlxuXHQgICAgICByZXR1cm4gbiAqIGg7XG5cdCAgICBjYXNlICdtaW51dGVzJzpcblx0ICAgIGNhc2UgJ21pbnV0ZSc6XG5cdCAgICBjYXNlICdtaW5zJzpcblx0ICAgIGNhc2UgJ21pbic6XG5cdCAgICBjYXNlICdtJzpcblx0ICAgICAgcmV0dXJuIG4gKiBtO1xuXHQgICAgY2FzZSAnc2Vjb25kcyc6XG5cdCAgICBjYXNlICdzZWNvbmQnOlxuXHQgICAgY2FzZSAnc2Vjcyc6XG5cdCAgICBjYXNlICdzZWMnOlxuXHQgICAgY2FzZSAncyc6XG5cdCAgICAgIHJldHVybiBuICogcztcblx0ICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG5cdCAgICBjYXNlICdtaWxsaXNlY29uZCc6XG5cdCAgICBjYXNlICdtc2Vjcyc6XG5cdCAgICBjYXNlICdtc2VjJzpcblx0ICAgIGNhc2UgJ21zJzpcblx0ICAgICAgcmV0dXJuIG47XG5cdCAgICBkZWZhdWx0OlxuXHQgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBmbXRTaG9ydChtcykge1xuXHQgIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcblx0ICBpZiAobXNBYnMgPj0gZCkge1xuXHQgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IGgpIHtcblx0ICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG5cdCAgfVxuXHQgIGlmIChtc0FicyA+PSBtKSB7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gcykge1xuXHQgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcblx0ICB9XG5cdCAgcmV0dXJuIG1zICsgJ21zJztcblx0fVxuXG5cdC8qKlxuXHQgKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1zXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGZtdExvbmcobXMpIHtcblx0ICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG5cdCAgaWYgKG1zQWJzID49IGQpIHtcblx0ICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG5cdCAgfVxuXHQgIGlmIChtc0FicyA+PSBoKSB7XG5cdCAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IG0pIHtcblx0ICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG5cdCAgfVxuXHQgIGlmIChtc0FicyA+PSBzKSB7XG5cdCAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuXHQgIH1cblx0ICByZXR1cm4gbXMgKyAnIG1zJztcblx0fVxuXG5cdC8qKlxuXHQgKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cblx0ICovXG5cblx0ZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuXHQgIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG5cdCAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG5cdH1cblx0cmV0dXJuIG1zO1xufVxuXG4vKiFcbiAqIGh1bWFuaXplLW1zIC0gaW5kZXguanNcbiAqIENvcHlyaWdodChjKSAyMDE0IGRlYWRfaG9yc2UgPGRlYWRfaG9yc2VAcXEuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGh1bWFuaXplTXM7XG52YXIgaGFzUmVxdWlyZWRIdW1hbml6ZU1zO1xuXG5mdW5jdGlvbiByZXF1aXJlSHVtYW5pemVNcyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEh1bWFuaXplTXMpIHJldHVybiBodW1hbml6ZU1zO1xuXHRoYXNSZXF1aXJlZEh1bWFuaXplTXMgPSAxO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgdXRpbCA9IHJlcXVpcmUkJDA7XG5cdHZhciBtcyA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZU1zKCk7XG5cblx0aHVtYW5pemVNcyA9IGZ1bmN0aW9uICh0KSB7XG5cdCAgaWYgKHR5cGVvZiB0ID09PSAnbnVtYmVyJykgcmV0dXJuIHQ7XG5cdCAgdmFyIHIgPSBtcyh0KTtcblx0ICBpZiAociA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICB2YXIgZXJyID0gbmV3IEVycm9yKHV0aWwuZm9ybWF0KCdodW1hbml6ZS1tcyglaikgcmVzdWx0IHVuZGVmaW5lZCcsIHQpKTtcblx0ICAgIGNvbnNvbGUud2FybihlcnIuc3RhY2spO1xuXHQgIH1cblx0ICByZXR1cm4gcjtcblx0fTtcblx0cmV0dXJuIGh1bWFuaXplTXM7XG59XG5cbnZhciBjb25zdGFudHM7XG52YXIgaGFzUmVxdWlyZWRDb25zdGFudHM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDb25zdGFudHMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDb25zdGFudHMpIHJldHVybiBjb25zdGFudHM7XG5cdGhhc1JlcXVpcmVkQ29uc3RhbnRzID0gMTtcblxuXHRjb25zdGFudHMgPSB7XG5cdCAgLy8gYWdlbnRcblx0ICBDVVJSRU5UX0lEOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2N1cnJlbnRJZCcpLFxuXHQgIENSRUFURV9JRDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNjcmVhdGVJZCcpLFxuXHQgIElOSVRfU09DS0VUOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2luaXRTb2NrZXQnKSxcblx0ICBDUkVBVEVfSFRUUFNfQ09OTkVDVElPTjogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNjcmVhdGVIdHRwc0Nvbm5lY3Rpb24nKSxcblx0ICAvLyBzb2NrZXRcblx0ICBTT0NLRVRfQ1JFQVRFRF9USU1FOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI3NvY2tldENyZWF0ZWRUaW1lJyksXG5cdCAgU09DS0VUX05BTUU6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0TmFtZScpLFxuXHQgIFNPQ0tFVF9SRVFVRVNUX0NPVU5UOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI3NvY2tldFJlcXVlc3RDb3VudCcpLFxuXHQgIFNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI3NvY2tldFJlcXVlc3RGaW5pc2hlZENvdW50JyksXG5cdH07XG5cdHJldHVybiBjb25zdGFudHM7XG59XG5cbnZhciBhZ2VudDtcbnZhciBoYXNSZXF1aXJlZEFnZW50O1xuXG5mdW5jdGlvbiByZXF1aXJlQWdlbnQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRBZ2VudCkgcmV0dXJuIGFnZW50O1xuXHRoYXNSZXF1aXJlZEFnZW50ID0gMTtcblxuXHRjb25zdCBPcmlnaW5hbEFnZW50ID0gcmVxdWlyZSQkMCQxLkFnZW50O1xuXHRjb25zdCBtcyA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUh1bWFuaXplTXMoKTtcblx0Y29uc3QgZGVidWcgPSByZXF1aXJlJCQwLmRlYnVnbG9nKCdhZ2VudGtlZXBhbGl2ZScpO1xuXHRjb25zdCB7XG5cdCAgSU5JVF9TT0NLRVQsXG5cdCAgQ1VSUkVOVF9JRCxcblx0ICBDUkVBVEVfSUQsXG5cdCAgU09DS0VUX0NSRUFURURfVElNRSxcblx0ICBTT0NLRVRfTkFNRSxcblx0ICBTT0NLRVRfUkVRVUVTVF9DT1VOVCxcblx0ICBTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVCxcblx0fSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUNvbnN0YW50cygpO1xuXG5cdC8vIE9yaWdpbmFsQWdlbnQgY29tZSBmcm9tXG5cdC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjguMTIuMC9saWIvX2h0dHBfYWdlbnQuanNcblx0Ly8gLSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuMTIuMC9saWIvX2h0dHBfYWdlbnQuanNcblxuXHQvLyBub2RlIDw9IDEwXG5cdGxldCBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgPSAxO1xuXHRjb25zdCBtYWpvclZlcnNpb24gPSBwYXJzZUludChwcm9jZXNzLnZlcnNpb24uc3BsaXQoJy4nLCAxKVswXS5zdWJzdHJpbmcoMSkpO1xuXHRpZiAobWFqb3JWZXJzaW9uID49IDExICYmIG1ham9yVmVyc2lvbiA8PSAxMikge1xuXHQgIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCA9IDI7XG5cdH0gZWxzZSBpZiAobWFqb3JWZXJzaW9uID49IDEzKSB7XG5cdCAgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ID0gMztcblx0fVxuXG5cdGZ1bmN0aW9uIGRlcHJlY2F0ZShtZXNzYWdlKSB7XG5cdCAgY29uc29sZS5sb2coJ1thZ2VudGtlZXBhbGl2ZTpkZXByZWNhdGVkXSAlcycsIG1lc3NhZ2UpO1xuXHR9XG5cblx0Y2xhc3MgQWdlbnQgZXh0ZW5kcyBPcmlnaW5hbEFnZW50IHtcblx0ICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdCAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICAgIG9wdGlvbnMua2VlcEFsaXZlID0gb3B0aW9ucy5rZWVwQWxpdmUgIT09IGZhbHNlO1xuXHQgICAgLy8gZGVmYXVsdCBpcyBrZWVwLWFsaXZlIGFuZCA0cyBmcmVlIHNvY2tldCB0aW1lb3V0XG5cdCAgICAvLyBzZWUgaHR0cHM6Ly9tZWRpdW0uY29tL3NzZW5zZS10ZWNoL3JlZHVjZS1uZXR3b3JraW5nLWVycm9ycy1pbi1ub2RlanMtMjNiNGViOWYyZDgzXG5cdCAgICBpZiAob3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSA0MDAwO1xuXHQgICAgfVxuXHQgICAgLy8gTGVnYWN5IEFQSToga2VlcEFsaXZlVGltZW91dCBzaG91bGQgYmUgcmVuYW1lIHRvIGBmcmVlU29ja2V0VGltZW91dGBcblx0ICAgIGlmIChvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQpIHtcblx0ICAgICAgZGVwcmVjYXRlKCdvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0IGluc3RlYWQnKTtcblx0ICAgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IG9wdGlvbnMua2VlcEFsaXZlVGltZW91dDtcblx0ICAgICAgZGVsZXRlIG9wdGlvbnMua2VlcEFsaXZlVGltZW91dDtcblx0ICAgIH1cblx0ICAgIC8vIExlZ2FjeSBBUEk6IGZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0IHNob3VsZCBiZSByZW5hbWUgdG8gYGZyZWVTb2NrZXRUaW1lb3V0YFxuXHQgICAgaWYgKG9wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQpIHtcblx0ICAgICAgZGVwcmVjYXRlKCdvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2Ugb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCBpbnN0ZWFkJyk7XG5cdCAgICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSBvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgICBkZWxldGUgb3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dDtcblx0ICAgIH1cblxuXHQgICAgLy8gU2V0cyB0aGUgc29ja2V0IHRvIHRpbWVvdXQgYWZ0ZXIgdGltZW91dCBtaWxsaXNlY29uZHMgb2YgaW5hY3Rpdml0eSBvbiB0aGUgc29ja2V0LlxuXHQgICAgLy8gQnkgZGVmYXVsdCBpcyBkb3VibGUgZnJlZSBzb2NrZXQgdGltZW91dC5cblx0ICAgIGlmIChvcHRpb25zLnRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAvLyBtYWtlIHN1cmUgc29ja2V0IGRlZmF1bHQgaW5hY3Rpdml0eSB0aW1lb3V0ID49IDhzXG5cdCAgICAgIG9wdGlvbnMudGltZW91dCA9IE1hdGgubWF4KG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgKiAyLCA4MDAwKTtcblx0ICAgIH1cblxuXHQgICAgLy8gc3VwcG9ydCBodW1hbml6ZSBmb3JtYXRcblx0ICAgIG9wdGlvbnMudGltZW91dCA9IG1zKG9wdGlvbnMudGltZW91dCk7XG5cdCAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gbXMob3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCk7XG5cdCAgICBvcHRpb25zLnNvY2tldEFjdGl2ZVRUTCA9IG9wdGlvbnMuc29ja2V0QWN0aXZlVFRMID8gbXMob3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwpIDogMDtcblxuXHQgICAgc3VwZXIob3B0aW9ucyk7XG5cblx0ICAgIHRoaXNbQ1VSUkVOVF9JRF0gPSAwO1xuXG5cdCAgICAvLyBjcmVhdGUgc29ja2V0IHN1Y2Nlc3MgY291bnRlclxuXHQgICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudCA9IDA7XG5cdCAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuXHQgICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50ID0gMDtcblx0ICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudCA9IDA7XG5cdCAgICB0aGlzLmNsb3NlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG5cdCAgICAvLyBzb2NrZXQgZXJyb3IgZXZlbnQgY291bnRcblx0ICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudCA9IDA7XG5cdCAgICB0aGlzLmVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG5cdCAgICAvLyByZXF1ZXN0IGZpbmlzaGVkIGNvdW50ZXJcblx0ICAgIHRoaXMucmVxdWVzdENvdW50ID0gMDtcblx0ICAgIHRoaXMucmVxdWVzdENvdW50TGFzdENoZWNrID0gMDtcblxuXHQgICAgLy8gaW5jbHVkaW5nIGZyZWUgc29ja2V0IHRpbWVvdXQgY291bnRlclxuXHQgICAgdGhpcy50aW1lb3V0U29ja2V0Q291bnQgPSAwO1xuXHQgICAgdGhpcy50aW1lb3V0U29ja2V0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG5cdCAgICB0aGlzLm9uKCdmcmVlJywgc29ja2V0ID0+IHtcblx0ICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzIwMDBcblx0ICAgICAgLy8gTm9kZS5qcyBuYXRpdmUgYWdlbnQgd2lsbCBjaGVjayBzb2NrZXQgdGltZW91dCBlcXMgYWdlbnQub3B0aW9ucy50aW1lb3V0LlxuXHQgICAgICAvLyBVc2UgdGhlIHR0bCBvciBmcmVlU29ja2V0VGltZW91dCB0byBvdmVyd3JpdGUuXG5cdCAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLmNhbGNTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG5cdCAgICAgIGlmICh0aW1lb3V0ID4gMCAmJiBzb2NrZXQudGltZW91dCAhPT0gdGltZW91dCkge1xuXHQgICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KHRpbWVvdXQpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBnZXQgZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQoKSB7XG5cdCAgICBkZXByZWNhdGUoJ2FnZW50LmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYWdlbnQub3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCBpbnN0ZWFkJyk7XG5cdCAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0O1xuXHQgIH1cblxuXHQgIGdldCB0aW1lb3V0KCkge1xuXHQgICAgZGVwcmVjYXRlKCdhZ2VudC50aW1lb3V0IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYWdlbnQub3B0aW9ucy50aW1lb3V0IGluc3RlYWQnKTtcblx0ICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGltZW91dDtcblx0ICB9XG5cblx0ICBnZXQgc29ja2V0QWN0aXZlVFRMKCkge1xuXHQgICAgZGVwcmVjYXRlKCdhZ2VudC5zb2NrZXRBY3RpdmVUVEwgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLnNvY2tldEFjdGl2ZVRUTCBpbnN0ZWFkJyk7XG5cdCAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNvY2tldEFjdGl2ZVRUTDtcblx0ICB9XG5cblx0ICBjYWxjU29ja2V0VGltZW91dChzb2NrZXQpIHtcblx0ICAgIC8qKlxuXHQgICAgICogcmV0dXJuIDw9IDA6IHNob3VsZCBmcmVlIHNvY2tldFxuXHQgICAgICogcmV0dXJuID4gMDogc2hvdWxkIHVwZGF0ZSBzb2NrZXQgdGltZW91dFxuXHQgICAgICogcmV0dXJuIHVuZGVmaW5lZDogbm90IGZpbmQgY3VzdG9tIHRpbWVvdXRcblx0ICAgICAqL1xuXHQgICAgbGV0IGZyZWVTb2NrZXRUaW1lb3V0ID0gdGhpcy5vcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0O1xuXHQgICAgY29uc3Qgc29ja2V0QWN0aXZlVFRMID0gdGhpcy5vcHRpb25zLnNvY2tldEFjdGl2ZVRUTDtcblx0ICAgIGlmIChzb2NrZXRBY3RpdmVUVEwpIHtcblx0ICAgICAgLy8gY2hlY2sgc29ja2V0QWN0aXZlVFRMXG5cdCAgICAgIGNvbnN0IGFsaXZlVGltZSA9IERhdGUubm93KCkgLSBzb2NrZXRbU09DS0VUX0NSRUFURURfVElNRV07XG5cdCAgICAgIGNvbnN0IGRpZmYgPSBzb2NrZXRBY3RpdmVUVEwgLSBhbGl2ZVRpbWU7XG5cdCAgICAgIGlmIChkaWZmIDw9IDApIHtcblx0ICAgICAgICByZXR1cm4gZGlmZjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoZnJlZVNvY2tldFRpbWVvdXQgJiYgZGlmZiA8IGZyZWVTb2NrZXRUaW1lb3V0KSB7XG5cdCAgICAgICAgZnJlZVNvY2tldFRpbWVvdXQgPSBkaWZmO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICAvLyBzZXQgZnJlZVNvY2tldFRpbWVvdXRcblx0ICAgIGlmIChmcmVlU29ja2V0VGltZW91dCkge1xuXHQgICAgICAvLyBzZXQgZnJlZSBrZWVwYWxpdmUgdGltZXJcblx0ICAgICAgLy8gdHJ5IHRvIHVzZSBzb2NrZXQgY3VzdG9tIGZyZWVTb2NrZXRUaW1lb3V0IGZpcnN0LCBzdXBwb3J0IGhlYWRlcnNbJ2tlZXAtYWxpdmUnXVxuXHQgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1tb2R1bGVzL3VybGxpYi9ibG9iL2I3NjA1MzAyMDkyM2Y0ZDk5YTFjOTNjZjJlMTZlMGM1YmExMGJhY2YvbGliL3VybGxpYi5qcyNMNDk4XG5cdCAgICAgIGNvbnN0IGN1c3RvbUZyZWVTb2NrZXRUaW1lb3V0ID0gc29ja2V0LmZyZWVTb2NrZXRUaW1lb3V0IHx8IHNvY2tldC5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dDtcblx0ICAgICAgcmV0dXJuIGN1c3RvbUZyZWVTb2NrZXRUaW1lb3V0IHx8IGZyZWVTb2NrZXRUaW1lb3V0O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGtlZXBTb2NrZXRBbGl2ZShzb2NrZXQpIHtcblx0ICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmtlZXBTb2NrZXRBbGl2ZShzb2NrZXQpO1xuXHQgICAgLy8gc2hvdWxkIG5vdCBrZWVwQWxpdmUsIGRvIG5vdGhpbmdcblx0ICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuXG5cdCAgICBjb25zdCBjdXN0b21UaW1lb3V0ID0gdGhpcy5jYWxjU29ja2V0VGltZW91dChzb2NrZXQpO1xuXHQgICAgaWYgKHR5cGVvZiBjdXN0b21UaW1lb3V0ID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmIChjdXN0b21UaW1lb3V0IDw9IDApIHtcblx0ICAgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBmcmVlIGJ1dCBuZWVkIHRvIGRlc3Ryb3kgYnkgVFRMLCByZXF1ZXN0IGNvdW50ICVzLCBkaWZmIGlzICVzJyxcblx0ICAgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLCBjdXN0b21UaW1lb3V0KTtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKHNvY2tldC50aW1lb3V0ICE9PSBjdXN0b21UaW1lb3V0KSB7XG5cdCAgICAgIHNvY2tldC5zZXRUaW1lb3V0KGN1c3RvbVRpbWVvdXQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgLy8gb25seSBjYWxsIG9uIGFkZFJlcXVlc3Rcblx0ICByZXVzZVNvY2tldCguLi5hcmdzKSB7XG5cdCAgICAvLyByZXVzZVNvY2tldChzb2NrZXQsIHJlcSlcblx0ICAgIHN1cGVyLnJldXNlU29ja2V0KC4uLmFyZ3MpO1xuXHQgICAgY29uc3Qgc29ja2V0ID0gYXJnc1swXTtcblx0ICAgIGNvbnN0IHJlcSA9IGFyZ3NbMV07XG5cdCAgICByZXEucmV1c2VkU29ja2V0ID0gdHJ1ZTtcblx0ICAgIGNvbnN0IGFnZW50VGltZW91dCA9IHRoaXMub3B0aW9ucy50aW1lb3V0O1xuXHQgICAgaWYgKGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSAhPT0gYWdlbnRUaW1lb3V0KSB7XG5cdCAgICAgIC8vIHJlc2V0IHRpbWVvdXQgYmVmb3JlIHVzZVxuXHQgICAgICBzb2NrZXQuc2V0VGltZW91dChhZ2VudFRpbWVvdXQpO1xuXHQgICAgICBkZWJ1ZygnJXMgcmVzZXQgdGltZW91dCB0byAlc21zJywgc29ja2V0W1NPQ0tFVF9OQU1FXSwgYWdlbnRUaW1lb3V0KTtcblx0ICAgIH1cblx0ICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0rKztcblx0ICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgcmV1c2Ugb24gYWRkUmVxdWVzdCwgdGltZW91dCAlc21zJyxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSxcblx0ICAgICAgZ2V0U29ja2V0VGltZW91dChzb2NrZXQpKTtcblx0ICB9XG5cblx0ICBbQ1JFQVRFX0lEXSgpIHtcblx0ICAgIGNvbnN0IGlkID0gdGhpc1tDVVJSRU5UX0lEXSsrO1xuXHQgICAgaWYgKHRoaXNbQ1VSUkVOVF9JRF0gPT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB0aGlzW0NVUlJFTlRfSURdID0gMDtcblx0ICAgIHJldHVybiBpZDtcblx0ICB9XG5cblx0ICBbSU5JVF9TT0NLRVRdKHNvY2tldCwgb3B0aW9ucykge1xuXHQgICAgLy8gYnVnZml4IGhlcmUuXG5cdCAgICAvLyBodHRwcyBvbiBub2RlIDgsIDEwIHdvbid0IHNldCBhZ2VudC5vcHRpb25zLnRpbWVvdXQgYnkgZGVmYXVsdFxuXHQgICAgLy8gVE9ETzogbmVlZCB0byBmaXggb24gbm9kZSBpdHNlbGZcblx0ICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcblx0ICAgICAgY29uc3QgdGltZW91dCA9IGdldFNvY2tldFRpbWVvdXQoc29ja2V0KTtcblx0ICAgICAgaWYgKCF0aW1lb3V0KSB7XG5cdCAgICAgICAgc29ja2V0LnNldFRpbWVvdXQob3B0aW9ucy50aW1lb3V0KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBBbGl2ZSkge1xuXHQgICAgICAvLyBEaXNhYmxlIE5hZ2xlJ3MgYWxnb3JpdGhtOiBodHRwOi8vYmxvZy5jYXVzdGlrLmNvbS8yMDEyLzA0LzA4L3NjYWxpbmctbm9kZS1qcy10by0xMDBrLWNvbmN1cnJlbnQtY29ubmVjdGlvbnMvXG5cdCAgICAgIC8vIGh0dHBzOi8vZmVuZ21rMi5jb20vYmVuY2htYXJrL25hZ2xlLWFsZ29yaXRobS1kZWxheWVkLWFjay1tb2NrLmh0bWxcblx0ICAgICAgc29ja2V0LnNldE5vRGVsYXkodHJ1ZSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50Kys7XG5cdCAgICBpZiAodGhpcy5vcHRpb25zLnNvY2tldEFjdGl2ZVRUTCkge1xuXHQgICAgICBzb2NrZXRbU09DS0VUX0NSRUFURURfVElNRV0gPSBEYXRlLm5vdygpO1xuXHQgICAgfVxuXHQgICAgLy8gZG9uJ3Qgc2hvdyB0aGUgaG9sZSAnLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0nIGtleSBzdHJpbmdcblx0ICAgIHNvY2tldFtTT0NLRVRfTkFNRV0gPSBgc29ja1ske3RoaXNbQ1JFQVRFX0lEXSgpfSMke29wdGlvbnMuX2FnZW50S2V5fV1gLnNwbGl0KCctLS0tLUJFR0lOJywgMSlbMF07XG5cdCAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdID0gMTtcblx0ICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0gPSAwO1xuXHQgICAgaW5zdGFsbExpc3RlbmVycyh0aGlzLCBzb2NrZXQsIG9wdGlvbnMpO1xuXHQgIH1cblxuXHQgIGNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgb25jcmVhdGUpIHtcblx0ICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblx0ICAgIGNvbnN0IG9uTmV3Q3JlYXRlID0gKGVyciwgc29ja2V0KSA9PiB7XG5cdCAgICAgIGlmIChjYWxsZWQpIHJldHVybjtcblx0ICAgICAgY2FsbGVkID0gdHJ1ZTtcblxuXHQgICAgICBpZiAoZXJyKSB7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50Kys7XG5cdCAgICAgICAgcmV0dXJuIG9uY3JlYXRlKGVycik7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpc1tJTklUX1NPQ0tFVF0oc29ja2V0LCBvcHRpb25zKTtcblx0ICAgICAgb25jcmVhdGUoZXJyLCBzb2NrZXQpO1xuXHQgICAgfTtcblxuXHQgICAgY29uc3QgbmV3U29ja2V0ID0gc3VwZXIuY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zLCBvbk5ld0NyZWF0ZSk7XG5cdCAgICBpZiAobmV3U29ja2V0KSBvbk5ld0NyZWF0ZShudWxsLCBuZXdTb2NrZXQpO1xuXHQgICAgcmV0dXJuIG5ld1NvY2tldDtcblx0ICB9XG5cblx0ICBnZXQgc3RhdHVzQ2hhbmdlZCgpIHtcblx0ICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLmNyZWF0ZVNvY2tldENvdW50ICE9PSB0aGlzLmNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrIHx8XG5cdCAgICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCAhPT0gdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50TGFzdENoZWNrIHx8XG5cdCAgICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudCAhPT0gdGhpcy5jbG9zZVNvY2tldENvdW50TGFzdENoZWNrIHx8XG5cdCAgICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudCAhPT0gdGhpcy5lcnJvclNvY2tldENvdW50TGFzdENoZWNrIHx8XG5cdCAgICAgIHRoaXMudGltZW91dFNvY2tldENvdW50ICE9PSB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuXHQgICAgICB0aGlzLnJlcXVlc3RDb3VudCAhPT0gdGhpcy5yZXF1ZXN0Q291bnRMYXN0Q2hlY2s7XG5cdCAgICBpZiAoY2hhbmdlZCkge1xuXHQgICAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy5jcmVhdGVTb2NrZXRDb3VudDtcblx0ICAgICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50TGFzdENoZWNrID0gdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50O1xuXHQgICAgICB0aGlzLmNsb3NlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLmNsb3NlU29ja2V0Q291bnQ7XG5cdCAgICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMuZXJyb3JTb2NrZXRDb3VudDtcblx0ICAgICAgdGhpcy50aW1lb3V0U29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudDtcblx0ICAgICAgdGhpcy5yZXF1ZXN0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLnJlcXVlc3RDb3VudDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjaGFuZ2VkO1xuXHQgIH1cblxuXHQgIGdldEN1cnJlbnRTdGF0dXMoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBjcmVhdGVTb2NrZXRDb3VudDogdGhpcy5jcmVhdGVTb2NrZXRDb3VudCxcblx0ICAgICAgY3JlYXRlU29ja2V0RXJyb3JDb3VudDogdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50LFxuXHQgICAgICBjbG9zZVNvY2tldENvdW50OiB0aGlzLmNsb3NlU29ja2V0Q291bnQsXG5cdCAgICAgIGVycm9yU29ja2V0Q291bnQ6IHRoaXMuZXJyb3JTb2NrZXRDb3VudCxcblx0ICAgICAgdGltZW91dFNvY2tldENvdW50OiB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudCxcblx0ICAgICAgcmVxdWVzdENvdW50OiB0aGlzLnJlcXVlc3RDb3VudCxcblx0ICAgICAgZnJlZVNvY2tldHM6IGluc3BlY3QodGhpcy5mcmVlU29ja2V0cyksXG5cdCAgICAgIHNvY2tldHM6IGluc3BlY3QodGhpcy5zb2NrZXRzKSxcblx0ICAgICAgcmVxdWVzdHM6IGluc3BlY3QodGhpcy5yZXF1ZXN0cyksXG5cdCAgICB9O1xuXHQgIH1cblx0fVxuXG5cdC8vIG5vZGUgOCBkb24ndCBoYXMgdGltZW91dCBhdHRyaWJ1dGUgb24gc29ja2V0XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzIxMjA0L2ZpbGVzI2RpZmYtZTZlZjAyNGMzNzc1ZDc4N2MzODQ4N2E2MzA5ZTQ5MWRSNDA4XG5cdGZ1bmN0aW9uIGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSB7XG5cdCAgcmV0dXJuIHNvY2tldC50aW1lb3V0IHx8IHNvY2tldC5faWRsZVRpbWVvdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBpbnN0YWxsTGlzdGVuZXJzKGFnZW50LCBzb2NrZXQsIG9wdGlvbnMpIHtcblx0ICBkZWJ1ZygnJXMgY3JlYXRlLCB0aW1lb3V0ICVzbXMnLCBzb2NrZXRbU09DS0VUX05BTUVdLCBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkpO1xuXG5cdCAgLy8gbGlzdGVuZXIgc29ja2V0IGV2ZW50czogY2xvc2UsIHRpbWVvdXQsIGVycm9yLCBmcmVlXG5cdCAgZnVuY3Rpb24gb25GcmVlKCkge1xuXHQgICAgLy8gY3JlYXRlIGFuZCBzb2NrZXQuZW1pdCgnZnJlZScpIGxvZ2ljXG5cdCAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL19odHRwX2FnZW50LmpzI0wzMTFcblx0ICAgIC8vIG5vIHJlcSBvbiB0aGUgc29ja2V0LCBpdCBzaG91bGQgYmUgdGhlIG5ldyBzb2NrZXRcblx0ICAgIGlmICghc29ja2V0Ll9odHRwTWVzc2FnZSAmJiBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdID09PSAxKSByZXR1cm47XG5cblx0ICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0rKztcblx0ICAgIGFnZW50LnJlcXVlc3RDb3VudCsrO1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBmcmVlJyxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSk7XG5cblx0ICAgIC8vIHNob3VsZCByZXVzZSBvbiBwZWRkaW5nIHJlcXVlc3RzP1xuXHQgICAgY29uc3QgbmFtZSA9IGFnZW50LmdldE5hbWUob3B0aW9ucyk7XG5cdCAgICBpZiAoc29ja2V0LndyaXRhYmxlICYmIGFnZW50LnJlcXVlc3RzW25hbWVdICYmIGFnZW50LnJlcXVlc3RzW25hbWVdLmxlbmd0aCkge1xuXHQgICAgICAvLyB3aWxsIGJlIHJldXNlIG9uIGFnZW50IGZyZWUgbGlzdGVuZXJcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSsrO1xuXHQgICAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIHdpbGwgYmUgcmV1c2Ugb24gYWdlbnQgZnJlZSBldmVudCcsXG5cdCAgICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHNvY2tldC5vbignZnJlZScsIG9uRnJlZSk7XG5cblx0ICBmdW5jdGlvbiBvbkNsb3NlKGlzRXJyb3IpIHtcblx0ICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgY2xvc2UsIGlzRXJyb3I6ICVzJyxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSwgaXNFcnJvcik7XG5cdCAgICBhZ2VudC5jbG9zZVNvY2tldENvdW50Kys7XG5cdCAgfVxuXHQgIHNvY2tldC5vbignY2xvc2UnLCBvbkNsb3NlKTtcblxuXHQgIC8vIHN0YXJ0IHNvY2tldCB0aW1lb3V0IGhhbmRsZXJcblx0ICBmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG5cdCAgICAvLyBvblRpbWVvdXQgYW5kIGVtaXRSZXF1ZXN0VGltZW91dChfaHR0cF9jbGllbnQuanMpXG5cdCAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTIueC9saWIvX2h0dHBfY2xpZW50LmpzI0w3MTFcblx0ICAgIGNvbnN0IGxpc3RlbmVyQ291bnQgPSBzb2NrZXQubGlzdGVuZXJzKCd0aW1lb3V0JykubGVuZ3RoO1xuXHQgICAgLy8gbm9kZSA8PSAxMCwgZGVmYXVsdCBsaXN0ZW5lckNvdW50IGlzIDEsIG9uVGltZW91dFxuXHQgICAgLy8gMTEgPCBub2RlIDw9IDEyLCBkZWZhdWx0IGxpc3RlbmVyQ291bnQgaXMgMiwgb25UaW1lb3V0IGFuZCBlbWl0UmVxdWVzdFRpbWVvdXRcblx0ICAgIC8vIG5vZGUgPj0gMTMsIGRlZmF1bHQgbGlzdGVuZXJDb3VudCBpcyAzLCBvblRpbWVvdXQsXG5cdCAgICAvLyAgIG9uVGltZW91dChodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMjAwMC9maWxlcyNkaWZmLTVmN2ZiMDg1MDQxMmM2YmUxODlmYWVkZGVhNmM1MzU5UjMzMylcblx0ICAgIC8vICAgYW5kIGVtaXRSZXF1ZXN0VGltZW91dFxuXHQgICAgY29uc3QgdGltZW91dCA9IGdldFNvY2tldFRpbWVvdXQoc29ja2V0KTtcblx0ICAgIGNvbnN0IHJlcSA9IHNvY2tldC5faHR0cE1lc3NhZ2U7XG5cdCAgICBjb25zdCByZXFUaW1lb3V0TGlzdGVuZXJDb3VudCA9IHJlcSAmJiByZXEubGlzdGVuZXJzKCd0aW1lb3V0JykubGVuZ3RoIHx8IDA7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIHRpbWVvdXQgYWZ0ZXIgJXNtcywgbGlzdGVuZXJzICVzLCBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgJXMsIGhhc0h0dHBSZXF1ZXN0ICVzLCBIdHRwUmVxdWVzdCB0aW1lb3V0TGlzdGVuZXJDb3VudCAlcycsXG5cdCAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sXG5cdCAgICAgIHRpbWVvdXQsIGxpc3RlbmVyQ291bnQsIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCwgISFyZXEsIHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50KTtcblx0ICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG5cdCAgICAgIGRlYnVnKCd0aW1lb3V0IGxpc3RlbmVyczogJXMnLCBzb2NrZXQubGlzdGVuZXJzKCd0aW1lb3V0JykubWFwKGYgPT4gZi5uYW1lKS5qb2luKCcsICcpKTtcblx0ICAgIH1cblx0ICAgIGFnZW50LnRpbWVvdXRTb2NrZXRDb3VudCsrO1xuXHQgICAgY29uc3QgbmFtZSA9IGFnZW50LmdldE5hbWUob3B0aW9ucyk7XG5cdCAgICBpZiAoYWdlbnQuZnJlZVNvY2tldHNbbmFtZV0gJiYgYWdlbnQuZnJlZVNvY2tldHNbbmFtZV0uaW5kZXhPZihzb2NrZXQpICE9PSAtMSkge1xuXHQgICAgICAvLyBmcmVlIHNvY2tldCB0aW1lb3V0LCBkZXN0cm95IHF1aWV0bHlcblx0ICAgICAgc29ja2V0LmRlc3Ryb3koKTtcblx0ICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gZnJlZVNvY2tldHMgbGlzdCBpbW1lZGlhdGVseSB0byBwcmV2ZW50IG5ldyByZXF1ZXN0c1xuXHQgICAgICAvLyBmcm9tIGJlaW5nIHNlbnQgdGhyb3VnaCB0aGlzIHNvY2tldC5cblx0ICAgICAgYWdlbnQucmVtb3ZlU29ja2V0KHNvY2tldCwgb3B0aW9ucyk7XG5cdCAgICAgIGRlYnVnKCclcyBpcyBmcmVlLCBkZXN0cm95IHF1aWV0bHknLCBzb2NrZXRbU09DS0VUX05BTUVdKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGFueSByZXF1ZXN0IHNvY2tldCB0aW1lb3V0IGhhbmRsZXIsXG5cdCAgICAgIC8vIGFnZW50IG5lZWQgdG8gaGFuZGxlIHNvY2tldCB0aW1lb3V0IGl0c2VsZi5cblx0ICAgICAgLy9cblx0ICAgICAgLy8gY3VzdG9tIHJlcXVlc3Qgc29ja2V0IHRpbWVvdXQgaGFuZGxlIGxvZ2ljIG11c3QgZm9sbG93IHRoZXNlIHJ1bGVzOlxuXHQgICAgICAvLyAgMS4gRGVzdHJveSBzb2NrZXQgZmlyc3Rcblx0ICAgICAgLy8gIDIuIE11c3QgZW1pdCBzb2NrZXQgJ2FnZW50UmVtb3ZlJyBldmVudCB0ZWxsIGFnZW50IHJlbW92ZSBzb2NrZXRcblx0ICAgICAgLy8gICAgIGZyb20gZnJlZVNvY2tldHMgbGlzdCBpbW1lZGlhdGVseS5cblx0ICAgICAgLy8gICAgIE90aGVyaXNlIHlvdSBtYXkgYmUgZ2V0ICdzb2NrZXQgaGFuZyB1cCcgZXJyb3Igd2hlbiByZXVzZVxuXHQgICAgICAvLyAgICAgZnJlZSBzb2NrZXQgYW5kIHRpbWVvdXQgaGFwcGVuIGluIHRoZSBzYW1lIHRpbWUuXG5cdCAgICAgIGlmIChyZXFUaW1lb3V0TGlzdGVuZXJDb3VudCA9PT0gMCkge1xuXHQgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdTb2NrZXQgdGltZW91dCcpO1xuXHQgICAgICAgIGVycm9yLmNvZGUgPSAnRVJSX1NPQ0tFVF9USU1FT1VUJztcblx0ICAgICAgICBlcnJvci50aW1lb3V0ID0gdGltZW91dDtcblx0ICAgICAgICAvLyBtdXN0IG1hbnVhbGx5IGNhbGwgc29ja2V0LmVuZCgpIG9yIHNvY2tldC5kZXN0cm95KCkgdG8gZW5kIHRoZSBjb25uZWN0aW9uLlxuXHQgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12MTAueC9kb2NzL2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X3NldHRpbWVvdXRfdGltZW91dF9jYWxsYmFja1xuXHQgICAgICAgIHNvY2tldC5kZXN0cm95KGVycm9yKTtcblx0ICAgICAgICBhZ2VudC5yZW1vdmVTb2NrZXQoc29ja2V0LCBvcHRpb25zKTtcblx0ICAgICAgICBkZWJ1ZygnJXMgZGVzdHJveSB3aXRoIHRpbWVvdXQgZXJyb3InLCBzb2NrZXRbU09DS0VUX05BTUVdKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICBzb2NrZXQub24oJ3RpbWVvdXQnLCBvblRpbWVvdXQpO1xuXG5cdCAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcblx0ICAgIGNvbnN0IGxpc3RlbmVyQ291bnQgPSBzb2NrZXQubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aDtcblx0ICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgZXJyb3I6ICVzLCBsaXN0ZW5lckNvdW50OiAlcycsXG5cdCAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sXG5cdCAgICAgIGVyciwgbGlzdGVuZXJDb3VudCk7XG5cdCAgICBhZ2VudC5lcnJvclNvY2tldENvdW50Kys7XG5cdCAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuXHQgICAgICAvLyBpZiBzb2NrZXQgZG9uJ3QgY29udGFpbiBlcnJvciBldmVudCBoYW5kbGVyLCBkb24ndCBjYXRjaCBpdCwgZW1pdCBpdCBhZ2FpblxuXHQgICAgICBkZWJ1ZygnJXMgZW1pdCB1bmNhdWdodCBlcnJvciBldmVudCcsIHNvY2tldFtTT0NLRVRfTkFNRV0pO1xuXHQgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG5cdCAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHNvY2tldC5vbignZXJyb3InLCBvbkVycm9yKTtcblxuXHQgIGZ1bmN0aW9uIG9uUmVtb3ZlKCkge1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBhZ2VudFJlbW92ZScsXG5cdCAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sXG5cdCAgICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0pO1xuXHQgICAgLy8gV2UgbmVlZCB0aGlzIGZ1bmN0aW9uIGZvciBjYXNlcyBsaWtlIEhUVFAgJ3VwZ3JhZGUnXG5cdCAgICAvLyAoZGVmaW5lZCBieSBXZWJTb2NrZXRzKSB3aGVyZSB3ZSBuZWVkIHRvIHJlbW92ZSBhIHNvY2tldCBmcm9tIHRoZVxuXHQgICAgLy8gcG9vbCBiZWNhdXNlIGl0J2xsIGJlIGxvY2tlZCB1cCBpbmRlZmluaXRlbHlcblx0ICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkNsb3NlKTtcblx0ICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcblx0ICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZnJlZScsIG9uRnJlZSk7XG5cdCAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ3RpbWVvdXQnLCBvblRpbWVvdXQpO1xuXHQgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdhZ2VudFJlbW92ZScsIG9uUmVtb3ZlKTtcblx0ICB9XG5cdCAgc29ja2V0Lm9uKCdhZ2VudFJlbW92ZScsIG9uUmVtb3ZlKTtcblx0fVxuXG5cdGFnZW50ID0gQWdlbnQ7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdChvYmopIHtcblx0ICBjb25zdCByZXMgPSB7fTtcblx0ICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcblx0ICAgIHJlc1trZXldID0gb2JqW2tleV0ubGVuZ3RoO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cdHJldHVybiBhZ2VudDtcbn1cblxudmFyIGh0dHBzX2FnZW50O1xudmFyIGhhc1JlcXVpcmVkSHR0cHNfYWdlbnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVIdHRwc19hZ2VudCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEh0dHBzX2FnZW50KSByZXR1cm4gaHR0cHNfYWdlbnQ7XG5cdGhhc1JlcXVpcmVkSHR0cHNfYWdlbnQgPSAxO1xuXG5cdGNvbnN0IE9yaWdpbmFsSHR0cHNBZ2VudCA9IHJlcXVpcmUkJDAkMi5BZ2VudDtcblx0Y29uc3QgSHR0cEFnZW50ID0gLypAX19QVVJFX18qLyByZXF1aXJlQWdlbnQoKTtcblx0Y29uc3Qge1xuXHQgIElOSVRfU09DS0VULFxuXHQgIENSRUFURV9IVFRQU19DT05ORUNUSU9OLFxuXHR9ID0gLypAX19QVVJFX18qLyByZXF1aXJlQ29uc3RhbnRzKCk7XG5cblx0Y2xhc3MgSHR0cHNBZ2VudCBleHRlbmRzIEh0dHBBZ2VudCB7XG5cdCAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXHQgICAgc3VwZXIob3B0aW9ucyk7XG5cblx0ICAgIHRoaXMuZGVmYXVsdFBvcnQgPSA0NDM7XG5cdCAgICB0aGlzLnByb3RvY29sID0gJ2h0dHBzOic7XG5cdCAgICB0aGlzLm1heENhY2hlZFNlc3Npb25zID0gdGhpcy5vcHRpb25zLm1heENhY2hlZFNlc3Npb25zO1xuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICAgIGlmICh0aGlzLm1heENhY2hlZFNlc3Npb25zID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdGhpcy5tYXhDYWNoZWRTZXNzaW9ucyA9IDEwMDtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fc2Vzc2lvbkNhY2hlID0ge1xuXHQgICAgICBtYXA6IHt9LFxuXHQgICAgICBsaXN0OiBbXSxcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zLCBvbmNyZWF0ZSkge1xuXHQgICAgY29uc3Qgc29ja2V0ID0gdGhpc1tDUkVBVEVfSFRUUFNfQ09OTkVDVElPTl0ob3B0aW9ucywgb25jcmVhdGUpO1xuXHQgICAgdGhpc1tJTklUX1NPQ0tFVF0oc29ja2V0LCBvcHRpb25zKTtcblx0ICAgIHJldHVybiBzb2NrZXQ7XG5cdCAgfVxuXHR9XG5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9odHRwcy5qcyNMODlcblx0SHR0cHNBZ2VudC5wcm90b3R5cGVbQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT05dID0gT3JpZ2luYWxIdHRwc0FnZW50LnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uO1xuXG5cdFtcblx0ICAnZ2V0TmFtZScsXG5cdCAgJ19nZXRTZXNzaW9uJyxcblx0ICAnX2NhY2hlU2Vzc2lvbicsXG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvNDk4MlxuXHQgICdfZXZpY3RTZXNzaW9uJyxcblx0XS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgaWYgKHR5cGVvZiBPcmlnaW5hbEh0dHBzQWdlbnQucHJvdG90eXBlW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIEh0dHBzQWdlbnQucHJvdG90eXBlW21ldGhvZF0gPSBPcmlnaW5hbEh0dHBzQWdlbnQucHJvdG90eXBlW21ldGhvZF07XG5cdCAgfVxuXHR9KTtcblxuXHRodHRwc19hZ2VudCA9IEh0dHBzQWdlbnQ7XG5cdHJldHVybiBodHRwc19hZ2VudDtcbn1cblxudmFyIGhhc1JlcXVpcmVkQWdlbnRrZWVwYWxpdmU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVBZ2VudGtlZXBhbGl2ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEFnZW50a2VlcGFsaXZlKSByZXR1cm4gYWdlbnRrZWVwYWxpdmUuZXhwb3J0cztcblx0aGFzUmVxdWlyZWRBZ2VudGtlZXBhbGl2ZSA9IDE7XG5cblx0YWdlbnRrZWVwYWxpdmUuZXhwb3J0cyA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUFnZW50KCk7XG5cdGFnZW50a2VlcGFsaXZlLmV4cG9ydHMuSHR0cHNBZ2VudCA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUh0dHBzX2FnZW50KCk7XG5cdGFnZW50a2VlcGFsaXZlLmV4cG9ydHMuY29uc3RhbnRzID0gLypAX19QVVJFX18qLyByZXF1aXJlQ29uc3RhbnRzKCk7XG5cdHJldHVybiBhZ2VudGtlZXBhbGl2ZS5leHBvcnRzO1xufVxuXG52YXIgYWdlbnRrZWVwYWxpdmVFeHBvcnRzID0gLypAX19QVVJFX18qLyByZXF1aXJlQWdlbnRrZWVwYWxpdmUoKTtcbnZhciBIdHRwS2VlcEFsaXZlQWdlbnQgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYWdlbnRrZWVwYWxpdmVFeHBvcnRzKTtcblxudmFyIGZhc3RTdGFibGVTdHJpbmdpZnkkMTtcbnZhciBoYXNSZXF1aXJlZEZhc3RTdGFibGVTdHJpbmdpZnk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVGYXN0U3RhYmxlU3RyaW5naWZ5ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRmFzdFN0YWJsZVN0cmluZ2lmeSkgcmV0dXJuIGZhc3RTdGFibGVTdHJpbmdpZnkkMTtcblx0aGFzUmVxdWlyZWRGYXN0U3RhYmxlU3RyaW5naWZ5ID0gMTtcblx0dmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIG9iaktleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmopIHtcblx0XHRcdHZhciBrZXlzID0gW107XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG9iaikge1xuXHRcdFx0XHRrZXlzLnB1c2gobmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ga2V5cztcblx0XHR9O1xuXG5cdGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWwsIGlzQXJyYXlQcm9wKSB7XG5cdFx0dmFyIGksIG1heCwgc3RyLCBrZXlzLCBrZXksIHByb3BWYWwsIHRvU3RyO1xuXHRcdGlmICh2YWwgPT09IHRydWUpIHtcblx0XHRcdHJldHVybiBcInRydWVcIjtcblx0XHR9XG5cdFx0aWYgKHZhbCA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybiBcImZhbHNlXCI7XG5cdFx0fVxuXHRcdHN3aXRjaCAodHlwZW9mIHZhbCkge1xuXHRcdFx0Y2FzZSBcIm9iamVjdFwiOlxuXHRcdFx0XHRpZiAodmFsID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsLnRvSlNPTiAmJiB0eXBlb2YgdmFsLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSh2YWwudG9KU09OKCksIGlzQXJyYXlQcm9wKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0b1N0ciA9IG9ialRvU3RyaW5nLmNhbGwodmFsKTtcblx0XHRcdFx0XHRpZiAodG9TdHIgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuXHRcdFx0XHRcdFx0c3RyID0gJ1snO1xuXHRcdFx0XHRcdFx0bWF4ID0gdmFsLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRzdHIgKz0gc3RyaW5naWZ5KHZhbFtpXSwgdHJ1ZSkgKyAnLCc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAobWF4ID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0c3RyICs9IHN0cmluZ2lmeSh2YWxbaV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHN0ciArICddJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRvU3RyID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG5cdFx0XHRcdFx0XHQvLyBvbmx5IG9iamVjdCBpcyBsZWZ0XG5cdFx0XHRcdFx0XHRrZXlzID0gb2JqS2V5cyh2YWwpLnNvcnQoKTtcblx0XHRcdFx0XHRcdG1heCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0c3RyID0gXCJcIjtcblx0XHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBtYXgpIHtcblx0XHRcdFx0XHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0XHRcdFx0cHJvcFZhbCA9IHN0cmluZ2lmeSh2YWxba2V5XSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHRpZiAocHJvcFZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0cikge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RyICs9ICcsJztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9IEpTT04uc3RyaW5naWZ5KGtleSkgKyAnOicgKyBwcm9wVmFsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiAneycgKyBzdHIgKyAnfSc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSBcImZ1bmN0aW9uXCI6XG5cdFx0XHRjYXNlIFwidW5kZWZpbmVkXCI6XG5cdFx0XHRcdHJldHVybiBpc0FycmF5UHJvcCA/IG51bGwgOiB1bmRlZmluZWQ7XG5cdFx0XHRjYXNlIFwic3RyaW5nXCI6XG5cdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGlzRmluaXRlKHZhbCkgPyB2YWwgOiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGZhc3RTdGFibGVTdHJpbmdpZnkkMSA9IGZ1bmN0aW9uKHZhbCkge1xuXHRcdHZhciByZXR1cm5WYWwgPSBzdHJpbmdpZnkodmFsLCBmYWxzZSk7XG5cdFx0aWYgKHJldHVyblZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gJycrIHJldHVyblZhbDtcblx0XHR9XG5cdH07XG5cdHJldHVybiBmYXN0U3RhYmxlU3RyaW5naWZ5JDE7XG59XG5cbnZhciBmYXN0U3RhYmxlU3RyaW5naWZ5RXhwb3J0cyA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUZhc3RTdGFibGVTdHJpbmdpZnkoKTtcbnZhciBmYXN0U3RhYmxlU3RyaW5naWZ5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGZhc3RTdGFibGVTdHJpbmdpZnlFeHBvcnRzKTtcblxuY29uc3QgTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCA9IDMyO1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBzZWxmLlxuZnVuY3Rpb24gdHJhaWxpbmdaZXJvcyhuKSB7XG4gIGxldCB0cmFpbGluZ1plcm9zID0gMDtcbiAgd2hpbGUgKG4gPiAxKSB7XG4gICAgbiAvPSAyO1xuICAgIHRyYWlsaW5nWmVyb3MrKztcbiAgfVxuICByZXR1cm4gdHJhaWxpbmdaZXJvcztcbn1cblxuLy8gUmV0dXJucyB0aGUgc21hbGxlc3QgcG93ZXIgb2YgdHdvIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBuXG5mdW5jdGlvbiBuZXh0UG93ZXJPZlR3byhuKSB7XG4gIGlmIChuID09PSAwKSByZXR1cm4gMTtcbiAgbi0tO1xuICBuIHw9IG4gPj4gMTtcbiAgbiB8PSBuID4+IDI7XG4gIG4gfD0gbiA+PiA0O1xuICBuIHw9IG4gPj4gODtcbiAgbiB8PSBuID4+IDE2O1xuICBuIHw9IG4gPj4gMzI7XG4gIHJldHVybiBuICsgMTtcbn1cblxuLyoqXG4gKiBFcG9jaCBzY2hlZHVsZVxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS90ZXJtaW5vbG9neSNlcG9jaClcbiAqIENhbiBiZSByZXRyaWV2ZWQgd2l0aCB0aGUge0BsaW5rIENvbm5lY3Rpb24uZ2V0RXBvY2hTY2hlZHVsZX0gbWV0aG9kXG4gKi9cbmNsYXNzIEVwb2NoU2NoZWR1bGUge1xuICBjb25zdHJ1Y3RvcihzbG90c1BlckVwb2NoLCBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQsIHdhcm11cCwgZmlyc3ROb3JtYWxFcG9jaCwgZmlyc3ROb3JtYWxTbG90KSB7XG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzbG90cyBpbiBlYWNoIGVwb2NoICovXG4gICAgdGhpcy5zbG90c1BlckVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHNsb3RzIGJlZm9yZSBiZWdpbm5pbmcgb2YgYW4gZXBvY2ggdG8gY2FsY3VsYXRlIGEgbGVhZGVyIHNjaGVkdWxlIGZvciB0aGF0IGVwb2NoICovXG4gICAgdGhpcy5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQgPSB2b2lkIDA7XG4gICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIGVwb2NocyBzdGFydCBzaG9ydCBhbmQgZ3JvdyAqL1xuICAgIHRoaXMud2FybXVwID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgZmlyc3QgZXBvY2ggd2l0aCBgc2xvdHNQZXJFcG9jaGAgc2xvdHMgKi9cbiAgICB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBmaXJzdCBzbG90IG9mIGBmaXJzdE5vcm1hbEVwb2NoYCAqL1xuICAgIHRoaXMuZmlyc3ROb3JtYWxTbG90ID0gdm9pZCAwO1xuICAgIHRoaXMuc2xvdHNQZXJFcG9jaCA9IHNsb3RzUGVyRXBvY2g7XG4gICAgdGhpcy5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQgPSBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQ7XG4gICAgdGhpcy53YXJtdXAgPSB3YXJtdXA7XG4gICAgdGhpcy5maXJzdE5vcm1hbEVwb2NoID0gZmlyc3ROb3JtYWxFcG9jaDtcbiAgICB0aGlzLmZpcnN0Tm9ybWFsU2xvdCA9IGZpcnN0Tm9ybWFsU2xvdDtcbiAgfVxuICBnZXRFcG9jaChzbG90KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RXBvY2hBbmRTbG90SW5kZXgoc2xvdClbMF07XG4gIH1cbiAgZ2V0RXBvY2hBbmRTbG90SW5kZXgoc2xvdCkge1xuICAgIGlmIChzbG90IDwgdGhpcy5maXJzdE5vcm1hbFNsb3QpIHtcbiAgICAgIGNvbnN0IGVwb2NoID0gdHJhaWxpbmdaZXJvcyhuZXh0UG93ZXJPZlR3byhzbG90ICsgTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCArIDEpKSAtIHRyYWlsaW5nWmVyb3MoTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCkgLSAxO1xuICAgICAgY29uc3QgZXBvY2hMZW4gPSB0aGlzLmdldFNsb3RzSW5FcG9jaChlcG9jaCk7XG4gICAgICBjb25zdCBzbG90SW5kZXggPSBzbG90IC0gKGVwb2NoTGVuIC0gTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCk7XG4gICAgICByZXR1cm4gW2Vwb2NoLCBzbG90SW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub3JtYWxTbG90SW5kZXggPSBzbG90IC0gdGhpcy5maXJzdE5vcm1hbFNsb3Q7XG4gICAgICBjb25zdCBub3JtYWxFcG9jaEluZGV4ID0gTWF0aC5mbG9vcihub3JtYWxTbG90SW5kZXggLyB0aGlzLnNsb3RzUGVyRXBvY2gpO1xuICAgICAgY29uc3QgZXBvY2ggPSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggKyBub3JtYWxFcG9jaEluZGV4O1xuICAgICAgY29uc3Qgc2xvdEluZGV4ID0gbm9ybWFsU2xvdEluZGV4ICUgdGhpcy5zbG90c1BlckVwb2NoO1xuICAgICAgcmV0dXJuIFtlcG9jaCwgc2xvdEluZGV4XTtcbiAgICB9XG4gIH1cbiAgZ2V0Rmlyc3RTbG90SW5FcG9jaChlcG9jaCkge1xuICAgIGlmIChlcG9jaCA8PSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpIHtcbiAgICAgIHJldHVybiAoTWF0aC5wb3coMiwgZXBvY2gpIC0gMSkgKiBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGVwb2NoIC0gdGhpcy5maXJzdE5vcm1hbEVwb2NoKSAqIHRoaXMuc2xvdHNQZXJFcG9jaCArIHRoaXMuZmlyc3ROb3JtYWxTbG90O1xuICAgIH1cbiAgfVxuICBnZXRMYXN0U2xvdEluRXBvY2goZXBvY2gpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGaXJzdFNsb3RJbkVwb2NoKGVwb2NoKSArIHRoaXMuZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKSAtIDE7XG4gIH1cbiAgZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKSB7XG4gICAgaWYgKGVwb2NoIDwgdGhpcy5maXJzdE5vcm1hbEVwb2NoKSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgZXBvY2ggKyB0cmFpbGluZ1plcm9zKE1JTklNVU1fU0xPVF9QRVJfRVBPQ0gpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2xvdHNQZXJFcG9jaDtcbiAgICB9XG4gIH1cbn1cblxudmFyIGZldGNoSW1wbCA9IHR5cGVvZiBnbG9iYWxUaGlzLmZldGNoID09PSAnZnVuY3Rpb24nID9cbi8vIFRoZSBGZXRjaCBBUEkgaXMgc3VwcG9ydGVkIGV4cGVyaW1lbnRhbGx5IGluIE5vZGUgMTcuNSsgYW5kIG5hdGl2ZWx5IGluIE5vZGUgMTgrLlxuZ2xvYmFsVGhpcy5mZXRjaCA6XG4vLyBPdGhlcndpc2UgdXNlIHRoZSBwb2x5ZmlsbC5cbmFzeW5jIGZ1bmN0aW9uIChpbnB1dCwgaW5pdCkge1xuICBjb25zdCBwcm9jZXNzZWRJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgaW5wdXQuc2xpY2UoMCwgMikgPT09ICcvLycgPyAnaHR0cHM6JyArIGlucHV0IDogaW5wdXQ7XG4gIHJldHVybiBhd2FpdCBub2RlRmV0Y2guZGVmYXVsdChwcm9jZXNzZWRJbnB1dCwgaW5pdCk7XG59O1xuXG5jbGFzcyBScGNXZWJTb2NrZXRDbGllbnQgZXh0ZW5kcyBDb21tb25DbGllbnQge1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBvcHRpb25zLCBnZW5lcmF0ZV9yZXF1ZXN0X2lkKSB7XG4gICAgY29uc3Qgd2ViU29ja2V0RmFjdG9yeSA9IHVybCA9PiB7XG4gICAgICBjb25zdCBycGMgPSBXZWJTb2NrZXQodXJsLCB7XG4gICAgICAgIGF1dG9jb25uZWN0OiB0cnVlLFxuICAgICAgICBtYXhfcmVjb25uZWN0czogNSxcbiAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWw6IDEwMDAsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCdzb2NrZXQnIGluIHJwYykge1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSBycGMuc29ja2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmRlcmx5aW5nU29ja2V0ID0gcnBjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJwYztcbiAgICB9O1xuICAgIHN1cGVyKHdlYlNvY2tldEZhY3RvcnksIGFkZHJlc3MsIG9wdGlvbnMsIGdlbmVyYXRlX3JlcXVlc3RfaWQpO1xuICAgIHRoaXMudW5kZXJseWluZ1NvY2tldCA9IHZvaWQgMDtcbiAgfVxuICBjYWxsKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0gdGhpcy51bmRlcmx5aW5nU29ja2V0Py5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAxIC8qIFdlYlNvY2tldC5PUEVOICovKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY2FsbCguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVHJpZWQgdG8gY2FsbCBhIEpTT04tUlBDIG1ldGhvZCBgJyArIGFyZ3NbMF0gKyAnYCBidXQgdGhlIHNvY2tldCB3YXMgbm90IGBDT05ORUNUSU5HYCBvciBgT1BFTmAgKGByZWFkeVN0YXRlYCB3YXMgJyArIHJlYWR5U3RhdGUgKyAnKScpKTtcbiAgfVxuICBub3RpZnkoLi4uYXJncykge1xuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB0aGlzLnVuZGVybHlpbmdTb2NrZXQ/LnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPT09IDEgLyogV2ViU29ja2V0Lk9QRU4gKi8pIHtcbiAgICAgIHJldHVybiBzdXBlci5ub3RpZnkoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RyaWVkIHRvIHNlbmQgYSBKU09OLVJQQyBub3RpZmljYXRpb24gYCcgKyBhcmdzWzBdICsgJ2AgYnV0IHRoZSBzb2NrZXQgd2FzIG5vdCBgQ09OTkVDVElOR2Agb3IgYE9QRU5gIChgcmVhZHlTdGF0ZWAgd2FzICcgKyByZWFkeVN0YXRlICsgJyknKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIERlY29kZSBhY2NvdW50IGRhdGEgYnVmZmVyIHVzaW5nIGFuIEFjY291bnRUeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZGVjb2RlRGF0YSh0eXBlLCBkYXRhKSB7XG4gIGxldCBkZWNvZGVkO1xuICB0cnkge1xuICAgIGRlY29kZWQgPSB0eXBlLmxheW91dC5kZWNvZGUoZGF0YSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgJyArIGVycik7XG4gIH1cbiAgaWYgKGRlY29kZWQudHlwZUluZGV4ICE9PSB0eXBlLmluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFjY291bnQgZGF0YTsgYWNjb3VudCB0eXBlIG1pc21hdGNoICR7ZGVjb2RlZC50eXBlSW5kZXh9ICE9ICR7dHlwZS5pbmRleH1gKTtcbiAgfVxuICByZXR1cm4gZGVjb2RlZDtcbn1cblxuLy8vIFRoZSBzZXJpYWxpemVkIHNpemUgb2YgbG9va3VwIHRhYmxlIG1ldGFkYXRhXG5jb25zdCBMT09LVVBfVEFCTEVfTUVUQV9TSVpFID0gNTY7XG5jbGFzcyBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50IHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBhcmdzLmtleTtcbiAgICB0aGlzLnN0YXRlID0gYXJncy5zdGF0ZTtcbiAgfVxuICBpc0FjdGl2ZSgpIHtcbiAgICBjb25zdCBVNjRfTUFYID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kZWFjdGl2YXRpb25TbG90ID09PSBVNjRfTUFYO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShhY2NvdW50RGF0YSkge1xuICAgIGNvbnN0IG1ldGEgPSBkZWNvZGVEYXRhKExvb2t1cFRhYmxlTWV0YUxheW91dCwgYWNjb3VudERhdGEpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gPSBhY2NvdW50RGF0YS5sZW5ndGggLSBMT09LVVBfVEFCTEVfTUVUQV9TSVpFO1xuICAgIGFzc2VydChzZXJpYWxpemVkQWRkcmVzc2VzTGVuID49IDAsICdsb29rdXAgdGFibGUgaXMgaW52YWxpZCcpO1xuICAgIGFzc2VydChzZXJpYWxpemVkQWRkcmVzc2VzTGVuICUgMzIgPT09IDAsICdsb29rdXAgdGFibGUgaXMgaW52YWxpZCcpO1xuICAgIGNvbnN0IG51bVNlcmlhbGl6ZWRBZGRyZXNzZXMgPSBzZXJpYWxpemVkQWRkcmVzc2VzTGVuIC8gMzI7XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzc2VzXG4gICAgfSA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIG51bVNlcmlhbGl6ZWRBZGRyZXNzZXMsICdhZGRyZXNzZXMnKV0pLmRlY29kZShhY2NvdW50RGF0YS5zbGljZShMT09LVVBfVEFCTEVfTUVUQV9TSVpFKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlYWN0aXZhdGlvblNsb3Q6IG1ldGEuZGVhY3RpdmF0aW9uU2xvdCxcbiAgICAgIGxhc3RFeHRlbmRlZFNsb3Q6IG1ldGEubGFzdEV4dGVuZGVkU2xvdCxcbiAgICAgIGxhc3RFeHRlbmRlZFNsb3RTdGFydEluZGV4OiBtZXRhLmxhc3RFeHRlbmRlZFN0YXJ0SW5kZXgsXG4gICAgICBhdXRob3JpdHk6IG1ldGEuYXV0aG9yaXR5Lmxlbmd0aCAhPT0gMCA/IG5ldyBQdWJsaWNLZXkobWV0YS5hdXRob3JpdHlbMF0pIDogdW5kZWZpbmVkLFxuICAgICAgYWRkcmVzc2VzOiBhZGRyZXNzZXMubWFwKGFkZHJlc3MgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSlcbiAgICB9O1xuICB9XG59XG5jb25zdCBMb29rdXBUYWJsZU1ldGFMYXlvdXQgPSB7XG4gIGluZGV4OiAxLFxuICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ3R5cGVJbmRleCcpLCB1NjQoJ2RlYWN0aXZhdGlvblNsb3QnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ2xhc3RFeHRlbmRlZFNsb3QnKSwgQnVmZmVyTGF5b3V0LnU4KCdsYXN0RXh0ZW5kZWRTdGFydEluZGV4JyksIEJ1ZmZlckxheW91dC51OCgpLFxuICAvLyBvcHRpb25cbiAgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTgoKSwgLTEpLCAnYXV0aG9yaXR5JyldKVxufTtcblxuY29uc3QgVVJMX1JFID0gL15bXjpdKzpcXC9cXC8oW146W10rfFxcW1teXFxdXStcXF0pKDpcXGQrKT8oLiopL2k7XG5mdW5jdGlvbiBtYWtlV2Vic29ja2V0VXJsKGVuZHBvaW50KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBlbmRwb2ludC5tYXRjaChVUkxfUkUpO1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKGBGYWlsZWQgdG8gdmFsaWRhdGUgZW5kcG9pbnQgVVJMIFxcYCR7ZW5kcG9pbnR9XFxgYCk7XG4gIH1cbiAgY29uc3QgW18sXG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGhvc3Rpc2gsIHBvcnRXaXRoQ29sb24sIHJlc3RdID0gbWF0Y2hlcztcbiAgY29uc3QgcHJvdG9jb2wgPSBlbmRwb2ludC5zdGFydHNXaXRoKCdodHRwczonKSA/ICd3c3M6JyA6ICd3czonO1xuICBjb25zdCBzdGFydFBvcnQgPSBwb3J0V2l0aENvbG9uID09IG51bGwgPyBudWxsIDogcGFyc2VJbnQocG9ydFdpdGhDb2xvbi5zbGljZSgxKSwgMTApO1xuICBjb25zdCB3ZWJzb2NrZXRQb3J0ID1cbiAgLy8gT25seSBzaGlmdCB0aGUgcG9ydCBieSArMSBhcyBhIGNvbnZlbnRpb24gZm9yIHdzKHMpIG9ubHkgaWYgZ2l2ZW4gZW5kcG9pbnRcbiAgLy8gaXMgZXhwbGljaXRseSBzcGVjaWZ5aW5nIHRoZSBlbmRwb2ludCBwb3J0IChIVFRQLWJhc2VkIFJQQyksIGFzc3VtaW5nXG4gIC8vIHdlJ3JlIGRpcmVjdGx5IHRyeWluZyB0byBjb25uZWN0IHRvIGFnYXZlLXZhbGlkYXRvcidzIHdzIGxpc3RlbmluZyBwb3J0LlxuICAvLyBXaGVuIHRoZSBlbmRwb2ludCBvbWl0cyB0aGUgcG9ydCwgd2UncmUgY29ubmVjdGluZyB0byB0aGUgcHJvdG9jb2xcbiAgLy8gZGVmYXVsdCBwb3J0czogaHR0cCg4MCkgb3IgaHR0cHMoNDQzKSBhbmQgaXQncyBhc3N1bWVkIHdlJ3JlIGJlaGluZCBhIHJldmVyc2VcbiAgLy8gcHJveHkgd2hpY2ggbWFuYWdlcyBXZWJTb2NrZXQgdXBncmFkZSBhbmQgYmFja2VuZCBwb3J0IHJlZGlyZWN0aW9uLlxuICBzdGFydFBvcnQgPT0gbnVsbCA/ICcnIDogYDoke3N0YXJ0UG9ydCArIDF9YDtcbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0aXNofSR7d2Vic29ja2V0UG9ydH0ke3Jlc3R9YDtcbn1cblxuY29uc3QgUHVibGljS2V5RnJvbVN0cmluZyA9IGNvZXJjZShpbnN0YW5jZShQdWJsaWNLZXkpLCBzdHJpbmcoKSwgdmFsdWUgPT4gbmV3IFB1YmxpY0tleSh2YWx1ZSkpO1xuY29uc3QgUmF3QWNjb3VudERhdGFSZXN1bHQgPSB0dXBsZShbc3RyaW5nKCksIGxpdGVyYWwoJ2Jhc2U2NCcpXSk7XG5jb25zdCBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEgPSBjb2VyY2UoaW5zdGFuY2UoQnVmZmVyKSwgUmF3QWNjb3VudERhdGFSZXN1bHQsIHZhbHVlID0+IEJ1ZmZlci5mcm9tKHZhbHVlWzBdLCAnYmFzZTY0JykpO1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gdXNlIGEgcmVjZW50IGJsb2NraGFzaCBmb3IgdXAgdG8gMzAgc2Vjb25kc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TID0gMzAgKiAxMDAwO1xuXG4vKipcbiAqIEhBQ0suXG4gKiBDb3BpZWQgZnJvbSBycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQuXG4gKiBPdGhlcndpc2UsIGB5YXJuIGJ1aWxkYCBmYWlscyB3aXRoOlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc3RldmVsdXNjaGVyL2MwNTdlY2E4MWQ0NzllZjcwNWNkYjUzMTYyZjk5NzFkXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuXG4vKiogQGludGVybmFsICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICogRXZlcnkgc3Vic2NyaXB0aW9uIGNvbnRhaW5zIHRoZSBhcmdzIHVzZWQgdG8gb3BlbiB0aGUgc3Vic2NyaXB0aW9uIHdpdGhcbiAqIHRoZSBzZXJ2ZXIsIGFuZCBhIGxpc3Qgb2YgY2FsbGVycyBpbnRlcmVzdGVkIGluIG5vdGlmaWNhdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEEgc3Vic2NyaXB0aW9uIG1heSBiZSBpbiB2YXJpb3VzIHN0YXRlcyBvZiBjb25uZWN0ZWRuZXNzLiBPbmx5IHdoZW4gaXQgaXNcbiAqIGZ1bGx5IGNvbm5lY3RlZCB3aWxsIGl0IGhhdmUgYSBzZXJ2ZXIgc3Vic2NyaXB0aW9uIGlkIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAqIFRoaXMgaWQgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBzZXJ2ZXIgdG8gdW5zdWJzY3JpYmUgdGhlIGNsaWVudCBlbnRpcmVseS5cbiAqL1xuXG4vKipcbiAqIEEgdHlwZSB0aGF0IGVuY2Fwc3VsYXRlcyBhIHN1YnNjcmlwdGlvbidzIFJQQyBtZXRob2RcbiAqIG5hbWVzIGFuZCBub3RpZmljYXRpb24gKGNhbGxiYWNrKSBzaWduYXR1cmUuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFV0aWxpdHkgdHlwZSB0aGF0IGtlZXBzIHRhZ2dlZCB1bmlvbnMgaW50YWN0IHdoaWxlIG9taXR0aW5nIHByb3BlcnRpZXMuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGEgc2luZ2xlIHN1YnNjcmliYWJsZSAndG9waWMuJyBJdCdzIG1hZGUgdXAgb2Y6XG4gKlxuICogLSBUaGUgYXJncyB1c2VkIHRvIG9wZW4gdGhlIHN1YnNjcmlwdGlvbiB3aXRoIHRoZSBzZXJ2ZXIsXG4gKiAtIFRoZSBzdGF0ZSBvZiB0aGUgc3Vic2NyaXB0aW9uLCBpbiB0ZXJtcyBvZiBpdHMgY29ubmVjdGVkbmVzcywgYW5kXG4gKiAtIFRoZSBzZXQgb2YgY2FsbGJhY2tzIHRvIGNhbGwgd2hlbiB0aGUgc2VydmVyIHB1Ymxpc2hlcyBub3RpZmljYXRpb25zXG4gKlxuICogVGhpcyByZWNvcmQgZ2V0cyBpbmRleGVkIGJ5IGBTdWJzY3JpcHRpb25Db25maWdIYXNoYCBhbmQgaXMgdXNlZCB0b1xuICogc2V0IHVwIHN1YnNjcmlwdGlvbnMsIGZhbiBvdXQgbm90aWZpY2F0aW9ucywgYW5kIHRyYWNrIHN1YnNjcmlwdGlvbiBzdGF0ZS5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogRXh0cmEgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBmb3IgUlBDIHJlc3BvbnNlc1xuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3Igc2VuZGluZyB0cmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGNvbmZpcm1pbmcgdHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzXG4gKi9cblxuLyoqXG4gKiBSUEMgUmVzcG9uc2Ugd2l0aCBleHRyYSBjb250ZXh0dWFsIGluZm9ybWF0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBjb25maXJtaW5nIHRyYW5zYWN0aW9ucyB0aGF0IHVzZXMgdGhlIGxhc3QgdmFsaWRcbiAqIGJsb2NrIGhlaWdodCBmb3IgYSBnaXZlbiBibG9ja2hhc2ggdG8gY2hlY2sgZm9yIHRyYW5zYWN0aW9uIGV4cGlyYXRpb24uXG4gKi9cblxuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBjb25maXJtaW5nIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb25zLlxuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBzaGFyZWQgYnkgYWxsIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdHJhdGVnaWVzXG4gKi9cblxuLyoqXG4gKiBUaGlzIHR5cGUgcmVwcmVzZW50cyBhbGwgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0cmF0ZWdpZXNcbiAqL1xuXG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGFzc2VydEVuZHBvaW50VXJsKHB1dGF0aXZlVXJsKSB7XG4gIGlmICgvXmh0dHBzPzovLnRlc3QocHV0YXRpdmVVcmwpID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZHBvaW50IFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKTtcbiAgfVxuICByZXR1cm4gcHV0YXRpdmVVcmw7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpIHtcbiAgbGV0IGNvbW1pdG1lbnQ7XG4gIGxldCBjb25maWc7XG4gIGlmICh0eXBlb2YgY29tbWl0bWVudE9yQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbW1pdG1lbnQgPSBjb21taXRtZW50T3JDb25maWc7XG4gIH0gZWxzZSBpZiAoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudDogc3BlY2lmaWVkQ29tbWl0bWVudCxcbiAgICAgIC4uLnNwZWNpZmllZENvbmZpZ1xuICAgIH0gPSBjb21taXRtZW50T3JDb25maWc7XG4gICAgY29tbWl0bWVudCA9IHNwZWNpZmllZENvbW1pdG1lbnQ7XG4gICAgY29uZmlnID0gc3BlY2lmaWVkQ29uZmlnO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWl0bWVudCxcbiAgICBjb25maWdcbiAgfTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0TWVtY21wRW5jb2RpbmdUb0ZpbHRlcnMoZmlsdGVycykge1xuICByZXR1cm4gZmlsdGVycy5tYXAoZmlsdGVyID0+ICdtZW1jbXAnIGluIGZpbHRlciA/IHtcbiAgICAuLi5maWx0ZXIsXG4gICAgbWVtY21wOiB7XG4gICAgICAuLi5maWx0ZXIubWVtY21wLFxuICAgICAgZW5jb2Rpbmc6IGZpbHRlci5tZW1jbXAuZW5jb2RpbmcgPz8gJ2Jhc2U1OCdcbiAgICB9XG4gIH0gOiBmaWx0ZXIpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBjcmVhdGVScGNSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiB1bmlvbihbdHlwZSh7XG4gICAganNvbnJwYzogbGl0ZXJhbCgnMi4wJyksXG4gICAgaWQ6IHN0cmluZygpLFxuICAgIHJlc3VsdFxuICB9KSwgdHlwZSh7XG4gICAganNvbnJwYzogbGl0ZXJhbCgnMi4wJyksXG4gICAgaWQ6IHN0cmluZygpLFxuICAgIGVycm9yOiB0eXBlKHtcbiAgICAgIGNvZGU6IHVua25vd24oKSxcbiAgICAgIG1lc3NhZ2U6IHN0cmluZygpLFxuICAgICAgZGF0YTogb3B0aW9uYWwoYW55KCkpXG4gICAgfSlcbiAgfSldKTtcbn1cbmNvbnN0IFVua25vd25ScGNSZXN1bHQgPSBjcmVhdGVScGNSZXN1bHQodW5rbm93bigpKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24ganNvblJwY1Jlc3VsdChzY2hlbWEpIHtcbiAgcmV0dXJuIGNvZXJjZShjcmVhdGVScGNSZXN1bHQoc2NoZW1hKSwgVW5rbm93blJwY1Jlc3VsdCwgdmFsdWUgPT4ge1xuICAgIGlmICgnZXJyb3InIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnZhbHVlLFxuICAgICAgICByZXN1bHQ6IGNyZWF0ZSh2YWx1ZS5yZXN1bHQsIHNjaGVtYSlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodmFsdWUpIHtcbiAgcmV0dXJuIGpzb25ScGNSZXN1bHQodHlwZSh7XG4gICAgY29udGV4dDogdHlwZSh7XG4gICAgICBzbG90OiBudW1iZXIoKVxuICAgIH0pLFxuICAgIHZhbHVlXG4gIH0pKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZSh7XG4gICAgY29udGV4dDogdHlwZSh7XG4gICAgICBzbG90OiBudW1iZXIoKVxuICAgIH0pLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlKHZlcnNpb24sIHJlc3BvbnNlKSB7XG4gIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlVjAoe1xuICAgICAgaGVhZGVyOiByZXNwb25zZS5oZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5czogcmVzcG9uc2UuYWNjb3VudEtleXMubWFwKGFjY291bnRLZXkgPT4gbmV3IFB1YmxpY0tleShhY2NvdW50S2V5KSksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHJlc3BvbnNlLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zOiByZXNwb25zZS5pbnN0cnVjdGlvbnMubWFwKGl4ID0+ICh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBpeC5wcm9ncmFtSWRJbmRleCxcbiAgICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGl4LmFjY291bnRzLFxuICAgICAgICBkYXRhOiBiczU4LmRlY29kZShpeC5kYXRhKVxuICAgICAgfSkpLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3VwczogcmVzcG9uc2UuYWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZShyZXNwb25zZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGV2ZWwgb2YgY29tbWl0bWVudCBkZXNpcmVkIHdoZW4gcXVlcnlpbmcgc3RhdGVcbiAqIDxwcmU+XG4gKiAgICdwcm9jZXNzZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNvbm5lY3RlZCBub2RlXG4gKiAgICdjb25maXJtZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG5cbi8vIERlcHJlY2F0ZWQgYXMgb2YgdjEuNS41XG5cbi8qKlxuICogQSBzdWJzZXQgb2YgQ29tbWl0bWVudCBsZXZlbHMsIHdoaWNoIGFyZSBhdCBsZWFzdCBvcHRpbWlzdGljYWxseSBjb25maXJtZWRcbiAqIDxwcmU+XG4gKiAgICdjb25maXJtZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogRmlsdGVyIGZvciBsYXJnZXN0IGFjY291bnRzIHF1ZXJ5XG4gKiA8cHJlPlxuICogICAnY2lyY3VsYXRpbmcnOiAgICBSZXR1cm4gdGhlIGxhcmdlc3QgYWNjb3VudHMgdGhhdCBhcmUgcGFydCBvZiB0aGUgY2lyY3VsYXRpbmcgc3VwcGx5XG4gKiAgICdub25DaXJjdWxhdGluZyc6IFJldHVybiB0aGUgbGFyZ2VzdCBhY2NvdW50cyB0aGF0IGFyZSBub3QgcGFydCBvZiB0aGUgY2lyY3VsYXRpbmcgc3VwcGx5XG4gKiA8L3ByZT5cbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QWNjb3VudEluZm9gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJhbGFuY2VgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tIZWlnaHRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEVwb2NoSW5mb2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0SW5mbGF0aW9uUmV3YXJkYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRMYXRlc3RCbG9ja2hhc2hgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGlzQmxvY2toYXNoVmFsaWRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFNsb3RgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFNsb3RMZWFkZXJgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFRyYW5zYWN0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRUcmFuc2FjdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0TGFyZ2VzdEFjY291bnRzYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTdXBwbHlgIHJlcXVlc3QgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhIGNsdXN0ZXIgbm9kZVxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhIHZvdGUgYWNjb3VudFxuICovXG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNsdXN0ZXIgdm90ZSBhY2NvdW50c1xuICovXG5cbi8qKlxuICogTmV0d29yayBJbmZsYXRpb25cbiAqIChzZWUgaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vaW1wbGVtZW50ZWQtcHJvcG9zYWxzL2VkX292ZXJ2aWV3KVxuICovXG5cbmNvbnN0IEdldEluZmxhdGlvbkdvdmVybm9yUmVzdWx0ID0gdHlwZSh7XG4gIGZvdW5kYXRpb246IG51bWJlcigpLFxuICBmb3VuZGF0aW9uVGVybTogbnVtYmVyKCksXG4gIGluaXRpYWw6IG51bWJlcigpLFxuICB0YXBlcjogbnVtYmVyKCksXG4gIHRlcm1pbmFsOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogVGhlIGluZmxhdGlvbiByZXdhcmQgZm9yIGFuIGVwb2NoXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmV3YXJkXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRJbmZsYXRpb25SZXdhcmRSZXN1bHQgPSBqc29uUnBjUmVzdWx0KGFycmF5KG51bGxhYmxlKHR5cGUoe1xuICBlcG9jaDogbnVtYmVyKCksXG4gIGVmZmVjdGl2ZVNsb3Q6IG51bWJlcigpLFxuICBhbW91bnQ6IG51bWJlcigpLFxuICBwb3N0QmFsYW5jZTogbnVtYmVyKCksXG4gIGNvbW1pc3Npb246IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSlcbn0pKSkpO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUmVzdWx0ID0gYXJyYXkodHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBwcmlvcml0aXphdGlvbkZlZTogbnVtYmVyKClcbn0pKTtcbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJhdGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJhdGVSZXN1bHQgPSB0eXBlKHtcbiAgdG90YWw6IG51bWJlcigpLFxuICB2YWxpZGF0b3I6IG51bWJlcigpLFxuICBmb3VuZGF0aW9uOiBudW1iZXIoKSxcbiAgZXBvY2g6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBlcG9jaFxuICovXG5cbmNvbnN0IEdldEVwb2NoSW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBlcG9jaDogbnVtYmVyKCksXG4gIHNsb3RJbmRleDogbnVtYmVyKCksXG4gIHNsb3RzSW5FcG9jaDogbnVtYmVyKCksXG4gIGFic29sdXRlU2xvdDogbnVtYmVyKCksXG4gIGJsb2NrSGVpZ2h0OiBvcHRpb25hbChudW1iZXIoKSksXG4gIHRyYW5zYWN0aW9uQ291bnQ6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG5jb25zdCBHZXRFcG9jaFNjaGVkdWxlUmVzdWx0ID0gdHlwZSh7XG4gIHNsb3RzUGVyRXBvY2g6IG51bWJlcigpLFxuICBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQ6IG51bWJlcigpLFxuICB3YXJtdXA6IGJvb2xlYW4oKSxcbiAgZmlyc3ROb3JtYWxFcG9jaDogbnVtYmVyKCksXG4gIGZpcnN0Tm9ybWFsU2xvdDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIExlYWRlciBzY2hlZHVsZVxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS90ZXJtaW5vbG9neSNsZWFkZXItc2NoZWR1bGUpXG4gKi9cblxuY29uc3QgR2V0TGVhZGVyU2NoZWR1bGVSZXN1bHQgPSByZWNvcmQoc3RyaW5nKCksIGFycmF5KG51bWJlcigpKSk7XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gZXJyb3Igb3IgbnVsbFxuICovXG5jb25zdCBUcmFuc2FjdGlvbkVycm9yUmVzdWx0ID0gbnVsbGFibGUodW5pb24oW3R5cGUoe30pLCBzdHJpbmcoKV0pKTtcblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzIGZvciBhIHRyYW5zYWN0aW9uXG4gKi9cbmNvbnN0IFNpZ25hdHVyZVN0YXR1c1Jlc3VsdCA9IHR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHRcbn0pO1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSByZWNlaXZlZCBub3RpZmljYXRpb25cbiAqL1xuY29uc3QgU2lnbmF0dXJlUmVjZWl2ZWRSZXN1bHQgPSBsaXRlcmFsKCdyZWNlaXZlZFNpZ25hdHVyZScpO1xuXG4vKipcbiAqIFZlcnNpb24gaW5mbyBmb3IgYSBub2RlXG4gKi9cblxuY29uc3QgVmVyc2lvblJlc3VsdCA9IHR5cGUoe1xuICAnc29sYW5hLWNvcmUnOiBzdHJpbmcoKSxcbiAgJ2ZlYXR1cmUtc2V0Jzogb3B0aW9uYWwobnVtYmVyKCkpXG59KTtcbmNvbnN0IFBhcnNlZEluc3RydWN0aW9uU3RydWN0ID0gdHlwZSh7XG4gIHByb2dyYW06IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIHBhcnNlZDogdW5rbm93bigpXG59KTtcbmNvbnN0IFBhcnRpYWxseURlY29kZWRJbnN0cnVjdGlvblN0cnVjdCA9IHR5cGUoe1xuICBwcm9ncmFtSWQ6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnRzOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSxcbiAgZGF0YTogc3RyaW5nKClcbn0pO1xuY29uc3QgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBlcnI6IG51bGxhYmxlKHVuaW9uKFt0eXBlKHt9KSwgc3RyaW5nKCldKSksXG4gIGxvZ3M6IG51bGxhYmxlKGFycmF5KHN0cmluZygpKSksXG4gIGFjY291bnRzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShudWxsYWJsZSh0eXBlKHtcbiAgICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gICAgb3duZXI6IHN0cmluZygpLFxuICAgIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgICBkYXRhOiBhcnJheShzdHJpbmcoKSksXG4gICAgcmVudEVwb2NoOiBvcHRpb25hbChudW1iZXIoKSlcbiAgfSkpKSkpLFxuICB1bml0c0NvbnN1bWVkOiBvcHRpb25hbChudW1iZXIoKSksXG4gIHJldHVybkRhdGE6IG9wdGlvbmFsKG51bGxhYmxlKHR5cGUoe1xuICAgIHByb2dyYW1JZDogc3RyaW5nKCksXG4gICAgZGF0YTogdHVwbGUoW3N0cmluZygpLCBsaXRlcmFsKCdiYXNlNjQnKV0pXG4gIH0pKSksXG4gIGlubmVySW5zdHJ1Y3Rpb25zOiBvcHRpb25hbChudWxsYWJsZShhcnJheSh0eXBlKHtcbiAgICBpbmRleDogbnVtYmVyKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheSh1bmlvbihbUGFyc2VkSW5zdHJ1Y3Rpb25TdHJ1Y3QsIFBhcnRpYWxseURlY29kZWRJbnN0cnVjdGlvblN0cnVjdF0pKVxuICB9KSkpKVxufSkpO1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIHBhcnNlZCBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgUGFyc2VkVHJhbnNhY3Rpb25NZXRhfSBpbnN0ZWFkLlxuICovXG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBhZGRyZXNzZXMgbG9hZGVkIGJ5IGEgdHJhbnNhY3Rpb24gdXNpbmcgYWRkcmVzcyB0YWJsZSBsb29rdXBzXG4gKi9cblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBwYXJzZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICovXG5cbi8qKlxuICogTWV0YWRhdGEgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2UgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC5cbiAqL1xuXG4vKipcbiAqIEEgcGFydGlhbGx5IGRlY29kZWQgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2UgYWNjb3VudFxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIGFkZHJlc3MgdGFibGUgbG9va3VwXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBtZXNzYWdlXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvblxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgYW5kIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBQYXJzZWRUcmFuc2FjdGlvbldpdGhNZXRhfSBpbnN0ZWFkLlxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlciB3aXRoIG1ldGFcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBhY2NvdW50c2BcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9ucyB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9ucyB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBhY2NvdW50c2BcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEEgY29uZmlybWVkIGJsb2NrIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuXG4gKi9cblxuLyoqXG4gKiBBIEJsb2NrIG9uIHRoZSBsZWRnZXIgd2l0aCBzaWduYXR1cmVzIG9ubHlcbiAqL1xuXG4vKipcbiAqIHJlY2VudCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tQcm9kdWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBieUlkZW50aXR5OiByZWNvcmQoc3RyaW5nKCksIGFycmF5KG51bWJlcigpKSksXG4gIHJhbmdlOiB0eXBlKHtcbiAgICBmaXJzdFNsb3Q6IG51bWJlcigpLFxuICAgIGxhc3RTbG90OiBudW1iZXIoKVxuICB9KVxufSkpO1xuXG4vKipcbiAqIEEgcGVyZm9ybWFuY2Ugc2FtcGxlXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUnBjQ2xpZW50KHVybCwgaHR0cEhlYWRlcnMsIGN1c3RvbUZldGNoLCBmZXRjaE1pZGRsZXdhcmUsIGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0LCBodHRwQWdlbnQpIHtcbiAgY29uc3QgZmV0Y2ggPSBjdXN0b21GZXRjaCA/IGN1c3RvbUZldGNoIDogZmV0Y2hJbXBsO1xuICBsZXQgYWdlbnQ7XG4gIHtcbiAgICBpZiAoaHR0cEFnZW50ID09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgY29uc3QgYWdlbnRPcHRpb25zID0ge1xuICAgICAgICAgIC8vIE9uZSBzZWNvbmQgZmV3ZXIgdGhhbiB0aGUgU29sYW5hIFJQQydzIGtlZXBhbGl2ZSB0aW1lb3V0LlxuICAgICAgICAgIC8vIFJlYWQgbW9yZTogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMjc4NTkjaXNzdWVjb21tZW50LTEzNDAwOTc4ODlcbiAgICAgICAgICBmcmVlU29ja2V0VGltZW91dDogMTkwMDAsXG4gICAgICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAgICAgIG1heFNvY2tldHM6IDI1XG4gICAgICAgIH07XG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaHR0cHM6JykpIHtcbiAgICAgICAgICBhZ2VudCA9IG5ldyBhZ2VudGtlZXBhbGl2ZUV4cG9ydHMuSHR0cHNBZ2VudChhZ2VudE9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFnZW50ID0gbmV3IEh0dHBLZWVwQWxpdmVBZ2VudChhZ2VudE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChodHRwQWdlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGlzSHR0cHMgPSB1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Jyk7XG4gICAgICAgIGlmIChpc0h0dHBzICYmICEoaHR0cEFnZW50IGluc3RhbmNlb2YgQWdlbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZW5kcG9pbnQgYCcgKyB1cmwgKyAnYCBjYW4gb25seSBiZSBwYWlyZWQgd2l0aCBhbiBgaHR0cHMuQWdlbnRgLiBZb3UgaGF2ZSwgaW5zdGVhZCwgc3VwcGxpZWQgYW4gJyArICdgaHR0cC5BZ2VudGAgdGhyb3VnaCBgaHR0cEFnZW50YC4nKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNIdHRwcyAmJiBodHRwQWdlbnQgaW5zdGFuY2VvZiBBZ2VudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGVuZHBvaW50IGAnICsgdXJsICsgJ2AgY2FuIG9ubHkgYmUgcGFpcmVkIHdpdGggYW4gYGh0dHAuQWdlbnRgLiBZb3UgaGF2ZSwgaW5zdGVhZCwgc3VwcGxpZWQgYW4gJyArICdgaHR0cHMuQWdlbnRgIHRocm91Z2ggYGh0dHBBZ2VudGAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWdlbnQgPSBodHRwQWdlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBmZXRjaFdpdGhNaWRkbGV3YXJlO1xuICBpZiAoZmV0Y2hNaWRkbGV3YXJlKSB7XG4gICAgZmV0Y2hXaXRoTWlkZGxld2FyZSA9IGFzeW5jIChpbmZvLCBpbml0KSA9PiB7XG4gICAgICBjb25zdCBtb2RpZmllZEZldGNoQXJncyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmZXRjaE1pZGRsZXdhcmUoaW5mbywgaW5pdCwgKG1vZGlmaWVkSW5mbywgbW9kaWZpZWRJbml0KSA9PiByZXNvbHZlKFttb2RpZmllZEluZm8sIG1vZGlmaWVkSW5pdF0pKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhd2FpdCBmZXRjaCguLi5tb2RpZmllZEZldGNoQXJncyk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBjbGllbnRCcm93c2VyID0gbmV3IFJwY0NsaWVudChhc3luYyAocmVxdWVzdCwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiByZXF1ZXN0LFxuICAgICAgYWdlbnQsXG4gICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfSwgaHR0cEhlYWRlcnMgfHwge30sIENPTU1PTl9IVFRQX0hFQURFUlMpXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgbGV0IHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgPSA1O1xuICAgICAgbGV0IHJlcztcbiAgICAgIGxldCB3YWl0VGltZSA9IDUwMDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKGZldGNoV2l0aE1pZGRsZXdhcmUpIHtcbiAgICAgICAgICByZXMgPSBhd2FpdCBmZXRjaFdpdGhNaWRkbGV3YXJlKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gYXdhaXQgZmV0Y2godXJsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzLnN0YXR1cyAhPT0gNDI5IC8qIFRvbyBtYW55IHJlcXVlc3RzICovKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0ID09PSB0cnVlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyAtPSAxO1xuICAgICAgICBpZiAodG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFNlcnZlciByZXNwb25kZWQgd2l0aCAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9LiAgUmV0cnlpbmcgYWZ0ZXIgJHt3YWl0VGltZX1tcyBkZWxheS4uLmApO1xuICAgICAgICBhd2FpdCBzbGVlcCh3YWl0VGltZSk7XG4gICAgICAgIHdhaXRUaW1lICo9IDI7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH06ICR7dGV4dH1gKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICB9LCB7fSk7XG4gIHJldHVybiBjbGllbnRCcm93c2VyO1xufVxuZnVuY3Rpb24gY3JlYXRlUnBjUmVxdWVzdChjbGllbnQpIHtcbiAgcmV0dXJuIChtZXRob2QsIGFyZ3MpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY2xpZW50LnJlcXVlc3QobWV0aG9kLCBhcmdzLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVScGNCYXRjaFJlcXVlc3QoY2xpZW50KSB7XG4gIHJldHVybiByZXF1ZXN0cyA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIERvIG5vdGhpbmcgaWYgcmVxdWVzdHMgaXMgZW1wdHlcbiAgICAgIGlmIChyZXF1ZXN0cy5sZW5ndGggPT09IDApIHJlc29sdmUoW10pO1xuICAgICAgY29uc3QgYmF0Y2ggPSByZXF1ZXN0cy5tYXAocGFyYW1zID0+IHtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5yZXF1ZXN0KHBhcmFtcy5tZXRob2ROYW1lLCBwYXJhbXMuYXJncyk7XG4gICAgICB9KTtcbiAgICAgIGNsaWVudC5yZXF1ZXN0KGJhdGNoLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvbkdvdmVybm9yXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRJbmZsYXRpb25Hb3Zlcm5vclJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0SW5mbGF0aW9uR292ZXJub3JSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25SYXRlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRJbmZsYXRpb25SYXRlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEVwb2NoSW5mb1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0RXBvY2hJbmZvUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRFcG9jaEluZm9SZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRFcG9jaFNjaGVkdWxlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRFcG9jaFNjaGVkdWxlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRFcG9jaFNjaGVkdWxlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGVhZGVyU2NoZWR1bGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcIm1pbmltdW1MZWRnZXJTbG90XCIgYW5kIFwiZ2V0Rmlyc3RBdmFpbGFibGVCbG9ja1wiIG1lc3NhZ2VzXG4gKi9cbmNvbnN0IFNsb3RScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bWJlcigpKTtcblxuLyoqXG4gKiBTdXBwbHlcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRTdXBwbHlcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFN1cHBseVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICB0b3RhbDogbnVtYmVyKCksXG4gIGNpcmN1bGF0aW5nOiBudW1iZXIoKSxcbiAgbm9uQ2lyY3VsYXRpbmc6IG51bWJlcigpLFxuICBub25DaXJjdWxhdGluZ0FjY291bnRzOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKVxufSkpO1xuXG4vKipcbiAqIFRva2VuIGFtb3VudCBvYmplY3Qgd2hpY2ggcmV0dXJucyBhIHRva2VuIGFtb3VudCBpbiBkaWZmZXJlbnQgZm9ybWF0c1xuICogZm9yIHZhcmlvdXMgY2xpZW50IHVzZSBjYXNlcy5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHN0cnVjdHVyZSBmb3IgdG9rZW4gYW1vdW50c1xuICovXG5jb25zdCBUb2tlbkFtb3VudFJlc3VsdCA9IHR5cGUoe1xuICBhbW91bnQ6IHN0cmluZygpLFxuICB1aUFtb3VudDogbnVsbGFibGUobnVtYmVyKCkpLFxuICBkZWNpbWFsczogbnVtYmVyKCksXG4gIHVpQW1vdW50U3RyaW5nOiBvcHRpb25hbChzdHJpbmcoKSlcbn0pO1xuXG4vKipcbiAqIFRva2VuIGFkZHJlc3MgYW5kIGJhbGFuY2UuXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFRva2VuTGFyZ2VzdEFjY291bnRzUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIGFkZHJlc3M6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFtb3VudDogc3RyaW5nKCksXG4gIHVpQW1vdW50OiBudWxsYWJsZShudW1iZXIoKSksXG4gIGRlY2ltYWxzOiBudW1iZXIoKSxcbiAgdWlBbW91bnRTdHJpbmc6IG9wdGlvbmFsKHN0cmluZygpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VG9rZW5BY2NvdW50c0J5T3duZXJcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFRva2VuQWNjb3VudHNCeU93bmVyID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogdHlwZSh7XG4gICAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICAgIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICAgIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgICBkYXRhOiBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEsXG4gICAgcmVudEVwb2NoOiBudW1iZXIoKVxuICB9KVxufSkpKTtcbmNvbnN0IFBhcnNlZEFjY291bnREYXRhUmVzdWx0ID0gdHlwZSh7XG4gIHByb2dyYW06IHN0cmluZygpLFxuICBwYXJzZWQ6IHVua25vd24oKSxcbiAgc3BhY2U6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VG9rZW5BY2NvdW50c0J5T3duZXJcIiBtZXNzYWdlIHdpdGggcGFyc2VkIGRhdGFcbiAqL1xuY29uc3QgR2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiB0eXBlKHtcbiAgICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gICAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gICAgbGFtcG9ydHM6IG51bWJlcigpLFxuICAgIGRhdGE6IFBhcnNlZEFjY291bnREYXRhUmVzdWx0LFxuICAgIHJlbnRFcG9jaDogbnVtYmVyKClcbiAgfSlcbn0pKSk7XG5cbi8qKlxuICogUGFpciBvZiBhbiBhY2NvdW50IGFkZHJlc3MgYW5kIGl0cyBiYWxhbmNlXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGFyZ2VzdEFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMYXJnZXN0QWNjb3VudHNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBhZGRyZXNzOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KSkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIGRhdGE6IEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSxcbiAgcmVudEVwb2NoOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEtleWVkQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiBBY2NvdW50SW5mb1Jlc3VsdFxufSk7XG5jb25zdCBQYXJzZWRPclJhd0FjY291bnREYXRhID0gY29lcmNlKHVuaW9uKFtpbnN0YW5jZShCdWZmZXIpLCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdF0pLCB1bmlvbihbUmF3QWNjb3VudERhdGFSZXN1bHQsIFBhcnNlZEFjY291bnREYXRhUmVzdWx0XSksIHZhbHVlID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgQnVmZmVyRnJvbVJhd0FjY291bnREYXRhKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIGRhdGE6IFBhcnNlZE9yUmF3QWNjb3VudERhdGEsXG4gIHJlbnRFcG9jaDogbnVtYmVyKClcbn0pO1xuY29uc3QgS2V5ZWRQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IFBhcnNlZEFjY291bnRJbmZvUmVzdWx0XG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU3Rha2VBY3RpdmF0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN0YXRlOiB1bmlvbihbbGl0ZXJhbCgnYWN0aXZlJyksIGxpdGVyYWwoJ2luYWN0aXZlJyksIGxpdGVyYWwoJ2FjdGl2YXRpbmcnKSwgbGl0ZXJhbCgnZGVhY3RpdmF0aW5nJyldKSxcbiAgYWN0aXZlOiBudW1iZXIoKSxcbiAgaW5hY3RpdmU6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyXCIgbWVzc2FnZVxuICovXG5cbmNvbnN0IEdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkodHlwZSh7XG4gIHNpZ25hdHVyZTogc3RyaW5nKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIG1lbW86IG51bGxhYmxlKHN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRTaWduYXR1cmVzRm9yQWRkcmVzc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KGFycmF5KHR5cGUoe1xuICBzaWduYXR1cmU6IHN0cmluZygpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBtZW1vOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSkpKTtcblxuLyoqKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImFjY291bnROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEFjY291bnROb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KEFjY291bnRJbmZvUmVzdWx0KVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IEFjY291bnRJbmZvUmVzdWx0XG59KTtcblxuLyoqKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInByb2dyYW1Ob3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dChQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU2xvdEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcGFyZW50OiBudW1iZXIoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHJvb3Q6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2xvdE5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2xvdE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IFNsb3RJbmZvUmVzdWx0XG59KTtcblxuLyoqXG4gKiBTbG90IHVwZGF0ZXMgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBsaXZlIHByb2dyZXNzIG9mIGEgY2x1c3Rlci5cbiAqIC0gYFwiZmlyc3RTaHJlZFJlY2VpdmVkXCJgOiBjb25uZWN0ZWQgbm9kZSByZWNlaXZlZCB0aGUgZmlyc3Qgc2hyZWQgb2YgYSBibG9jay5cbiAqIEluZGljYXRlcyB0aGF0IGEgbmV3IGJsb2NrIHRoYXQgaXMgYmVpbmcgcHJvZHVjZWQuXG4gKiAtIGBcImNvbXBsZXRlZFwiYDogY29ubmVjdGVkIG5vZGUgaGFzIHJlY2VpdmVkIGFsbCBzaHJlZHMgb2YgYSBibG9jay4gSW5kaWNhdGVzXG4gKiBhIGJsb2NrIHdhcyByZWNlbnRseSBwcm9kdWNlZC5cbiAqIC0gYFwib3B0aW1pc3RpY0NvbmZpcm1hdGlvblwiYDogYmxvY2sgd2FzIG9wdGltaXN0aWNhbGx5IGNvbmZpcm1lZCBieSB0aGVcbiAqIGNsdXN0ZXIuIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRoYXQgYW4gb3B0aW1pc3RpYyBjb25maXJtYXRpb24gbm90aWZpY2F0aW9uXG4gKiB3aWxsIGJlIHNlbnQgZm9yIGV2ZXJ5IGZpbmFsaXplZCBibG9ja3MuXG4gKiAtIGBcInJvb3RcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSByb290ZWQgdGhpcyBibG9jay5cbiAqIC0gYFwiY3JlYXRlZEJhbmtcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSBoYXMgc3RhcnRlZCB2YWxpZGF0aW5nIHRoaXMgYmxvY2suXG4gKiAtIGBcImZyb3plblwiYDogdGhlIGNvbm5lY3RlZCBub2RlIGhhcyB2YWxpZGF0ZWQgdGhpcyBibG9jay5cbiAqIC0gYFwiZGVhZFwiYDogdGhlIGNvbm5lY3RlZCBub2RlIGZhaWxlZCB0byB2YWxpZGF0ZSB0aGlzIGJsb2NrLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNsb3RVcGRhdGVSZXN1bHQgPSB1bmlvbihbdHlwZSh7XG4gIHR5cGU6IHVuaW9uKFtsaXRlcmFsKCdmaXJzdFNocmVkUmVjZWl2ZWQnKSwgbGl0ZXJhbCgnY29tcGxldGVkJyksIGxpdGVyYWwoJ29wdGltaXN0aWNDb25maXJtYXRpb24nKSwgbGl0ZXJhbCgncm9vdCcpXSksXG4gIHNsb3Q6IG51bWJlcigpLFxuICB0aW1lc3RhbXA6IG51bWJlcigpXG59KSwgdHlwZSh7XG4gIHR5cGU6IGxpdGVyYWwoJ2NyZWF0ZWRCYW5rJyksXG4gIHBhcmVudDogbnVtYmVyKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICB0aW1lc3RhbXA6IG51bWJlcigpXG59KSwgdHlwZSh7XG4gIHR5cGU6IGxpdGVyYWwoJ2Zyb3plbicpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKSxcbiAgc3RhdHM6IHR5cGUoe1xuICAgIG51bVRyYW5zYWN0aW9uRW50cmllczogbnVtYmVyKCksXG4gICAgbnVtU3VjY2Vzc2Z1bFRyYW5zYWN0aW9uczogbnVtYmVyKCksXG4gICAgbnVtRmFpbGVkVHJhbnNhY3Rpb25zOiBudW1iZXIoKSxcbiAgICBtYXhUcmFuc2FjdGlvbnNQZXJFbnRyeTogbnVtYmVyKClcbiAgfSlcbn0pLCB0eXBlKHtcbiAgdHlwZTogbGl0ZXJhbCgnZGVhZCcpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKSxcbiAgZXJyOiBzdHJpbmcoKVxufSldKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2xvdHNVcGRhdGVzTm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTbG90VXBkYXRlTm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogU2xvdFVwZGF0ZVJlc3VsdFxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNpZ25hdHVyZU5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dCh1bmlvbihbU2lnbmF0dXJlU3RhdHVzUmVzdWx0LCBTaWduYXR1cmVSZWNlaXZlZFJlc3VsdF0pKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInJvb3ROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFJvb3ROb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBudW1iZXIoKVxufSk7XG5jb25zdCBDb250YWN0SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IHN0cmluZygpLFxuICBnb3NzaXA6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgdHB1OiBudWxsYWJsZShzdHJpbmcoKSksXG4gIHJwYzogbnVsbGFibGUoc3RyaW5nKCkpLFxuICB2ZXJzaW9uOiBudWxsYWJsZShzdHJpbmcoKSlcbn0pO1xuY29uc3QgVm90ZUFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHZvdGVQdWJrZXk6IHN0cmluZygpLFxuICBub2RlUHVia2V5OiBzdHJpbmcoKSxcbiAgYWN0aXZhdGVkU3Rha2U6IG51bWJlcigpLFxuICBlcG9jaFZvdGVBY2NvdW50OiBib29sZWFuKCksXG4gIGVwb2NoQ3JlZGl0czogYXJyYXkodHVwbGUoW251bWJlcigpLCBudW1iZXIoKSwgbnVtYmVyKCldKSksXG4gIGNvbW1pc3Npb246IG51bWJlcigpLFxuICBsYXN0Vm90ZTogbnVtYmVyKCksXG4gIHJvb3RTbG90OiBudWxsYWJsZShudW1iZXIoKSlcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRWb3RlQWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFZvdGVBY2NvdW50cyA9IGpzb25ScGNSZXN1bHQodHlwZSh7XG4gIGN1cnJlbnQ6IGFycmF5KFZvdGVBY2NvdW50SW5mb1Jlc3VsdCksXG4gIGRlbGlucXVlbnQ6IGFycmF5KFZvdGVBY2NvdW50SW5mb1Jlc3VsdClcbn0pKTtcbmNvbnN0IENvbmZpcm1hdGlvblN0YXR1cyA9IHVuaW9uKFtsaXRlcmFsKCdwcm9jZXNzZWQnKSwgbGl0ZXJhbCgnY29uZmlybWVkJyksIGxpdGVyYWwoJ2ZpbmFsaXplZCcpXSk7XG5jb25zdCBTaWduYXR1cmVTdGF0dXNSZXNwb25zZSA9IHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgY29uZmlybWF0aW9uczogbnVsbGFibGUobnVtYmVyKCkpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGNvbmZpcm1hdGlvblN0YXR1czogb3B0aW9uYWwoQ29uZmlybWF0aW9uU3RhdHVzKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFNpZ25hdHVyZVN0YXR1c2VzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KG51bGxhYmxlKFNpZ25hdHVyZVN0YXR1c1Jlc3BvbnNlKSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVtYmVyKCkpO1xuY29uc3QgQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0ID0gdHlwZSh7XG4gIGFjY291bnRLZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIHdyaXRhYmxlSW5kZXhlczogYXJyYXkobnVtYmVyKCkpLFxuICByZWFkb25seUluZGV4ZXM6IGFycmF5KG51bWJlcigpKVxufSk7XG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSksXG4gIG1lc3NhZ2U6IHR5cGUoe1xuICAgIGFjY291bnRLZXlzOiBhcnJheShzdHJpbmcoKSksXG4gICAgaGVhZGVyOiB0eXBlKHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogbnVtYmVyKCksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBudW1iZXIoKSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogbnVtYmVyKClcbiAgICB9KSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgICAgYWNjb3VudHM6IGFycmF5KG51bWJlcigpKSxcbiAgICAgIGRhdGE6IHN0cmluZygpLFxuICAgICAgcHJvZ3JhbUlkSW5kZXg6IG51bWJlcigpXG4gICAgfSkpLFxuICAgIHJlY2VudEJsb2NraGFzaDogc3RyaW5nKCksXG4gICAgYWRkcmVzc1RhYmxlTG9va3Vwczogb3B0aW9uYWwoYXJyYXkoQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0KSlcbiAgfSlcbn0pO1xuY29uc3QgQW5ub3RhdGVkQWNjb3VudEtleSA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIHNpZ25lcjogYm9vbGVhbigpLFxuICB3cml0YWJsZTogYm9vbGVhbigpLFxuICBzb3VyY2U6IG9wdGlvbmFsKHVuaW9uKFtsaXRlcmFsKCd0cmFuc2FjdGlvbicpLCBsaXRlcmFsKCdsb29rdXBUYWJsZScpXSkpXG59KTtcbmNvbnN0IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0ID0gdHlwZSh7XG4gIGFjY291bnRLZXlzOiBhcnJheShBbm5vdGF0ZWRBY2NvdW50S2V5KSxcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpXG59KTtcbmNvbnN0IFBhcnNlZEluc3RydWN0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHBhcnNlZDogdW5rbm93bigpLFxuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KTtcbmNvbnN0IFJhd0luc3RydWN0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIGFjY291bnRzOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSxcbiAgZGF0YTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZ1xufSk7XG5jb25zdCBJbnN0cnVjdGlvblJlc3VsdCA9IHVuaW9uKFtSYXdJbnN0cnVjdGlvblJlc3VsdCwgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHRdKTtcbmNvbnN0IFVua25vd25JbnN0cnVjdGlvblJlc3VsdCA9IHVuaW9uKFt0eXBlKHtcbiAgcGFyc2VkOiB1bmtub3duKCksXG4gIHByb2dyYW06IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IHN0cmluZygpXG59KSwgdHlwZSh7XG4gIGFjY291bnRzOiBhcnJheShzdHJpbmcoKSksXG4gIGRhdGE6IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IHN0cmluZygpXG59KV0pO1xuY29uc3QgUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiA9IGNvZXJjZShJbnN0cnVjdGlvblJlc3VsdCwgVW5rbm93bkluc3RydWN0aW9uUmVzdWx0LCB2YWx1ZSA9PiB7XG4gIGlmICgnYWNjb3VudHMnIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgUmF3SW5zdHJ1Y3Rpb25SZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIFBhcnNlZEluc3RydWN0aW9uUmVzdWx0KTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKSxcbiAgbWVzc2FnZTogdHlwZSh7XG4gICAgYWNjb3VudEtleXM6IGFycmF5KEFubm90YXRlZEFjY291bnRLZXkpLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkoUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiksXG4gICAgcmVjZW50QmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QpKSlcbiAgfSlcbn0pO1xuY29uc3QgVG9rZW5CYWxhbmNlUmVzdWx0ID0gdHlwZSh7XG4gIGFjY291bnRJbmRleDogbnVtYmVyKCksXG4gIG1pbnQ6IHN0cmluZygpLFxuICBvd25lcjogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICBwcm9ncmFtSWQ6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAgdWlUb2tlbkFtb3VudDogVG9rZW5BbW91bnRSZXN1bHRcbn0pO1xuY29uc3QgTG9hZGVkQWRkcmVzc2VzUmVzdWx0ID0gdHlwZSh7XG4gIHdyaXRhYmxlOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSxcbiAgcmVhZG9ubHk6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgZmVlOiBudW1iZXIoKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHR5cGUoe1xuICAgIGluZGV4OiBudW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgICAgYWNjb3VudHM6IGFycmF5KG51bWJlcigpKSxcbiAgICAgIGRhdGE6IHN0cmluZygpLFxuICAgICAgcHJvZ3JhbUlkSW5kZXg6IG51bWJlcigpXG4gICAgfSkpXG4gIH0pKSkpLFxuICBwcmVCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBwb3N0QmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgbG9nTWVzc2FnZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHN0cmluZygpKSkpLFxuICBwcmVUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIHBvc3RUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIGxvYWRlZEFkZHJlc3Nlczogb3B0aW9uYWwoTG9hZGVkQWRkcmVzc2VzUmVzdWx0KSxcbiAgY29tcHV0ZVVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgY29zdFVuaXRzOiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQgPSB0eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBmZWU6IG51bWJlcigpLFxuICBpbm5lckluc3RydWN0aW9uczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkodHlwZSh7XG4gICAgaW5kZXg6IG51bWJlcigpLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkoUGFyc2VkT3JSYXdJbnN0cnVjdGlvbilcbiAgfSkpKSksXG4gIHByZUJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIHBvc3RCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBsb2dNZXNzYWdlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSksXG4gIHByZVRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgcG9zdFRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgbG9hZGVkQWRkcmVzc2VzOiBvcHRpb25hbChMb2FkZWRBZGRyZXNzZXNSZXN1bHQpLFxuICBjb21wdXRlVW5pdHNDb25zdW1lZDogb3B0aW9uYWwobnVtYmVyKCkpLFxuICBjb3N0VW5pdHM6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG5jb25zdCBUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QgPSB1bmlvbihbbGl0ZXJhbCgwKSwgbGl0ZXJhbCgnbGVnYWN5JyldKTtcblxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgUmV3YXJkc1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IHN0cmluZygpLFxuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIHBvc3RCYWxhbmNlOiBudWxsYWJsZShudW1iZXIoKSksXG4gIHJld2FyZFR5cGU6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgY29tbWlzc2lvbjogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG5jb25zdCBHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYGFjY291bnRzYFxuICovXG5jb25zdCBHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBhY2NvdW50c2BcbiAqL1xuY29uc3QgR2V0UGFyc2VkQWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG5jb25zdCBHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Q29uZmlybWVkQmxvY2tcIiBtZXNzYWdlXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBHZXRCbG9ja1JwY1Jlc3VsdH0gaW5zdGVhZC5cbiAqL1xuY29uc3QgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSksXG4gIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbjogUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gIG1ldGE6IG51bGxhYmxlKFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKSxcbiAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGF0ZXN0QmxvY2toYXNoXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IG51bWJlcigpXG59KSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImlzQmxvY2toYXNoVmFsaWRcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IElzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChib29sZWFuKCkpO1xuY29uc3QgUGVyZlNhbXBsZVJlc3VsdCA9IHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgbnVtVHJhbnNhY3Rpb25zOiBudW1iZXIoKSxcbiAgbnVtU2xvdHM6IG51bWJlcigpLFxuICBzYW1wbGVQZXJpb2RTZWNzOiBudW1iZXIoKVxufSk7XG5cbi8qXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgXCJnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkoUGVyZlNhbXBsZVJlc3VsdCkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRGZWVDYWxjdWxhdG9yUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUodHlwZSh7XG4gIGZlZUNhbGN1bGF0b3I6IHR5cGUoe1xuICAgIGxhbXBvcnRzUGVyU2lnbmF0dXJlOiBudW1iZXIoKVxuICB9KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicmVxdWVzdEFpcmRyb3BcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFJlcXVlc3RBaXJkcm9wUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdHJpbmcoKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNlbmRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdHJpbmcoKSk7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIGxhdGVzdCBzbG90IGJlaW5nIHByb2Nlc3NlZCBieSBhIG5vZGVcbiAqL1xuXG4vKipcbiAqIFBhcnNlZCBhY2NvdW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIFN0YWtlIEFjdGl2YXRpb24gZGF0YVxuICovXG5cbi8qKlxuICogRGF0YSBzbGljZSBhcmd1bWVudCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBNZW1vcnkgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogRGF0YSBzaXplIGNvbXBhcmlzb24gZmlsdGVyIGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIEEgZmlsdGVyIG9iamVjdCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzIHJlcXVlc3RzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0TXVsdGlwbGVBY2NvdW50c1xuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXROb25jZWBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0Tm9uY2VBbmRDb250ZXh0YFxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhbiBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBY2NvdW50IGluZm9ybWF0aW9uIGlkZW50aWZpZWQgYnkgcHVia2V5XG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHByb2dyYW0gYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNsb3QgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzbG90IHVwZGF0ZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2lnbmF0dXJlIHN0YXR1cyBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzIG5vdGlmaWNhdGlvbiB3aXRoIHRyYW5zYWN0aW9uIHJlc3VsdFxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHJlY2VpdmVkIG5vdGlmaWNhdGlvblxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNpZ25hdHVyZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3Vic2NyaXB0aW9uIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciByb290IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTG9nc1Jlc3VsdCA9IHR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGxvZ3M6IGFycmF5KHN0cmluZygpKSxcbiAgc2lnbmF0dXJlOiBzdHJpbmcoKVxufSk7XG5cbi8qKlxuICogTG9ncyByZXN1bHQuXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwibG9nc05vdGlmaWNhdGlvblwiIG1lc3NhZ2UuXG4gKi9cbmNvbnN0IExvZ3NOb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KExvZ3NSZXN1bHQpLFxuICBzdWJzY3JpcHRpb246IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBGaWx0ZXIgZm9yIGxvZyBzdWJzY3JpcHRpb25zLlxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGxvZyBub3RpZmljYXRpb25zLlxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHJlc3VsdFxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gZXJyb3JcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdGF0dXNcbiAqIDxwcmU+XG4gKiAgICdwcm9jZXNzZWQnOiBUcmFuc2FjdGlvbiBsYW5kZWQgaW4gYSBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY29ubmVjdGVkIG5vZGVcbiAqICAgJ2NvbmZpcm1lZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjbHVzdGVyXG4gKiAgICdmaW5hbGl6ZWQnOiBUcmFuc2FjdGlvbiBsYW5kZWQgaW4gYSBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHN0YXR1c1xuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgc2lnbmF0dXJlIHdpdGggaXRzIHN0YXR1c1xuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IGRlZmluaW5nIGhlYWRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBSUEMgc2VydmVyXG4gKi9cblxuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgSmF2YVNjcmlwdCBgZmV0Y2goKWAgQVBJXG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIHVzZWQgdG8gYXVnbWVudCB0aGUgb3V0Z29pbmcgSFRUUCByZXF1ZXN0XG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBpbnN0YW50aWF0aW5nIGEgQ29ubmVjdGlvblxuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IENPTU1PTl9IVFRQX0hFQURFUlMgPSB7XG4gICdzb2xhbmEtY2xpZW50JzogYGpzLyR7XCIxLjAuMC1tYWludGVuYW5jZVwifWBcbn07XG5cbi8qKlxuICogQSBjb25uZWN0aW9uIHRvIGEgZnVsbG5vZGUgSlNPTiBSUEMgZW5kcG9pbnRcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbiB7XG4gIC8qKlxuICAgKiBFc3RhYmxpc2ggYSBKU09OIFJQQyBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBlbmRwb2ludCBVUkwgdG8gdGhlIGZ1bGxub2RlIEpTT04gUlBDIGVuZHBvaW50XG4gICAqIEBwYXJhbSBjb21taXRtZW50T3JDb25maWcgb3B0aW9uYWwgZGVmYXVsdCBjb21taXRtZW50IGxldmVsIG9yIG9wdGlvbmFsIENvbm5lY3Rpb25Db25maWcgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVuZHBvaW50LCBfY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2NvbW1pdG1lbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNFbmRwb2ludCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV3NFbmRwb2ludCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjQ2xpZW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNCYXRjaFJlcXVlc3QgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAvKiogQGludGVybmFsXG4gICAgICogQSBudW1iZXIgdGhhdCB3ZSBpbmNyZW1lbnQgZXZlcnkgdGltZSBhbiBhY3RpdmUgY29ubmVjdGlvbiBjbG9zZXMuXG4gICAgICogVXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc2FtZSBzb2NrZXQgY29ubmVjdGlvbiB0aGF0IHdhcyBvcGVuXG4gICAgICogd2hlbiBhbiBhc3luYyBvcGVyYXRpb24gc3RhcnRlZCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzIGFjdGl2ZSB3aGVuXG4gICAgICogaXRzIGNvbnRpbnVhdGlvbiBmaXJlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZyA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wb2xsaW5nQmxvY2toYXNoID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2Jsb2NraGFzaEluZm8gPSB7XG4gICAgICBsYXRlc3RCbG9ja2hhc2g6IG51bGwsXG4gICAgICBsYXN0RmV0Y2g6IDAsXG4gICAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IFtdLFxuICAgICAgc2ltdWxhdGVkU2lnbmF0dXJlczogW11cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkID0ge307XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2ggPSB7fTtcbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICogQWZ0ZXIgYSBzaWduYXR1cmUgaXMgcHJvY2Vzc2VkLCBSUENzIGF1dG9tYXRpY2FsbHkgZGlzcG9zZSBvZiB0aGVcbiAgICAgKiBzdWJzY3JpcHRpb24gb24gdGhlIHNlcnZlciBzaWRlLiBXZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9mIHRoZXNlXG4gICAgICogc3Vic2NyaXB0aW9ucyBoYXZlIGJlZW4gZGlzcG9zZWQgaW4gc3VjaCBhIHdheSwgc28gdGhhdCB3ZSBrbm93XG4gICAgICogd2hldGhlciB0aGUgY2xpZW50IGlzIGRlYWxpbmcgd2l0aCBhIG5vdC15ZXQtcHJvY2Vzc2VkIHNpZ25hdHVyZVxuICAgICAqIChpbiB3aGljaCBjYXNlIHdlIG11c3QgdGVhciBkb3duIHRoZSBzZXJ2ZXIgc3Vic2NyaXB0aW9uKSBvciBhblxuICAgICAqIGFscmVhZHktcHJvY2Vzc2VkIHNpZ25hdHVyZSAoaW4gd2hpY2ggY2FzZSB0aGUgY2xpZW50IGNhbiBzaW1wbHlcbiAgICAgKiBjbGVhciBvdXQgdGhlIHN1YnNjcmlwdGlvbiBsb2NhbGx5IHdpdGhvdXQgdGVsbGluZyB0aGUgc2VydmVyKS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZXJlIGlzIGEgcHJvcG9zYWwgdG8gZWxpbWluYXRlIHRoaXMgc3BlY2lhbCBjYXNlLCBoZXJlOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzE4ODkyXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYyA9IG5ldyBTZXQoKTtcbiAgICAvKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmxvY2sgaGVpZ2h0IG9mIHRoZSBub2RlXG4gICAgICovXG4gICAgdGhpcy5nZXRCbG9ja0hlaWdodCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSB7fTtcbiAgICAgIHJldHVybiBhc3luYyBjb21taXRtZW50T3JDb25maWcgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29tbWl0bWVudCxcbiAgICAgICAgICBjb25maWdcbiAgICAgICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RIYXNoID0gZmFzdFN0YWJsZVN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXSA9IHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF0gPz8gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tIZWlnaHQnLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2sgaGVpZ2h0IGluZm9ybWF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF07XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXTtcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICBsZXQgd3NFbmRwb2ludDtcbiAgICBsZXQgaHR0cEhlYWRlcnM7XG4gICAgbGV0IGZldGNoO1xuICAgIGxldCBmZXRjaE1pZGRsZXdhcmU7XG4gICAgbGV0IGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0O1xuICAgIGxldCBodHRwQWdlbnQ7XG4gICAgaWYgKF9jb21taXRtZW50T3JDb25maWcgJiYgdHlwZW9mIF9jb21taXRtZW50T3JDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9jb21taXRtZW50ID0gX2NvbW1pdG1lbnRPckNvbmZpZztcbiAgICB9IGVsc2UgaWYgKF9jb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLmNvbW1pdG1lbnQ7XG4gICAgICB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCA9IF9jb21taXRtZW50T3JDb25maWcuY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQ7XG4gICAgICB3c0VuZHBvaW50ID0gX2NvbW1pdG1lbnRPckNvbmZpZy53c0VuZHBvaW50O1xuICAgICAgaHR0cEhlYWRlcnMgPSBfY29tbWl0bWVudE9yQ29uZmlnLmh0dHBIZWFkZXJzO1xuICAgICAgZmV0Y2ggPSBfY29tbWl0bWVudE9yQ29uZmlnLmZldGNoO1xuICAgICAgZmV0Y2hNaWRkbGV3YXJlID0gX2NvbW1pdG1lbnRPckNvbmZpZy5mZXRjaE1pZGRsZXdhcmU7XG4gICAgICBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCA9IF9jb21taXRtZW50T3JDb25maWcuZGlzYWJsZVJldHJ5T25SYXRlTGltaXQ7XG4gICAgICBodHRwQWdlbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLmh0dHBBZ2VudDtcbiAgICB9XG4gICAgdGhpcy5fcnBjRW5kcG9pbnQgPSBhc3NlcnRFbmRwb2ludFVybChlbmRwb2ludCk7XG4gICAgdGhpcy5fcnBjV3NFbmRwb2ludCA9IHdzRW5kcG9pbnQgfHwgbWFrZVdlYnNvY2tldFVybChlbmRwb2ludCk7XG4gICAgdGhpcy5fcnBjQ2xpZW50ID0gY3JlYXRlUnBjQ2xpZW50KGVuZHBvaW50LCBodHRwSGVhZGVycywgZmV0Y2gsIGZldGNoTWlkZGxld2FyZSwgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQsIGh0dHBBZ2VudCk7XG4gICAgdGhpcy5fcnBjUmVxdWVzdCA9IGNyZWF0ZVJwY1JlcXVlc3QodGhpcy5fcnBjQ2xpZW50KTtcbiAgICB0aGlzLl9ycGNCYXRjaFJlcXVlc3QgPSBjcmVhdGVScGNCYXRjaFJlcXVlc3QodGhpcy5fcnBjQ2xpZW50KTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQgPSBuZXcgUnBjV2ViU29ja2V0Q2xpZW50KHRoaXMuX3JwY1dzRW5kcG9pbnQsIHtcbiAgICAgIGF1dG9jb25uZWN0OiBmYWxzZSxcbiAgICAgIG1heF9yZWNvbm5lY3RzOiBJbmZpbml0eVxuICAgIH0pO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignb3BlbicsIHRoaXMuX3dzT25PcGVuLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignZXJyb3InLCB0aGlzLl93c09uRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdjbG9zZScsIHRoaXMuX3dzT25DbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2FjY291bnROb3RpZmljYXRpb24nLCB0aGlzLl93c09uQWNjb3VudE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Byb2dyYW1Ob3RpZmljYXRpb24nLCB0aGlzLl93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzbG90Tm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblNsb3ROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzbG90c1VwZGF0ZXNOb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzaWduYXR1cmVOb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbigncm9vdE5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Sb290Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignbG9nc05vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Mb2dzTm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGNvbW1pdG1lbnQgdXNlZCBmb3IgcmVxdWVzdHNcbiAgICovXG4gIGdldCBjb21taXRtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jb21taXRtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBSUEMgZW5kcG9pbnRcbiAgICovXG4gIGdldCBycGNFbmRwb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcnBjRW5kcG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGJhbGFuY2UgZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleSwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0QmFsYW5jZUFuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCYWxhbmNlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBiYWxhbmNlIGZvciAke3B1YmxpY0tleS50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgYmFsYW5jZSBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRCYWxhbmNlKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmFsYW5jZUFuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpLnRoZW4oeCA9PiB4LnZhbHVlKS5jYXRjaChlID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCBiYWxhbmNlIG9mIGFjY291bnQgJyArIHB1YmxpY0tleS50b0Jhc2U1OCgpICsgJzogJyArIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBlc3RpbWF0ZWQgcHJvZHVjdGlvbiB0aW1lIG9mIGEgYmxvY2tcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrVGltZShzbG90KSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tUaW1lJywgW3Nsb3RdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bGxhYmxlKG51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGJsb2NrIHRpbWUgZm9yIHNsb3QgJHtzbG90fWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbG93ZXN0IHNsb3QgdGhhdCB0aGUgbm9kZSBoYXMgaW5mb3JtYXRpb24gYWJvdXQgaW4gaXRzIGxlZGdlci5cbiAgICogVGhpcyB2YWx1ZSBtYXkgaW5jcmVhc2Ugb3ZlciB0aW1lIGlmIHRoZSBub2RlIGlzIGNvbmZpZ3VyZWQgdG8gcHVyZ2Ugb2xkZXIgbGVkZ2VyIGRhdGFcbiAgICovXG4gIGFzeW5jIGdldE1pbmltdW1MZWRnZXJTbG90KCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ21pbmltdW1MZWRnZXJTbG90JywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBtaW5pbXVtIGxlZGdlciBzbG90Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBzbG90IG9mIHRoZSBsb3dlc3QgY29uZmlybWVkIGJsb2NrIHRoYXQgaGFzIG5vdCBiZWVuIHB1cmdlZCBmcm9tIHRoZSBsZWRnZXJcbiAgICovXG4gIGFzeW5jIGdldEZpcnN0QXZhaWxhYmxlQmxvY2soKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaycsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTbG90UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmaXJzdCBhdmFpbGFibGUgYmxvY2snKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgc3VwcGx5XG4gICAqL1xuICBhc3luYyBnZXRTdXBwbHkoY29uZmlnKSB7XG4gICAgbGV0IGNvbmZpZ0FyZyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnQXJnID0ge1xuICAgICAgICBjb21taXRtZW50OiBjb25maWdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjb25maWcpIHtcbiAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBjb21taXRtZW50OiBjb25maWcgJiYgY29uZmlnLmNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWdBcmcgPSB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IHRoaXMuY29tbWl0bWVudFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U3VwcGx5JywgW2NvbmZpZ0FyZ10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFN1cHBseVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc3VwcGx5Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN1cHBseSBvZiBhIHRva2VuIG1pbnRcbiAgICovXG4gIGFzeW5jIGdldFRva2VuU3VwcGx5KHRva2VuTWludEFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0b2tlbk1pbnRBZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlblN1cHBseScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFRva2VuQW1vdW50UmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gc3VwcGx5Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IGJhbGFuY2Ugb2YgYSB0b2tlbiBhY2NvdW50XG4gICAqL1xuICBhc3luYyBnZXRUb2tlbkFjY291bnRCYWxhbmNlKHRva2VuQWRkcmVzcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Rva2VuQWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50QmFsYW5jZScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFRva2VuQW1vdW50UmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudCBiYWxhbmNlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEdldFByb2dyYW1BY2NvdW50c1Jlc3BvbnNlPn1cbiAgICovXG4gIGFzeW5jIGdldFRva2VuQWNjb3VudHNCeU93bmVyKG93bmVyQWRkcmVzcywgZmlsdGVyLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGxldCBfYXJncyA9IFtvd25lckFkZHJlc3MudG9CYXNlNTgoKV07XG4gICAgaWYgKCdtaW50JyBpbiBmaWx0ZXIpIHtcbiAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICBtaW50OiBmaWx0ZXIubWludC50b0Jhc2U1OCgpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZDogZmlsdGVyLnByb2dyYW1JZC50b0Jhc2U1OCgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhfYXJncywgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50c0J5T3duZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUb2tlbkFjY291bnRzQnlPd25lcik7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgYWNjb3VudCAke293bmVyQWRkcmVzcy50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88UGFyc2VkQWNjb3VudERhdGE+fT4+Pn1cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyKG93bmVyQWRkcmVzcywgZmlsdGVyLCBjb21taXRtZW50KSB7XG4gICAgbGV0IF9hcmdzID0gW293bmVyQWRkcmVzcy50b0Jhc2U1OCgpXTtcbiAgICBpZiAoJ21pbnQnIGluIGZpbHRlcikge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIG1pbnQ6IGZpbHRlci5taW50LnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkOiBmaWx0ZXIucHJvZ3JhbUlkLnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKF9hcmdzLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuQWNjb3VudHNCeU93bmVyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IHRva2VuIGFjY291bnRzIG93bmVkIGJ5IGFjY291bnQgJHtvd25lckFkZHJlc3MudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIDIwIGxhcmdlc3QgYWNjb3VudHMgd2l0aCB0aGVpciBjdXJyZW50IGJhbGFuY2VzXG4gICAqL1xuICBhc3luYyBnZXRMYXJnZXN0QWNjb3VudHMoY29uZmlnKSB7XG4gICAgY29uc3QgYXJnID0ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgY29tbWl0bWVudDogY29uZmlnICYmIGNvbmZpZy5jb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudFxuICAgIH07XG4gICAgY29uc3QgYXJncyA9IGFyZy5maWx0ZXIgfHwgYXJnLmNvbW1pdG1lbnQgPyBbYXJnXSA6IFtdO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldExhcmdlc3RBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGFyZ2VzdCBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgMjAgbGFyZ2VzdCB0b2tlbiBhY2NvdW50cyB3aXRoIHRoZWlyIGN1cnJlbnQgYmFsYW5jZXNcbiAgICogZm9yIGEgZ2l2ZW4gbWludC5cbiAgICovXG4gIGFzeW5jIGdldFRva2VuTGFyZ2VzdEFjY291bnRzKG1pbnRBZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbbWludEFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuTGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRva2VuIGxhcmdlc3QgYWNjb3VudHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleSwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEFjY291bnRJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUoQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQWNjb3VudEluZm8ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEFjY291bnRJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUoUGFyc2VkQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGFzeW5jIGdldEFjY291bnRJbmZvKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IGluZm8gYWJvdXQgYWNjb3VudCAnICsgcHVibGljS2V5LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXMsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlUGFyc2VkQWNjb3VudHMocHVibGljS2V5cywgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBrZXlzID0gcHVibGljS2V5cy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtrZXlzXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldE11bHRpcGxlQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheShudWxsYWJsZShQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBmb3IgYWNjb3VudHMgJHtrZXlzfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgbXVsdGlwbGUgYWNjb3VudHMgc3BlY2lmaWVkIGJ5IGFuIGFycmF5IG9mIHB1YmxpYyBrZXlzLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBrZXlzID0gcHVibGljS2V5cy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtrZXlzXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TXVsdGlwbGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KG51bGxhYmxlKEFjY291bnRJbmZvUmVzdWx0KSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGZvciBhY2NvdW50cyAke2tleXN9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXNcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlQWNjb3VudHNJbmZvKHB1YmxpY0tleXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0KHB1YmxpY0tleXMsIGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVwb2NoIGFjdGl2YXRpb24gaW5mb3JtYXRpb24gZm9yIGEgc3Rha2UgYWNjb3VudCB0aGF0IGhhcyBiZWVuIGRlbGVnYXRlZFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS4xODsgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gICAqL1xuICBhc3luYyBnZXRTdGFrZUFjdGl2YXRpb24ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcsIGVwb2NoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgZXBvY2g6IGVwb2NoICE9IG51bGwgPyBlcG9jaCA6IGNvbmZpZz8uZXBvY2hcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdGFrZUFjdGl2YXRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KFN0YWtlQWN0aXZhdGlvblJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IFN0YWtlIEFjdGl2YXRpb24gJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIHByb2dyYW0gaWRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTx7cHVia2V5OiBQdWJsaWNLZXksIGFjY291bnQ6IEFjY291bnRJbmZvPEJ1ZmZlcj59Pj59XG4gICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFByb2dyYW1BY2NvdW50cyhwcm9ncmFtSWQsIGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZ09yQ29tbWl0bWVudCk7XG4gICAgY29uc3Qge1xuICAgICAgZW5jb2RpbmcsXG4gICAgICAuLi5jb25maWdXaXRob3V0RW5jb2RpbmdcbiAgICB9ID0gY29uZmlnIHx8IHt9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgZW5jb2RpbmcgfHwgJ2Jhc2U2NCcsIHtcbiAgICAgIC4uLmNvbmZpZ1dpdGhvdXRFbmNvZGluZyxcbiAgICAgIC4uLihjb25maWdXaXRob3V0RW5jb2RpbmcuZmlsdGVycyA/IHtcbiAgICAgICAgZmlsdGVyczogYXBwbHlEZWZhdWx0TWVtY21wRW5jb2RpbmdUb0ZpbHRlcnMoY29uZmlnV2l0aG91dEVuY29kaW5nLmZpbHRlcnMpXG4gICAgICB9IDogbnVsbClcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRQcm9ncmFtQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCBiYXNlU2NoZW1hID0gYXJyYXkoS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCk7XG4gICAgY29uc3QgcmVzID0gY29uZmlnV2l0aG91dEVuY29kaW5nLndpdGhDb250ZXh0ID09PSB0cnVlID8gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYmFzZVNjaGVtYSkpIDogY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChiYXNlU2NoZW1hKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYWNjb3VudHMgb3duZWQgYnkgcHJvZ3JhbSAke3Byb2dyYW1JZC50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbmQgcGFyc2UgYWxsIHRoZSBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIHByb2dyYW0gaWRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTx7cHVia2V5OiBQdWJsaWNLZXksIGFjY291bnQ6IEFjY291bnRJbmZvPEJ1ZmZlciB8IFBhcnNlZEFjY291bnREYXRhPn0+Pn1cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFByb2dyYW1BY2NvdW50cyhwcm9ncmFtSWQsIGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZ09yQ29tbWl0bWVudCk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHJvZ3JhbUlkLnRvQmFzZTU4KCldLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UHJvZ3JhbUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChhcnJheShLZXllZFBhcnNlZEFjY291bnRJbmZvUmVzdWx0KSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGFjY291bnRzIG93bmVkIGJ5IHByb2dyYW0gJHtwcm9ncmFtSWQudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgY29uZmlybVRyYW5zYWN0aW9uYCBhbmQgcGFzcyBpbiB7QGxpbmsgVHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneX0gKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uKHN0cmF0ZWd5LCBjb21taXRtZW50KSB7XG4gICAgbGV0IHJhd1NpZ25hdHVyZTtcbiAgICBpZiAodHlwZW9mIHN0cmF0ZWd5ID09ICdzdHJpbmcnKSB7XG4gICAgICByYXdTaWduYXR1cmUgPSBzdHJhdGVneTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29uZmlnID0gc3RyYXRlZ3k7XG4gICAgICBpZiAoY29uZmlnLmFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb25maWcuYWJvcnRTaWduYWwucmVhc29uKTtcbiAgICAgIH1cbiAgICAgIHJhd1NpZ25hdHVyZSA9IGNvbmZpZy5zaWduYXR1cmU7XG4gICAgfVxuICAgIGxldCBkZWNvZGVkU2lnbmF0dXJlO1xuICAgIHRyeSB7XG4gICAgICBkZWNvZGVkU2lnbmF0dXJlID0gYnM1OC5kZWNvZGUocmF3U2lnbmF0dXJlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbmF0dXJlIG11c3QgYmUgYmFzZTU4IGVuY29kZWQ6ICcgKyByYXdTaWduYXR1cmUpO1xuICAgIH1cbiAgICBhc3NlcnQoZGVjb2RlZFNpZ25hdHVyZS5sZW5ndGggPT09IDY0LCAnc2lnbmF0dXJlIGhhcyBpbnZhbGlkIGxlbmd0aCcpO1xuICAgIGlmICh0eXBlb2Ygc3RyYXRlZ3kgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSh7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50LFxuICAgICAgICBzaWduYXR1cmU6IHJhd1NpZ25hdHVyZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgnbGFzdFZhbGlkQmxvY2tIZWlnaHQnIGluIHN0cmF0ZWd5KSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0Jsb2NrSGVpZ2h0RXhjZWVkYW5jZVN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29uZmlybVRyYW5zYWN0aW9uVXNpbmdEdXJhYmxlTm9uY2VTdHJhdGVneSh7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50LFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldENhbmNlbGxhdGlvblByb21pc2Uoc2lnbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmVqZWN0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgIHJlamVjdChzaWduYWwucmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICBjb21taXRtZW50LFxuICAgIHNpZ25hdHVyZVxuICB9KSB7XG4gICAgbGV0IHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkO1xuICAgIGxldCBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlcjtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IGNvbmZpcm1hdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9IHRoaXMub25TaWduYXR1cmUoc2lnbmF0dXJlLCAocmVzdWx0LCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCxcbiAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGNvbW1pdG1lbnQpO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TZXR1cFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXAgPT4ge1xuICAgICAgICAgIGlmIChzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXAoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIgPSB0aGlzLl9vblN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkLCBuZXh0U3RhdGUgPT4ge1xuICAgICAgICAgICAgICBpZiAobmV4dFN0YXRlID09PSAnc3Vic2NyaWJlZCcpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBzdWJzY3JpcHRpb25TZXR1cFByb21pc2U7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlPy5lcnIpIHtcbiAgICAgICAgICAgIHJlamVjdCh2YWx1ZS5lcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1pdG1lbnQpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlR29zc2lwJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAncHJvY2Vzc2VkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3Jvb3QnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jb25maXJtYXRpb25TdGF0dXMgPT09ICdwcm9jZXNzZWQnIHx8IHZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ2NvbmZpcm1lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBleGhhdXN0IGVudW1zIHRvIGVuc3VyZSBmdWxsIGNvdmVyYWdlXG4gICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3JlY2VudCc6XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBhYm9ydENvbmZpcm1hdGlvbiA9ICgpID0+IHtcbiAgICAgIGlmIChkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlcikge1xuICAgICAgICBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlcigpO1xuICAgICAgICBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYXR1cmVTdWJzY3JpcHRpb25JZCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbixcbiAgICAgIGNvbmZpcm1hdGlvblByb21pc2VcbiAgICB9O1xuICB9XG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc3RyYXRlZ3k6IHtcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQsXG4gICAgICBzaWduYXR1cmVcbiAgICB9XG4gIH0pIHtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IGV4cGlyeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IGNoZWNrQmxvY2tIZWlnaHQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgYmxvY2tIZWlnaHQgPSBhd2FpdCB0aGlzLmdldEJsb2NrSGVpZ2h0KGNvbW1pdG1lbnQpO1xuICAgICAgICAgIHJldHVybiBibG9ja0hlaWdodDtcbiAgICAgICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudEJsb2NrSGVpZ2h0ID0gYXdhaXQgY2hlY2tCbG9ja0hlaWdodCgpO1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAoY3VycmVudEJsb2NrSGVpZ2h0IDw9IGxhc3RWYWxpZEJsb2NrSGVpZ2h0KSB7XG4gICAgICAgICAgYXdhaXQgc2xlZXAoMTAwMCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBjdXJyZW50QmxvY2tIZWlnaHQgPSBhd2FpdCBjaGVja0Jsb2NrSGVpZ2h0KCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLkJMT0NLSEVJR0hUX0VYQ0VFREVEXG4gICAgICAgIH0pO1xuICAgICAgfSkoKTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbixcbiAgICAgIGNvbmZpcm1hdGlvblByb21pc2VcbiAgICB9ID0gdGhpcy5nZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0pO1xuICAgIGNvbnN0IGNhbmNlbGxhdGlvblByb21pc2UgPSB0aGlzLmdldENhbmNlbGxhdGlvblByb21pc2UoYWJvcnRTaWduYWwpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dGNvbWUgPSBhd2FpdCBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvblByb21pc2UsIGNvbmZpcm1hdGlvblByb21pc2UsIGV4cGlyeVByb21pc2VdKTtcbiAgICAgIGlmIChvdXRjb21lLl9fdHlwZSA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VEKSB7XG4gICAgICAgIHJlc3VsdCA9IG91dGNvbWUucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgYWJvcnRDb25maXJtYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5KHtcbiAgICBjb21taXRtZW50LFxuICAgIHN0cmF0ZWd5OiB7XG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIG1pbkNvbnRleHRTbG90LFxuICAgICAgbm9uY2VBY2NvdW50UHVia2V5LFxuICAgICAgbm9uY2VWYWx1ZSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH1cbiAgfSkge1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IGN1cnJlbnROb25jZVZhbHVlID0gbm9uY2VWYWx1ZTtcbiAgICAgIGxldCBsYXN0Q2hlY2tlZFNsb3QgPSBudWxsO1xuICAgICAgY29uc3QgZ2V0Q3VycmVudE5vbmNlVmFsdWUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiBub25jZUFjY291bnRcbiAgICAgICAgICB9ID0gYXdhaXQgdGhpcy5nZXROb25jZUFuZENvbnRleHQobm9uY2VBY2NvdW50UHVia2V5LCB7XG4gICAgICAgICAgICBjb21taXRtZW50LFxuICAgICAgICAgICAgbWluQ29udGV4dFNsb3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXN0Q2hlY2tlZFNsb3QgPSBjb250ZXh0LnNsb3Q7XG4gICAgICAgICAgcmV0dXJuIG5vbmNlQWNjb3VudD8ubm9uY2U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBJZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHdlIGNhbid0IHJlYWNoL3JlYWQgdGhlIG5vbmNlXG4gICAgICAgICAgLy8gYWNjb3VudCwganVzdCBrZWVwIHVzaW5nIHRoZSBsYXN0LWtub3duIHZhbHVlLlxuICAgICAgICAgIHJldHVybiBjdXJyZW50Tm9uY2VWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGN1cnJlbnROb25jZVZhbHVlID0gYXdhaXQgZ2V0Q3VycmVudE5vbmNlVmFsdWUoKTtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgd2hpbGUgKHRydWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKG5vbmNlVmFsdWUgIT09IGN1cnJlbnROb25jZVZhbHVlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5OT05DRV9JTlZBTElELFxuICAgICAgICAgICAgICBzbG90SW5XaGljaE5vbmNlRGlkQWR2YW5jZTogbGFzdENoZWNrZWRTbG90XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgc2xlZXAoMjAwMCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBjdXJyZW50Tm9uY2VWYWx1ZSA9IGF3YWl0IGdldEN1cnJlbnROb25jZVZhbHVlKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbixcbiAgICAgIGNvbmZpcm1hdGlvblByb21pc2VcbiAgICB9ID0gdGhpcy5nZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0pO1xuICAgIGNvbnN0IGNhbmNlbGxhdGlvblByb21pc2UgPSB0aGlzLmdldENhbmNlbGxhdGlvblByb21pc2UoYWJvcnRTaWduYWwpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dGNvbWUgPSBhd2FpdCBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvblByb21pc2UsIGNvbmZpcm1hdGlvblByb21pc2UsIGV4cGlyeVByb21pc2VdKTtcbiAgICAgIGlmIChvdXRjb21lLl9fdHlwZSA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VEKSB7XG4gICAgICAgIHJlc3VsdCA9IG91dGNvbWUucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEb3VibGUgY2hlY2sgdGhhdCB0aGUgdHJhbnNhY3Rpb24gaXMgaW5kZWVkIHVuY29uZmlybWVkLlxuICAgICAgICBsZXQgc2lnbmF0dXJlU3RhdHVzO1xuICAgICAgICB3aGlsZSAodHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCB0aGlzLmdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUpO1xuICAgICAgICAgIGlmIChzdGF0dXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0dXMuY29udGV4dC5zbG90IDwgKG91dGNvbWUuc2xvdEluV2hpY2hOb25jZURpZEFkdmFuY2UgPz8gbWluQ29udGV4dFNsb3QpKSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcCg0MDApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpZ25hdHVyZVN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnbmF0dXJlU3RhdHVzPy52YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IGNvbW1pdG1lbnRGb3JTdGF0dXMgPSBjb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbmZpcm1hdGlvblN0YXR1c1xuICAgICAgICAgIH0gPSBzaWduYXR1cmVTdGF0dXMudmFsdWU7XG4gICAgICAgICAgc3dpdGNoIChjb21taXRtZW50Rm9yU3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICAgICAgY2FzZSAncmVjZW50JzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ3Byb2Nlc3NlZCcgJiYgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnY29uZmlybWVkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdmaW5hbGl6ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZUdvc3NpcCc6XG4gICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25TdGF0dXMgIT09ICdjb25maXJtZWQnICYmIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgY2FzZSAncm9vdCc6XG4gICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25TdGF0dXMgIT09ICdmaW5hbGl6ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBFeGhhdXN0aXZlIHN3aXRjaC5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAoXyA9PiB7fSkoY29tbWl0bWVudEZvclN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IHNpZ25hdHVyZVN0YXR1cy5jb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgZXJyOiBzaWduYXR1cmVTdGF0dXMudmFsdWUuZXJyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc2lnbmF0dXJlXG4gIH0pIHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IGV4cGlyeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCB0aW1lb3V0TXMgPSB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCB8fCA2MCAqIDEwMDA7XG4gICAgICBzd2l0Y2ggKGNvbW1pdG1lbnQpIHtcbiAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgY2FzZSAncmVjZW50JzpcbiAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlR29zc2lwJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aW1lb3V0TXMgPSB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCB8fCAzMCAqIDEwMDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoe1xuICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLlRJTUVEX09VVCxcbiAgICAgICAgdGltZW91dE1zXG4gICAgICB9KSwgdGltZW91dE1zKTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbixcbiAgICAgIGNvbmZpcm1hdGlvblByb21pc2VcbiAgICB9ID0gdGhpcy5nZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0pO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dGNvbWUgPSBhd2FpdCBQcm9taXNlLnJhY2UoW2NvbmZpcm1hdGlvblByb21pc2UsIGV4cGlyeVByb21pc2VdKTtcbiAgICAgIGlmIChvdXRjb21lLl9fdHlwZSA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VEKSB7XG4gICAgICAgIHJlc3VsdCA9IG91dGNvbWUucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yKHNpZ25hdHVyZSwgb3V0Y29tZS50aW1lb3V0TXMgLyAxMDAwKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSBjdXJyZW50bHkgcGFydGljaXBhdGluZyBpbiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0Q2x1c3Rlck5vZGVzKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENsdXN0ZXJOb2RlcycsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KENvbnRhY3RJbmZvUmVzdWx0KSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNsdXN0ZXIgbm9kZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRWb3RlQWNjb3VudHMoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFZvdGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFZvdGVBY2NvdW50cyk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdm90ZSBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzbG90IHRoYXQgdGhlIG5vZGUgaXMgcHJvY2Vzc2luZ1xuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90JywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc2xvdCBsZWFkZXIgb2YgdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldFNsb3RMZWFkZXIoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdExlYWRlcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoc3RyaW5nKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzbG90IGxlYWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBgbGltaXRgIG51bWJlciBvZiBzbG90IGxlYWRlcnMgc3RhcnRpbmcgZnJvbSBgc3RhcnRTbG90YFxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnRTbG90IGZldGNoIHNsb3QgbGVhZGVycyBzdGFydGluZyBmcm9tIHRoaXMgc2xvdFxuICAgKiBAcGFyYW0gbGltaXQgbnVtYmVyIG9mIHNsb3QgbGVhZGVycyB0byByZXR1cm5cbiAgICovXG4gIGFzeW5jIGdldFNsb3RMZWFkZXJzKHN0YXJ0U2xvdCwgbGltaXQpIHtcbiAgICBjb25zdCBhcmdzID0gW3N0YXJ0U2xvdCwgbGltaXRdO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNsb3RMZWFkZXJzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QgbGVhZGVycycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzdGF0dXMgb2YgYSBzaWduYXR1cmVcbiAgICovXG4gIGFzeW5jIGdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUsIGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogdmFsdWVzXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0U2lnbmF0dXJlU3RhdHVzZXMoW3NpZ25hdHVyZV0sIGNvbmZpZyk7XG4gICAgYXNzZXJ0KHZhbHVlcy5sZW5ndGggPT09IDEpO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN0YXR1c2VzIG9mIGEgYmF0Y2ggb2Ygc2lnbmF0dXJlc1xuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlU3RhdHVzZXMoc2lnbmF0dXJlcywgY29uZmlnKSB7XG4gICAgY29uc3QgcGFyYW1zID0gW3NpZ25hdHVyZXNdO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNpZ25hdHVyZVN0YXR1c2VzJywgcGFyYW1zKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2lnbmF0dXJlIHN0YXR1cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBjb3VudCBvZiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25Db3VudChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbkNvdW50JywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uIGNvdW50Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHRvdGFsIGN1cnJlbmN5IHN1cHBseSBvZiB0aGUgY2x1c3RlciBpbiBsYW1wb3J0c1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS4yLjguIFBsZWFzZSB1c2Uge0BsaW5rIGdldFN1cHBseX0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFRvdGFsU3VwcGx5KGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldFN1cHBseSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgZXhjbHVkZU5vbkNpcmN1bGF0aW5nQWNjb3VudHNMaXN0OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZS50b3RhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY2x1c3RlciBJbmZsYXRpb25Hb3Zlcm5vciBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25Hb3Zlcm5vcihjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uR292ZXJub3InLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25Hb3Zlcm5vclJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBpbmZsYXRpb24gcmV3YXJkIGZvciBhIGxpc3Qgb2YgYWRkcmVzc2VzIGZvciBhbiBlcG9jaFxuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbGF0aW9uUmV3YXJkKGFkZHJlc3NlcywgZXBvY2gsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbYWRkcmVzc2VzLm1hcChwdWJrZXkgPT4gcHVia2V5LnRvQmFzZTU4KCkpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBlcG9jaDogZXBvY2ggIT0gbnVsbCA/IGVwb2NoIDogY29uZmlnPy5lcG9jaFxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEluZmxhdGlvblJld2FyZCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvblJld2FyZFJlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uIHJld2FyZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgc3BlY2lmaWMgaW5mbGF0aW9uIHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgZXBvY2hcbiAgICovXG4gIGFzeW5jIGdldEluZmxhdGlvblJhdGUoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uUmF0ZScsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24gcmF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgRXBvY2ggSW5mbyBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRFcG9jaEluZm8oY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RXBvY2hJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RXBvY2hJbmZvUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBlcG9jaCBpbmZvJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBFcG9jaCBTY2hlZHVsZSBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRFcG9jaFNjaGVkdWxlKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEVwb2NoU2NoZWR1bGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZXBvY2ggc2NoZWR1bGUnKTtcbiAgICB9XG4gICAgY29uc3QgZXBvY2hTY2hlZHVsZSA9IHJlcy5yZXN1bHQ7XG4gICAgcmV0dXJuIG5ldyBFcG9jaFNjaGVkdWxlKGVwb2NoU2NoZWR1bGUuc2xvdHNQZXJFcG9jaCwgZXBvY2hTY2hlZHVsZS5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQsIGVwb2NoU2NoZWR1bGUud2FybXVwLCBlcG9jaFNjaGVkdWxlLmZpcnN0Tm9ybWFsRXBvY2gsIGVwb2NoU2NoZWR1bGUuZmlyc3ROb3JtYWxTbG90KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGVhZGVyIHNjaGVkdWxlIGZvciB0aGUgY3VycmVudCBlcG9jaFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxMZWFkZXJTY2hlZHVsZT4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0TGVhZGVyU2NoZWR1bGUoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGVhZGVyU2NoZWR1bGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGVhZGVyU2NoZWR1bGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGxlYWRlciBzY2hlZHVsZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbWluaW11bSBiYWxhbmNlIG5lZWRlZCB0byBleGVtcHQgYW4gYWNjb3VudCBvZiBgZGF0YUxlbmd0aGBcbiAgICogc2l6ZSBmcm9tIHJlbnRcbiAgICovXG4gIGFzeW5jIGdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbihkYXRhTGVuZ3RoLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbZGF0YUxlbmd0aF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBmZXRjaCBtaW5pbXVtIGJhbGFuY2UgZm9yIHJlbnQgZXhlbXB0aW9uJyk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSByZWNlbnQgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8e2Jsb2NraGFzaDogQmxvY2toYXNoLCBmZWVDYWxjdWxhdG9yOiBGZWVDYWxjdWxhdG9yfT4+fVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS45LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldExhdGVzdEJsb2NraGFzaH0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBibG9ja2hhc2hcbiAgICAgIH1cbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IGZlZUNhbGN1bGF0b3IgPSB7XG4gICAgICBnZXQgbGFtcG9ydHNQZXJTaWduYXR1cmUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNhcGFiaWxpdHkgdG8gZmV0Y2ggYGxhbXBvcnRzUGVyU2lnbmF0dXJlYCB1c2luZyB0aGUgYGdldFJlY2VudEJsb2NraGFzaGAgQVBJIGlzICcgKyAnbm8gbG9uZ2VyIG9mZmVyZWQgYnkgdGhlIG5ldHdvcmsuIFVzZSB0aGUgYGdldEZlZUZvck1lc3NhZ2VgIEFQSSB0byBvYnRhaW4gdGhlIGZlZSAnICsgJ2ZvciBhIGdpdmVuIG1lc3NhZ2UuJyk7XG4gICAgICB9LFxuICAgICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGJsb2NraGFzaCxcbiAgICAgICAgZmVlQ2FsY3VsYXRvclxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcmVjZW50IHBlcmZvcm1hbmNlIHNhbXBsZXNcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxQZXJmU2FtcGxlPj59XG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMobGltaXQpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMnLCBsaW1pdCA/IFtsaW1pdF0gOiBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCByZWNlbnQgcGVyZm9ybWFuY2Ugc2FtcGxlcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZmVlIGNhbGN1bGF0b3IgZm9yIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjkuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0RmVlRm9yTWVzc2FnZX0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2goYmxvY2toYXNoLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbYmxvY2toYXNoXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEZlZUNhbGN1bGF0b3JScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZlZSBjYWxjdWxhdG9yJyk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH0gPSByZXMucmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IHZhbHVlICE9PSBudWxsID8gdmFsdWUuZmVlQ2FsY3VsYXRvciA6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBmZWUgZm9yIGEgbWVzc2FnZSBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRGZWVGb3JNZXNzYWdlKG1lc3NhZ2UsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCB3aXJlTWVzc2FnZSA9IHRvQnVmZmVyKG1lc3NhZ2Uuc2VyaWFsaXplKCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt3aXJlTWVzc2FnZV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEZlZUZvck1lc3NhZ2UnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShudW1iZXIoKSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmZWUgZm9yIG1lc3NhZ2UnKTtcbiAgICB9XG4gICAgaWYgKHJlcy5yZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBibG9ja2hhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIHByaW9yaXRpemF0aW9uIGZlZXMgZnJvbSByZWNlbnQgYmxvY2tzLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzKGNvbmZpZykge1xuICAgIGNvbnN0IGFjY291bnRzID0gY29uZmlnPy5sb2NrZWRXcml0YWJsZUFjY291bnRzPy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gYWNjb3VudHM/Lmxlbmd0aCA/IFthY2NvdW50c10gOiBbXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBwcmlvcml0aXphdGlvbiBmZWVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHtibG9ja2hhc2g6IEJsb2NraGFzaCwgZmVlQ2FsY3VsYXRvcjogRmVlQ2FsY3VsYXRvcn0+fVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldExhdGVzdEJsb2NraGFzaH0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudEJsb2NraGFzaChjb21taXRtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50KTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2g6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGxhdGVzdCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodD59XG4gICAqL1xuICBhc3luYyBnZXRMYXRlc3RCbG9ja2hhc2goY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgcmVjZW50IGJsb2NraGFzaDogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGF0ZXN0IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0Pn1cbiAgICovXG4gIGFzeW5jIGdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGF0ZXN0QmxvY2toYXNoJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsYXRlc3QgYmxvY2toYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhIGJsb2NraGFzaCBpcyBzdGlsbCB2YWxpZCBvciBub3RcbiAgICovXG4gIGFzeW5jIGlzQmxvY2toYXNoVmFsaWQoYmxvY2toYXNoLCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2Jsb2NraGFzaF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdpc0Jsb2NraGFzaFZhbGlkJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGJsb2NraGFzaCBgJyArIGJsb2NraGFzaCArICdgaXMgdmFsaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIG5vZGUgdmVyc2lvblxuICAgKi9cbiAgYXN5bmMgZ2V0VmVyc2lvbigpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRWZXJzaW9uJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoVmVyc2lvblJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHZlcnNpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGdlbmVzaXMgaGFzaFxuICAgKi9cbiAgYXN5bmMgZ2V0R2VuZXNpc0hhc2goKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0R2VuZXNpc0hhc2gnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdHJpbmcoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGdlbmVzaXMgaGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0QmxvY2tgIHVzaW5nIGEgYEdldFZlcnNpb25lZEJsb2NrQ29uZmlnYCBieVxuICAgKiBzZXR0aW5nIHRoZSBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0QmxvY2tgIHVzaW5nIGEgYEdldFZlcnNpb25lZEJsb2NrQ29uZmlnYCBieVxuICAgKiBzZXR0aW5nIHRoZSBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9jZXNzZWQgYmxvY2sgZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRCbG9jayhzbG90LCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoY29uZmlnPy50cmFuc2FjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgY2FzZSAnYWNjb3VudHMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldE5vbmVNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIH0gPSByZXM7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogcmVzdWx0LnRyYW5zYWN0aW9ucy5tYXAoKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgICAgICAgfSkgPT4gKHtcbiAgICAgICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UodmVyc2lvbiwgdHJhbnNhY3Rpb24ubWVzc2FnZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihlLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCBibG9ja1xuICAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0UGFyc2VkQmxvY2soc2xvdCwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKGNvbmZpZz8udHJhbnNhY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgJ2FjY291bnRzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKGUsICdmYWlsZWQgdG8gZ2V0IGJsb2NrJyk7XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIFJldHVybnMgcmVjZW50IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb24gZnJvbSB0aGUgY3VycmVudCBvciBwcmV2aW91cyBlcG9jaFxuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tQcm9kdWN0aW9uKGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGxldCBleHRyYTtcbiAgICBsZXQgY29tbWl0bWVudDtcbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yQ29tbWl0bWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbW1pdG1lbnQgPSBjb25maWdPckNvbW1pdG1lbnQ7XG4gICAgfSBlbHNlIGlmIChjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29tbWl0bWVudDogYyxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfSA9IGNvbmZpZ09yQ29tbWl0bWVudDtcbiAgICAgIGNvbW1pdG1lbnQgPSBjO1xuICAgICAgZXh0cmEgPSByZXN0O1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCAnYmFzZTY0JywgZXh0cmEpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrUHJvZHVjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEJsb2NrUHJvZHVjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRUcmFuc2FjdGlvbmAgdXNpbmcgYVxuICAgKiBgR2V0VmVyc2lvbmVkVHJhbnNhY3Rpb25Db25maWdgIGJ5IHNldHRpbmcgdGhlXG4gICAqIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbihzaWduYXR1cmUsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAuLi5yZXN1bHQudHJhbnNhY3Rpb24sXG4gICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UocmVzdWx0LnZlcnNpb24sIHJlc3VsdC50cmFuc2FjdGlvbi5tZXNzYWdlKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zKHNpZ25hdHVyZXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChzaWduYXR1cmUgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0KGJhdGNoKTtcbiAgICBjb25zdCByZXMgPSB1bnNhZmVSZXMubWFwKHVuc2FmZVJlcyA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gYnV0IHJldHVybnMgYSB7QGxpbmsgVHJhbnNhY3Rpb25SZXNwb25zZX0uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldFRyYW5zYWN0aW9uc2AgdXNpbmcgYVxuICAgKiBgR2V0VmVyc2lvbmVkVHJhbnNhY3Rpb25Db25maWdgIGJ5IHNldHRpbmcgdGhlXG4gICAqIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cblxuICAvKipcbiAgICogRmV0Y2ggdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zLlxuICAgKiBTaW1pbGFyIHRvIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGJ1dCByZXR1cm5zIGEge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9uUmVzcG9uc2V9LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gYnV0IHJldHVybnMgYSB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb25SZXNwb25zZX0uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9ucyhzaWduYXR1cmVzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2ROYW1lOiAnZ2V0VHJhbnNhY3Rpb24nLFxuICAgICAgICBhcmdzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY0JhdGNoUmVxdWVzdChiYXRjaCk7XG4gICAgY29uc3QgcmVzID0gdW5zYWZlUmVzLm1hcCh1bnNhZmVSZXMgPT4ge1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAuLi5yZXN1bHQudHJhbnNhY3Rpb24sXG4gICAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZShyZXN1bHQudmVyc2lvbiwgcmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgVHJhbnNhY3Rpb25zIGFuZCB0cmFuc2FjdGlvbiBzdGF0dXNlcyBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIGZvciBhIGNvbmZpcm1lZCBibG9jay5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRCbG9ja30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZEJsb2NrKHNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpcm1lZCBibG9jayAnICsgc2xvdCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrID0ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb25zOiByZXN1bHQudHJhbnNhY3Rpb25zLm1hcCgoe1xuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IE1lc3NhZ2UodHJhbnNhY3Rpb24ubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWV0YSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5ibG9jayxcbiAgICAgIHRyYW5zYWN0aW9uczogYmxvY2sudHJhbnNhY3Rpb25zLm1hcCgoe1xuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLnBvcHVsYXRlKHRyYW5zYWN0aW9uLm1lc3NhZ2UsIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMpXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggY29uZmlybWVkIGJsb2NrcyBiZXR3ZWVuIHR3byBzbG90c1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tzKHN0YXJ0U2xvdCwgZW5kU2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKGVuZFNsb3QgIT09IHVuZGVmaW5lZCA/IFtzdGFydFNsb3QsIGVuZFNsb3RdIDogW3N0YXJ0U2xvdF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrcycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkobnVtYmVyKCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2tzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBTaWduYXR1cmVzIGZyb20gdGhlIGNsdXN0ZXIgZm9yIGEgYmxvY2ssIGV4Y2x1ZGluZyByZXdhcmRzXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja1NpZ25hdHVyZXMoc2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCB7XG4gICAgICB0cmFuc2FjdGlvbkRldGFpbHM6ICdzaWduYXR1cmVzJyxcbiAgICAgIHJld2FyZHM6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBTaWduYXR1cmVzIGZyb20gdGhlIGNsdXN0ZXIgZm9yIGEgY29uZmlybWVkIGJsb2NrLCBleGNsdWRpbmcgcmV3YXJkc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEJsb2NrU2lnbmF0dXJlc30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhzbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQsIHtcbiAgICAgIHRyYW5zYWN0aW9uRGV0YWlsczogJ3NpZ25hdHVyZXMnLFxuICAgICAgcmV3YXJkczogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlybWVkIGJsb2NrICcgKyBzbG90ICsgJyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0VHJhbnNhY3Rpb259IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRUcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICBjb25zdCBtZXNzYWdlID0gbmV3IE1lc3NhZ2UocmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSByZXN1bHQudHJhbnNhY3Rpb24uc2lnbmF0dXJlcztcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLnBvcHVsYXRlKG1lc3NhZ2UsIHNpZ25hdHVyZXMpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbn0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25zKHNpZ25hdHVyZXMsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBiYXRjaCA9IHNpZ25hdHVyZXMubWFwKHNpZ25hdHVyZSA9PiB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0KGJhdGNoKTtcbiAgICBjb25zdCByZXMgPSB1bnNhZmVSZXMubWFwKHVuc2FmZVJlcyA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW4gYWRkcmVzc1xuICAgKiB3aXRoaW4gYSBzcGVjaWZpZWQgc2xvdCByYW5nZS4gTWF4IHJhbmdlIGFsbG93ZWQgaXMgMTAsMDAwIHNsb3RzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS4zLiBQbGVhc2UgdXNlIHtAbGluayBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJ9IGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHF1ZXJpZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gc3RhcnRTbG90IHN0YXJ0IHNsb3QsIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0gZW5kU2xvdCBlbmQgc2xvdCwgaW5jbHVzaXZlXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzcyhhZGRyZXNzLCBzdGFydFNsb3QsIGVuZFNsb3QpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgIGxldCBmaXJzdEF2YWlsYWJsZUJsb2NrID0gYXdhaXQgdGhpcy5nZXRGaXJzdEF2YWlsYWJsZUJsb2NrKCk7XG4gICAgd2hpbGUgKCEoJ3VudGlsJyBpbiBvcHRpb25zKSkge1xuICAgICAgc3RhcnRTbG90LS07XG4gICAgICBpZiAoc3RhcnRTbG90IDw9IDAgfHwgc3RhcnRTbG90IDwgZmlyc3RBdmFpbGFibGVCbG9jaykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5nZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMoc3RhcnRTbG90LCAnZmluYWxpemVkJyk7XG4gICAgICAgIGlmIChibG9jay5zaWduYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvcHRpb25zLnVudGlsID0gYmxvY2suc2lnbmF0dXJlc1tibG9jay5zaWduYXR1cmVzLmxlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ3NraXBwZWQnKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaGlnaGVzdENvbmZpcm1lZFJvb3QgPSBhd2FpdCB0aGlzLmdldFNsb3QoJ2ZpbmFsaXplZCcpO1xuICAgIHdoaWxlICghKCdiZWZvcmUnIGluIG9wdGlvbnMpKSB7XG4gICAgICBlbmRTbG90Kys7XG4gICAgICBpZiAoZW5kU2xvdCA+IGhpZ2hlc3RDb25maXJtZWRSb290KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhlbmRTbG90KTtcbiAgICAgICAgaWYgKGJsb2NrLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9wdGlvbnMuYmVmb3JlID0gYmxvY2suc2lnbmF0dXJlc1tibG9jay5zaWduYXR1cmVzLmxlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ3NraXBwZWQnKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb25maXJtZWRTaWduYXR1cmVJbmZvID0gYXdhaXQgdGhpcy5nZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIoYWRkcmVzcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNvbmZpcm1lZFNpZ25hdHVyZUluZm8ubWFwKGluZm8gPT4gaW5mby5zaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW5cbiAgICogYWRkcmVzcyBiYWNrd2FyZHMgaW4gdGltZSBmcm9tIHRoZSBwcm92aWRlZCBzaWduYXR1cmUgb3IgbW9zdCByZWNlbnQgY29uZmlybWVkIGJsb2NrXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3N9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIoYWRkcmVzcywgb3B0aW9ucywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFthZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50LCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhblxuICAgKiBhZGRyZXNzIGJhY2t3YXJkcyBpbiB0aW1lIGZyb20gdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBvciBtb3N0IHJlY2VudCBjb25maXJtZWQgYmxvY2tcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVzRm9yQWRkcmVzcyhhZGRyZXNzLCBvcHRpb25zLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW2FkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2lnbmF0dXJlcyBmb3IgYWRkcmVzcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuICBhc3luYyBnZXRBZGRyZXNzTG9va3VwVGFibGUoYWNjb3VudEtleSwgY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiBhY2NvdW50SW5mb1xuICAgIH0gPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChhY2NvdW50S2V5LCBjb25maWcpO1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgaWYgKGFjY291bnRJbmZvICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50KHtcbiAgICAgICAga2V5OiBhY2NvdW50S2V5LFxuICAgICAgICBzdGF0ZTogQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudC5kZXNlcmlhbGl6ZShhY2NvdW50SW5mby5kYXRhKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjb250ZW50cyBvZiBhIE5vbmNlIGFjY291bnQgZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0Tm9uY2VBbmRDb250ZXh0KG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiBhY2NvdW50SW5mb1xuICAgIH0gPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoYWNjb3VudEluZm8gIT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gTm9uY2VBY2NvdW50LmZyb21BY2NvdW50RGF0YShhY2NvdW50SW5mby5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGNvbnRlbnRzIG9mIGEgTm9uY2UgYWNjb3VudCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXROb25jZShub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZykudGhlbih4ID0+IHgudmFsdWUpLmNhdGNoKGUgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IG5vbmNlIGZvciBhY2NvdW50ICcgKyBub25jZUFjY291bnQudG9CYXNlNTgoKSArICc6ICcgKyBlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IGFuIGFsbG9jYXRpb24gb2YgbGFtcG9ydHMgdG8gdGhlIHNwZWNpZmllZCBhZGRyZXNzXG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IHsgQ29ubmVjdGlvbiwgUHVibGljS2V5LCBMQU1QT1JUU19QRVJfU09MIH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuICAgKlxuICAgKiAoYXN5bmMgKCkgPT4ge1xuICAgKiAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihcImh0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbVwiLCBcImNvbmZpcm1lZFwiKTtcbiAgICogICBjb25zdCBteUFkZHJlc3MgPSBuZXcgUHVibGljS2V5KFwiMm5yMWJIRlQ4Nlc5dEdueXZtWVc0dmNIS3NRQjNzVlFmbmRkYXN6NGtFeE1cIik7XG4gICAqICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5yZXF1ZXN0QWlyZHJvcChteUFkZHJlc3MsIExBTVBPUlRTX1BFUl9TT0wpO1xuICAgKiAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSk7XG4gICAqIH0pKCk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdEFpcmRyb3AodG8sIGxhbXBvcnRzKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgncmVxdWVzdEFpcmRyb3AnLCBbdG8udG9CYXNlNTgoKSwgbGFtcG9ydHNdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBSZXF1ZXN0QWlyZHJvcFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGFpcmRyb3AgdG8gJHt0by50b0Jhc2U1OCgpfSBmYWlsZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSkge1xuICAgIGlmICghZGlzYWJsZUNhY2hlKSB7XG4gICAgICAvLyBXYWl0IGZvciBwb2xsaW5nIHRvIGZpbmlzaFxuICAgICAgd2hpbGUgKHRoaXMuX3BvbGxpbmdCbG9ja2hhc2gpIHtcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpbWVTaW5jZUZldGNoID0gRGF0ZS5ub3coKSAtIHRoaXMuX2Jsb2NraGFzaEluZm8ubGFzdEZldGNoO1xuICAgICAgY29uc3QgZXhwaXJlZCA9IHRpbWVTaW5jZUZldGNoID49IEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TO1xuICAgICAgaWYgKHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoICE9PSBudWxsICYmICFleHBpcmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3BvbGxOZXdCbG9ja2hhc2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF9wb2xsTmV3QmxvY2toYXNoKCkge1xuICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgY2FjaGVkTGF0ZXN0QmxvY2toYXNoID0gdGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2g7XG4gICAgICBjb25zdCBjYWNoZWRCbG9ja2hhc2ggPSBjYWNoZWRMYXRlc3RCbG9ja2hhc2ggPyBjYWNoZWRMYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoIDogbnVsbDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTA7IGkrKykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NraGFzaCgnZmluYWxpemVkJyk7XG4gICAgICAgIGlmIChjYWNoZWRCbG9ja2hhc2ggIT09IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2gpIHtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvID0ge1xuICAgICAgICAgICAgbGF0ZXN0QmxvY2toYXNoLFxuICAgICAgICAgICAgbGFzdEZldGNoOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25TaWduYXR1cmVzOiBbXSxcbiAgICAgICAgICAgIHNpbXVsYXRlZFNpZ25hdHVyZXM6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gbGF0ZXN0QmxvY2toYXNoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2xlZXAgZm9yIGFwcHJveGltYXRlbHkgaGFsZiBhIHNsb3RcbiAgICAgICAgYXdhaXQgc2xlZXAoTVNfUEVSX1NMT1QgLyAyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIG9idGFpbiBhIG5ldyBibG9ja2hhc2ggYWZ0ZXIgJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zYCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBzdGFrZSBtaW5pbXVtIGRlbGVnYXRpb25cbiAgICovXG4gIGFzeW5jIGdldFN0YWtlTWluaW11bURlbGVnYXRpb24oY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZzogY29uZmlnQXJnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBjb25maWdBcmcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFN0YWtlTWluaW11bURlbGVnYXRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IHN0YWtlIG1pbmltdW0gZGVsZWdhdGlvbmApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNpbXVsYXRlVHJhbnNhY3Rpb259IHdpdGgge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9ufSBhbmQge0BsaW5rIFNpbXVsYXRlVHJhbnNhY3Rpb25Db25maWd9IHBhcmFtZXRlcnNcbiAgICovXG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBzaW11bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uT3JNZXNzYWdlLCBjb25maWdPclNpZ25lcnMsIGluY2x1ZGVBY2NvdW50cykge1xuICAgIGlmICgnbWVzc2FnZScgaW4gdHJhbnNhY3Rpb25Pck1lc3NhZ2UpIHtcbiAgICAgIGNvbnN0IHZlcnNpb25lZFR4ID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2U7XG4gICAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB2ZXJzaW9uZWRUeC5zZXJpYWxpemUoKTtcbiAgICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IEJ1ZmZlci5mcm9tKHdpcmVUcmFuc2FjdGlvbikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnT3JTaWduZXJzKSB8fCBpbmNsdWRlQWNjb3VudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25maWcgPSBjb25maWdPclNpZ25lcnMgfHwge307XG4gICAgICBjb25maWcuZW5jb2RpbmcgPSAnYmFzZTY0JztcbiAgICAgIGlmICghKCdjb21taXRtZW50JyBpbiBjb25maWcpKSB7XG4gICAgICAgIGNvbmZpZy5jb21taXRtZW50ID0gdGhpcy5jb21taXRtZW50O1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZ09yU2lnbmVycyAmJiB0eXBlb2YgY29uZmlnT3JTaWduZXJzID09PSAnb2JqZWN0JyAmJiAnaW5uZXJJbnN0cnVjdGlvbnMnIGluIGNvbmZpZ09yU2lnbmVycykge1xuICAgICAgICBjb25maWcuaW5uZXJJbnN0cnVjdGlvbnMgPSBjb25maWdPclNpZ25lcnMuaW5uZXJJbnN0cnVjdGlvbnM7XG4gICAgICB9XG4gICAgICBjb25zdCBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NpbXVsYXRlVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFNpbXVsYXRlZFRyYW5zYWN0aW9uUmVzcG9uc2VTdHJ1Y3QpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNpbXVsYXRlIHRyYW5zYWN0aW9uOiAnICsgcmVzLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfVxuICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICBpZiAodHJhbnNhY3Rpb25Pck1lc3NhZ2UgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikge1xuICAgICAgbGV0IG9yaWdpbmFsVHggPSB0cmFuc2FjdGlvbk9yTWVzc2FnZTtcbiAgICAgIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IG9yaWdpbmFsVHguZmVlUGF5ZXI7XG4gICAgICB0cmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMgPSB0cmFuc2FjdGlvbk9yTWVzc2FnZS5pbnN0cnVjdGlvbnM7XG4gICAgICB0cmFuc2FjdGlvbi5ub25jZUluZm8gPSBvcmlnaW5hbFR4Lm5vbmNlSW5mbztcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMgPSBvcmlnaW5hbFR4LnNpZ25hdHVyZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb24ucG9wdWxhdGUodHJhbnNhY3Rpb25Pck1lc3NhZ2UpO1xuICAgICAgLy8gSEFDSzogdGhpcyBmdW5jdGlvbiByZWxpZXMgb24gbXV0YXRpbmcgdGhlIHBvcHVsYXRlZCB0cmFuc2FjdGlvblxuICAgICAgdHJhbnNhY3Rpb24uX21lc3NhZ2UgPSB0cmFuc2FjdGlvbi5fanNvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ09yU2lnbmVycyAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KGNvbmZpZ09yU2lnbmVycykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVycyA9IGNvbmZpZ09yU2lnbmVycztcbiAgICBpZiAodHJhbnNhY3Rpb24ubm9uY2VJbmZvICYmIHNpZ25lcnMpIHtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXNhYmxlQ2FjaGUgPSB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZztcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2toYXNoID0gYXdhaXQgdGhpcy5fYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGF0ZXN0QmxvY2toYXNoLmxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBsYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoO1xuICAgICAgICBpZiAoIXNpZ25lcnMpIGJyZWFrO1xuICAgICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLnNpZ25hdHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIXNpZ25hdHVyZScpOyAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdHJhbnNhY3Rpb24uc2lnbmF0dXJlLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ibG9ja2hhc2hJbmZvLnNpbXVsYXRlZFNpZ25hdHVyZXMuaW5jbHVkZXMoc2lnbmF0dXJlKSAmJiAhdGhpcy5fYmxvY2toYXNoSW5mby50cmFuc2FjdGlvblNpZ25hdHVyZXMuaW5jbHVkZXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2YgdGhpcyB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gc2VlbiBiZWZvcmUgd2l0aCB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IHJlY2VudEJsb2NraGFzaCwgYWxsIGRvbmUuIExldCdzIGJyZWFrXG4gICAgICAgICAgdGhpcy5fYmxvY2toYXNoSW5mby5zaW11bGF0ZWRTaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIHRyYW5zYWN0aW9uIHdvdWxkIGJlIHRyZWF0ZWQgYXMgZHVwbGljYXRlIChpdHMgZGVyaXZlZCBzaWduYXR1cmVcbiAgICAgICAgICAvLyBtYXRjaGVkIHRvIG9uZSBvZiBhbHJlYWR5IHJlY29yZGVkIHNpZ25hdHVyZXMpLlxuICAgICAgICAgIC8vIFNvLCB3ZSBtdXN0IGZldGNoIGEgbmV3IGJsb2NraGFzaCBmb3IgYSBkaWZmZXJlbnQgc2lnbmF0dXJlIGJ5IGRpc2FibGluZ1xuICAgICAgICAgIC8vIG91ciBjYWNoZSBub3QgdG8gd2FpdCBmb3IgdGhlIGNhY2hlIGV4cGlyYXRpb24gKEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TKS5cbiAgICAgICAgICBkaXNhYmxlQ2FjaGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0cmFuc2FjdGlvbi5fY29tcGlsZSgpO1xuICAgIGNvbnN0IHNpZ25EYXRhID0gbWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5fc2VyaWFsaXplKHNpZ25EYXRhKTtcbiAgICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb24gPSB3aXJlVHJhbnNhY3Rpb24udG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIGVuY29kaW5nOiAnYmFzZTY0JyxcbiAgICAgIGNvbW1pdG1lbnQ6IHRoaXMuY29tbWl0bWVudFxuICAgIH07XG4gICAgaWYgKGluY2x1ZGVBY2NvdW50cykge1xuICAgICAgY29uc3QgYWRkcmVzc2VzID0gKEFycmF5LmlzQXJyYXkoaW5jbHVkZUFjY291bnRzKSA/IGluY2x1ZGVBY2NvdW50cyA6IG1lc3NhZ2Uubm9uUHJvZ3JhbUlkcygpKS5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICAgIGNvbmZpZ1snYWNjb3VudHMnXSA9IHtcbiAgICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICBhZGRyZXNzZXNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChzaWduZXJzKSB7XG4gICAgICBjb25maWcuc2lnVmVyaWZ5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ09yU2lnbmVycyAmJiB0eXBlb2YgY29uZmlnT3JTaWduZXJzID09PSAnb2JqZWN0JyAmJiAnaW5uZXJJbnN0cnVjdGlvbnMnIGluIGNvbmZpZ09yU2lnbmVycykge1xuICAgICAgY29uZmlnLmlubmVySW5zdHJ1Y3Rpb25zID0gY29uZmlnT3JTaWduZXJzLmlubmVySW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzaW11bGF0ZVRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBsZXQgbG9ncztcbiAgICAgIGlmICgnZGF0YScgaW4gcmVzLmVycm9yKSB7XG4gICAgICAgIGxvZ3MgPSByZXMuZXJyb3IuZGF0YS5sb2dzO1xuICAgICAgICBpZiAobG9ncyAmJiBBcnJheS5pc0FycmF5KGxvZ3MpKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2VJbmRlbnQgPSAnXFxuICAgICc7XG4gICAgICAgICAgY29uc3QgbG9nVHJhY2UgPSB0cmFjZUluZGVudCArIGxvZ3Muam9pbih0cmFjZUluZGVudCk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuZXJyb3IubWVzc2FnZSwgbG9nVHJhY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3Ioe1xuICAgICAgICBhY3Rpb246ICdzaW11bGF0ZScsXG4gICAgICAgIHNpZ25hdHVyZTogJycsXG4gICAgICAgIHRyYW5zYWN0aW9uTWVzc2FnZTogcmVzLmVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGxvZ3M6IGxvZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIGFuZCBzZW5kIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2VuZFRyYW5zYWN0aW9ufSB3aXRoIGEge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9ufVxuICAgKi9cblxuICAvKipcbiAgICogU2VuZCBhIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBTaWduIGFuZCBzZW5kIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduZXJzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKCd2ZXJzaW9uJyBpbiB0cmFuc2FjdGlvbikge1xuICAgICAgaWYgKHNpZ25lcnNPck9wdGlvbnMgJiYgQXJyYXkuaXNBcnJheShzaWduZXJzT3JPcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSYXdUcmFuc2FjdGlvbih3aXJlVHJhbnNhY3Rpb24sIHNpZ25lcnNPck9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoc2lnbmVyc09yT3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICFBcnJheS5pc0FycmF5KHNpZ25lcnNPck9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lcnMgPSBzaWduZXJzT3JPcHRpb25zO1xuICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZUluZm8pIHtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXNhYmxlQ2FjaGUgPSB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZztcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2toYXNoID0gYXdhaXQgdGhpcy5fYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGF0ZXN0QmxvY2toYXNoLmxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBsYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoO1xuICAgICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLnNpZ25hdHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIXNpZ25hdHVyZScpOyAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdHJhbnNhY3Rpb24uc2lnbmF0dXJlLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBzZWVuIGJlZm9yZSB3aXRoIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3b3VsZCBiZSB0cmVhdGVkIGFzIGR1cGxpY2F0ZSAoaXRzIGRlcml2ZWQgc2lnbmF0dXJlXG4gICAgICAgICAgLy8gbWF0Y2hlZCB0byBvbmUgb2YgYWxyZWFkeSByZWNvcmRlZCBzaWduYXR1cmVzKS5cbiAgICAgICAgICAvLyBTbywgd2UgbXVzdCBmZXRjaCBhIG5ldyBibG9ja2hhc2ggZm9yIGEgZGlmZmVyZW50IHNpZ25hdHVyZSBieSBkaXNhYmxpbmdcbiAgICAgICAgICAvLyBvdXIgY2FjaGUgbm90IHRvIHdhaXQgZm9yIHRoZSBjYWNoZSBleHBpcmF0aW9uIChCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUykuXG4gICAgICAgICAgZGlzYWJsZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb24od2lyZVRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgdHJhbnNhY3Rpb24gdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNpZ25lZCBhbmQgc2VyaWFsaXplZCBpbnRvIHRoZVxuICAgKiB3aXJlIGZvcm1hdFxuICAgKi9cbiAgYXN5bmMgc2VuZFJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gdG9CdWZmZXIocmF3VHJhbnNhY3Rpb24pLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlbmRFbmNvZGVkVHJhbnNhY3Rpb24oZW5jb2RlZFRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSB0cmFuc2FjdGlvbiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2lnbmVkLCBzZXJpYWxpemVkIGludG8gdGhlXG4gICAqIHdpcmUgZm9ybWF0LCBhbmQgZW5jb2RlZCBhcyBhIGJhc2U2NCBzdHJpbmdcbiAgICovXG4gIGFzeW5jIHNlbmRFbmNvZGVkVHJhbnNhY3Rpb24oZW5jb2RlZFRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnXG4gICAgfTtcbiAgICBjb25zdCBza2lwUHJlZmxpZ2h0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnNraXBQcmVmbGlnaHQ7XG4gICAgY29uc3QgcHJlZmxpZ2h0Q29tbWl0bWVudCA9IHNraXBQcmVmbGlnaHQgPT09IHRydWUgPyAncHJvY2Vzc2VkJyAvLyBGSVhNRSBSZW1vdmUgd2hlbiBodHRwczovL2dpdGh1Yi5jb20vYW56YS14eXovYWdhdmUvcHVsbC80ODMgaXMgZGVwbG95ZWQuXG4gICAgOiBvcHRpb25zICYmIG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5tYXhSZXRyaWVzID0gb3B0aW9ucy5tYXhSZXRyaWVzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1pbkNvbnRleHRTbG90ICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5taW5Db250ZXh0U2xvdCA9IG9wdGlvbnMubWluQ29udGV4dFNsb3Q7XG4gICAgfVxuICAgIGlmIChza2lwUHJlZmxpZ2h0KSB7XG4gICAgICBjb25maWcuc2tpcFByZWZsaWdodCA9IHNraXBQcmVmbGlnaHQ7XG4gICAgfVxuICAgIGlmIChwcmVmbGlnaHRDb21taXRtZW50KSB7XG4gICAgICBjb25maWcucHJlZmxpZ2h0Q29tbWl0bWVudCA9IHByZWZsaWdodENvbW1pdG1lbnQ7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NlbmRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFNlbmRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBsZXQgbG9ncyA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICgnZGF0YScgaW4gcmVzLmVycm9yKSB7XG4gICAgICAgIGxvZ3MgPSByZXMuZXJyb3IuZGF0YS5sb2dzO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFNlbmRUcmFuc2FjdGlvbkVycm9yKHtcbiAgICAgICAgYWN0aW9uOiBza2lwUHJlZmxpZ2h0ID8gJ3NlbmQnIDogJ3NpbXVsYXRlJyxcbiAgICAgICAgc2lnbmF0dXJlOiAnJyxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiByZXMuZXJyb3IubWVzc2FnZSxcbiAgICAgICAgbG9nczogbG9nc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25PcGVuKCkge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IHRydWU7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgLy8gUGluZyBzZXJ2ZXIgZXZlcnkgNXMgdG8gcHJldmVudCBpZGxlIHRpbWVvdXRzXG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3JwY1dlYlNvY2tldC5ub3RpZnkoJ3BpbmcnKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfSkoKTtcbiAgICB9LCA1MDAwKTtcbiAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkVycm9yKGVycikge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIGNvbnNvbGUuZXJyb3IoJ3dzIGVycm9yOicsIGVyci5tZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uQ2xvc2UoY29kZSkge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gPSAodGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiArIDEpICUgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0KSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gMTAwMCkge1xuICAgICAgLy8gZXhwbGljaXQgY2xvc2UsIGNoZWNrIGlmIGFueSBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBtYWRlIHNpbmNlIGNsb3NlXG4gICAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaW1wbGljaXQgY2xvc2UsIHByZXBhcmUgc3Vic2NyaXB0aW9ucyBmb3IgYXV0by1yZWNvbm5lY3RcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkID0ge307XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCkuZm9yRWFjaCgoW2hhc2gsIHN1YnNjcmlwdGlvbl0pID0+IHtcbiAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0U3Vic2NyaXB0aW9uKGhhc2gsIG5leHRTdWJzY3JpcHRpb24pIHtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdPy5zdGF0ZTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdID0gbmV4dFN1YnNjcmlwdGlvbjtcbiAgICBpZiAocHJldlN0YXRlICE9PSBuZXh0U3Vic2NyaXB0aW9uLnN0YXRlKSB7XG4gICAgICBjb25zdCBzdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoW2hhc2hdO1xuICAgICAgaWYgKHN0YXRlQ2hhbmdlQ2FsbGJhY2tzKSB7XG4gICAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYihuZXh0U3Vic2NyaXB0aW9uLnN0YXRlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2UoY2xpZW50U3Vic2NyaXB0aW9uSWQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoaGFzaCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF0gfHw9IG5ldyBTZXQoKTtcbiAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgaWYgKHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoW2hhc2hdO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfdXBkYXRlU3Vic2NyaXB0aW9ucygpIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBzd2FsbG93IGVycm9yIGlmIHNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3Igd2hlbiBjbG9zaW5nIHNvY2tldCBjb25uZWN0aW9uOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldC5jb25uZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24gPSB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uO1xuICAgIGNvbnN0IGlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBhY3RpdmVXZWJTb2NrZXRHZW5lcmF0aW9uID09PSB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uO1xuICAgIH07XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgLy8gRG9uJ3QgYmUgdGVtcHRlZCB0byBjaGFuZ2UgdGhpcyB0byBgT2JqZWN0LmVudHJpZXNgLiBXZSBjYWxsXG4gICAgLy8gYF91cGRhdGVTdWJzY3JpcHRpb25zYCByZWN1cnNpdmVseSB3aGVuIHByb2Nlc3NpbmcgdGhlIHN0YXRlLFxuICAgIC8vIHNvIGl0J3MgaW1wb3J0YW50IHRoYXQgd2UgbG9vayB1cCB0aGUgKmN1cnJlbnQqIHZlcnNpb24gb2ZcbiAgICAvLyBlYWNoIHN1YnNjcmlwdGlvbiwgZXZlcnkgdGltZSB3ZSBwcm9jZXNzIGEgaGFzaC5cbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5tYXAoYXN5bmMgaGFzaCA9PiB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRoaXMgZW50cnkgaGFzIHNpbmNlIGJlZW4gZGVsZXRlZC4gU2tpcC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzdWJzY3JpcHRpb24uc3RhdGUpIHtcbiAgICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJlZCc6XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBZb3UgY2FuIGVuZCB1cCBoZXJlIHdoZW46XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLSBhIHN1YnNjcmlwdGlvbiBoYXMgcmVjZW50bHkgdW5zdWJzY3JpYmVkXG4gICAgICAgICAgICAgKiAgIHdpdGhvdXQgaGF2aW5nIG5ldyBjYWxsYmFja3MgYWRkZWQgdG8gaXRcbiAgICAgICAgICAgICAqICAgd2hpbGUgdGhlIHVuc3Vic2NyaWJlIHdhcyBpbiBmbGlnaHQsIG9yXG4gICAgICAgICAgICAgKiAtIHdoZW4gYSBwZW5kaW5nIHN1YnNjcmlwdGlvbiBoYXMgaXRzXG4gICAgICAgICAgICAgKiAgIGxpc3RlbmVycyByZW1vdmVkIGJlZm9yZSBhIHJlcXVlc3Qgd2FzXG4gICAgICAgICAgICAgKiAgIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBCZWluZyB0aGF0IG5vYm9keSBpcyBpbnRlcmVzdGVkIGluIHRoaXNcbiAgICAgICAgICAgICAqIHN1YnNjcmlwdGlvbiBhbnkgbG9uZ2VyLCBkZWxldGUgaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zdGF0ZSA9PT0gJ3Vuc3Vic2NyaWJlZCcpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWRbc3Vic2NyaXB0aW9uLnNlcnZlclN1YnNjcmlwdGlvbklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgbWV0aG9kXG4gICAgICAgICAgICB9ID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmluZydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1YnNjcmlwdGlvbklkID0gYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0LmNhbGwobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF0gPSBzdWJzY3JpcHRpb24uY2FsbGJhY2tzO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFJlY2VpdmVkICR7ZSBpbnN0YW5jZW9mIEVycm9yID8gJycgOiAnSlNPTi1SUEMgJ31lcnJvciBjYWxsaW5nIFxcYCR7bWV0aG9kfVxcYGAsIHtcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFRPRE86IE1heWJlIGFkZCBhbiAnZXJyb3JlZCcgc3RhdGUgb3IgYSByZXRyeSBsaW1pdD9cbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N1YnNjcmliZWQnOlxuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEJ5IHRoZSB0aW1lIHdlIHN1Y2Nlc3NmdWxseSBzZXQgdXAgYSBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIC8vIHdpdGggdGhlIHNlcnZlciwgdGhlIGNsaWVudCBzdG9wcGVkIGNhcmluZyBhYm91dCBpdC5cbiAgICAgICAgICAgIC8vIFRlYXIgaXQgZG93biBub3cuXG4gICAgICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQsXG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVNZXRob2RcbiAgICAgICAgICAgICAgfSA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5oYXMoc2VydmVyU3Vic2NyaXB0aW9uSWQpKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAgICAgICAgICAgICAqIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHN1YnNjcmlwdGlvbiB0aGF0IGhhcyBiZWVuIGF1dG8tXG4gICAgICAgICAgICAgICAgICogZGlzcG9zZWQgYnkgdGhlIFJQQywgdGhlbiB3ZSBjYW4gc2tpcCB0aGUgUlBDIGNhbGwgdG9cbiAgICAgICAgICAgICAgICAgKiB0ZWFyIGRvd24gdGhlIHN1YnNjcmlwdGlvbiBoZXJlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogTk9URTogVGhlcmUgaXMgYSBwcm9wb3NhbCB0byBlbGltaW5hdGUgdGhpcyBzcGVjaWFsIGNhc2UsIGhlcmU6XG4gICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMTg4OTJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMuZGVsZXRlKHNlcnZlclN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6ICd1bnN1YnNjcmliaW5nJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JwY1dlYlNvY2tldC5jYWxsKHVuc3Vic2NyaWJlTWV0aG9kLCBbc2VydmVyU3Vic2NyaXB0aW9uSWRdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7dW5zdWJzY3JpYmVNZXRob2R9IGVycm9yOmAsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE1heWJlIGFkZCBhbiAnZXJyb3JlZCcgc3RhdGUgb3IgYSByZXRyeSBsaW1pdD9cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAndW5zdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzZXJ2ZXJTdWJzY3JpcHRpb25JZCwgY2FsbGJhY2tBcmdzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF07XG4gICAgaWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiKFxuICAgICAgICAvLyBJIGZhaWxlZCB0byBmaW5kIGEgd2F5IHRvIGNvbnZpbmNlIFR5cGVTY3JpcHQgdGhhdCBgY2JgIGlzIG9mIHR5cGVcbiAgICAgICAgLy8gYFRDYWxsYmFja2Agd2hpY2ggaXMgY2VydGFpbmx5IGNvbXBhdGlibGUgd2l0aCBgUGFyYW1ldGVyczxUQ2FsbGJhY2s+YC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDc2MTVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAuLi5jYWxsYmFja0FyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBBY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0LnZhbHVlLCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX21ha2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uQ29uZmlnLFxuICAvKipcbiAgICogV2hlbiBwcmVwYXJpbmcgYGFyZ3NgIGZvciBhIGNhbGwgdG8gYF9tYWtlU3Vic2NyaXB0aW9uYCwgYmUgc3VyZVxuICAgKiB0byBjYXJlZnVsbHkgYXBwbHkgYSBkZWZhdWx0IGBjb21taXRtZW50YCBwcm9wZXJ0eSwgaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiAtIElmIHRoZSB1c2VyIHN1cHBsaWVkIGEgYGNvbW1pdG1lbnRgIHVzZSB0aGF0LlxuICAgKiAtIE90aGVyd2lzZSwgaWYgdGhlIGBDb25uZWN0aW9uOjpjb21taXRtZW50YCBpcyBzZXQsIHVzZSB0aGF0LlxuICAgKiAtIE90aGVyd2lzZSwgc2V0IGl0IHRvIHRoZSBSUEMgc2VydmVyIGRlZmF1bHQ6IGBmaW5hbGl6ZWRgLlxuICAgKlxuICAgKiBUaGlzIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQgdG8gZW5zdXJlIHRoYXQgdGhlc2UgdHdvIGZ1bmRhbWVudGFsbHlcbiAgICogaWRlbnRpY2FsIHN1YnNjcmlwdGlvbnMgcHJvZHVjZSB0aGUgc2FtZSBpZGVudGlmeWluZyBoYXNoOlxuICAgKlxuICAgKiAtIEEgc3Vic2NyaXB0aW9uIG1hZGUgd2l0aG91dCBzcGVjaWZ5aW5nIGEgY29tbWl0bWVudC5cbiAgICogLSBBIHN1YnNjcmlwdGlvbiBtYWRlIHdoZXJlIHRoZSBjb21taXRtZW50IHNwZWNpZmllZCBpcyB0aGUgc2FtZVxuICAgKiAgIGFzIHRoZSBkZWZhdWx0IGFwcGxpZWQgdG8gdGhlIHN1YnNjcmlwdGlvbiBhYm92ZS5cbiAgICpcbiAgICogRXhhbXBsZTsgdGhlc2UgdHdvIHN1YnNjcmlwdGlvbnMgbXVzdCBwcm9kdWNlIHRoZSBzYW1lIGhhc2g6XG4gICAqXG4gICAqIC0gQW4gYGFjY291bnRTdWJzY3JpYmVgIHN1YnNjcmlwdGlvbiBmb3IgYCdQVUJLRVknYFxuICAgKiAtIEFuIGBhY2NvdW50U3Vic2NyaWJlYCBzdWJzY3JpcHRpb24gZm9yIGAnUFVCS0VZJ2Agd2l0aCBjb21taXRtZW50XG4gICAqICAgYCdmaW5hbGl6ZWQnYC5cbiAgICpcbiAgICogU2VlIHRoZSAnbWFraW5nIGEgc3Vic2NyaXB0aW9uIHdpdGggZGVmYXVsdGVkIHBhcmFtcyBvbWl0dGVkJyB0ZXN0XG4gICAqIGluIGBjb25uZWN0aW9uLXN1YnNjcmlwdGlvbnMudHNgIGZvciBtb3JlLlxuICAgKi9cbiAgYXJncykge1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbmV4dENsaWVudFN1YnNjcmlwdGlvbklkKys7XG4gICAgY29uc3QgaGFzaCA9IGZhc3RTdGFibGVTdHJpbmdpZnkoW3N1YnNjcmlwdGlvbkNvbmZpZy5tZXRob2QsIGFyZ3NdKTtcbiAgICBjb25zdCBleGlzdGluZ1N1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgaWYgKGV4aXN0aW5nU3Vic2NyaXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0gPSB7XG4gICAgICAgIC4uLnN1YnNjcmlwdGlvbkNvbmZpZyxcbiAgICAgICAgYXJncyxcbiAgICAgICAgY2FsbGJhY2tzOiBuZXcgU2V0KFtzdWJzY3JpcHRpb25Db25maWcuY2FsbGJhY2tdKSxcbiAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmdTdWJzY3JpcHRpb24uY2FsbGJhY2tzLmFkZChzdWJzY3JpcHRpb25Db25maWcuY2FsbGJhY2spO1xuICAgIH1cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF0gPSBoYXNoO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF07XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXTtcbiAgICAgIGFzc2VydChzdWJzY3JpcHRpb24gIT09IHVuZGVmaW5lZCwgYENvdWxkIG5vdCBmaW5kIGEgXFxgU3Vic2NyaXB0aW9uXFxgIHdoZW4gdGVhcmluZyBkb3duIGNsaWVudCBzdWJzY3JpcHRpb24gIyR7Y2xpZW50U3Vic2NyaXB0aW9uSWR9YCk7XG4gICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2tzLmRlbGV0ZShzdWJzY3JpcHRpb25Db25maWcuY2FsbGJhY2spO1xuICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgIH07XG4gICAgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgdGhlIHNwZWNpZmllZCBhY2NvdW50IGNoYW5nZXNcbiAgICpcbiAgICogQHBhcmFtIHB1YmxpY0tleSBQdWJsaWMga2V5IG9mIHRoZSBhY2NvdW50IHRvIG1vbml0b3JcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgYWNjb3VudCBpcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSBjb25maWdcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG5cbiAgLyoqIEBkZXByZWNhdGVkIEluc3RlYWQsIHBhc3MgaW4gYW4ge0BsaW5rIEFjY291bnRTdWJzY3JpcHRpb25Db25maWd9ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIG9uQWNjb3VudENoYW5nZShwdWJsaWNLZXksIGNhbGxiYWNrLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnLFxuICAgIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdhY2NvdW50U3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnYWNjb3VudFVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdhY2NvdW50IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFt7XG4gICAgICBhY2NvdW50SWQ6IHJlc3VsdC52YWx1ZS5wdWJrZXksXG4gICAgICBhY2NvdW50SW5mbzogcmVzdWx0LnZhbHVlLmFjY291bnRcbiAgICB9LCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciBhY2NvdW50cyBvd25lZCBieSB0aGVcbiAgICogc3BlY2lmaWVkIHByb2dyYW0gY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgUHVibGljIGtleSBvZiB0aGUgcHJvZ3JhbSB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gY29uZmlnXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuXG4gIC8qKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBwYXNzIGluIGEge0BsaW5rIFByb2dyYW1BY2NvdW50U3Vic2NyaXB0aW9uQ29uZmlnfSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBvblByb2dyYW1BY2NvdW50Q2hhbmdlKHByb2dyYW1JZCwgY2FsbGJhY2ssIGNvbW1pdG1lbnRPckNvbmZpZywgbWF5YmVGaWx0ZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwcm9ncmFtSWQudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyxcbiAgICAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICdiYXNlNjQnIC8qIGVuY29kaW5nICovLCBjb25maWcgPyBjb25maWcgOiBtYXliZUZpbHRlcnMgPyB7XG4gICAgICBmaWx0ZXJzOiBhcHBseURlZmF1bHRNZW1jbXBFbmNvZGluZ1RvRmlsdGVycyhtYXliZUZpbHRlcnMpXG4gICAgfSA6IHVuZGVmaW5lZCAvKiBleHRyYSAqLyk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdwcm9ncmFtU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncHJvZ3JhbVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlUHJvZ3JhbUFjY291bnRDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAncHJvZ3JhbSBhY2NvdW50IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgbG9ncyBhcmUgZW1pdHRlZC5cbiAgICovXG4gIG9uTG9ncyhmaWx0ZXIsIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcgPyB7XG4gICAgICBtZW50aW9uczogW2ZpbHRlci50b1N0cmluZygpXVxuICAgIH0gOiBmaWx0ZXJdLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICApO1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnbG9nc1N1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2xvZ3NVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgbG9ncyBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3Rlci5cbiAgICovXG4gIGFzeW5jIHJlbW92ZU9uTG9nc0xpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdsb2dzJyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkxvZ3NOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIExvZ3NOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHQudmFsdWUsIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblNsb3ROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFNsb3ROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzbG90IGNoYW5nZXNcbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgc2xvdCBjaGFuZ2VzXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNsb3RDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Nsb3RTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzbG90VW5zdWJzY3JpYmUnXG4gICAgfSwgW10gLyogYXJncyAqLyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNsb3Qgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVNsb3RDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2xvdCBjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzbG90IHVwZGF0ZXMuIHtAbGluayBTbG90VXBkYXRlfSdzXG4gICAqIG1heSBiZSB1c2VmdWwgdG8gdHJhY2sgbGl2ZSBwcm9ncmVzcyBvZiBhIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIHNsb3QgdXBkYXRlc1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TbG90VXBkYXRlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdzbG90c1VwZGF0ZXNTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzbG90c1VwZGF0ZXNVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2xvdCB1cGRhdGUgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVNsb3RVcGRhdGVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2xvdCB1cGRhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgYXN5bmMgX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCBzdWJzY3JpcHRpb25OYW1lKSB7XG4gICAgY29uc3QgZGlzcG9zZSA9IHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoZGlzcG9zZSkge1xuICAgICAgYXdhaXQgZGlzcG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0lnbm9yZWQgdW5zdWJzY3JpYmUgcmVxdWVzdCBiZWNhdXNlIGFuIGFjdGl2ZSBzdWJzY3JpcHRpb24gd2l0aCBpZCAnICsgYFxcYCR7Y2xpZW50U3Vic2NyaXB0aW9uSWR9XFxgIGZvciAnJHtzdWJzY3JpcHRpb25OYW1lfScgZXZlbnRzIGAgKyAnY291bGQgbm90IGJlIGZvdW5kLicpO1xuICAgIH1cbiAgfVxuICBfYnVpbGRBcmdzKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpIHtcbiAgICBjb25zdCBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICBpZiAoY29tbWl0bWVudCB8fCBlbmNvZGluZyB8fCBleHRyYSkge1xuICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICBvcHRpb25zLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWl0bWVudCkge1xuICAgICAgICBvcHRpb25zLmNvbW1pdG1lbnQgPSBjb21taXRtZW50O1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGV4dHJhKTtcbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChhcmdzLCBvdmVycmlkZSwgZW5jb2RpbmcsIGV4dHJhKSB7XG4gICAgY29uc3QgY29tbWl0bWVudCA9IG92ZXJyaWRlIHx8IHRoaXMuX2NvbW1pdG1lbnQ7XG4gICAgaWYgKGNvbW1pdG1lbnQgJiYgIVsnY29uZmlybWVkJywgJ2ZpbmFsaXplZCddLmluY2x1ZGVzKGNvbW1pdG1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzaW5nIENvbm5lY3Rpb24gd2l0aCBkZWZhdWx0IGNvbW1pdG1lbnQ6IGAnICsgdGhpcy5fY29tbWl0bWVudCArICdgLCBidXQgbWV0aG9kIHJlcXVpcmVzIGF0IGxlYXN0IGBjb25maXJtZWRgJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9idWlsZEFyZ3MoYXJncywgb3ZlcnJpZGUsIGVuY29kaW5nLCBleHRyYSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblNpZ25hdHVyZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICBpZiAocmVzdWx0LnZhbHVlICE9PSAncmVjZWl2ZWRTaWduYXR1cmUnKSB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpYWwgY2FzZS5cbiAgICAgICAqIEFmdGVyIGEgc2lnbmF0dXJlIGlzIHByb2Nlc3NlZCwgUlBDcyBhdXRvbWF0aWNhbGx5IGRpc3Bvc2Ugb2YgdGhlXG4gICAgICAgKiBzdWJzY3JpcHRpb24gb24gdGhlIHNlcnZlciBzaWRlLiBXZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9mIHRoZXNlXG4gICAgICAgKiBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBkaXNwb3NlZCBpbiBzdWNoIGEgd2F5LCBzbyB0aGF0IHdlIGtub3dcbiAgICAgICAqIHdoZXRoZXIgdGhlIGNsaWVudCBpcyBkZWFsaW5nIHdpdGggYSBub3QteWV0LXByb2Nlc3NlZCBzaWduYXR1cmVcbiAgICAgICAqIChpbiB3aGljaCBjYXNlIHdlIG11c3QgdGVhciBkb3duIHRoZSBzZXJ2ZXIgc3Vic2NyaXB0aW9uKSBvciBhblxuICAgICAgICogYWxyZWFkeS1wcm9jZXNzZWQgc2lnbmF0dXJlIChpbiB3aGljaCBjYXNlIHRoZSBjbGllbnQgY2FuIHNpbXBseVxuICAgICAgICogY2xlYXIgb3V0IHRoZSBzdWJzY3JpcHRpb24gbG9jYWxseSB3aXRob3V0IHRlbGxpbmcgdGhlIHNlcnZlcikuXG4gICAgICAgKlxuICAgICAgICogTk9URTogVGhlcmUgaXMgYSBwcm9wb3NhbCB0byBlbGltaW5hdGUgdGhpcyBzcGVjaWFsIGNhc2UsIGhlcmU6XG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAgICovXG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIHJlc3VsdC52YWx1ZSA9PT0gJ3JlY2VpdmVkU2lnbmF0dXJlJyA/IFt7XG4gICAgICB0eXBlOiAncmVjZWl2ZWQnXG4gICAgfSwgcmVzdWx0LmNvbnRleHRdIDogW3tcbiAgICAgIHR5cGU6ICdzdGF0dXMnLFxuICAgICAgcmVzdWx0OiByZXN1bHQudmFsdWVcbiAgICB9LCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNpZ25hdHVyZSB1cGRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHN0cmluZyBpbiBiYXNlIDU4XG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugb24gc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAgICogQHBhcmFtIGNvbW1pdG1lbnQgU3BlY2lmeSB0aGUgY29tbWl0bWVudCBsZXZlbCBzaWduYXR1cmUgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNpZ25hdHVyZShzaWduYXR1cmUsIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbc2lnbmF0dXJlXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgKTtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2s6IChub3RpZmljYXRpb24sIGNvbnRleHQpID0+IHtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgIGNhbGxiYWNrKG5vdGlmaWNhdGlvbi5yZXN1bHQsIGNvbnRleHQpO1xuICAgICAgICAgIC8vIFNpZ25hdHVyZXMgc3Vic2NyaXB0aW9ucyBhcmUgYXV0by1yZW1vdmVkIGJ5IHRoZSBSUEMgc2VydmljZVxuICAgICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZXhwbGljaXRseSBzZW5kIGFuIHVuc3Vic2NyaWJlIG1lc3NhZ2UuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSByZW1vdmVkLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogJ3NpZ25hdHVyZVN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3NpZ25hdHVyZVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhIHRyYW5zYWN0aW9uIGlzXG4gICAqIHJlY2VpdmVkIGFuZC9vciBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHN0cmluZyBpbiBiYXNlIDU4XG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugb24gc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMgRW5hYmxlIHJlY2VpdmVkIG5vdGlmaWNhdGlvbnMgYW5kIHNldCB0aGUgY29tbWl0bWVudFxuICAgKiAgIGxldmVsIHRoYXQgc2lnbmF0dXJlIG11c3QgcmVhY2ggYmVmb3JlIG5vdGlmaWNhdGlvblxuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TaWduYXR1cmVXaXRoT3B0aW9ucyhzaWduYXR1cmUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIC4uLmV4dHJhXG4gICAgfSA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBjb21taXRtZW50OiBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGV4dHJhKTtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2s6IChub3RpZmljYXRpb24sIGNvbnRleHQpID0+IHtcbiAgICAgICAgY2FsbGJhY2sobm90aWZpY2F0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzdWJzY3JpcHRpb25zIGFyZSBhdXRvLXJlbW92ZWQgYnkgdGhlIFJQQyBzZXJ2aWNlXG4gICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZXhwbGljaXRseSBzZW5kIGFuIHVuc3Vic2NyaWJlIG1lc3NhZ2UuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2Q6ICdzaWduYXR1cmVTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzaWduYXR1cmVVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgICByZXR1cm4gY2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNpZ25hdHVyZSBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3NpZ25hdHVyZSByZXN1bHQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uUm9vdE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgUm9vdE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHJvb3QgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSByb290IGNoYW5nZXNcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uUm9vdENoYW5nZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAncm9vdFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Jvb3RVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgcm9vdCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlUm9vdENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdyb290IGNoYW5nZScpO1xuICB9XG59XG5cbi8qKlxuICogS2V5cGFpciBzaWduZXIgaW50ZXJmYWNlXG4gKi9cblxuLyoqXG4gKiBBbiBhY2NvdW50IGtleXBhaXIgdXNlZCBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmNsYXNzIEtleXBhaXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGtleXBhaXIgaW5zdGFuY2UuXG4gICAqIEdlbmVyYXRlIHJhbmRvbSBrZXlwYWlyIGlmIG5vIHtAbGluayBFZDI1NTE5S2V5cGFpcn0gaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWQyNTUxOUtleXBhaXJ9IGtleXBhaXIgZWQyNTUxOSBrZXlwYWlyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXlwYWlyKSB7XG4gICAgdGhpcy5fa2V5cGFpciA9IHZvaWQgMDtcbiAgICB0aGlzLl9rZXlwYWlyID0ga2V5cGFpciA/PyBnZW5lcmF0ZUtleXBhaXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyByYW5kb20ga2V5cGFpclxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlKCkge1xuICAgIHJldHVybiBuZXcgS2V5cGFpcihnZW5lcmF0ZUtleXBhaXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEga2V5cGFpciBmcm9tIGEgcmF3IHNlY3JldCBrZXkgYnl0ZSBhcnJheS5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB0byByZWNyZWF0ZSBhIGtleXBhaXIgZnJvbSBhIHByZXZpb3VzbHlcbiAgICogZ2VuZXJhdGVkIHNlY3JldCBrZXkuIEdlbmVyYXRpbmcga2V5cGFpcnMgZnJvbSBhIHJhbmRvbSBzZWVkIHNob3VsZCBiZSBkb25lXG4gICAqIHdpdGggdGhlIHtAbGluayBLZXlwYWlyLmZyb21TZWVkfSBtZXRob2QuXG4gICAqXG4gICAqIEB0aHJvd3MgZXJyb3IgaWYgdGhlIHByb3ZpZGVkIHNlY3JldCBrZXkgaXMgaW52YWxpZCBhbmQgdmFsaWRhdGlvbiBpcyBub3Qgc2tpcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlY3JldEtleSBzZWNyZXQga2V5IGJ5dGUgYXJyYXlcbiAgICogQHBhcmFtIG9wdGlvbnMgc2tpcCBzZWNyZXQga2V5IHZhbGlkYXRpb25cbiAgICpcbiAgICogQHJldHVybnMge0tleXBhaXJ9IEtleXBhaXJcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VjcmV0S2V5KHNlY3JldEtleSwgb3B0aW9ucykge1xuICAgIGlmIChzZWNyZXRLZXkuYnl0ZUxlbmd0aCAhPT0gNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBzZWNyZXRLZXkuc2xpY2UoMzIsIDY0KTtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIGNvbnN0IHByaXZhdGVTY2FsYXIgPSBzZWNyZXRLZXkuc2xpY2UoMCwgMzIpO1xuICAgICAgY29uc3QgY29tcHV0ZWRQdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkocHJpdmF0ZVNjYWxhcik7XG4gICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgMzI7IGlpKyspIHtcbiAgICAgICAgaWYgKHB1YmxpY0tleVtpaV0gIT09IGNvbXB1dGVkUHVibGljS2V5W2lpXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdmlkZWQgc2VjcmV0S2V5IGlzIGludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEtleXBhaXIoe1xuICAgICAgcHVibGljS2V5LFxuICAgICAgc2VjcmV0S2V5XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBrZXlwYWlyIGZyb20gYSAzMiBieXRlIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkIHNlZWQgYnl0ZSBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWVkKHNlZWQpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkoc2VlZCk7XG4gICAgY29uc3Qgc2VjcmV0S2V5ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgIHNlY3JldEtleS5zZXQoc2VlZCk7XG4gICAgc2VjcmV0S2V5LnNldChwdWJsaWNLZXksIDMyKTtcbiAgICByZXR1cm4gbmV3IEtleXBhaXIoe1xuICAgICAgcHVibGljS2V5LFxuICAgICAgc2VjcmV0S2V5XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgZm9yIHRoaXMga2V5cGFpclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHVibGljS2V5fSBQdWJsaWNLZXlcbiAgICovXG4gIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkodGhpcy5fa2V5cGFpci5wdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByYXcgc2VjcmV0IGtleSBmb3IgdGhpcyBrZXlwYWlyXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBTZWNyZXQga2V5IGluIGFuIGFycmF5IG9mIFVpbnQ4IGJ5dGVzXG4gICAqL1xuICBnZXQgc2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLl9rZXlwYWlyLnNlY3JldEtleSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBMb29rdXBUYWJsZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBhZGRyZXNzIGxvb2t1cCB0YWJsZSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENyZWF0ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ3JlY2VudFNsb3QnKSwgQnVmZmVyTGF5b3V0LnU4KCdidW1wU2VlZCcpXSlcbiAgfSxcbiAgRnJlZXplTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBFeHRlbmRMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdhZGRyZXNzZXMnKV0pXG4gIH0sXG4gIERlYWN0aXZhdGVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIENsb3NlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9XG59KTtcbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2xheW91dFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBsYXlvdXRUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSW5zdHJ1Y3Rpb24uIFNob3VsZCBiZSBhIExvb2t1cFRhYmxlIEluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5c0xlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA0KTtcbiAgICBjb25zdCB7XG4gICAgICByZWNlbnRTbG90XG4gICAgfSA9IGRlY29kZURhdGEkMShMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVMb29rdXBUYWJsZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBwYXllcjogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICByZWNlbnRTbG90OiBOdW1iZXIocmVjZW50U2xvdClcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVFeHRlbmRMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7aW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0IDJgKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzc2VzXG4gICAgfSA9IGRlY29kZURhdGEkMShMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5FeHRlbmRMb29rdXBUYWJsZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBwYXllcjogaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAyID8gaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXkgOiB1bmRlZmluZWQsXG4gICAgICBhZGRyZXNzZXM6IGFkZHJlc3Nlcy5tYXAoYnVmZmVyID0+IG5ldyBQdWJsaWNLZXkoYnVmZmVyKSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVDbG9zZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgcmVjaXBpZW50OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUZyZWV6ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlRGVhY3RpdmF0ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgQWRkcmVzc0xvb2t1cFRhYmxlIFByb2dyYW0nKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5c0xlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuICBzdGF0aWMgY3JlYXRlTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgW2xvb2t1cFRhYmxlQWRkcmVzcywgYnVtcFNlZWRdID0gUHVibGljS2V5LmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoW3BhcmFtcy5hdXRob3JpdHkudG9CdWZmZXIoKSwgZ2V0VTY0RW5jb2RlcigpLmVuY29kZShwYXJhbXMucmVjZW50U2xvdCldLCB0aGlzLnByb2dyYW1JZCk7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIHJlY2VudFNsb3Q6IEJpZ0ludChwYXJhbXMucmVjZW50U2xvdCksXG4gICAgICBidW1wU2VlZDogYnVtcFNlZWRcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogbG9va3VwVGFibGVBZGRyZXNzLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5wYXllcixcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBbbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSksIGxvb2t1cFRhYmxlQWRkcmVzc107XG4gIH1cbiAgc3RhdGljIGZyZWV6ZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5GcmVlemVMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGV4dGVuZExvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5FeHRlbmRMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhZGRyZXNzZXM6IHBhcmFtcy5hZGRyZXNzZXMubWFwKGFkZHIgPT4gYWRkci50b0J5dGVzKCkpXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKHBhcmFtcy5wYXllcikge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMucGF5ZXIsXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGRlYWN0aXZhdGVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVhY3RpdmF0ZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgY2xvc2VMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ2xvc2VMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5yZWNpcGllbnQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG59XG5BZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0FkZHJlc3NMb29rdXBUYWIxZTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBDb21wdXRlIEJ1ZGdldCBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbaXhUeXBlLCBsYXlvdXRdIG9mIE9iamVjdC5lbnRyaWVzKENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHJlcXVlc3QgdW5pdHMgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlUmVxdWVzdFVuaXRzKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHVuaXRzLFxuICAgICAgYWRkaXRpb25hbEZlZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0VW5pdHMsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB1bml0cyxcbiAgICAgIGFkZGl0aW9uYWxGZWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSByZXF1ZXN0IGhlYXAgZnJhbWUgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlUmVxdWVzdEhlYXBGcmFtZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICBieXRlc1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0SGVhcEZyYW1lLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYnl0ZXNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBzZXQgY29tcHV0ZSB1bml0IGxpbWl0IGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNldENvbXB1dGVVbml0TGltaXQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgdW5pdHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuU2V0Q29tcHV0ZVVuaXRMaW1pdCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgc2V0IGNvbXB1dGUgdW5pdCBwcmljZSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVTZXRDb21wdXRlVW5pdFByaWNlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1pY3JvTGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuU2V0Q29tcHV0ZVVuaXRQcmljZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pY3JvTGFtcG9ydHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhDb21wdXRlQnVkZ2V0UHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgQ29tcHV0ZUJ1ZGdldFByb2dyYW0nKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3QgdW5pdHMgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBSZXF1ZXN0IGhlYXAgZnJhbWUgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBTZXQgY29tcHV0ZSB1bml0IGxpbWl0IGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogU2V0IGNvbXB1dGUgdW5pdCBwcmljZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIENvbXB1dGVCdWRnZXQgSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFJlcXVlc3RVbml0czoge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCd1bml0cycpLCBCdWZmZXJMYXlvdXQudTMyKCdhZGRpdGlvbmFsRmVlJyldKVxuICB9LFxuICBSZXF1ZXN0SGVhcEZyYW1lOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ2J5dGVzJyldKVxuICB9LFxuICBTZXRDb21wdXRlVW5pdExpbWl0OiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ3VuaXRzJyldKVxuICB9LFxuICBTZXRDb21wdXRlVW5pdFByaWNlOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyksIHU2NCgnbWljcm9MYW1wb3J0cycpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb25zIHRvIGludGVyYWN0IHdpdGggdGhlIENvbXB1dGUgQnVkZ2V0IHByb2dyYW1cbiAqL1xuY2xhc3MgQ29tcHV0ZUJ1ZGdldFByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBDb21wdXRlIEJ1ZGdldCBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIHtAbGluayBzZXRDb21wdXRlVW5pdExpbWl0fSBhbmQvb3Ige0BsaW5rIHNldENvbXB1dGVVbml0UHJpY2V9XG4gICAqL1xuICBzdGF0aWMgcmVxdWVzdFVuaXRzKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RVbml0cztcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCBwYXJhbXMpO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHJlcXVlc3RIZWFwRnJhbWUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdEhlYXBGcmFtZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCBwYXJhbXMpO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHNldENvbXB1dGVVbml0TGltaXQocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuU2V0Q29tcHV0ZVVuaXRMaW1pdDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCBwYXJhbXMpO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHNldENvbXB1dGVVbml0UHJpY2UocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuU2V0Q29tcHV0ZVVuaXRQcmljZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBtaWNyb0xhbXBvcnRzOiBCaWdJbnQocGFyYW1zLm1pY3JvTGFtcG9ydHMpXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuQ29tcHV0ZUJ1ZGdldFByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnQ29tcHV0ZUJ1ZGdldDExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG5jb25zdCBQUklWQVRFX0tFWV9CWVRFUyQxID0gNjQ7XG5jb25zdCBQVUJMSUNfS0VZX0JZVEVTJDEgPSAzMjtcbmNvbnN0IFNJR05BVFVSRV9CWVRFUyA9IDY0O1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB1c2luZyBhIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB1c2luZyBhIHByaXZhdGUga2V5XG4gKi9cblxuY29uc3QgRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ251bVNpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0LnU4KCdwYWRkaW5nJyksIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTE2KCdzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC51MTYoJ3B1YmxpY0tleU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTE2KCdwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhU2l6ZScpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlSW5zdHJ1Y3Rpb25JbmRleCcpXSk7XG5jbGFzcyBFZDI1NTE5UHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIGVkMjU1MTkgcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGVkMjU1MTkgaW5zdHJ1Y3Rpb24gd2l0aCBhIHB1YmxpYyBrZXkgYW5kIHNpZ25hdHVyZS4gVGhlXG4gICAqIHB1YmxpYyBrZXkgbXVzdCBiZSBhIGJ1ZmZlciB0aGF0IGlzIDMyIGJ5dGVzIGxvbmcsIGFuZCB0aGUgc2lnbmF0dXJlXG4gICAqIG11c3QgYmUgYSBidWZmZXIgb2YgNjQgYnl0ZXMuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHB1YmxpY0tleSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICBhc3NlcnQocHVibGljS2V5Lmxlbmd0aCA9PT0gUFVCTElDX0tFWV9CWVRFUyQxLCBgUHVibGljIEtleSBtdXN0IGJlICR7UFVCTElDX0tFWV9CWVRFUyQxfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwdWJsaWNLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIGFzc2VydChzaWduYXR1cmUubGVuZ3RoID09PSBTSUdOQVRVUkVfQllURVMsIGBTaWduYXR1cmUgbXVzdCBiZSAke1NJR05BVFVSRV9CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7c2lnbmF0dXJlLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICBjb25zdCBwdWJsaWNLZXlPZmZzZXQgPSBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuO1xuICAgIGNvbnN0IHNpZ25hdHVyZU9mZnNldCA9IHB1YmxpY0tleU9mZnNldCArIHB1YmxpY0tleS5sZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZURhdGFPZmZzZXQgPSBzaWduYXR1cmVPZmZzZXQgKyBzaWduYXR1cmUubGVuZ3RoO1xuICAgIGNvbnN0IG51bVNpZ25hdHVyZXMgPSAxO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5hbGxvYyhtZXNzYWdlRGF0YU9mZnNldCArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICBjb25zdCBpbmRleCA9IGluc3RydWN0aW9uSW5kZXggPT0gbnVsbCA/IDB4ZmZmZiAvLyBBbiBpbmRleCBvZiBgdTE2OjpNQVhgIG1ha2VzIGl0IGRlZmF1bHQgdG8gdGhlIGN1cnJlbnQgaW5zdHJ1Y3Rpb24uXG4gICAgOiBpbnN0cnVjdGlvbkluZGV4O1xuICAgIEVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VULmVuY29kZSh7XG4gICAgICBudW1TaWduYXR1cmVzLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHNpZ25hdHVyZU9mZnNldCxcbiAgICAgIHNpZ25hdHVyZUluc3RydWN0aW9uSW5kZXg6IGluZGV4LFxuICAgICAgcHVibGljS2V5T2Zmc2V0LFxuICAgICAgcHVibGljS2V5SW5zdHJ1Y3Rpb25JbmRleDogaW5kZXgsXG4gICAgICBtZXNzYWdlRGF0YU9mZnNldCxcbiAgICAgIG1lc3NhZ2VEYXRhU2l6ZTogbWVzc2FnZS5sZW5ndGgsXG4gICAgICBtZXNzYWdlSW5zdHJ1Y3Rpb25JbmRleDogaW5kZXhcbiAgICB9LCBpbnN0cnVjdGlvbkRhdGEpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKHB1YmxpY0tleSwgcHVibGljS2V5T2Zmc2V0KTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChzaWduYXR1cmUsIHNpZ25hdHVyZU9mZnNldCk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwobWVzc2FnZSwgbWVzc2FnZURhdGFPZmZzZXQpO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogRWQyNTUxOVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgZGF0YTogaW5zdHJ1Y3Rpb25EYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGVkMjU1MTkgaW5zdHJ1Y3Rpb24gd2l0aCBhIHByaXZhdGUga2V5LiBUaGUgcHJpdmF0ZSBrZXlcbiAgICogbXVzdCBiZSBhIGJ1ZmZlciB0aGF0IGlzIDY0IGJ5dGVzIGxvbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHJpdmF0ZUtleShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwcml2YXRlS2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9ID0gcGFyYW1zO1xuICAgIGFzc2VydChwcml2YXRlS2V5Lmxlbmd0aCA9PT0gUFJJVkFURV9LRVlfQllURVMkMSwgYFByaXZhdGUga2V5IG11c3QgYmUgJHtQUklWQVRFX0tFWV9CWVRFUyQxfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwcml2YXRlS2V5Lmxlbmd0aH0gYnl0ZXNgKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qga2V5cGFpciA9IEtleXBhaXIuZnJvbVNlY3JldEtleShwcml2YXRlS2V5KTtcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGtleXBhaXIucHVibGljS2V5LnRvQnl0ZXMoKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ24obWVzc2FnZSwga2V5cGFpci5zZWNyZXRLZXkpO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5KHtcbiAgICAgICAgcHVibGljS2V5LFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGNyZWF0aW5nIGluc3RydWN0aW9uOyAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxufVxuRWQyNTUxOVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnRWQyNTUxOVNpZ1ZlcmlmeTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG5jb25zdCBlY2RzYVNpZ24gPSAobXNnSGFzaCwgcHJpdktleSkgPT4ge1xuICBjb25zdCBzaWduYXR1cmUgPSBzZWNwMjU2azEuc2lnbihtc2dIYXNoLCBwcml2S2V5KTtcbiAgcmV0dXJuIFtzaWduYXR1cmUudG9Db21wYWN0UmF3Qnl0ZXMoKSwgc2lnbmF0dXJlLnJlY292ZXJ5XTtcbn07XG5zZWNwMjU2azEudXRpbHMuaXNWYWxpZFByaXZhdGVLZXk7XG5jb25zdCBwdWJsaWNLZXlDcmVhdGUgPSBzZWNwMjU2azEuZ2V0UHVibGljS2V5O1xuXG5jb25zdCBQUklWQVRFX0tFWV9CWVRFUyA9IDMyO1xuY29uc3QgRVRIRVJFVU1fQUREUkVTU19CWVRFUyA9IDIwO1xuY29uc3QgUFVCTElDX0tFWV9CWVRFUyA9IDY0O1xuY29uc3QgU0lHTkFUVVJFX09GRlNFVFNfU0VSSUFMSVpFRF9TSVpFID0gMTE7XG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwdWJsaWMga2V5XG4gKi9cblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB1c2luZyBhbiBFdGhlcmV1bSBhZGRyZXNzXG4gKi9cblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB1c2luZyBhIHByaXZhdGUga2V5XG4gKi9cblxuY29uc3QgU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnbnVtU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQudTE2KCdzaWduYXR1cmVPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnU4KCdzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC51MTYoJ2V0aEFkZHJlc3NPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnU4KCdldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlRGF0YU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlRGF0YVNpemUnKSwgQnVmZmVyTGF5b3V0LnU4KCdtZXNzYWdlSW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQuYmxvYigyMCwgJ2V0aEFkZHJlc3MnKSwgQnVmZmVyTGF5b3V0LmJsb2IoNjQsICdzaWduYXR1cmUnKSwgQnVmZmVyTGF5b3V0LnU4KCdyZWNvdmVyeUlkJyldKTtcbmNsYXNzIFNlY3AyNTZrMVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBzZWNwMjU2azEgcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIEV0aGVyZXVtIGFkZHJlc3MgZnJvbSBhIHNlY3AyNTZrMSBwdWJsaWMga2V5IGJ1ZmZlci5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleSBhIDY0IGJ5dGUgc2VjcDI1NmsxIHB1YmxpYyBrZXkgYnVmZmVyXG4gICAqL1xuICBzdGF0aWMgcHVibGljS2V5VG9FdGhBZGRyZXNzKHB1YmxpY0tleSkge1xuICAgIGFzc2VydChwdWJsaWNLZXkubGVuZ3RoID09PSBQVUJMSUNfS0VZX0JZVEVTLCBgUHVibGljIGtleSBtdXN0IGJlICR7UFVCTElDX0tFWV9CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cHVibGljS2V5Lmxlbmd0aH0gYnl0ZXNgKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGtlY2Nha18yNTYodG9CdWZmZXIocHVibGljS2V5KSkpLnNsaWNlKC1FVEhFUkVVTV9BRERSRVNTX0JZVEVTKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjb25zdHJ1Y3RpbmcgRXRoZXJldW0gYWRkcmVzczogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB3aXRoIGEgcHVibGljIGtleS4gVGhlIHB1YmxpYyBrZXlcbiAgICogbXVzdCBiZSBhIGJ1ZmZlciB0aGF0IGlzIDY0IGJ5dGVzIGxvbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHB1YmxpY0tleSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICByZWNvdmVyeUlkLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIFNlY3AyNTZrMVByb2dyYW0uY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoRXRoQWRkcmVzcyh7XG4gICAgICBldGhBZGRyZXNzOiBTZWNwMjU2azFQcm9ncmFtLnB1YmxpY0tleVRvRXRoQWRkcmVzcyhwdWJsaWNLZXkpLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHJlY292ZXJ5SWQsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB3aXRoIGFuIEV0aGVyZXVtIGFkZHJlc3MuIFRoZSBhZGRyZXNzXG4gICAqIG11c3QgYmUgYSBoZXggc3RyaW5nIG9yIGEgYnVmZmVyIHRoYXQgaXMgMjAgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGV0aEFkZHJlc3M6IHJhd0FkZHJlc3MsXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgIGluc3RydWN0aW9uSW5kZXggPSAwXG4gICAgfSA9IHBhcmFtcztcbiAgICBsZXQgZXRoQWRkcmVzcztcbiAgICBpZiAodHlwZW9mIHJhd0FkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAocmF3QWRkcmVzcy5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgIGV0aEFkZHJlc3MgPSBCdWZmZXIuZnJvbShyYXdBZGRyZXNzLnN1YnN0cigyKSwgJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXRoQWRkcmVzcyA9IEJ1ZmZlci5mcm9tKHJhd0FkZHJlc3MsICdoZXgnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXRoQWRkcmVzcyA9IHJhd0FkZHJlc3M7XG4gICAgfVxuICAgIGFzc2VydChldGhBZGRyZXNzLmxlbmd0aCA9PT0gRVRIRVJFVU1fQUREUkVTU19CWVRFUywgYEFkZHJlc3MgbXVzdCBiZSAke0VUSEVSRVVNX0FERFJFU1NfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke2V0aEFkZHJlc3MubGVuZ3RofSBieXRlc2ApO1xuICAgIGNvbnN0IGRhdGFTdGFydCA9IDEgKyBTSUdOQVRVUkVfT0ZGU0VUU19TRVJJQUxJWkVEX1NJWkU7XG4gICAgY29uc3QgZXRoQWRkcmVzc09mZnNldCA9IGRhdGFTdGFydDtcbiAgICBjb25zdCBzaWduYXR1cmVPZmZzZXQgPSBkYXRhU3RhcnQgKyBldGhBZGRyZXNzLmxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlRGF0YU9mZnNldCA9IHNpZ25hdHVyZU9mZnNldCArIHNpZ25hdHVyZS5sZW5ndGggKyAxO1xuICAgIGNvbnN0IG51bVNpZ25hdHVyZXMgPSAxO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5hbGxvYyhTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VULnNwYW4gKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5lbmNvZGUoe1xuICAgICAgbnVtU2lnbmF0dXJlcyxcbiAgICAgIHNpZ25hdHVyZU9mZnNldCxcbiAgICAgIHNpZ25hdHVyZUluc3RydWN0aW9uSW5kZXg6IGluc3RydWN0aW9uSW5kZXgsXG4gICAgICBldGhBZGRyZXNzT2Zmc2V0LFxuICAgICAgZXRoQWRkcmVzc0luc3RydWN0aW9uSW5kZXg6IGluc3RydWN0aW9uSW5kZXgsXG4gICAgICBtZXNzYWdlRGF0YU9mZnNldCxcbiAgICAgIG1lc3NhZ2VEYXRhU2l6ZTogbWVzc2FnZS5sZW5ndGgsXG4gICAgICBtZXNzYWdlSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIHNpZ25hdHVyZTogdG9CdWZmZXIoc2lnbmF0dXJlKSxcbiAgICAgIGV0aEFkZHJlc3M6IHRvQnVmZmVyKGV0aEFkZHJlc3MpLFxuICAgICAgcmVjb3ZlcnlJZFxuICAgIH0sIGluc3RydWN0aW9uRGF0YSk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwodG9CdWZmZXIobWVzc2FnZSksIFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuc3Bhbik7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiBTZWNwMjU2azFQcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgIGRhdGE6IGluc3RydWN0aW9uRGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gd2l0aCBhIHByaXZhdGUga2V5LiBUaGUgcHJpdmF0ZSBrZXlcbiAgICogbXVzdCBiZSBhIGJ1ZmZlciB0aGF0IGlzIDMyIGJ5dGVzIGxvbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHJpdmF0ZUtleShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwcml2YXRlS2V5OiBwa2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9ID0gcGFyYW1zO1xuICAgIGFzc2VydChwa2V5Lmxlbmd0aCA9PT0gUFJJVkFURV9LRVlfQllURVMsIGBQcml2YXRlIGtleSBtdXN0IGJlICR7UFJJVkFURV9LRVlfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3BrZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcml2YXRlS2V5ID0gdG9CdWZmZXIocGtleSk7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBwdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgZmFsc2UgLyogaXNDb21wcmVzc2VkICovKS5zbGljZSgxKTsgLy8gdGhyb3cgYXdheSBsZWFkaW5nIGJ5dGVcbiAgICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gQnVmZmVyLmZyb20oa2VjY2FrXzI1Nih0b0J1ZmZlcihtZXNzYWdlKSkpO1xuICAgICAgY29uc3QgW3NpZ25hdHVyZSwgcmVjb3ZlcnlJZF0gPSBlY2RzYVNpZ24obWVzc2FnZUhhc2gsIHByaXZhdGVLZXkpO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5KHtcbiAgICAgICAgcHVibGljS2V5LFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIHJlY292ZXJ5SWQsXG4gICAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGNyZWF0aW5nIGluc3RydWN0aW9uOyAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxufVxuU2VjcDI1NmsxUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdLZWNjYWtTZWNwMjU2azExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbnZhciBfTG9ja3VwO1xuXG4vKipcbiAqIEFkZHJlc3Mgb2YgdGhlIHN0YWtlIGNvbmZpZyBhY2NvdW50IHdoaWNoIGNvbmZpZ3VyZXMgdGhlIHJhdGVcbiAqIG9mIHN0YWtlIHdhcm11cCBhbmQgY29vbGRvd24gYXMgd2VsbCBhcyB0aGUgc2xhc2hpbmcgcGVuYWx0eS5cbiAqL1xuY29uc3QgU1RBS0VfQ09ORklHX0lEID0gbmV3IFB1YmxpY0tleSgnU3Rha2VDb25maWcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIFN0YWtlIGFjY291bnQgYXV0aG9yaXR5IGluZm9cbiAqL1xuY2xhc3MgQXV0aG9yaXplZCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQXV0aG9yaXplZCBvYmplY3RcbiAgICogQHBhcmFtIHN0YWtlciB0aGUgc3Rha2UgYXV0aG9yaXR5XG4gICAqIEBwYXJhbSB3aXRoZHJhd2VyIHRoZSB3aXRoZHJhdyBhdXRob3JpdHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHN0YWtlciwgd2l0aGRyYXdlcikge1xuICAgIC8qKiBzdGFrZSBhdXRob3JpdHkgKi9cbiAgICB0aGlzLnN0YWtlciA9IHZvaWQgMDtcbiAgICAvKiogd2l0aGRyYXcgYXV0aG9yaXR5ICovXG4gICAgdGhpcy53aXRoZHJhd2VyID0gdm9pZCAwO1xuICAgIHRoaXMuc3Rha2VyID0gc3Rha2VyO1xuICAgIHRoaXMud2l0aGRyYXdlciA9IHdpdGhkcmF3ZXI7XG4gIH1cbn1cbi8qKlxuICogU3Rha2UgYWNjb3VudCBsb2NrdXAgaW5mb1xuICovXG5jbGFzcyBMb2NrdXAge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IExvY2t1cCBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKHVuaXhUaW1lc3RhbXAsIGVwb2NoLCBjdXN0b2RpYW4pIHtcbiAgICAvKiogVW5peCB0aW1lc3RhbXAgb2YgbG9ja3VwIGV4cGlyYXRpb24gKi9cbiAgICB0aGlzLnVuaXhUaW1lc3RhbXAgPSB2b2lkIDA7XG4gICAgLyoqIEVwb2NoIG9mIGxvY2t1cCBleHBpcmF0aW9uICovXG4gICAgdGhpcy5lcG9jaCA9IHZvaWQgMDtcbiAgICAvKiogTG9ja3VwIGN1c3RvZGlhbiBhdXRob3JpdHkgKi9cbiAgICB0aGlzLmN1c3RvZGlhbiA9IHZvaWQgMDtcbiAgICB0aGlzLnVuaXhUaW1lc3RhbXAgPSB1bml4VGltZXN0YW1wO1xuICAgIHRoaXMuZXBvY2ggPSBlcG9jaDtcbiAgICB0aGlzLmN1c3RvZGlhbiA9IGN1c3RvZGlhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0LCBpbmFjdGl2ZSBMb2NrdXAgdmFsdWVcbiAgICovXG59XG5fTG9ja3VwID0gTG9ja3VwO1xuTG9ja3VwLmRlZmF1bHQgPSBuZXcgX0xvY2t1cCgwLCAwLCBQdWJsaWNLZXkuZGVmYXVsdCk7XG4vKipcbiAqIENyZWF0ZSBzdGFrZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIENyZWF0ZSBzdGFrZSBhY2NvdW50IHdpdGggc2VlZCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBJbml0aWFsaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIERlbGVnYXRlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBBdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zIHVzaW5nIGEgZGVyaXZlZCBrZXlcbiAqL1xuLyoqXG4gKiBTcGxpdCBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBTcGxpdCB3aXRoIHNlZWQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogV2l0aGRyYXcgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogRGVhY3RpdmF0ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBNZXJnZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBTdGFrZSBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBTdGFrZUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIFN0YWtlSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgaW5pdGlhbGl6ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbml0aWFsaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZDogbmV3IEF1dGhvcml6ZWQobmV3IFB1YmxpY0tleShhdXRob3JpemVkLnN0YWtlciksIG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZC53aXRoZHJhd2VyKSksXG4gICAgICBsb2NrdXA6IG5ldyBMb2NrdXAobG9ja3VwLnVuaXhUaW1lc3RhbXAsIGxvY2t1cC5lcG9jaCwgbmV3IFB1YmxpY0tleShsb2NrdXAuY3VzdG9kaWFuKSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGRlbGVnYXRlIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZURlbGVnYXRlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNik7XG4gICAgZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVsZWdhdGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNV0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUF1dGhvcml6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5ld0F1dGhvcml6ZWQsXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHN0YWtlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDMpIHtcbiAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1szXS5wdWJrZXk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUtd2l0aC1zZWVkIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUF1dGhvcml6ZVdpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXJcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHlCYXNlOiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eVNlZWQ6IGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lcjogbmV3IFB1YmxpY0tleShhdXRob3JpdHlPd25lciksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogc3Rha2VBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gMykge1xuICAgICAgby5jdXN0b2RpYW5QdWJrZXkgPSBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgc3BsaXQgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU3BsaXQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5TcGxpdCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHNwbGl0U3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbWVyZ2Ugc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTWVyZ2UoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5NZXJnZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHNvdXJjZVN0YWtlUHViS2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNF0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB3aXRoZHJhdyBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVXaXRoZHJhdyhpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s0XS5wdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH07XG4gICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gNSkge1xuICAgICAgby5jdXN0b2RpYW5QdWJrZXkgPSBpbnN0cnVjdGlvbi5rZXlzWzVdLnB1YmtleTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgZGVhY3RpdmF0ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVEZWFjdGl2YXRlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVhY3RpdmF0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoU3Rha2VQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBTdGFrZVByb2dyYW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlMZW5ndGgoa2V5cywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFN0YWtlSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIHN0YWtlIEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBJbml0aWFsaXplOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBhdXRob3JpemVkKCksIGxvY2t1cCgpXSlcbiAgfSxcbiAgQXV0aG9yaXplOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0LnUzMignc3Rha2VBdXRob3JpemF0aW9uVHlwZScpXSlcbiAgfSxcbiAgRGVsZWdhdGU6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBTcGxpdDoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBXaXRoZHJhdzoge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBEZWFjdGl2YXRlOiB7XG4gICAgaW5kZXg6IDUsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgTWVyZ2U6IHtcbiAgICBpbmRleDogNyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBBdXRob3JpemVXaXRoU2VlZDoge1xuICAgIGluZGV4OiA4LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyksIEJ1ZmZlckxheW91dC51MzIoJ3N0YWtlQXV0aG9yaXphdGlvblR5cGUnKSwgcnVzdFN0cmluZygnYXV0aG9yaXR5U2VlZCcpLCBwdWJsaWNLZXkoJ2F1dGhvcml0eU93bmVyJyldKVxuICB9XG59KTtcblxuLyoqXG4gKiBTdGFrZSBhdXRob3JpemF0aW9uIHR5cGVcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFN0YWtlQXV0aG9yaXphdGlvbkxheW91dCdzXG4gKi9cbmNvbnN0IFN0YWtlQXV0aG9yaXphdGlvbkxheW91dCA9IE9iamVjdC5mcmVlemUoe1xuICBTdGFrZXI6IHtcbiAgICBpbmRleDogMFxuICB9LFxuICBXaXRoZHJhd2VyOiB7XG4gICAgaW5kZXg6IDFcbiAgfVxufSk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggdGhlIFN0YWtlIHByb2dyYW1cbiAqL1xuY2xhc3MgU3Rha2VQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgU3Rha2UgcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gSW5pdGlhbGl6ZSBpbnN0cnVjdGlvbiB0byBhZGQgdG8gYSBTdGFrZSBDcmVhdGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHN0YXRpYyBpbml0aWFsaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cDogbWF5YmVMb2NrdXBcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGxvY2t1cCA9IG1heWJlTG9ja3VwIHx8IExvY2t1cC5kZWZhdWx0O1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYXV0aG9yaXplZDoge1xuICAgICAgICBzdGFrZXI6IHRvQnVmZmVyKGF1dGhvcml6ZWQuc3Rha2VyLnRvQnVmZmVyKCkpLFxuICAgICAgICB3aXRoZHJhd2VyOiB0b0J1ZmZlcihhdXRob3JpemVkLndpdGhkcmF3ZXIudG9CdWZmZXIoKSlcbiAgICAgIH0sXG4gICAgICBsb2NrdXA6IHtcbiAgICAgICAgdW5peFRpbWVzdGFtcDogbG9ja3VwLnVuaXhUaW1lc3RhbXAsXG4gICAgICAgIGVwb2NoOiBsb2NrdXAuZXBvY2gsXG4gICAgICAgIGN1c3RvZGlhbjogdG9CdWZmZXIobG9ja3VwLmN1c3RvZGlhbi50b0J1ZmZlcigpKVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgU3Rha2UgYWNjb3VudCBhdFxuICAgKiAgIGFuIGFkZHJlc3MgZ2VuZXJhdGVkIHdpdGggYGZyb21gLCBhIHNlZWQsIGFuZCB0aGUgU3Rha2UgcHJvZ3JhbUlkXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudFdpdGhTZWVkKHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudFdpdGhTZWVkKHtcbiAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuaW5pdGlhbGl6ZSh7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgU3Rha2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplKHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgZGVsZWdhdGVzIFN0YWtlIHRva2VucyB0byBhIHZhbGlkYXRvclxuICAgKiBWb3RlIFB1YmxpY0tleS4gVGhpcyB0cmFuc2FjdGlvbiBjYW4gYWxzbyBiZSB1c2VkIHRvIHJlZGVsZWdhdGUgU3Rha2VcbiAgICogdG8gYSBuZXcgdmFsaWRhdG9yIFZvdGUgUHVibGljS2V5LlxuICAgKi9cbiAgc3RhdGljIGRlbGVnYXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHZvdGVQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlbGVnYXRlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTVEFLRV9DT05GSUdfSUQsXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBQdWJsaWNLZXkgYXMgU3Rha2VyXG4gICAqIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFN0YWtlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgYXV0aG9yaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgY3VzdG9kaWFuUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHN0YWtlQXV0aG9yaXphdGlvblR5cGUuaW5kZXhcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICBpZiAoY3VzdG9kaWFuUHVia2V5KSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IGN1c3RvZGlhblB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBQdWJsaWNLZXkgYXMgU3Rha2VyXG4gICAqIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFN0YWtlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgYXV0aG9yaXplV2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpdHlCYXNlLFxuICAgICAgYXV0aG9yaXR5U2VlZCxcbiAgICAgIGF1dGhvcml0eU93bmVyLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZVdpdGhTZWVkO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG5ld0F1dGhvcml6ZWQ6IHRvQnVmZmVyKG5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiBzdGFrZUF1dGhvcml6YXRpb25UeXBlLmluZGV4LFxuICAgICAgYXV0aG9yaXR5U2VlZDogYXV0aG9yaXR5U2VlZCxcbiAgICAgIGF1dGhvcml0eU93bmVyOiB0b0J1ZmZlcihhdXRob3JpdHlPd25lci50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml0eUJhc2UsXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICBpZiAoY3VzdG9kaWFuUHVia2V5KSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IGN1c3RvZGlhblB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBzcGxpdEluc3RydWN0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuU3BsaXQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHNcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IHNwbGl0cyBTdGFrZSB0b2tlbnMgaW50byBhbm90aGVyIHN0YWtlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBzcGxpdChwYXJhbXMsXG4gIC8vIENvbXB1dGUgdGhlIGNvc3Qgb2YgYWxsb2NhdGluZyB0aGUgbmV3IHN0YWtlIGFjY291bnQgaW4gbGFtcG9ydHNcbiAgcmVudEV4ZW1wdFJlc2VydmUpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzOiByZW50RXhlbXB0UmVzZXJ2ZSxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuc3BsaXRJbnN0cnVjdGlvbihwYXJhbXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgc3BsaXRzIFN0YWtlIHRva2VucyBpbnRvIGFub3RoZXIgYWNjb3VudFxuICAgKiBkZXJpdmVkIGZyb20gYSBiYXNlIHB1YmxpYyBrZXkgYW5kIHNlZWRcbiAgICovXG4gIHN0YXRpYyBzcGxpdFdpdGhTZWVkKHBhcmFtcyxcbiAgLy8gSWYgdGhpcyBzdGFrZSBhY2NvdW50IGlzIG5ldywgY29tcHV0ZSB0aGUgY29zdCBvZiBhbGxvY2F0aW5nIGl0IGluIGxhbXBvcnRzXG4gIHJlbnRFeGVtcHRSZXNlcnZlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXksXG4gICAgICBzZWVkLFxuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uYWxsb2NhdGUoe1xuICAgICAgYWNjb3VudFB1YmtleTogc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXksXG4gICAgICBzZWVkLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIGlmIChyZW50RXhlbXB0UmVzZXJ2ZSAmJiByZW50RXhlbXB0UmVzZXJ2ZSA+IDApIHtcbiAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLnRyYW5zZmVyKHtcbiAgICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIHRvUHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgICBsYW1wb3J0czogcmVudEV4ZW1wdFJlc2VydmVcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLnNwbGl0SW5zdHJ1Y3Rpb24oe1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBtZXJnZXMgU3Rha2UgYWNjb3VudHMuXG4gICAqL1xuICBzdGF0aWMgbWVyZ2UocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBzb3VyY2VTdGFrZVB1YktleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLk1lcmdlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogc291cmNlU3Rha2VQdWJLZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgd2l0aGRyYXdzIGRlYWN0aXZhdGVkIFN0YWtlIHRva2Vucy5cbiAgICovXG4gIHN0YXRpYyB3aXRoZHJhdyhwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICB0b1B1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgY3VzdG9kaWFuUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdztcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHRvUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICBpZiAoY3VzdG9kaWFuUHVia2V5KSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IGN1c3RvZGlhblB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgZGVhY3RpdmF0ZXMgU3Rha2UgdG9rZW5zLlxuICAgKi9cbiAgc3RhdGljIGRlYWN0aXZhdGUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5TdGFrZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnU3Rha2UxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuLyoqXG4gKiBNYXggc3BhY2Ugb2YgYSBTdGFrZSBhY2NvdW50XG4gKlxuICogVGhpcyBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgc29sYW5hLXN0YWtlLXByb2dyYW0gU3Rha2VTdGF0ZSBzdHJ1Y3QgYXNcbiAqIGBTdGFrZVN0YXRlVjI6OnNpemVfb2YoKWA6XG4gKiBodHRwczovL2RvY3MucnMvc29sYW5hLXN0YWtlLXByb2dyYW0vbGF0ZXN0L3NvbGFuYV9zdGFrZV9wcm9ncmFtL3N0YWtlX3N0YXRlL2VudW0uU3Rha2VTdGF0ZVYyLmh0bWxcbiAqL1xuU3Rha2VQcm9ncmFtLnNwYWNlID0gMjAwO1xuXG4vKipcbiAqIFZvdGUgYWNjb3VudCBpbmZvXG4gKi9cbmNsYXNzIFZvdGVJbml0IHtcbiAgLyoqIFswLCAxMDBdICovXG5cbiAgY29uc3RydWN0b3Iobm9kZVB1YmtleSwgYXV0aG9yaXplZFZvdGVyLCBhdXRob3JpemVkV2l0aGRyYXdlciwgY29tbWlzc2lvbikge1xuICAgIHRoaXMubm9kZVB1YmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlciA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhvcml6ZWRXaXRoZHJhd2VyID0gdm9pZCAwO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IHZvaWQgMDtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSBub2RlUHVia2V5O1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVyID0gYXV0aG9yaXplZFZvdGVyO1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSBhdXRob3JpemVkV2l0aGRyYXdlcjtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSBjb21taXNzaW9uO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIHZvdGUgYWNjb3VudCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEluaXRpYWxpemVBY2NvdW50IGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXV0aG9yaXplIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXV0aG9yaXplV2l0aFNlZWQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBXaXRoZHJhdyBmcm9tIHZvdGUgYWNjb3VudCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFVwZGF0ZSB2YWxpZGF0b3IgaWRlbnRpdHkgKG5vZGUgcHVia2V5KSB2b3RlIGFjY291bnQgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICovXG5cbi8qKlxuICogVm90ZSBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBWb3RlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHZvdGUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbaXhUeXBlLCBsYXlvdXRdIG9mIE9iamVjdC5lbnRyaWVzKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIFZvdGVJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gaW5pdGlhbGl6ZSB2b3RlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluaXRpYWxpemVBY2NvdW50KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNCk7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZUluaXRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgbm9kZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1szXS5wdWJrZXksXG4gICAgICB2b3RlSW5pdDogbmV3IFZvdGVJbml0KG5ldyBQdWJsaWNLZXkodm90ZUluaXQubm9kZVB1YmtleSksIG5ldyBQdWJsaWNLZXkodm90ZUluaXQuYXV0aG9yaXplZFZvdGVyKSwgbmV3IFB1YmxpY0tleSh2b3RlSW5pdC5hdXRob3JpemVkV2l0aGRyYXdlciksIHZvdGVJbml0LmNvbW1pc3Npb24pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUF1dGhvcml6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5ld0F1dGhvcml6ZWQsXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUF1dGhvcml6ZVdpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJnczoge1xuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LFxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICAgIG5ld0F1dGhvcml6ZWQsXG4gICAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXk6IG5ldyBQdWJsaWNLZXkoY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQ6IGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfSxcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB3aXRoZHJhdyBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVXaXRoZHJhdyhpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXcsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoVm90ZVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFZvdGVQcm9ncmFtJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5TGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBWb3RlSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKiogQGludGVybmFsICovXG5cbmNvbnN0IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBJbml0aWFsaXplQWNjb3VudDoge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdm90ZUluaXQoKV0pXG4gIH0sXG4gIEF1dGhvcml6ZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyksIEJ1ZmZlckxheW91dC51MzIoJ3ZvdGVBdXRob3JpemF0aW9uVHlwZScpXSlcbiAgfSxcbiAgV2l0aGRyYXc6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgVXBkYXRlVmFsaWRhdG9ySWRlbnRpdHk6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBBdXRob3JpemVXaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MoKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIFZvdGVBdXRob3JpemUgdHlwZVxuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgVm90ZUF1dGhvcml6YXRpb24gbGF5b3V0cy5cbiAqL1xuY29uc3QgVm90ZUF1dGhvcml6YXRpb25MYXlvdXQgPSBPYmplY3QuZnJlZXplKHtcbiAgVm90ZXI6IHtcbiAgICBpbmRleDogMFxuICB9LFxuICBXaXRoZHJhd2VyOiB7XG4gICAgaW5kZXg6IDFcbiAgfVxufSk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggdGhlIFZvdGUgcHJvZ3JhbVxuICovXG5jbGFzcyBWb3RlUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFZvdGUgcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gSW5pdGlhbGl6ZSBpbnN0cnVjdGlvbi5cbiAgICovXG4gIHN0YXRpYyBpbml0aWFsaXplQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlUHVia2V5LFxuICAgICAgbm9kZVB1YmtleSxcbiAgICAgIHZvdGVJbml0XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIHZvdGVJbml0OiB7XG4gICAgICAgIG5vZGVQdWJrZXk6IHRvQnVmZmVyKHZvdGVJbml0Lm5vZGVQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIGF1dGhvcml6ZWRWb3RlcjogdG9CdWZmZXIodm90ZUluaXQuYXV0aG9yaXplZFZvdGVyLnRvQnVmZmVyKCkpLFxuICAgICAgICBhdXRob3JpemVkV2l0aGRyYXdlcjogdG9CdWZmZXIodm90ZUluaXQuYXV0aG9yaXplZFdpdGhkcmF3ZXIudG9CdWZmZXIoKSksXG4gICAgICAgIGNvbW1pc3Npb246IHZvdGVJbml0LmNvbW1pc3Npb25cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBub2RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpbnN0cnVjdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFZvdGUgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy52b3RlUHVia2V5LFxuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuaW5pdGlhbGl6ZUFjY291bnQoe1xuICAgICAgdm90ZVB1YmtleTogcGFyYW1zLnZvdGVQdWJrZXksXG4gICAgICBub2RlUHVia2V5OiBwYXJhbXMudm90ZUluaXQubm9kZVB1YmtleSxcbiAgICAgIHZvdGVJbml0OiBwYXJhbXMudm90ZUluaXRcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgVm90ZXIgb3IgV2l0aGRyYXdlciBvbiB0aGUgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXksXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG5ld0F1dGhvcml6ZWQ6IHRvQnVmZmVyKG5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHZvdGVBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgVm90ZXIgb3IgV2l0aGRyYXdlciBvbiB0aGUgVm90ZSBhY2NvdW50XG4gICAqIHdoZXJlIHRoZSBjdXJyZW50IFZvdGVyIG9yIFdpdGhkcmF3ZXIgYXV0aG9yaXR5IGlzIGEgZGVyaXZlZCBrZXkuXG4gICAqL1xuICBzdGF0aWMgYXV0aG9yaXplV2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5LFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXksXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICB2b3RlUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZVdpdGhTZWVkO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIHZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3M6IHtcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleTogdG9CdWZmZXIoY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkOiBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICAgIG5ld0F1dGhvcml6ZWQ6IHRvQnVmZmVyKG5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZTogdm90ZUF1dGhvcml6YXRpb25UeXBlLmluZGV4XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdG8gd2l0aGRyYXcgZnJvbSBhIFZvdGUgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyB3aXRoZHJhdyhwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHRvUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiB0b1B1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB3aXRoZHJhdyBzYWZlbHkgZnJvbSBhIFZvdGUgYWNjb3VudC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3YXMgY3JlYXRlZCBhcyBhIHNhZmVndWFyZCBmb3Igdm90ZSBhY2NvdW50cyBydW5uaW5nIHZhbGlkYXRvcnMsIGBzYWZlV2l0aGRyYXdgXG4gICAqIGNoZWNrcyB0aGF0IHRoZSB3aXRoZHJhdyBhbW91bnQgd2lsbCBub3QgZXhjZWVkIHRoZSBzcGVjaWZpZWQgYmFsYW5jZSB3aGlsZSBsZWF2aW5nIGVub3VnaCBsZWZ0XG4gICAqIHRvIGNvdmVyIHJlbnQuIElmIHlvdSB3aXNoIHRvIGNsb3NlIHRoZSB2b3RlIGFjY291bnQgYnkgd2l0aGRyYXdpbmcgdGhlIGZ1bGwgYW1vdW50LCBjYWxsIHRoZVxuICAgKiBgd2l0aGRyYXdgIG1ldGhvZCBkaXJlY3RseS5cbiAgICovXG4gIHN0YXRpYyBzYWZlV2l0aGRyYXcocGFyYW1zLCBjdXJyZW50Vm90ZUFjY291bnRCYWxhbmNlLCByZW50RXhlbXB0TWluaW11bSkge1xuICAgIGlmIChwYXJhbXMubGFtcG9ydHMgPiBjdXJyZW50Vm90ZUFjY291bnRCYWxhbmNlIC0gcmVudEV4ZW1wdE1pbmltdW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2l0aGRyYXcgd2lsbCBsZWF2ZSB2b3RlIGFjY291bnQgd2l0aCBpbnN1ZmZpY2llbnQgZnVuZHMuJyk7XG4gICAgfVxuICAgIHJldHVybiBWb3RlUHJvZ3JhbS53aXRoZHJhdyhwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdG8gdXBkYXRlIHRoZSB2YWxpZGF0b3IgaWRlbnRpdHkgKG5vZGUgcHVia2V5KSBvZiBhIFZvdGUgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyB1cGRhdGVWYWxpZGF0b3JJZGVudGl0eShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBub2RlUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLlVwZGF0ZVZhbGlkYXRvcklkZW50aXR5O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogbm9kZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblZvdGVQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ1ZvdGUxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbi8qKlxuICogTWF4IHNwYWNlIG9mIGEgVm90ZSBhY2NvdW50XG4gKlxuICogVGhpcyBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgc29sYW5hLXZvdGUtcHJvZ3JhbSBWb3RlU3RhdGUgc3RydWN0IGFzXG4gKiBgVm90ZVN0YXRlOjpzaXplX29mKClgOlxuICogaHR0cHM6Ly9kb2NzLnJzL3NvbGFuYS12b3RlLXByb2dyYW0vMS45LjUvc29sYW5hX3ZvdGVfcHJvZ3JhbS92b3RlX3N0YXRlL3N0cnVjdC5Wb3RlU3RhdGUuaHRtbCNtZXRob2Quc2l6ZV9vZlxuICpcbiAqIEtFRVAgSU4gU1lOQyBXSVRIIGBWb3RlU3RhdGU6OnNpemVfb2YoKWAgaW4gaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iL2E0NzRjYjI0YjkyMzhmNWVkY2M5ODJmNjVjMGIzN2Q0YTEwNDZmN2Uvc2RrL3Byb2dyYW0vc3JjL3ZvdGUvc3RhdGUvbW9kLnJzI0wzNDAtTDM0MlxuICovXG5Wb3RlUHJvZ3JhbS5zcGFjZSA9IDM3NjI7XG5cbmNvbnN0IFZBTElEQVRPUl9JTkZPX0tFWSA9IG5ldyBQdWJsaWNLZXkoJ1ZhMWlkYXRvcjFuZm8xMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIEluZm8gdXNlZCB0byBpZGVudGl0eSB2YWxpZGF0b3JzLlxuICovXG5cbmNvbnN0IEluZm9TdHJpbmcgPSB0eXBlKHtcbiAgbmFtZTogc3RyaW5nKCksXG4gIHdlYnNpdGU6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAgZGV0YWlsczogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICBpY29uVXJsOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIGtleWJhc2VVc2VybmFtZTogb3B0aW9uYWwoc3RyaW5nKCkpXG59KTtcblxuLyoqXG4gKiBWYWxpZGF0b3JJbmZvIGNsYXNzXG4gKi9cbmNsYXNzIFZhbGlkYXRvckluZm8ge1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgdmFsaWQgVmFsaWRhdG9ySW5mb1xuICAgKlxuICAgKiBAcGFyYW0ga2V5IHZhbGlkYXRvciBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBpbmZvIHZhbGlkYXRvciBpbmZvcm1hdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2V5LCBpbmZvKSB7XG4gICAgLyoqXG4gICAgICogdmFsaWRhdG9yIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiB2YWxpZGF0b3IgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICB0aGlzLmluZm8gPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBWYWxpZGF0b3JJbmZvIGZyb20gdGhlIGNvbmZpZyBhY2NvdW50IGRhdGEuIEV4YWN0bHkgdHdvIGNvbmZpZ1xuICAgKiBrZXlzIGFyZSByZXF1aXJlZCBpbiB0aGUgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciBjb25maWcgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gbnVsbCBpZiBpbmZvIHdhcyBub3QgZm91bmRcbiAgICovXG4gIHN0YXRpYyBmcm9tQ29uZmlnRGF0YShidWZmZXIpIHtcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLmJ1ZmZlcl07XG4gICAgY29uc3QgY29uZmlnS2V5Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBpZiAoY29uZmlnS2V5Q291bnQgIT09IDIpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGNvbmZpZ0tleXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICAgIGNvbnN0IGlzU2lnbmVyID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSkgPT09IDE7XG4gICAgICBjb25maWdLZXlzLnB1c2goe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIGlzU2lnbmVyXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ0tleXNbMF0ucHVibGljS2V5LmVxdWFscyhWQUxJREFUT1JfSU5GT19LRVkpKSB7XG4gICAgICBpZiAoY29uZmlnS2V5c1sxXS5pc1NpZ25lcikge1xuICAgICAgICBjb25zdCByYXdJbmZvID0gcnVzdFN0cmluZygpLmRlY29kZShCdWZmZXIuZnJvbShieXRlQXJyYXkpKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IEpTT04ucGFyc2UocmF3SW5mbyk7XG4gICAgICAgIGFzc2VydCQxKGluZm8sIEluZm9TdHJpbmcpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbGlkYXRvckluZm8oY29uZmlnS2V5c1sxXS5wdWJsaWNLZXksIGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5jb25zdCBWT1RFX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KCdWb3RlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogSGlzdG9yeSBvZiBob3cgbWFueSBjcmVkaXRzIGVhcm5lZCBieSB0aGUgZW5kIG9mIGVhY2ggZXBvY2hcbiAqL1xuXG4vKipcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvOGExMmVkMDI5Y2ZhMzhkNGE0NTQwMDkxNmMyNDYzZmI4MmJiZWM4Yy9wcm9ncmFtcy92b3RlX2FwaS9zcmMvdm90ZV9zdGF0ZS5ycyNMNjgtTDg4XG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFZvdGVBY2NvdW50TGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdub2RlUHVia2V5JyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFdpdGhkcmF3ZXInKSwgQnVmZmVyTGF5b3V0LnU4KCdjb21taXNzaW9uJyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyB2b3Rlcy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ3Nsb3QnKSwgQnVmZmVyTGF5b3V0LnUzMignY29uZmlybWF0aW9uQ291bnQnKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAndm90ZXMnKSwgQnVmZmVyTGF5b3V0LnU4KCdyb290U2xvdFZhbGlkJyksIEJ1ZmZlckxheW91dC5udTY0KCdyb290U2xvdCcpLCBCdWZmZXJMYXlvdXQubnU2NCgpLFxuLy8gYXV0aG9yaXplZFZvdGVycy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFZvdGVyJyldKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2F1dGhvcml6ZWRWb3RlcnMnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ2F1dGhvcml6ZWRQdWJrZXknKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCcpLCBCdWZmZXJMYXlvdXQubnU2NCgndGFyZ2V0RXBvY2gnKV0pLCAzMiwgJ2J1ZicpLCBCdWZmZXJMYXlvdXQubnU2NCgnaWR4JyksIEJ1ZmZlckxheW91dC51OCgnaXNFbXB0eScpXSwgJ3ByaW9yVm90ZXJzJyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyBlcG9jaENyZWRpdHMubGVuZ3RoXG5CdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5udTY0KCdlcG9jaCcpLCBCdWZmZXJMYXlvdXQubnU2NCgnY3JlZGl0cycpLCBCdWZmZXJMYXlvdXQubnU2NCgncHJldkNyZWRpdHMnKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnZXBvY2hDcmVkaXRzJyksIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5udTY0KCdzbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCd0aW1lc3RhbXAnKV0sICdsYXN0VGltZXN0YW1wJyldKTtcbi8qKlxuICogVm90ZUFjY291bnQgY2xhc3NcbiAqL1xuY2xhc3MgVm90ZUFjY291bnQge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb21taXNzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMucm9vdFNsb3QgPSB2b2lkIDA7XG4gICAgdGhpcy52b3RlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5wcmlvclZvdGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLmVwb2NoQ3JlZGl0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSB2b2lkIDA7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gYXJncy5ub2RlUHVia2V5O1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSBhcmdzLmF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IGFyZ3MuY29tbWlzc2lvbjtcbiAgICB0aGlzLnJvb3RTbG90ID0gYXJncy5yb290U2xvdDtcbiAgICB0aGlzLnZvdGVzID0gYXJncy52b3RlcztcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlcnMgPSBhcmdzLmF1dGhvcml6ZWRWb3RlcnM7XG4gICAgdGhpcy5wcmlvclZvdGVycyA9IGFyZ3MucHJpb3JWb3RlcnM7XG4gICAgdGhpcy5lcG9jaENyZWRpdHMgPSBhcmdzLmVwb2NoQ3JlZGl0cztcbiAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSBhcmdzLmxhc3RUaW1lc3RhbXA7XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgVm90ZUFjY291bnQgZnJvbSB0aGUgYWNjb3VudCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIFZvdGVBY2NvdW50XG4gICAqL1xuICBzdGF0aWMgZnJvbUFjY291bnREYXRhKGJ1ZmZlcikge1xuICAgIGNvbnN0IHZlcnNpb25PZmZzZXQgPSA0O1xuICAgIGNvbnN0IHZhID0gVm90ZUFjY291bnRMYXlvdXQuZGVjb2RlKHRvQnVmZmVyKGJ1ZmZlciksIHZlcnNpb25PZmZzZXQpO1xuICAgIGxldCByb290U2xvdCA9IHZhLnJvb3RTbG90O1xuICAgIGlmICghdmEucm9vdFNsb3RWYWxpZCkge1xuICAgICAgcm9vdFNsb3QgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZvdGVBY2NvdW50KHtcbiAgICAgIG5vZGVQdWJrZXk6IG5ldyBQdWJsaWNLZXkodmEubm9kZVB1YmtleSksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlcjogbmV3IFB1YmxpY0tleSh2YS5hdXRob3JpemVkV2l0aGRyYXdlciksXG4gICAgICBjb21taXNzaW9uOiB2YS5jb21taXNzaW9uLFxuICAgICAgdm90ZXM6IHZhLnZvdGVzLFxuICAgICAgcm9vdFNsb3QsXG4gICAgICBhdXRob3JpemVkVm90ZXJzOiB2YS5hdXRob3JpemVkVm90ZXJzLm1hcChwYXJzZUF1dGhvcml6ZWRWb3RlciksXG4gICAgICBwcmlvclZvdGVyczogZ2V0UHJpb3JWb3RlcnModmEucHJpb3JWb3RlcnMpLFxuICAgICAgZXBvY2hDcmVkaXRzOiB2YS5lcG9jaENyZWRpdHMsXG4gICAgICBsYXN0VGltZXN0YW1wOiB2YS5sYXN0VGltZXN0YW1wXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlQXV0aG9yaXplZFZvdGVyKHtcbiAgYXV0aG9yaXplZFZvdGVyLFxuICBlcG9jaFxufSkge1xuICByZXR1cm4ge1xuICAgIGVwb2NoLFxuICAgIGF1dGhvcml6ZWRWb3RlcjogbmV3IFB1YmxpY0tleShhdXRob3JpemVkVm90ZXIpXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVByaW9yVm90ZXJzKHtcbiAgYXV0aG9yaXplZFB1YmtleSxcbiAgZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoLFxuICB0YXJnZXRFcG9jaFxufSkge1xuICByZXR1cm4ge1xuICAgIGF1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZFB1YmtleSksXG4gICAgZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoLFxuICAgIHRhcmdldEVwb2NoXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQcmlvclZvdGVycyh7XG4gIGJ1ZixcbiAgaWR4LFxuICBpc0VtcHR5XG59KSB7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBbLi4uYnVmLnNsaWNlKGlkeCArIDEpLm1hcChwYXJzZVByaW9yVm90ZXJzKSwgLi4uYnVmLnNsaWNlKDAsIGlkeCkubWFwKHBhcnNlUHJpb3JWb3RlcnMpXTtcbn1cblxuY29uc3QgZW5kcG9pbnQgPSB7XG4gIGh0dHA6IHtcbiAgICBkZXZuZXQ6ICdodHRwOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tJyxcbiAgICB0ZXN0bmV0OiAnaHR0cDovL2FwaS50ZXN0bmV0LnNvbGFuYS5jb20nLFxuICAgICdtYWlubmV0LWJldGEnOiAnaHR0cDovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbS8nXG4gIH0sXG4gIGh0dHBzOiB7XG4gICAgZGV2bmV0OiAnaHR0cHM6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nLFxuICAgIHRlc3RuZXQ6ICdodHRwczovL2FwaS50ZXN0bmV0LnNvbGFuYS5jb20nLFxuICAgICdtYWlubmV0LWJldGEnOiAnaHR0cHM6Ly9hcGkubWFpbm5ldC1iZXRhLnNvbGFuYS5jb20vJ1xuICB9XG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIFJQQyBBUEkgVVJMIGZvciB0aGUgc3BlY2lmaWVkIGNsdXN0ZXJcbiAqIEBwYXJhbSB7Q2x1c3Rlcn0gW2NsdXN0ZXI9XCJkZXZuZXRcIl0gLSBUaGUgY2x1c3RlciBuYW1lIG9mIHRoZSBSUEMgQVBJIFVSTCB0byB1c2UuIFBvc3NpYmxlIG9wdGlvbnM6ICdkZXZuZXQnIHwgJ3Rlc3RuZXQnIHwgJ21haW5uZXQtYmV0YSdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Rscz1cImh0dHBcIl0gLSBVc2UgVExTIHdoZW4gY29ubmVjdGluZyB0byBjbHVzdGVyLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBzdHJpbmcgb2YgdGhlIFJQQyBlbmRwb2ludFxuICovXG5mdW5jdGlvbiBjbHVzdGVyQXBpVXJsKGNsdXN0ZXIsIHRscykge1xuICBjb25zdCBrZXkgPSB0bHMgPT09IGZhbHNlID8gJ2h0dHAnIDogJ2h0dHBzJztcbiAgaWYgKCFjbHVzdGVyKSB7XG4gICAgcmV0dXJuIGVuZHBvaW50W2tleV1bJ2Rldm5ldCddO1xuICB9XG4gIGNvbnN0IHVybCA9IGVuZHBvaW50W2tleV1bY2x1c3Rlcl07XG4gIGlmICghdXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duICR7a2V5fSBjbHVzdGVyOiAke2NsdXN0ZXJ9YCk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBTZW5kIGFuZCBjb25maXJtIGEgcmF3IHRyYW5zYWN0aW9uXG4gKlxuICogSWYgYGNvbW1pdG1lbnRgIG9wdGlvbiBpcyBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byAnbWF4JyBjb21taXRtZW50LlxuICpcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQHBhcmFtIHtCdWZmZXJ9IHJhd1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3l9IGNvbmZpcm1hdGlvblN0cmF0ZWd5XG4gKiBAcGFyYW0ge0NvbmZpcm1PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uU2lnbmF0dXJlPn1cbiAqL1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIENhbGxpbmcgYHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24oKWAgd2l0aG91dCBhIGBjb25maXJtYXRpb25TdHJhdGVneWBcbiAqIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmFzeW5jIGZ1bmN0aW9uIHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgcmF3VHJhbnNhY3Rpb24sIGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgbWF5YmVDb25maXJtT3B0aW9ucykge1xuICBsZXQgY29uZmlybWF0aW9uU3RyYXRlZ3k7XG4gIGxldCBvcHRpb25zO1xuICBpZiAoY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMsICdsYXN0VmFsaWRCbG9ja0hlaWdodCcpKSB7XG4gICAgY29uZmlybWF0aW9uU3RyYXRlZ3kgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG1heWJlQ29uZmlybU9wdGlvbnM7XG4gIH0gZWxzZSBpZiAoY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMsICdub25jZVZhbHVlJykpIHtcbiAgICBjb25maXJtYXRpb25TdHJhdGVneSA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucztcbiAgICBvcHRpb25zID0gbWF5YmVDb25maXJtT3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zO1xuICB9XG4gIGNvbnN0IHNlbmRPcHRpb25zID0gb3B0aW9ucyAmJiB7XG4gICAgc2tpcFByZWZsaWdodDogb3B0aW9ucy5za2lwUHJlZmxpZ2h0LFxuICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCBvcHRpb25zLmNvbW1pdG1lbnQsXG4gICAgbWluQ29udGV4dFNsb3Q6IG9wdGlvbnMubWluQ29udGV4dFNsb3RcbiAgfTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24sIHNlbmRPcHRpb25zKTtcbiAgY29uc3QgY29tbWl0bWVudCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50O1xuICBjb25zdCBjb25maXJtYXRpb25Qcm9taXNlID0gY29uZmlybWF0aW9uU3RyYXRlZ3kgPyBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihjb25maXJtYXRpb25TdHJhdGVneSwgY29tbWl0bWVudCkgOiBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnQpO1xuICBjb25zdCBzdGF0dXMgPSAoYXdhaXQgY29uZmlybWF0aW9uUHJvbWlzZSkudmFsdWU7XG4gIGlmIChzdGF0dXMuZXJyKSB7XG4gICAgaWYgKHNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3Ioe1xuICAgICAgICBhY3Rpb246IHNlbmRPcHRpb25zPy5za2lwUHJlZmxpZ2h0ID8gJ3NlbmQnIDogJ3NpbXVsYXRlJyxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgIHRyYW5zYWN0aW9uTWVzc2FnZTogYFN0YXR1czogKCR7SlNPTi5zdHJpbmdpZnkoc3RhdHVzKX0pYFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgUmF3IHRyYW5zYWN0aW9uICR7c2lnbmF0dXJlfSBmYWlsZWQgKCR7SlNPTi5zdHJpbmdpZnkoc3RhdHVzKX0pYCk7XG4gIH1cbiAgcmV0dXJuIHNpZ25hdHVyZTtcbn1cblxuLyoqXG4gKiBUaGVyZSBhcmUgMS1iaWxsaW9uIGxhbXBvcnRzIGluIG9uZSBTT0xcbiAqL1xuY29uc3QgTEFNUE9SVFNfUEVSX1NPTCA9IDEwMDAwMDAwMDA7XG5cbmV4cG9ydCB7IEFjY291bnQsIEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQsIEFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uLCBBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtLCBBdXRob3JpemVkLCBCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUywgQlBGX0xPQURFUl9ERVBSRUNBVEVEX1BST0dSQU1fSUQsIEJQRl9MT0FERVJfUFJPR1JBTV9JRCwgQnBmTG9hZGVyLCBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLCBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb24sIENvbXB1dGVCdWRnZXRQcm9ncmFtLCBDb25uZWN0aW9uLCBFZDI1NTE5UHJvZ3JhbSwgRW51bSwgRXBvY2hTY2hlZHVsZSwgRmVlQ2FsY3VsYXRvckxheW91dCwgS2V5cGFpciwgTEFNUE9SVFNfUEVSX1NPTCwgTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMsIExvYWRlciwgTG9ja3VwLCBNQVhfU0VFRF9MRU5HVEgsIE1lc3NhZ2UsIE1lc3NhZ2VBY2NvdW50S2V5cywgTWVzc2FnZVYwLCBOT05DRV9BQ0NPVU5UX0xFTkdUSCwgTm9uY2VBY2NvdW50LCBQQUNLRVRfREFUQV9TSVpFLCBQVUJMSUNfS0VZX0xFTkdUSCwgUHVibGljS2V5LCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTLCBTT0xBTkFfU0NIRU1BLCBTVEFLRV9DT05GSUdfSUQsIFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMsIFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLCBTWVNWQVJfQ0xPQ0tfUFVCS0VZLCBTWVNWQVJfRVBPQ0hfU0NIRURVTEVfUFVCS0VZLCBTWVNWQVJfSU5TVFJVQ1RJT05TX1BVQktFWSwgU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksIFNZU1ZBUl9SRU5UX1BVQktFWSwgU1lTVkFSX1JFV0FSRFNfUFVCS0VZLCBTWVNWQVJfU0xPVF9IQVNIRVNfUFVCS0VZLCBTWVNWQVJfU0xPVF9ISVNUT1JZX1BVQktFWSwgU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLCBTZWNwMjU2azFQcm9ncmFtLCBTZW5kVHJhbnNhY3Rpb25FcnJvciwgU29sYW5hSlNPTlJQQ0Vycm9yLCBTb2xhbmFKU09OUlBDRXJyb3JDb2RlLCBTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQsIFN0YWtlSW5zdHJ1Y3Rpb24sIFN0YWtlUHJvZ3JhbSwgU3RydWN0LCBTeXN0ZW1JbnN0cnVjdGlvbiwgU3lzdGVtUHJvZ3JhbSwgVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciwgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IsIFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvciwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiwgVHJhbnNhY3Rpb25NZXNzYWdlLCBUcmFuc2FjdGlvblN0YXR1cywgVkFMSURBVE9SX0lORk9fS0VZLCBWRVJTSU9OX1BSRUZJWF9NQVNLLCBWT1RFX1BST0dSQU1fSUQsIFZhbGlkYXRvckluZm8sIFZlcnNpb25lZE1lc3NhZ2UsIFZlcnNpb25lZFRyYW5zYWN0aW9uLCBWb3RlQWNjb3VudCwgVm90ZUF1dGhvcml6YXRpb25MYXlvdXQsIFZvdGVJbml0LCBWb3RlSW5zdHJ1Y3Rpb24sIFZvdGVQcm9ncmFtLCBjbHVzdGVyQXBpVXJsLCBzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uLCBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiQnVmZmVyIiwiZWQyNTUxOSIsIkJOIiwiYnM1OCIsInNoYTI1NiIsInNlcmlhbGl6ZSIsImRlc2VyaWFsaXplIiwiZGVzZXJpYWxpemVVbmNoZWNrZWQiLCJCdWZmZXJMYXlvdXQiLCJibG9iIiwiZ2V0VTY0Q29kZWMiLCJnZXRVNjRFbmNvZGVyIiwicmVxdWlyZSQkMCIsInJlcXVpcmUkJDAkMSIsInJlcXVpcmUkJDAkMiIsIkFnZW50IiwiY29lcmNlIiwiaW5zdGFuY2UiLCJzdHJpbmciLCJ0dXBsZSIsImxpdGVyYWwiLCJ1bmtub3duIiwidHlwZSIsIm51bWJlciIsImFycmF5IiwibnVsbGFibGUiLCJvcHRpb25hbCIsImJvb2xlYW4iLCJyZWNvcmQiLCJ1bmlvbiIsImNyZWF0ZSIsImFueSIsImFzc2VydCIsImFzc2VydCQxIiwiUnBjQ2xpZW50Iiwibm9kZUZldGNoIiwiQ29tbW9uQ2xpZW50IiwiV2ViU29ja2V0Iiwia2VjY2FrXzI1NiIsInNlY3AyNTZrMSIsImdlbmVyYXRlUHJpdmF0ZUtleSIsInV0aWxzIiwicmFuZG9tUHJpdmF0ZUtleSIsImdlbmVyYXRlS2V5cGFpciIsInByaXZhdGVTY2FsYXIiLCJwdWJsaWNLZXkiLCJnZXRQdWJsaWNLZXkiLCJzZWNyZXRLZXkiLCJVaW50OEFycmF5Iiwic2V0IiwiaXNPbkN1cnZlIiwiRXh0ZW5kZWRQb2ludCIsImZyb21IZXgiLCJzaWduIiwibWVzc2FnZSIsInNsaWNlIiwidmVyaWZ5IiwidG9CdWZmZXIiLCJhcnIiLCJpc0J1ZmZlciIsImZyb20iLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIlN0cnVjdCIsImNvbnN0cnVjdG9yIiwicHJvcGVydGllcyIsIk9iamVjdCIsImFzc2lnbiIsImVuY29kZSIsIlNPTEFOQV9TQ0hFTUEiLCJkZWNvZGUiLCJkYXRhIiwiZGVjb2RlVW5jaGVja2VkIiwiRW51bSIsImVudW0iLCJrZXlzIiwibGVuZ3RoIiwiRXJyb3IiLCJtYXAiLCJrZXkiLCJNYXAiLCJfUHVibGljS2V5IiwiTUFYX1NFRURfTEVOR1RIIiwiUFVCTElDX0tFWV9MRU5HVEgiLCJpc1B1YmxpY0tleURhdGEiLCJ2YWx1ZSIsIl9ibiIsInVuZGVmaW5lZCIsInVuaXF1ZVB1YmxpY0tleUNvdW50ZXIiLCJQdWJsaWNLZXkiLCJkZWNvZGVkIiwidW5pcXVlIiwiZXF1YWxzIiwiZXEiLCJ0b0Jhc2U1OCIsInRvQnl0ZXMiLCJ0b0pTT04iLCJidWYiLCJiIiwidG9BcnJheUxpa2UiLCJ6ZXJvUGFkIiwiYWxsb2MiLCJjb3B5IiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ0b1N0cmluZyIsImNyZWF0ZVdpdGhTZWVkIiwiZnJvbVB1YmxpY0tleSIsInNlZWQiLCJwcm9ncmFtSWQiLCJjb25jYXQiLCJwdWJsaWNLZXlCeXRlcyIsImNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyIsInNlZWRzIiwiZm9yRWFjaCIsIlR5cGVFcnJvciIsImNyZWF0ZVByb2dyYW1BZGRyZXNzIiwiZmluZFByb2dyYW1BZGRyZXNzU3luYyIsIm5vbmNlIiwiYWRkcmVzcyIsInNlZWRzV2l0aE5vbmNlIiwiZXJyIiwiZmluZFByb2dyYW1BZGRyZXNzIiwicHVia2V5RGF0YSIsInB1YmtleSIsImRlZmF1bHQiLCJraW5kIiwiZmllbGRzIiwiQWNjb3VudCIsIl9wdWJsaWNLZXkiLCJfc2VjcmV0S2V5Iiwic2VjcmV0S2V5QnVmZmVyIiwiQlBGX0xPQURFUl9ERVBSRUNBVEVEX1BST0dSQU1fSUQiLCJQQUNLRVRfREFUQV9TSVpFIiwiVkVSU0lPTl9QUkVGSVhfTUFTSyIsIlNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMiLCJUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IiLCJzaWduYXR1cmUiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsIlRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvciIsInRpbWVvdXRTZWNvbmRzIiwidG9GaXhlZCIsIlRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yIiwiTWVzc2FnZUFjY291bnRLZXlzIiwic3RhdGljQWNjb3VudEtleXMiLCJhY2NvdW50S2V5c0Zyb21Mb29rdXBzIiwia2V5U2VnbWVudHMiLCJwdXNoIiwid3JpdGFibGUiLCJyZWFkb25seSIsImdldCIsImluZGV4Iiwia2V5U2VnbWVudCIsImZsYXQiLCJjb21waWxlSW5zdHJ1Y3Rpb25zIiwiaW5zdHJ1Y3Rpb25zIiwiVThfTUFYIiwia2V5SW5kZXhNYXAiLCJmaW5kS2V5SW5kZXgiLCJrZXlJbmRleCIsImluc3RydWN0aW9uIiwicHJvZ3JhbUlkSW5kZXgiLCJhY2NvdW50S2V5SW5kZXhlcyIsIm1ldGEiLCJwcm9wZXJ0eSIsInJ1c3RTdHJpbmciLCJyc2wiLCJzdHJ1Y3QiLCJ1MzIiLCJvZmZzZXQiLCJfZGVjb2RlIiwiYmluZCIsIl9lbmNvZGUiLCJyc2xTaGltIiwic3RyIiwiY2hhcnMiLCJzcGFuIiwiYXV0aG9yaXplZCIsImxvY2t1cCIsIm5zNjQiLCJ2b3RlSW5pdCIsInU4Iiwidm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyIsImdldEFsbG9jIiwiZ2V0SXRlbUFsbG9jIiwiaXRlbSIsImZpZWxkIiwiQXJyYXkiLCJpc0FycmF5IiwiZWxlbWVudExheW91dCIsImxheW91dCIsImRlY29kZUxlbmd0aCIsImJ5dGVzIiwibGVuIiwic2l6ZSIsImVsZW0iLCJzaGlmdCIsImVuY29kZUxlbmd0aCIsInJlbV9sZW4iLCJjb25kaXRpb24iLCJDb21waWxlZEtleXMiLCJwYXllciIsImtleU1ldGFNYXAiLCJjb21waWxlIiwiZ2V0T3JJbnNlcnREZWZhdWx0Iiwia2V5TWV0YSIsImlzU2lnbmVyIiwiaXNXcml0YWJsZSIsImlzSW52b2tlZCIsInBheWVyS2V5TWV0YSIsIml4IiwiYWNjb3VudE1ldGEiLCJnZXRNZXNzYWdlQ29tcG9uZW50cyIsIm1hcEVudHJpZXMiLCJlbnRyaWVzIiwid3JpdGFibGVTaWduZXJzIiwiZmlsdGVyIiwicmVhZG9ubHlTaWduZXJzIiwid3JpdGFibGVOb25TaWduZXJzIiwicmVhZG9ubHlOb25TaWduZXJzIiwiaGVhZGVyIiwibnVtUmVxdWlyZWRTaWduYXR1cmVzIiwibnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyIsIm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyIsInBheWVyQWRkcmVzcyIsImV4dHJhY3RUYWJsZUxvb2t1cCIsImxvb2t1cFRhYmxlIiwid3JpdGFibGVJbmRleGVzIiwiZHJhaW5lZFdyaXRhYmxlS2V5cyIsImRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZSIsInN0YXRlIiwiYWRkcmVzc2VzIiwicmVhZG9ubHlJbmRleGVzIiwiZHJhaW5lZFJlYWRvbmx5S2V5cyIsImFjY291bnRLZXkiLCJsb29rdXBUYWJsZUVudHJpZXMiLCJrZXlNZXRhRmlsdGVyIiwibG9va3VwVGFibGVJbmRleGVzIiwiZHJhaW5lZEtleXMiLCJsb29rdXBUYWJsZUluZGV4IiwiZmluZEluZGV4IiwiZW50cnkiLCJkZWxldGUiLCJFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UiLCJndWFyZGVkU2hpZnQiLCJieXRlQXJyYXkiLCJndWFyZGVkU3BsaWNlIiwiYXJncyIsInN0YXJ0Iiwic3BsaWNlIiwiTWVzc2FnZSIsImFjY291bnRLZXlzIiwicmVjZW50QmxvY2toYXNoIiwiaW5kZXhUb1Byb2dyYW1JZHMiLCJhY2NvdW50IiwidmVyc2lvbiIsImNvbXBpbGVkSW5zdHJ1Y3Rpb25zIiwiYWNjb3VudHMiLCJhZGRyZXNzVGFibGVMb29rdXBzIiwiZ2V0QWNjb3VudEtleXMiLCJjb21waWxlZEtleXMiLCJwYXllcktleSIsImlzQWNjb3VudFNpZ25lciIsImlzQWNjb3VudFdyaXRhYmxlIiwibnVtU2lnbmVkQWNjb3VudHMiLCJ1bnNpZ25lZEFjY291bnRJbmRleCIsIm51bVVuc2lnbmVkQWNjb3VudHMiLCJudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMiLCJudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzIiwiaXNQcm9ncmFtSWQiLCJoYXMiLCJwcm9ncmFtSWRzIiwidmFsdWVzIiwibm9uUHJvZ3JhbUlkcyIsIl8iLCJudW1LZXlzIiwia2V5Q291bnQiLCJrZXlJbmRpY2VzQ291bnQiLCJkYXRhQ291bnQiLCJrZXlJbmRpY2VzIiwiZGF0YUxlbmd0aCIsImluc3RydWN0aW9uQ291bnQiLCJpbnN0cnVjdGlvbkJ1ZmZlciIsImluc3RydWN0aW9uQnVmZmVyTGVuZ3RoIiwiaW5zdHJ1Y3Rpb25MYXlvdXQiLCJzZXEiLCJzaWduRGF0YUxheW91dCIsInRyYW5zYWN0aW9uIiwic2lnbkRhdGEiLCJhY2NvdW50Q291bnQiLCJpIiwiZGF0YVNsaWNlIiwibWVzc2FnZUFyZ3MiLCJNZXNzYWdlVjAiLCJudW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzIiwiY291bnQiLCJsb29rdXAiLCJhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyIsInJlc29sdmVBZGRyZXNzVGFibGVMb29rdXBzIiwibnVtU3RhdGljQWNjb3VudEtleXMiLCJsb29rdXBBY2NvdW50S2V5c0luZGV4IiwibnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cyIsInJlZHVjZSIsInRhYmxlTG9va3VwIiwidGFibGVBY2NvdW50IiwiZmluZCIsImxvb2t1cFRhYmxlQWNjb3VudHMiLCJleHRyYWN0UmVzdWx0IiwiYWRkcmVzc1RhYmxlTG9va3VwIiwiZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoIiwic2VyaWFsaXplZEluc3RydWN0aW9ucyIsInNlcmlhbGl6ZUluc3RydWN0aW9ucyIsImVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgiLCJzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyIsInNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMiLCJlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCIsIm1lc3NhZ2VMYXlvdXQiLCJzZXJpYWxpemVkTWVzc2FnZSIsIk1FU1NBR0VfVkVSU0lPTl8wX1BSRUZJWCIsInNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoIiwicHJlZml4Iiwic3RhdGljQWNjb3VudEtleXNMZW5ndGgiLCJpbnN0cnVjdGlvbnNMZW5ndGgiLCJhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoIiwic2VyaWFsaXplZExlbmd0aCIsImVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCIsImVuY29kZWREYXRhTGVuZ3RoIiwiZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCIsImVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgiLCJhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQiLCJtYXNrZWRQcmVmaXgiLCJhY2NvdW50S2V5SW5kZXhlc0xlbmd0aCIsImFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudCIsIndyaXRhYmxlSW5kZXhlc0xlbmd0aCIsInJlYWRvbmx5SW5kZXhlc0xlbmd0aCIsIlZlcnNpb25lZE1lc3NhZ2UiLCJkZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uIiwiVHJhbnNhY3Rpb25TdGF0dXMiLCJERUZBVUxUX1NJR05BVFVSRSIsImZpbGwiLCJUcmFuc2FjdGlvbkluc3RydWN0aW9uIiwib3B0cyIsIlRyYW5zYWN0aW9uIiwic2lnbmF0dXJlcyIsImZlZVBheWVyIiwibGFzdFZhbGlkQmxvY2tIZWlnaHQiLCJub25jZUluZm8iLCJtaW5Ob25jZUNvbnRleHRTbG90IiwiX21lc3NhZ2UiLCJfanNvbiIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm1pbkNvbnRleHRTbG90IiwiYmxvY2toYXNoIiwibm9uY2VJbnN0cnVjdGlvbiIsInNpZ25lcnMiLCJhZGQiLCJpdGVtcyIsImNvbXBpbGVNZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbnNvbGUiLCJ3YXJuIiwiYWNjb3VudE1ldGFzIiwiaW5jbHVkZXMiLCJ1bmlxdWVNZXRhcyIsInB1YmtleVN0cmluZyIsInVuaXF1ZUluZGV4IiwieCIsInNvcnQiLCJ5Iiwib3B0aW9ucyIsImxvY2FsZU1hdGNoZXIiLCJ1c2FnZSIsInNlbnNpdGl2aXR5IiwiaWdub3JlUHVuY3R1YXRpb24iLCJudW1lcmljIiwiY2FzZUZpcnN0IiwibG9jYWxlQ29tcGFyZSIsImZlZVBheWVySW5kZXgiLCJwYXllck1ldGEiLCJ1bnNoaWZ0Iiwic2lnbmVkS2V5cyIsInVuc2lnbmVkS2V5cyIsImluZGV4T2YiLCJfY29tcGlsZSIsInZhbGlkIiwiZXZlcnkiLCJwYWlyIiwic2VyaWFsaXplTWVzc2FnZSIsImdldEVzdGltYXRlZEZlZSIsImNvbm5lY3Rpb24iLCJnZXRGZWVGb3JNZXNzYWdlIiwic2V0U2lnbmVycyIsInNlZW4iLCJTZXQiLCJ1bmlxdWVTaWduZXJzIiwic2lnbmVyIiwiX3BhcnRpYWxTaWduIiwicGFydGlhbFNpZ24iLCJfYWRkU2lnbmF0dXJlIiwiYWRkU2lnbmF0dXJlIiwic2lncGFpciIsInZlcmlmeVNpZ25hdHVyZXMiLCJyZXF1aXJlQWxsU2lnbmF0dXJlcyIsInNpZ25hdHVyZUVycm9ycyIsIl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyIsImVycm9ycyIsIm1pc3NpbmciLCJpbnZhbGlkIiwiY29uZmlnIiwic2lnRXJyb3JzIiwiZXJyb3JNZXNzYWdlIiwicCIsImpvaW4iLCJfc2VyaWFsaXplIiwic2lnbmF0dXJlQ291bnQiLCJ0cmFuc2FjdGlvbkxlbmd0aCIsIndpcmVUcmFuc2FjdGlvbiIsImtleU9iaiIsInBvcHVsYXRlIiwic2lnUHVia2V5UGFpciIsInNvbWUiLCJUcmFuc2FjdGlvbk1lc3NhZ2UiLCJkZWNvbXBpbGUiLCJjb21waWxlZEl4IiwiY29tcGlsZVRvTGVnYWN5TWVzc2FnZSIsImNvbXBpbGVUb1YwTWVzc2FnZSIsIlZlcnNpb25lZFRyYW5zYWN0aW9uIiwiZGVmYXVsdFNpZ25hdHVyZXMiLCJlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCIsInRyYW5zYWN0aW9uTGF5b3V0Iiwic2VyaWFsaXplZFRyYW5zYWN0aW9uIiwic2VyaWFsaXplZFRyYW5zYWN0aW9uTGVuZ3RoIiwic2lnbmF0dXJlc0xlbmd0aCIsIm1lc3NhZ2VEYXRhIiwic2lnbmVyUHVia2V5cyIsInNpZ25lckluZGV4IiwiTlVNX1RJQ0tTX1BFUl9TRUNPTkQiLCJERUZBVUxUX1RJQ0tTX1BFUl9TTE9UIiwiTlVNX1NMT1RTX1BFUl9TRUNPTkQiLCJNU19QRVJfU0xPVCIsIlNZU1ZBUl9DTE9DS19QVUJLRVkiLCJTWVNWQVJfRVBPQ0hfU0NIRURVTEVfUFVCS0VZIiwiU1lTVkFSX0lOU1RSVUNUSU9OU19QVUJLRVkiLCJTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSIsIlNZU1ZBUl9SRU5UX1BVQktFWSIsIlNZU1ZBUl9SRVdBUkRTX1BVQktFWSIsIlNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVkiLCJTWVNWQVJfU0xPVF9ISVNUT1JZX1BVQktFWSIsIlNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSIsIlNlbmRUcmFuc2FjdGlvbkVycm9yIiwiYWN0aW9uIiwidHJhbnNhY3Rpb25NZXNzYWdlIiwibG9ncyIsIm1heWJlTG9nc091dHB1dCIsImd1aWRlVGV4dCIsImEiLCJ0cmFuc2FjdGlvbkxvZ3MiLCJ0cmFuc2FjdGlvbkVycm9yIiwiY2FjaGVkTG9ncyIsImdldExvZ3MiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImdldFRyYW5zYWN0aW9uIiwidGhlbiIsInR4IiwibG9nTWVzc2FnZXMiLCJjYXRjaCIsIlNvbGFuYUpTT05SUENFcnJvckNvZGUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9UIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVgiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fSElTVE9SWV9OT1RfQVZBSUxBQkxFIiwiSlNPTl9SUENfU0NBTl9FUlJPUiIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQiLCJTb2xhbmFKU09OUlBDRXJyb3IiLCJjb2RlIiwiY3VzdG9tTWVzc2FnZSIsIm5hbWUiLCJzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uIiwic2VuZE9wdGlvbnMiLCJza2lwUHJlZmxpZ2h0IiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsImNvbW1pdG1lbnQiLCJtYXhSZXRyaWVzIiwic2VuZFRyYW5zYWN0aW9uIiwic3RhdHVzIiwiY29uZmlybVRyYW5zYWN0aW9uIiwiYWJvcnRTaWduYWwiLCJub25jZUFjY291bnRQdWJrZXkiLCJub25jZVZhbHVlIiwic2xlZXAiLCJtcyIsInNldFRpbWVvdXQiLCJlbmNvZGVEYXRhIiwiYWxsb2NMZW5ndGgiLCJsYXlvdXRGaWVsZHMiLCJkZWNvZGVEYXRhJDEiLCJGZWVDYWxjdWxhdG9yTGF5b3V0IiwibnU2NCIsIk5vbmNlQWNjb3VudExheW91dCIsIk5PTkNFX0FDQ09VTlRfTEVOR1RIIiwiTm9uY2VBY2NvdW50IiwiYXV0aG9yaXplZFB1YmtleSIsImZlZUNhbGN1bGF0b3IiLCJmcm9tQWNjb3VudERhdGEiLCJub25jZUFjY291bnQiLCJ1NjQiLCJiaWdJbnRMYXlvdXQiLCJjb2RlYyIsInNyYyIsImJpZ0ludCIsIlN5c3RlbUluc3RydWN0aW9uIiwiZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlIiwiY2hlY2tQcm9ncmFtSWQiLCJpbnN0cnVjdGlvblR5cGVMYXlvdXQiLCJ0eXBlSW5kZXgiLCJpeFR5cGUiLCJTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUNyZWF0ZUFjY291bnQiLCJjaGVja0tleUxlbmd0aCIsImxhbXBvcnRzIiwic3BhY2UiLCJDcmVhdGUiLCJmcm9tUHVia2V5IiwibmV3QWNjb3VudFB1YmtleSIsImRlY29kZVRyYW5zZmVyIiwiVHJhbnNmZXIiLCJ0b1B1YmtleSIsImRlY29kZVRyYW5zZmVyV2l0aFNlZWQiLCJUcmFuc2ZlcldpdGhTZWVkIiwiYmFzZVB1YmtleSIsImRlY29kZUFsbG9jYXRlIiwiQWxsb2NhdGUiLCJhY2NvdW50UHVia2V5IiwiZGVjb2RlQWxsb2NhdGVXaXRoU2VlZCIsImJhc2UiLCJBbGxvY2F0ZVdpdGhTZWVkIiwiZGVjb2RlQXNzaWduIiwiQXNzaWduIiwiZGVjb2RlQXNzaWduV2l0aFNlZWQiLCJBc3NpZ25XaXRoU2VlZCIsImRlY29kZUNyZWF0ZVdpdGhTZWVkIiwiQ3JlYXRlV2l0aFNlZWQiLCJkZWNvZGVOb25jZUluaXRpYWxpemUiLCJJbml0aWFsaXplTm9uY2VBY2NvdW50Iiwibm9uY2VQdWJrZXkiLCJkZWNvZGVOb25jZUFkdmFuY2UiLCJBZHZhbmNlTm9uY2VBY2NvdW50IiwiZGVjb2RlTm9uY2VXaXRoZHJhdyIsIldpdGhkcmF3Tm9uY2VBY2NvdW50IiwiZGVjb2RlTm9uY2VBdXRob3JpemUiLCJBdXRob3JpemVOb25jZUFjY291bnQiLCJuZXdBdXRob3JpemVkUHVia2V5IiwiU3lzdGVtUHJvZ3JhbSIsImV4cGVjdGVkTGVuZ3RoIiwiZnJlZXplIiwiVXBncmFkZU5vbmNlQWNjb3VudCIsImNyZWF0ZUFjY291bnQiLCJwYXJhbXMiLCJ0cmFuc2ZlciIsIkJpZ0ludCIsImNyZWF0ZUFjY291bnRXaXRoU2VlZCIsImNyZWF0ZU5vbmNlQWNjb3VudCIsImluaXRQYXJhbXMiLCJub25jZUluaXRpYWxpemUiLCJpbnN0cnVjdGlvbkRhdGEiLCJub25jZUFkdmFuY2UiLCJub25jZVdpdGhkcmF3Iiwibm9uY2VBdXRob3JpemUiLCJhbGxvY2F0ZSIsIkNIVU5LX1NJWkUiLCJMb2FkZXIiLCJnZXRNaW5OdW1TaWduYXR1cmVzIiwiTWF0aCIsImNlaWwiLCJjaHVua1NpemUiLCJsb2FkIiwicHJvZ3JhbSIsImJhbGFuY2VOZWVkZWQiLCJnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24iLCJwcm9ncmFtSW5mbyIsImdldEFjY291bnRJbmZvIiwiZXhlY3V0YWJsZSIsImVycm9yIiwib3duZXIiLCJkYXRhTGF5b3V0IiwidHJhbnNhY3Rpb25zIiwiYnl0ZXNMZW5ndGgiLCJieXRlc0xlbmd0aFBhZGRpbmciLCJfcnBjRW5kcG9pbnQiLCJSRVFVRVNUU19QRVJfU0VDT05EIiwiYWxsIiwiZGVwbG95Q29tbWl0bWVudCIsImZpbmFsaXplU2lnbmF0dXJlIiwiY29udGV4dCIsImN1cnJlbnRTbG90IiwiZ2V0U2xvdCIsInNsb3QiLCJyb3VuZCIsIkJQRl9MT0FERVJfUFJPR1JBTV9JRCIsIkJwZkxvYWRlciIsImVsZiIsImxvYWRlclByb2dyYW1JZCIsImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIiwiX19lc01vZHVsZSIsImFnZW50a2VlcGFsaXZlIiwiZXhwb3J0cyIsImhhc1JlcXVpcmVkTXMiLCJyZXF1aXJlTXMiLCJzIiwibSIsImgiLCJkIiwidyIsInZhbCIsInBhcnNlIiwiaXNGaW5pdGUiLCJsb25nIiwiZm10TG9uZyIsImZtdFNob3J0IiwiU3RyaW5nIiwibWF0Y2giLCJleGVjIiwibiIsInBhcnNlRmxvYXQiLCJ0b0xvd2VyQ2FzZSIsIm1zQWJzIiwiYWJzIiwicGx1cmFsIiwiaXNQbHVyYWwiLCJodW1hbml6ZU1zIiwiaGFzUmVxdWlyZWRIdW1hbml6ZU1zIiwicmVxdWlyZUh1bWFuaXplTXMiLCJ1dGlsIiwidCIsInIiLCJmb3JtYXQiLCJzdGFjayIsImNvbnN0YW50cyIsImhhc1JlcXVpcmVkQ29uc3RhbnRzIiwicmVxdWlyZUNvbnN0YW50cyIsIkNVUlJFTlRfSUQiLCJDUkVBVEVfSUQiLCJJTklUX1NPQ0tFVCIsIkNSRUFURV9IVFRQU19DT05ORUNUSU9OIiwiU09DS0VUX0NSRUFURURfVElNRSIsIlNPQ0tFVF9OQU1FIiwiU09DS0VUX1JFUVVFU1RfQ09VTlQiLCJTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVCIsImFnZW50IiwiaGFzUmVxdWlyZWRBZ2VudCIsInJlcXVpcmVBZ2VudCIsIk9yaWdpbmFsQWdlbnQiLCJkZWJ1ZyIsImRlYnVnbG9nIiwiZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50IiwibWFqb3JWZXJzaW9uIiwicGFyc2VJbnQiLCJwcm9jZXNzIiwic3BsaXQiLCJzdWJzdHJpbmciLCJkZXByZWNhdGUiLCJsb2ciLCJrZWVwQWxpdmUiLCJmcmVlU29ja2V0VGltZW91dCIsImtlZXBBbGl2ZVRpbWVvdXQiLCJmcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCIsInRpbWVvdXQiLCJtYXgiLCJzb2NrZXRBY3RpdmVUVEwiLCJjcmVhdGVTb2NrZXRDb3VudCIsImNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrIiwiY3JlYXRlU29ja2V0RXJyb3JDb3VudCIsImNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2siLCJjbG9zZVNvY2tldENvdW50IiwiY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayIsImVycm9yU29ja2V0Q291bnQiLCJlcnJvclNvY2tldENvdW50TGFzdENoZWNrIiwicmVxdWVzdENvdW50IiwicmVxdWVzdENvdW50TGFzdENoZWNrIiwidGltZW91dFNvY2tldENvdW50IiwidGltZW91dFNvY2tldENvdW50TGFzdENoZWNrIiwib24iLCJzb2NrZXQiLCJjYWxjU29ja2V0VGltZW91dCIsImFsaXZlVGltZSIsIkRhdGUiLCJub3ciLCJkaWZmIiwiY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQiLCJrZWVwU29ja2V0QWxpdmUiLCJyZXN1bHQiLCJjdXN0b21UaW1lb3V0IiwicmV1c2VTb2NrZXQiLCJyZXEiLCJyZXVzZWRTb2NrZXQiLCJhZ2VudFRpbWVvdXQiLCJnZXRTb2NrZXRUaW1lb3V0IiwiaWQiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwic2V0Tm9EZWxheSIsIl9hZ2VudEtleSIsImluc3RhbGxMaXN0ZW5lcnMiLCJjcmVhdGVDb25uZWN0aW9uIiwib25jcmVhdGUiLCJjYWxsZWQiLCJvbk5ld0NyZWF0ZSIsIm5ld1NvY2tldCIsInN0YXR1c0NoYW5nZWQiLCJjaGFuZ2VkIiwiZ2V0Q3VycmVudFN0YXR1cyIsImZyZWVTb2NrZXRzIiwiaW5zcGVjdCIsInNvY2tldHMiLCJyZXF1ZXN0cyIsIl9pZGxlVGltZW91dCIsIm9uRnJlZSIsIl9odHRwTWVzc2FnZSIsImdldE5hbWUiLCJvbkNsb3NlIiwiaXNFcnJvciIsIm9uVGltZW91dCIsImxpc3RlbmVyQ291bnQiLCJsaXN0ZW5lcnMiLCJyZXFUaW1lb3V0TGlzdGVuZXJDb3VudCIsImVuYWJsZWQiLCJmIiwiZGVzdHJveSIsInJlbW92ZVNvY2tldCIsIm9uRXJyb3IiLCJyZW1vdmVMaXN0ZW5lciIsImVtaXQiLCJvblJlbW92ZSIsIm9iaiIsInJlcyIsImh0dHBzX2FnZW50IiwiaGFzUmVxdWlyZWRIdHRwc19hZ2VudCIsInJlcXVpcmVIdHRwc19hZ2VudCIsIk9yaWdpbmFsSHR0cHNBZ2VudCIsIkh0dHBBZ2VudCIsIkh0dHBzQWdlbnQiLCJkZWZhdWx0UG9ydCIsInByb3RvY29sIiwibWF4Q2FjaGVkU2Vzc2lvbnMiLCJfc2Vzc2lvbkNhY2hlIiwibGlzdCIsIm1ldGhvZCIsImhhc1JlcXVpcmVkQWdlbnRrZWVwYWxpdmUiLCJyZXF1aXJlQWdlbnRrZWVwYWxpdmUiLCJhZ2VudGtlZXBhbGl2ZUV4cG9ydHMiLCJIdHRwS2VlcEFsaXZlQWdlbnQiLCJmYXN0U3RhYmxlU3RyaW5naWZ5JDEiLCJoYXNSZXF1aXJlZEZhc3RTdGFibGVTdHJpbmdpZnkiLCJyZXF1aXJlRmFzdFN0YWJsZVN0cmluZ2lmeSIsIm9ialRvU3RyaW5nIiwib2JqS2V5cyIsImlzQXJyYXlQcm9wIiwicHJvcFZhbCIsInRvU3RyIiwicmV0dXJuVmFsIiwiZmFzdFN0YWJsZVN0cmluZ2lmeUV4cG9ydHMiLCJmYXN0U3RhYmxlU3RyaW5naWZ5IiwiTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCIsInRyYWlsaW5nWmVyb3MiLCJuZXh0UG93ZXJPZlR3byIsIkVwb2NoU2NoZWR1bGUiLCJzbG90c1BlckVwb2NoIiwibGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0Iiwid2FybXVwIiwiZmlyc3ROb3JtYWxFcG9jaCIsImZpcnN0Tm9ybWFsU2xvdCIsImdldEVwb2NoIiwiZ2V0RXBvY2hBbmRTbG90SW5kZXgiLCJlcG9jaCIsImVwb2NoTGVuIiwiZ2V0U2xvdHNJbkVwb2NoIiwic2xvdEluZGV4Iiwibm9ybWFsU2xvdEluZGV4Iiwibm9ybWFsRXBvY2hJbmRleCIsImZsb29yIiwiZ2V0Rmlyc3RTbG90SW5FcG9jaCIsInBvdyIsImdldExhc3RTbG90SW5FcG9jaCIsImZldGNoSW1wbCIsImdsb2JhbFRoaXMiLCJmZXRjaCIsImlucHV0IiwiaW5pdCIsInByb2Nlc3NlZElucHV0IiwiUnBjV2ViU29ja2V0Q2xpZW50IiwiZ2VuZXJhdGVfcmVxdWVzdF9pZCIsIndlYlNvY2tldEZhY3RvcnkiLCJ1cmwiLCJycGMiLCJhdXRvY29ubmVjdCIsIm1heF9yZWNvbm5lY3RzIiwicmVjb25uZWN0IiwicmVjb25uZWN0X2ludGVydmFsIiwidW5kZXJseWluZ1NvY2tldCIsInJlYWR5U3RhdGUiLCJub3RpZnkiLCJkZWNvZGVEYXRhIiwiTE9PS1VQX1RBQkxFX01FVEFfU0laRSIsIkFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQiLCJpc0FjdGl2ZSIsIlU2NF9NQVgiLCJkZWFjdGl2YXRpb25TbG90IiwiYWNjb3VudERhdGEiLCJMb29rdXBUYWJsZU1ldGFMYXlvdXQiLCJzZXJpYWxpemVkQWRkcmVzc2VzTGVuIiwibnVtU2VyaWFsaXplZEFkZHJlc3NlcyIsImxhc3RFeHRlbmRlZFNsb3QiLCJsYXN0RXh0ZW5kZWRTbG90U3RhcnRJbmRleCIsImxhc3RFeHRlbmRlZFN0YXJ0SW5kZXgiLCJhdXRob3JpdHkiLCJVUkxfUkUiLCJtYWtlV2Vic29ja2V0VXJsIiwiZW5kcG9pbnQiLCJtYXRjaGVzIiwiaG9zdGlzaCIsInBvcnRXaXRoQ29sb24iLCJyZXN0Iiwic3RhcnRzV2l0aCIsInN0YXJ0UG9ydCIsIndlYnNvY2tldFBvcnQiLCJQdWJsaWNLZXlGcm9tU3RyaW5nIiwiUmF3QWNjb3VudERhdGFSZXN1bHQiLCJCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEiLCJCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUyIsImFzc2VydEVuZHBvaW50VXJsIiwicHV0YXRpdmVVcmwiLCJ0ZXN0IiwiZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnIiwiY29tbWl0bWVudE9yQ29uZmlnIiwic3BlY2lmaWVkQ29tbWl0bWVudCIsInNwZWNpZmllZENvbmZpZyIsImFwcGx5RGVmYXVsdE1lbWNtcEVuY29kaW5nVG9GaWx0ZXJzIiwiZmlsdGVycyIsIm1lbWNtcCIsImVuY29kaW5nIiwiY3JlYXRlUnBjUmVzdWx0IiwianNvbnJwYyIsIlVua25vd25ScGNSZXN1bHQiLCJqc29uUnBjUmVzdWx0Iiwic2NoZW1hIiwianNvblJwY1Jlc3VsdEFuZENvbnRleHQiLCJub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0IiwidmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSIsInJlc3BvbnNlIiwiR2V0SW5mbGF0aW9uR292ZXJub3JSZXN1bHQiLCJmb3VuZGF0aW9uIiwiZm91bmRhdGlvblRlcm0iLCJpbml0aWFsIiwidGFwZXIiLCJ0ZXJtaW5hbCIsIkdldEluZmxhdGlvblJld2FyZFJlc3VsdCIsImVmZmVjdGl2ZVNsb3QiLCJhbW91bnQiLCJwb3N0QmFsYW5jZSIsImNvbW1pc3Npb24iLCJHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQiLCJwcmlvcml0aXphdGlvbkZlZSIsIkdldEluZmxhdGlvblJhdGVSZXN1bHQiLCJ0b3RhbCIsInZhbGlkYXRvciIsIkdldEVwb2NoSW5mb1Jlc3VsdCIsInNsb3RzSW5FcG9jaCIsImFic29sdXRlU2xvdCIsImJsb2NrSGVpZ2h0IiwidHJhbnNhY3Rpb25Db3VudCIsIkdldEVwb2NoU2NoZWR1bGVSZXN1bHQiLCJHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCIsIlRyYW5zYWN0aW9uRXJyb3JSZXN1bHQiLCJTaWduYXR1cmVTdGF0dXNSZXN1bHQiLCJTaWduYXR1cmVSZWNlaXZlZFJlc3VsdCIsIlZlcnNpb25SZXN1bHQiLCJQYXJzZWRJbnN0cnVjdGlvblN0cnVjdCIsInBhcnNlZCIsIlBhcnRpYWxseURlY29kZWRJbnN0cnVjdGlvblN0cnVjdCIsIlNpbXVsYXRlZFRyYW5zYWN0aW9uUmVzcG9uc2VTdHJ1Y3QiLCJyZW50RXBvY2giLCJ1bml0c0NvbnN1bWVkIiwicmV0dXJuRGF0YSIsImlubmVySW5zdHJ1Y3Rpb25zIiwiQmxvY2tQcm9kdWN0aW9uUmVzcG9uc2VTdHJ1Y3QiLCJieUlkZW50aXR5IiwicmFuZ2UiLCJmaXJzdFNsb3QiLCJsYXN0U2xvdCIsImNyZWF0ZVJwY0NsaWVudCIsImh0dHBIZWFkZXJzIiwiY3VzdG9tRmV0Y2giLCJmZXRjaE1pZGRsZXdhcmUiLCJkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCIsImh0dHBBZ2VudCIsImFnZW50T3B0aW9ucyIsIm1heFNvY2tldHMiLCJpc0h0dHBzIiwiZmV0Y2hXaXRoTWlkZGxld2FyZSIsImluZm8iLCJtb2RpZmllZEZldGNoQXJncyIsIm1vZGlmaWVkSW5mbyIsIm1vZGlmaWVkSW5pdCIsImNsaWVudEJyb3dzZXIiLCJyZXF1ZXN0IiwiY2FsbGJhY2siLCJib2R5IiwiaGVhZGVycyIsIkNPTU1PTl9IVFRQX0hFQURFUlMiLCJ0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzIiwid2FpdFRpbWUiLCJzdGF0dXNUZXh0IiwidGV4dCIsIm9rIiwiY3JlYXRlUnBjUmVxdWVzdCIsImNsaWVudCIsImNyZWF0ZVJwY0JhdGNoUmVxdWVzdCIsImJhdGNoIiwibWV0aG9kTmFtZSIsIkdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0IiwiR2V0SW5mbGF0aW9uUmF0ZVJwY1Jlc3VsdCIsIkdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1JwY1Jlc3VsdCIsIkdldEVwb2NoSW5mb1JwY1Jlc3VsdCIsIkdldEVwb2NoU2NoZWR1bGVScGNSZXN1bHQiLCJHZXRMZWFkZXJTY2hlZHVsZVJwY1Jlc3VsdCIsIlNsb3RScGNSZXN1bHQiLCJHZXRTdXBwbHlScGNSZXN1bHQiLCJjaXJjdWxhdGluZyIsIm5vbkNpcmN1bGF0aW5nIiwibm9uQ2lyY3VsYXRpbmdBY2NvdW50cyIsIlRva2VuQW1vdW50UmVzdWx0IiwidWlBbW91bnQiLCJkZWNpbWFscyIsInVpQW1vdW50U3RyaW5nIiwiR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQiLCJHZXRUb2tlbkFjY291bnRzQnlPd25lciIsIlBhcnNlZEFjY291bnREYXRhUmVzdWx0IiwiR2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIiLCJHZXRMYXJnZXN0QWNjb3VudHNScGNSZXN1bHQiLCJBY2NvdW50SW5mb1Jlc3VsdCIsIktleWVkQWNjb3VudEluZm9SZXN1bHQiLCJQYXJzZWRPclJhd0FjY291bnREYXRhIiwiUGFyc2VkQWNjb3VudEluZm9SZXN1bHQiLCJLZXllZFBhcnNlZEFjY291bnRJbmZvUmVzdWx0IiwiU3Rha2VBY3RpdmF0aW9uUmVzdWx0IiwiYWN0aXZlIiwiaW5hY3RpdmUiLCJHZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJScGNSZXN1bHQiLCJtZW1vIiwiYmxvY2tUaW1lIiwiR2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NScGNSZXN1bHQiLCJBY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0Iiwic3Vic2NyaXB0aW9uIiwiUHJvZ3JhbUFjY291bnRJbmZvUmVzdWx0IiwiUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQiLCJTbG90SW5mb1Jlc3VsdCIsInBhcmVudCIsInJvb3QiLCJTbG90Tm90aWZpY2F0aW9uUmVzdWx0IiwiU2xvdFVwZGF0ZVJlc3VsdCIsInRpbWVzdGFtcCIsInN0YXRzIiwibnVtVHJhbnNhY3Rpb25FbnRyaWVzIiwibnVtU3VjY2Vzc2Z1bFRyYW5zYWN0aW9ucyIsIm51bUZhaWxlZFRyYW5zYWN0aW9ucyIsIm1heFRyYW5zYWN0aW9uc1BlckVudHJ5IiwiU2xvdFVwZGF0ZU5vdGlmaWNhdGlvblJlc3VsdCIsIlNpZ25hdHVyZU5vdGlmaWNhdGlvblJlc3VsdCIsIlJvb3ROb3RpZmljYXRpb25SZXN1bHQiLCJDb250YWN0SW5mb1Jlc3VsdCIsImdvc3NpcCIsInRwdSIsIlZvdGVBY2NvdW50SW5mb1Jlc3VsdCIsInZvdGVQdWJrZXkiLCJub2RlUHVia2V5IiwiYWN0aXZhdGVkU3Rha2UiLCJlcG9jaFZvdGVBY2NvdW50IiwiZXBvY2hDcmVkaXRzIiwibGFzdFZvdGUiLCJyb290U2xvdCIsIkdldFZvdGVBY2NvdW50cyIsImN1cnJlbnQiLCJkZWxpbnF1ZW50IiwiQ29uZmlybWF0aW9uU3RhdHVzIiwiU2lnbmF0dXJlU3RhdHVzUmVzcG9uc2UiLCJjb25maXJtYXRpb25zIiwiY29uZmlybWF0aW9uU3RhdHVzIiwiR2V0U2lnbmF0dXJlU3RhdHVzZXNScGNSZXN1bHQiLCJHZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25ScGNSZXN1bHQiLCJBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QiLCJDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCIsIkFubm90YXRlZEFjY291bnRLZXkiLCJzb3VyY2UiLCJDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCIsIlBhcnNlZEluc3RydWN0aW9uUmVzdWx0IiwiUmF3SW5zdHJ1Y3Rpb25SZXN1bHQiLCJJbnN0cnVjdGlvblJlc3VsdCIsIlVua25vd25JbnN0cnVjdGlvblJlc3VsdCIsIlBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24iLCJQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCIsIlRva2VuQmFsYW5jZVJlc3VsdCIsImFjY291bnRJbmRleCIsIm1pbnQiLCJ1aVRva2VuQW1vdW50IiwiTG9hZGVkQWRkcmVzc2VzUmVzdWx0IiwiQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0IiwiZmVlIiwicHJlQmFsYW5jZXMiLCJwb3N0QmFsYW5jZXMiLCJwcmVUb2tlbkJhbGFuY2VzIiwicG9zdFRva2VuQmFsYW5jZXMiLCJsb2FkZWRBZGRyZXNzZXMiLCJjb21wdXRlVW5pdHNDb25zdW1lZCIsImNvc3RVbml0cyIsIlBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCIsIlRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdCIsIlJld2FyZHNSZXN1bHQiLCJyZXdhcmRUeXBlIiwiR2V0QmxvY2tScGNSZXN1bHQiLCJwcmV2aW91c0Jsb2NraGFzaCIsInBhcmVudFNsb3QiLCJyZXdhcmRzIiwiR2V0Tm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQiLCJHZXRQYXJzZWRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldFBhcnNlZE5vbmVNb2RlQmxvY2tScGNSZXN1bHQiLCJHZXRDb25maXJtZWRCbG9ja1JwY1Jlc3VsdCIsIkdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCIsIkdldFRyYW5zYWN0aW9uUnBjUmVzdWx0IiwiR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQiLCJJc0Jsb2NraGFzaFZhbGlkUnBjUmVzdWx0IiwiUGVyZlNhbXBsZVJlc3VsdCIsIm51bVRyYW5zYWN0aW9ucyIsIm51bVNsb3RzIiwic2FtcGxlUGVyaW9kU2VjcyIsIkdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCIsIkdldEZlZUNhbGN1bGF0b3JScGNSZXN1bHQiLCJsYW1wb3J0c1BlclNpZ25hdHVyZSIsIlJlcXVlc3RBaXJkcm9wUnBjUmVzdWx0IiwiU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0IiwiTG9nc1Jlc3VsdCIsIkxvZ3NOb3RpZmljYXRpb25SZXN1bHQiLCJDb25uZWN0aW9uIiwiX2NvbW1pdG1lbnRPckNvbmZpZyIsIl9jb21taXRtZW50IiwiX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IiwiX3JwY1dzRW5kcG9pbnQiLCJfcnBjQ2xpZW50IiwiX3JwY1JlcXVlc3QiLCJfcnBjQmF0Y2hSZXF1ZXN0IiwiX3JwY1dlYlNvY2tldCIsIl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQiLCJfcnBjV2ViU29ja2V0SGVhcnRiZWF0IiwiX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0IiwiX3JwY1dlYlNvY2tldEdlbmVyYXRpb24iLCJfZGlzYWJsZUJsb2NraGFzaENhY2hpbmciLCJfcG9sbGluZ0Jsb2NraGFzaCIsIl9ibG9ja2hhc2hJbmZvIiwibGF0ZXN0QmxvY2toYXNoIiwibGFzdEZldGNoIiwidHJhbnNhY3Rpb25TaWduYXR1cmVzIiwic2ltdWxhdGVkU2lnbmF0dXJlcyIsIl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2giLCJfc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25zQnlIYXNoIiwiX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYyIsImdldEJsb2NrSGVpZ2h0IiwicmVxdWVzdFByb21pc2VzIiwiX2J1aWxkQXJncyIsInJlcXVlc3RIYXNoIiwidW5zYWZlUmVzIiwid3NFbmRwb2ludCIsImNvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IiwiSW5maW5pdHkiLCJfd3NPbk9wZW4iLCJfd3NPbkVycm9yIiwiX3dzT25DbG9zZSIsIl93c09uQWNjb3VudE5vdGlmaWNhdGlvbiIsIl93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24iLCJfd3NPblNsb3ROb3RpZmljYXRpb24iLCJfd3NPblNsb3RVcGRhdGVzTm90aWZpY2F0aW9uIiwiX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24iLCJfd3NPblJvb3ROb3RpZmljYXRpb24iLCJfd3NPbkxvZ3NOb3RpZmljYXRpb24iLCJycGNFbmRwb2ludCIsImdldEJhbGFuY2VBbmRDb250ZXh0IiwiZ2V0QmFsYW5jZSIsImUiLCJnZXRCbG9ja1RpbWUiLCJnZXRNaW5pbXVtTGVkZ2VyU2xvdCIsImdldEZpcnN0QXZhaWxhYmxlQmxvY2siLCJnZXRTdXBwbHkiLCJjb25maWdBcmciLCJnZXRUb2tlblN1cHBseSIsInRva2VuTWludEFkZHJlc3MiLCJnZXRUb2tlbkFjY291bnRCYWxhbmNlIiwidG9rZW5BZGRyZXNzIiwiZ2V0VG9rZW5BY2NvdW50c0J5T3duZXIiLCJvd25lckFkZHJlc3MiLCJfYXJncyIsImdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyIiwiZ2V0TGFyZ2VzdEFjY291bnRzIiwiYXJnIiwiZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMiLCJtaW50QWRkcmVzcyIsImdldEFjY291bnRJbmZvQW5kQ29udGV4dCIsImdldFBhcnNlZEFjY291bnRJbmZvIiwiZ2V0TXVsdGlwbGVQYXJzZWRBY2NvdW50cyIsInB1YmxpY0tleXMiLCJyYXdDb25maWciLCJnZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQiLCJnZXRNdWx0aXBsZUFjY291bnRzSW5mbyIsImdldFN0YWtlQWN0aXZhdGlvbiIsImdldFByb2dyYW1BY2NvdW50cyIsImNvbmZpZ09yQ29tbWl0bWVudCIsImNvbmZpZ1dpdGhvdXRFbmNvZGluZyIsImJhc2VTY2hlbWEiLCJ3aXRoQ29udGV4dCIsImdldFBhcnNlZFByb2dyYW1BY2NvdW50cyIsInN0cmF0ZWd5IiwicmF3U2lnbmF0dXJlIiwiYWJvcnRlZCIsInJlYXNvbiIsImRlY29kZWRTaWduYXR1cmUiLCJjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSIsImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3kiLCJjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5IiwiZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZSIsInNpZ25hbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2UiLCJzaWduYXR1cmVTdWJzY3JpcHRpb25JZCIsImRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyIiwiZG9uZSIsImNvbmZpcm1hdGlvblByb21pc2UiLCJvblNpZ25hdHVyZSIsIl9fdHlwZSIsIlBST0NFU1NFRCIsInN1YnNjcmlwdGlvblNldHVwUHJvbWlzZSIsInJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCIsIl9vblN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlIiwibmV4dFN0YXRlIiwiZ2V0U2lnbmF0dXJlU3RhdHVzIiwiYWJvcnRDb25maXJtYXRpb24iLCJyZW1vdmVTaWduYXR1cmVMaXN0ZW5lciIsImV4cGlyeVByb21pc2UiLCJjaGVja0Jsb2NrSGVpZ2h0IiwiX2UiLCJjdXJyZW50QmxvY2tIZWlnaHQiLCJCTE9DS0hFSUdIVF9FWENFRURFRCIsImNhbmNlbGxhdGlvblByb21pc2UiLCJvdXRjb21lIiwicmFjZSIsImN1cnJlbnROb25jZVZhbHVlIiwibGFzdENoZWNrZWRTbG90IiwiZ2V0Q3VycmVudE5vbmNlVmFsdWUiLCJnZXROb25jZUFuZENvbnRleHQiLCJOT05DRV9JTlZBTElEIiwic2xvdEluV2hpY2hOb25jZURpZEFkdmFuY2UiLCJzaWduYXR1cmVTdGF0dXMiLCJjb21taXRtZW50Rm9yU3RhdHVzIiwidGltZW91dElkIiwidGltZW91dE1zIiwiVElNRURfT1VUIiwiY2xlYXJUaW1lb3V0IiwiZ2V0Q2x1c3Rlck5vZGVzIiwiZ2V0Vm90ZUFjY291bnRzIiwiZ2V0U2xvdExlYWRlciIsImdldFNsb3RMZWFkZXJzIiwic3RhcnRTbG90IiwibGltaXQiLCJnZXRTaWduYXR1cmVTdGF0dXNlcyIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJnZXRUb3RhbFN1cHBseSIsImV4Y2x1ZGVOb25DaXJjdWxhdGluZ0FjY291bnRzTGlzdCIsImdldEluZmxhdGlvbkdvdmVybm9yIiwiZ2V0SW5mbGF0aW9uUmV3YXJkIiwiZ2V0SW5mbGF0aW9uUmF0ZSIsImdldEVwb2NoSW5mbyIsImdldEVwb2NoU2NoZWR1bGUiLCJlcG9jaFNjaGVkdWxlIiwiZ2V0TGVhZGVyU2NoZWR1bGUiLCJnZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0IiwiZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dCIsImdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlcyIsImdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2giLCJ3aXJlTWVzc2FnZSIsImdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcyIsImxvY2tlZFdyaXRhYmxlQWNjb3VudHMiLCJnZXRSZWNlbnRCbG9ja2hhc2giLCJnZXRMYXRlc3RCbG9ja2hhc2giLCJpc0Jsb2NraGFzaFZhbGlkIiwiZ2V0VmVyc2lvbiIsImdldEdlbmVzaXNIYXNoIiwiZ2V0QmxvY2siLCJfYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZCIsInRyYW5zYWN0aW9uRGV0YWlscyIsImdldFBhcnNlZEJsb2NrIiwiZ2V0QmxvY2tQcm9kdWN0aW9uIiwiZXh0cmEiLCJjIiwiZ2V0UGFyc2VkVHJhbnNhY3Rpb24iLCJnZXRQYXJzZWRUcmFuc2FjdGlvbnMiLCJnZXRUcmFuc2FjdGlvbnMiLCJnZXRDb25maXJtZWRCbG9jayIsImJsb2NrIiwiZ2V0QmxvY2tzIiwiZW5kU2xvdCIsImdldEJsb2NrU2lnbmF0dXJlcyIsImdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyIsImdldENvbmZpcm1lZFRyYW5zYWN0aW9uIiwiZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb24iLCJnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbnMiLCJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzcyIsImZpcnN0QXZhaWxhYmxlQmxvY2siLCJ1bnRpbCIsImhpZ2hlc3RDb25maXJtZWRSb290IiwiYmVmb3JlIiwiY29uZmlybWVkU2lnbmF0dXJlSW5mbyIsImdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMiIsImdldFNpZ25hdHVyZXNGb3JBZGRyZXNzIiwiZ2V0QWRkcmVzc0xvb2t1cFRhYmxlIiwiYWNjb3VudEluZm8iLCJnZXROb25jZSIsInJlcXVlc3RBaXJkcm9wIiwidG8iLCJfYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0IiwiZGlzYWJsZUNhY2hlIiwidGltZVNpbmNlRmV0Y2giLCJleHBpcmVkIiwiX3BvbGxOZXdCbG9ja2hhc2giLCJzdGFydFRpbWUiLCJjYWNoZWRMYXRlc3RCbG9ja2hhc2giLCJjYWNoZWRCbG9ja2hhc2giLCJnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uIiwic2ltdWxhdGVUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uT3JNZXNzYWdlIiwiY29uZmlnT3JTaWduZXJzIiwiaW5jbHVkZUFjY291bnRzIiwidmVyc2lvbmVkVHgiLCJlbmNvZGVkVHJhbnNhY3Rpb24iLCJvcmlnaW5hbFR4Iiwic2lnVmVyaWZ5IiwidHJhY2VJbmRlbnQiLCJsb2dUcmFjZSIsInNpZ25lcnNPck9wdGlvbnMiLCJzZW5kUmF3VHJhbnNhY3Rpb24iLCJyYXdUcmFuc2FjdGlvbiIsInNlbmRFbmNvZGVkVHJhbnNhY3Rpb24iLCJzZXRJbnRlcnZhbCIsIl91cGRhdGVTdWJzY3JpcHRpb25zIiwiY2xlYXJJbnRlcnZhbCIsImhhc2giLCJfc2V0U3Vic2NyaXB0aW9uIiwibmV4dFN1YnNjcmlwdGlvbiIsInByZXZTdGF0ZSIsInN0YXRlQ2hhbmdlQ2FsbGJhY2tzIiwiY2IiLCJjbGllbnRTdWJzY3JpcHRpb25JZCIsImNsb3NlIiwiY29ubmVjdCIsImFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24iLCJpc0N1cnJlbnRDb25uZWN0aW9uU3RpbGxBY3RpdmUiLCJjYWxsYmFja3MiLCJzZXJ2ZXJTdWJzY3JpcHRpb25JZCIsInVuc3Vic2NyaWJlTWV0aG9kIiwiX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbiIsImNhbGxiYWNrQXJncyIsIm5vdGlmaWNhdGlvbiIsIl9tYWtlU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uQ29uZmlnIiwiZXhpc3RpbmdTdWJzY3JpcHRpb24iLCJvbkFjY291bnRDaGFuZ2UiLCJyZW1vdmVBY2NvdW50Q2hhbmdlTGlzdGVuZXIiLCJfdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24iLCJhY2NvdW50SWQiLCJvblByb2dyYW1BY2NvdW50Q2hhbmdlIiwibWF5YmVGaWx0ZXJzIiwicmVtb3ZlUHJvZ3JhbUFjY291bnRDaGFuZ2VMaXN0ZW5lciIsIm9uTG9ncyIsIm1lbnRpb25zIiwicmVtb3ZlT25Mb2dzTGlzdGVuZXIiLCJvblNsb3RDaGFuZ2UiLCJyZW1vdmVTbG90Q2hhbmdlTGlzdGVuZXIiLCJvblNsb3RVcGRhdGUiLCJyZW1vdmVTbG90VXBkYXRlTGlzdGVuZXIiLCJzdWJzY3JpcHRpb25OYW1lIiwiZGlzcG9zZSIsIm92ZXJyaWRlIiwiX2VyciIsIm9uU2lnbmF0dXJlV2l0aE9wdGlvbnMiLCJvblJvb3RDaGFuZ2UiLCJyZW1vdmVSb290Q2hhbmdlTGlzdGVuZXIiLCJLZXlwYWlyIiwia2V5cGFpciIsIl9rZXlwYWlyIiwiZ2VuZXJhdGUiLCJmcm9tU2VjcmV0S2V5Iiwic2tpcFZhbGlkYXRpb24iLCJjb21wdXRlZFB1YmxpY0tleSIsImlpIiwiZnJvbVNlZWQiLCJMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUyIsIkNyZWF0ZUxvb2t1cFRhYmxlIiwiRnJlZXplTG9va3VwVGFibGUiLCJFeHRlbmRMb29rdXBUYWJsZSIsIkRlYWN0aXZhdGVMb29rdXBUYWJsZSIsIkNsb3NlTG9va3VwVGFibGUiLCJBZGRyZXNzTG9va3VwVGFibGVJbnN0cnVjdGlvbiIsImxheW91dFR5cGUiLCJkZWNvZGVDcmVhdGVMb29rdXBUYWJsZSIsImNoZWNrS2V5c0xlbmd0aCIsInJlY2VudFNsb3QiLCJkZWNvZGVFeHRlbmRMb29rdXBUYWJsZSIsImRlY29kZUNsb3NlTG9va3VwVGFibGUiLCJyZWNpcGllbnQiLCJkZWNvZGVGcmVlemVMb29rdXBUYWJsZSIsImRlY29kZURlYWN0aXZhdGVMb29rdXBUYWJsZSIsIkFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0iLCJjcmVhdGVMb29rdXBUYWJsZSIsImxvb2t1cFRhYmxlQWRkcmVzcyIsImJ1bXBTZWVkIiwiZnJlZXplTG9va3VwVGFibGUiLCJleHRlbmRMb29rdXBUYWJsZSIsImFkZHIiLCJkZWFjdGl2YXRlTG9va3VwVGFibGUiLCJjbG9zZUxvb2t1cFRhYmxlIiwiQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uIiwiQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZVJlcXVlc3RVbml0cyIsInVuaXRzIiwiYWRkaXRpb25hbEZlZSIsIlJlcXVlc3RVbml0cyIsImRlY29kZVJlcXVlc3RIZWFwRnJhbWUiLCJSZXF1ZXN0SGVhcEZyYW1lIiwiZGVjb2RlU2V0Q29tcHV0ZVVuaXRMaW1pdCIsIlNldENvbXB1dGVVbml0TGltaXQiLCJkZWNvZGVTZXRDb21wdXRlVW5pdFByaWNlIiwibWljcm9MYW1wb3J0cyIsIlNldENvbXB1dGVVbml0UHJpY2UiLCJDb21wdXRlQnVkZ2V0UHJvZ3JhbSIsInJlcXVlc3RVbml0cyIsInJlcXVlc3RIZWFwRnJhbWUiLCJzZXRDb21wdXRlVW5pdExpbWl0Iiwic2V0Q29tcHV0ZVVuaXRQcmljZSIsIlBSSVZBVEVfS0VZX0JZVEVTJDEiLCJQVUJMSUNfS0VZX0JZVEVTJDEiLCJTSUdOQVRVUkVfQllURVMiLCJFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVCIsInUxNiIsIkVkMjU1MTlQcm9ncmFtIiwiY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5IiwiaW5zdHJ1Y3Rpb25JbmRleCIsInB1YmxpY0tleU9mZnNldCIsInNpZ25hdHVyZU9mZnNldCIsIm1lc3NhZ2VEYXRhT2Zmc2V0IiwibnVtU2lnbmF0dXJlcyIsInBhZGRpbmciLCJzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4IiwicHVibGljS2V5SW5zdHJ1Y3Rpb25JbmRleCIsIm1lc3NhZ2VEYXRhU2l6ZSIsIm1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4IiwiY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJlY2RzYVNpZ24iLCJtc2dIYXNoIiwicHJpdktleSIsInRvQ29tcGFjdFJhd0J5dGVzIiwicmVjb3ZlcnkiLCJpc1ZhbGlkUHJpdmF0ZUtleSIsInB1YmxpY0tleUNyZWF0ZSIsIlBSSVZBVEVfS0VZX0JZVEVTIiwiRVRIRVJFVU1fQUREUkVTU19CWVRFUyIsIlBVQkxJQ19LRVlfQllURVMiLCJTSUdOQVRVUkVfT0ZGU0VUU19TRVJJQUxJWkVEX1NJWkUiLCJTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VUIiwiU2VjcDI1NmsxUHJvZ3JhbSIsInB1YmxpY0tleVRvRXRoQWRkcmVzcyIsInJlY292ZXJ5SWQiLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzIiwiZXRoQWRkcmVzcyIsInJhd0FkZHJlc3MiLCJzdWJzdHIiLCJkYXRhU3RhcnQiLCJldGhBZGRyZXNzT2Zmc2V0IiwiZXRoQWRkcmVzc0luc3RydWN0aW9uSW5kZXgiLCJwa2V5IiwibWVzc2FnZUhhc2giLCJfTG9ja3VwIiwiU1RBS0VfQ09ORklHX0lEIiwiQXV0aG9yaXplZCIsInN0YWtlciIsIndpdGhkcmF3ZXIiLCJMb2NrdXAiLCJ1bml4VGltZXN0YW1wIiwiY3VzdG9kaWFuIiwiU3Rha2VJbnN0cnVjdGlvbiIsIlNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCJkZWNvZGVJbml0aWFsaXplIiwiSW5pdGlhbGl6ZSIsInN0YWtlUHVia2V5IiwiZGVjb2RlRGVsZWdhdGUiLCJEZWxlZ2F0ZSIsImRlY29kZUF1dGhvcml6ZSIsIm5ld0F1dGhvcml6ZWQiLCJzdGFrZUF1dGhvcml6YXRpb25UeXBlIiwiQXV0aG9yaXplIiwibyIsImN1c3RvZGlhblB1YmtleSIsImRlY29kZUF1dGhvcml6ZVdpdGhTZWVkIiwiYXV0aG9yaXR5U2VlZCIsImF1dGhvcml0eU93bmVyIiwiQXV0aG9yaXplV2l0aFNlZWQiLCJhdXRob3JpdHlCYXNlIiwiZGVjb2RlU3BsaXQiLCJTcGxpdCIsInNwbGl0U3Rha2VQdWJrZXkiLCJkZWNvZGVNZXJnZSIsIk1lcmdlIiwic291cmNlU3Rha2VQdWJLZXkiLCJkZWNvZGVXaXRoZHJhdyIsIldpdGhkcmF3IiwiZGVjb2RlRGVhY3RpdmF0ZSIsIkRlYWN0aXZhdGUiLCJTdGFrZVByb2dyYW0iLCJTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQiLCJTdGFrZXIiLCJXaXRoZHJhd2VyIiwiaW5pdGlhbGl6ZSIsIm1heWJlTG9ja3VwIiwiZGVsZWdhdGUiLCJhdXRob3JpemUiLCJhdXRob3JpemVXaXRoU2VlZCIsInNwbGl0SW5zdHJ1Y3Rpb24iLCJyZW50RXhlbXB0UmVzZXJ2ZSIsInNwbGl0V2l0aFNlZWQiLCJtZXJnZSIsIndpdGhkcmF3IiwiZGVhY3RpdmF0ZSIsIlZvdGVJbml0IiwiYXV0aG9yaXplZFZvdGVyIiwiYXV0aG9yaXplZFdpdGhkcmF3ZXIiLCJWb3RlSW5zdHJ1Y3Rpb24iLCJWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCJkZWNvZGVJbml0aWFsaXplQWNjb3VudCIsIkluaXRpYWxpemVBY2NvdW50Iiwidm90ZUF1dGhvcml6YXRpb25UeXBlIiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSIsImN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCIsImN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleSIsImF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5IiwiVm90ZVByb2dyYW0iLCJVcGRhdGVWYWxpZGF0b3JJZGVudGl0eSIsIlZvdGVBdXRob3JpemF0aW9uTGF5b3V0IiwiVm90ZXIiLCJpbml0aWFsaXplQWNjb3VudCIsInNhZmVXaXRoZHJhdyIsImN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UiLCJyZW50RXhlbXB0TWluaW11bSIsInVwZGF0ZVZhbGlkYXRvcklkZW50aXR5IiwiVkFMSURBVE9SX0lORk9fS0VZIiwiSW5mb1N0cmluZyIsIndlYnNpdGUiLCJkZXRhaWxzIiwiaWNvblVybCIsImtleWJhc2VVc2VybmFtZSIsIlZhbGlkYXRvckluZm8iLCJmcm9tQ29uZmlnRGF0YSIsImNvbmZpZ0tleUNvdW50IiwiY29uZmlnS2V5cyIsInJhd0luZm8iLCJWT1RFX1BST0dSQU1fSUQiLCJWb3RlQWNjb3VudExheW91dCIsIlZvdGVBY2NvdW50Iiwidm90ZXMiLCJhdXRob3JpemVkVm90ZXJzIiwicHJpb3JWb3RlcnMiLCJsYXN0VGltZXN0YW1wIiwidmVyc2lvbk9mZnNldCIsInZhIiwicm9vdFNsb3RWYWxpZCIsInBhcnNlQXV0aG9yaXplZFZvdGVyIiwiZ2V0UHJpb3JWb3RlcnMiLCJwYXJzZVByaW9yVm90ZXJzIiwiZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoIiwidGFyZ2V0RXBvY2giLCJpZHgiLCJpc0VtcHR5IiwiaHR0cCIsImRldm5ldCIsInRlc3RuZXQiLCJodHRwcyIsImNsdXN0ZXJBcGlVcmwiLCJjbHVzdGVyIiwidGxzIiwic2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbiIsImNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucyIsIm1heWJlQ29uZmlybU9wdGlvbnMiLCJjb25maXJtYXRpb25TdHJhdGVneSIsIkxBTVBPUlRTX1BFUl9TT0wiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/base-x/src/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/base-x/src/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer);\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n    ;\n    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n    ;\n    function encode(source) {\n        if (Array.isArray(source) || source instanceof Uint8Array) {\n            source = _Buffer.from(source);\n        }\n        if (!_Buffer.isBuffer(source)) {\n            throw new TypeError(\"Expected Buffer\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return _Buffer.alloc(0);\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.\n        ;\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(psz < source.length){\n            // Find code of next character\n            var charCode = source.charCodeAt(psz);\n            // Base map can not be indexed using char code\n            if (charCode > 255) {\n                return;\n            }\n            // Decode character\n            var carry = BASE_MAP[charCode];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));\n        vch.fill(0x00, 0, zeroes);\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nmodule.exports = base;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsNkJBQTZCO0FBQzdCLHlDQUF5QztBQUN6QyxtRUFBbUU7QUFDbkUsbUVBQW1FO0FBQ25FLHNFQUFzRTtBQUN0RSxhQUFhO0FBQ2IsSUFBSUEsVUFBVUMsNEZBQTZCO0FBQzNDLFNBQVNFLEtBQU1DLFFBQVE7SUFDckIsSUFBSUEsU0FBU0MsTUFBTSxJQUFJLEtBQUs7UUFBRSxNQUFNLElBQUlDLFVBQVU7SUFBcUI7SUFDdkUsSUFBSUMsV0FBVyxJQUFJQyxXQUFXO0lBQzlCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixTQUFTRixNQUFNLEVBQUVJLElBQUs7UUFDeENGLFFBQVEsQ0FBQ0UsRUFBRSxHQUFHO0lBQ2hCO0lBQ0EsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLFNBQVNDLE1BQU0sRUFBRUssSUFBSztRQUN4QyxJQUFJQyxJQUFJUCxTQUFTUSxNQUFNLENBQUNGO1FBQ3hCLElBQUlHLEtBQUtGLEVBQUVHLFVBQVUsQ0FBQztRQUN0QixJQUFJUCxRQUFRLENBQUNNLEdBQUcsS0FBSyxLQUFLO1lBQUUsTUFBTSxJQUFJUCxVQUFVSyxJQUFJO1FBQWlCO1FBQ3JFSixRQUFRLENBQUNNLEdBQUcsR0FBR0g7SUFDakI7SUFDQSxJQUFJSyxPQUFPWCxTQUFTQyxNQUFNO0lBQzFCLElBQUlXLFNBQVNaLFNBQVNRLE1BQU0sQ0FBQztJQUM3QixJQUFJSyxTQUFTQyxLQUFLQyxHQUFHLENBQUNKLFFBQVFHLEtBQUtDLEdBQUcsQ0FBQyxLQUFLLG1DQUFtQzs7SUFDL0UsSUFBSUMsVUFBVUYsS0FBS0MsR0FBRyxDQUFDLE9BQU9ELEtBQUtDLEdBQUcsQ0FBQ0osTUFBTSxtQ0FBbUM7O0lBQ2hGLFNBQVNNLE9BQVFDLE1BQU07UUFDckIsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixXQUFXQSxrQkFBa0JkLFlBQVk7WUFBRWMsU0FBU3RCLFFBQVF5QixJQUFJLENBQUNIO1FBQVE7UUFDM0YsSUFBSSxDQUFDdEIsUUFBUTBCLFFBQVEsQ0FBQ0osU0FBUztZQUFFLE1BQU0sSUFBSWhCLFVBQVU7UUFBbUI7UUFDeEUsSUFBSWdCLE9BQU9qQixNQUFNLEtBQUssR0FBRztZQUFFLE9BQU87UUFBRztRQUNqQywrQkFBK0I7UUFDbkMsSUFBSXNCLFNBQVM7UUFDYixJQUFJdEIsU0FBUztRQUNiLElBQUl1QixTQUFTO1FBQ2IsSUFBSUMsT0FBT1AsT0FBT2pCLE1BQU07UUFDeEIsTUFBT3VCLFdBQVdDLFFBQVFQLE1BQU0sQ0FBQ00sT0FBTyxLQUFLLEVBQUc7WUFDOUNBO1lBQ0FEO1FBQ0Y7UUFDSSw2REFBNkQ7UUFDakUsSUFBSUcsT0FBTyxDQUFFRCxPQUFPRCxNQUFLLElBQUtSLFVBQVUsTUFBTztRQUMvQyxJQUFJVyxNQUFNLElBQUl2QixXQUFXc0I7UUFDckIscUJBQXFCO1FBQ3pCLE1BQU9GLFdBQVdDLEtBQU07WUFDdEIsSUFBSUcsUUFBUVYsTUFBTSxDQUFDTSxPQUFPO1lBQ3BCLGdDQUFnQztZQUN0QyxJQUFJbEIsSUFBSTtZQUNSLElBQUssSUFBSXVCLE1BQU1ILE9BQU8sR0FBRyxDQUFDRSxVQUFVLEtBQUt0QixJQUFJTCxNQUFLLEtBQU80QixRQUFRLENBQUMsR0FBSUEsT0FBT3ZCLElBQUs7Z0JBQ2hGc0IsU0FBUyxNQUFPRCxHQUFHLENBQUNFLElBQUksS0FBTTtnQkFDOUJGLEdBQUcsQ0FBQ0UsSUFBSSxHQUFHLFFBQVNsQixTQUFVO2dCQUM5QmlCLFFBQVEsUUFBU2pCLFNBQVU7WUFDN0I7WUFDQSxJQUFJaUIsVUFBVSxHQUFHO2dCQUFFLE1BQU0sSUFBSUUsTUFBTTtZQUFrQjtZQUNyRDdCLFNBQVNLO1lBQ1RrQjtRQUNGO1FBQ0ksd0NBQXdDO1FBQzVDLElBQUlPLE1BQU1MLE9BQU96QjtRQUNqQixNQUFPOEIsUUFBUUwsUUFBUUMsR0FBRyxDQUFDSSxJQUFJLEtBQUssRUFBRztZQUNyQ0E7UUFDRjtRQUNJLHNDQUFzQztRQUMxQyxJQUFJQyxNQUFNcEIsT0FBT3FCLE1BQU0sQ0FBQ1Y7UUFDeEIsTUFBT1EsTUFBTUwsTUFBTSxFQUFFSyxJQUFLO1lBQUVDLE9BQU9oQyxTQUFTUSxNQUFNLENBQUNtQixHQUFHLENBQUNJLElBQUk7UUFBRTtRQUM3RCxPQUFPQztJQUNUO0lBQ0EsU0FBU0UsYUFBY2hCLE1BQU07UUFDM0IsSUFBSSxPQUFPQSxXQUFXLFVBQVU7WUFBRSxNQUFNLElBQUloQixVQUFVO1FBQW1CO1FBQ3pFLElBQUlnQixPQUFPakIsTUFBTSxLQUFLLEdBQUc7WUFBRSxPQUFPTCxRQUFRdUMsS0FBSyxDQUFDO1FBQUc7UUFDbkQsSUFBSUMsTUFBTTtRQUNOLCtCQUErQjtRQUNuQyxJQUFJYixTQUFTO1FBQ2IsSUFBSXRCLFNBQVM7UUFDYixNQUFPaUIsTUFBTSxDQUFDa0IsSUFBSSxLQUFLeEIsT0FBUTtZQUM3Qlc7WUFDQWE7UUFDRjtRQUNJLDhEQUE4RDtRQUNsRSxJQUFJVixPQUFPLENBQUdSLE9BQU9qQixNQUFNLEdBQUdtQyxHQUFFLElBQUt2QixTQUFVLE1BQU8sRUFBRSxrQ0FBa0M7O1FBQzFGLElBQUl3QixPQUFPLElBQUlqQyxXQUFXc0I7UUFDdEIsMEJBQTBCO1FBQzlCLE1BQU9VLE1BQU1sQixPQUFPakIsTUFBTSxDQUFFO1lBQ3BCLDhCQUE4QjtZQUNwQyxJQUFJcUMsV0FBV3BCLE9BQU9SLFVBQVUsQ0FBQzBCO1lBQzNCLDhDQUE4QztZQUNwRCxJQUFJRSxXQUFXLEtBQUs7Z0JBQUU7WUFBTztZQUN2QixtQkFBbUI7WUFDekIsSUFBSVYsUUFBUXpCLFFBQVEsQ0FBQ21DLFNBQVM7WUFDeEIsb0JBQW9CO1lBQzFCLElBQUlWLFVBQVUsS0FBSztnQkFBRTtZQUFPO1lBQzVCLElBQUl0QixJQUFJO1lBQ1IsSUFBSyxJQUFJaUMsTUFBTWIsT0FBTyxHQUFHLENBQUNFLFVBQVUsS0FBS3RCLElBQUlMLE1BQUssS0FBT3NDLFFBQVEsQ0FBQyxHQUFJQSxPQUFPakMsSUFBSztnQkFDaEZzQixTQUFTLE9BQVFTLElBQUksQ0FBQ0UsSUFBSSxLQUFNO2dCQUNoQ0YsSUFBSSxDQUFDRSxJQUFJLEdBQUcsUUFBUyxRQUFTO2dCQUM5QlgsUUFBUSxRQUFTLFFBQVM7WUFDNUI7WUFDQSxJQUFJQSxVQUFVLEdBQUc7Z0JBQUUsTUFBTSxJQUFJRSxNQUFNO1lBQWtCO1lBQ3JEN0IsU0FBU0s7WUFDVDhCO1FBQ0Y7UUFDSSwrQkFBK0I7UUFDbkMsSUFBSUksTUFBTWQsT0FBT3pCO1FBQ2pCLE1BQU91QyxRQUFRZCxRQUFRVyxJQUFJLENBQUNHLElBQUksS0FBSyxFQUFHO1lBQ3RDQTtRQUNGO1FBQ0EsSUFBSUMsTUFBTTdDLFFBQVE4QyxXQUFXLENBQUNuQixTQUFVRyxDQUFBQSxPQUFPYyxHQUFFO1FBQ2pEQyxJQUFJRSxJQUFJLENBQUMsTUFBTSxHQUFHcEI7UUFDbEIsSUFBSWxCLElBQUlrQjtRQUNSLE1BQU9pQixRQUFRZCxLQUFNO1lBQ25CZSxHQUFHLENBQUNwQyxJQUFJLEdBQUdnQyxJQUFJLENBQUNHLE1BQU07UUFDeEI7UUFDQSxPQUFPQztJQUNUO0lBQ0EsU0FBU0csT0FBUUMsTUFBTTtRQUNyQixJQUFJQyxTQUFTWixhQUFhVztRQUMxQixJQUFJQyxRQUFRO1lBQUUsT0FBT0E7UUFBTztRQUM1QixNQUFNLElBQUloQixNQUFNLGFBQWFuQixPQUFPO0lBQ3RDO0lBQ0EsT0FBTztRQUNMTSxRQUFRQTtRQUNSaUIsY0FBY0E7UUFDZFUsUUFBUUE7SUFDVjtBQUNGO0FBQ0FHLE9BQU9DLE9BQU8sR0FBR2pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzPzhiMmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbi8vIEB0cy1pZ25vcmVcbnZhciBfQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKVxuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKVxuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpXG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGhcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKVxuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpIC8vIGxvZyhCQVNFKSAvIGxvZygyNTYpLCByb3VuZGVkIHVwXG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpIC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7IHNvdXJjZSA9IF9CdWZmZXIuZnJvbShzb3VyY2UpIH1cbiAgICBpZiAoIV9CdWZmZXIuaXNCdWZmZXIoc291cmNlKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBCdWZmZXInKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB2YXIgcGJlZ2luID0gMFxuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aFxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrXG4gICAgICB6ZXJvZXMrK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMFxuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXVxuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDEgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDEgIT09IC0xKTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoMjU2ICogYjU4W2l0MV0pID4+PiAwXG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwYmVnaW4rK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKytcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKVxuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKSB9XG4gICAgcmV0dXJuIHN0clxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gX0J1ZmZlci5hbGxvYygwKSB9XG4gICAgdmFyIHBzeiA9IDBcbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKytcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDAgLy8gbG9nKDU4KSAvIGxvZygyNTYpLCByb3VuZGVkIHVwLlxuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAocHN6IDwgc291cmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRmluZCBjb2RlIG9mIG5leHQgY2hhcmFjdGVyXG4gICAgICB2YXIgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwc3opXG4gICAgICAgICAgICAvLyBCYXNlIG1hcCBjYW4gbm90IGJlIGluZGV4ZWQgdXNpbmcgY2hhciBjb2RlXG4gICAgICBpZiAoY2hhckNvZGUgPiAyNTUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW2NoYXJDb2RlXVxuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMFxuICAgICAgICBiMjU2W2l0M10gPSAoY2FycnkgJSAyNTYpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrXG4gICAgfVxuICAgIHZhciB2Y2ggPSBfQnVmZmVyLmFsbG9jVW5zYWZlKHplcm9lcyArIChzaXplIC0gaXQ0KSlcbiAgICB2Y2guZmlsbCgweDAwLCAwLCB6ZXJvZXMpXG4gICAgdmFyIGogPSB6ZXJvZXNcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdXG4gICAgfVxuICAgIHJldHVybiB2Y2hcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBkZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlXG4iXSwibmFtZXMiOlsiX0J1ZmZlciIsInJlcXVpcmUiLCJCdWZmZXIiLCJiYXNlIiwiQUxQSEFCRVQiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJCQVNFX01BUCIsIlVpbnQ4QXJyYXkiLCJqIiwiaSIsIngiLCJjaGFyQXQiLCJ4YyIsImNoYXJDb2RlQXQiLCJCQVNFIiwiTEVBREVSIiwiRkFDVE9SIiwiTWF0aCIsImxvZyIsImlGQUNUT1IiLCJlbmNvZGUiLCJzb3VyY2UiLCJBcnJheSIsImlzQXJyYXkiLCJmcm9tIiwiaXNCdWZmZXIiLCJ6ZXJvZXMiLCJwYmVnaW4iLCJwZW5kIiwic2l6ZSIsImI1OCIsImNhcnJ5IiwiaXQxIiwiRXJyb3IiLCJpdDIiLCJzdHIiLCJyZXBlYXQiLCJkZWNvZGVVbnNhZmUiLCJhbGxvYyIsInBzeiIsImIyNTYiLCJjaGFyQ29kZSIsIml0MyIsIml0NCIsInZjaCIsImFsbG9jVW5zYWZlIiwiZmlsbCIsImRlY29kZSIsInN0cmluZyIsImJ1ZmZlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/base-x/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/bs58/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/bs58/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar basex = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/base-x/src/index.js\");\nvar ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nmodule.exports = basex(ALPHABET);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxXQUFXO0FBRWZDLE9BQU9DLE9BQU8sR0FBR0osTUFBTUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanM/MDNkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZXggPSByZXF1aXJlKCdiYXNlLXgnKVxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZXgoQUxQSEFCRVQpXG4iXSwibmFtZXMiOlsiYmFzZXgiLCJyZXF1aXJlIiwiQUxQSEFCRVQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/bs58/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react-ui/styles.css":
/*!*****************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/styles.css ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"210c0ed7ce31\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9zdHlsZXMuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9zdHlsZXMuY3NzP2E5ODEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIyMTBjMGVkN2NlMzFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react-ui/styles.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@solana/codecs-core/dist/index.node.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCodecSentinel: () => (/* binding */ addCodecSentinel),\n/* harmony export */   addCodecSizePrefix: () => (/* binding */ addCodecSizePrefix),\n/* harmony export */   addDecoderSentinel: () => (/* binding */ addDecoderSentinel),\n/* harmony export */   addDecoderSizePrefix: () => (/* binding */ addDecoderSizePrefix),\n/* harmony export */   addEncoderSentinel: () => (/* binding */ addEncoderSentinel),\n/* harmony export */   addEncoderSizePrefix: () => (/* binding */ addEncoderSizePrefix),\n/* harmony export */   assertByteArrayHasEnoughBytesForCodec: () => (/* binding */ assertByteArrayHasEnoughBytesForCodec),\n/* harmony export */   assertByteArrayIsNotEmptyForCodec: () => (/* binding */ assertByteArrayIsNotEmptyForCodec),\n/* harmony export */   assertByteArrayOffsetIsNotOutOfRange: () => (/* binding */ assertByteArrayOffsetIsNotOutOfRange),\n/* harmony export */   assertIsFixedSize: () => (/* binding */ assertIsFixedSize),\n/* harmony export */   assertIsVariableSize: () => (/* binding */ assertIsVariableSize),\n/* harmony export */   combineCodec: () => (/* binding */ combineCodec),\n/* harmony export */   containsBytes: () => (/* binding */ containsBytes),\n/* harmony export */   createCodec: () => (/* binding */ createCodec),\n/* harmony export */   createDecoder: () => (/* binding */ createDecoder),\n/* harmony export */   createEncoder: () => (/* binding */ createEncoder),\n/* harmony export */   fixBytes: () => (/* binding */ fixBytes),\n/* harmony export */   fixCodecSize: () => (/* binding */ fixCodecSize),\n/* harmony export */   fixDecoderSize: () => (/* binding */ fixDecoderSize),\n/* harmony export */   fixEncoderSize: () => (/* binding */ fixEncoderSize),\n/* harmony export */   getEncodedSize: () => (/* binding */ getEncodedSize),\n/* harmony export */   isFixedSize: () => (/* binding */ isFixedSize),\n/* harmony export */   isVariableSize: () => (/* binding */ isVariableSize),\n/* harmony export */   mergeBytes: () => (/* binding */ mergeBytes),\n/* harmony export */   offsetCodec: () => (/* binding */ offsetCodec),\n/* harmony export */   offsetDecoder: () => (/* binding */ offsetDecoder),\n/* harmony export */   offsetEncoder: () => (/* binding */ offsetEncoder),\n/* harmony export */   padBytes: () => (/* binding */ padBytes),\n/* harmony export */   padLeftCodec: () => (/* binding */ padLeftCodec),\n/* harmony export */   padLeftDecoder: () => (/* binding */ padLeftDecoder),\n/* harmony export */   padLeftEncoder: () => (/* binding */ padLeftEncoder),\n/* harmony export */   padRightCodec: () => (/* binding */ padRightCodec),\n/* harmony export */   padRightDecoder: () => (/* binding */ padRightDecoder),\n/* harmony export */   padRightEncoder: () => (/* binding */ padRightEncoder),\n/* harmony export */   resizeCodec: () => (/* binding */ resizeCodec),\n/* harmony export */   resizeDecoder: () => (/* binding */ resizeDecoder),\n/* harmony export */   resizeEncoder: () => (/* binding */ resizeEncoder),\n/* harmony export */   reverseCodec: () => (/* binding */ reverseCodec),\n/* harmony export */   reverseDecoder: () => (/* binding */ reverseDecoder),\n/* harmony export */   reverseEncoder: () => (/* binding */ reverseEncoder),\n/* harmony export */   transformCodec: () => (/* binding */ transformCodec),\n/* harmony export */   transformDecoder: () => (/* binding */ transformDecoder),\n/* harmony export */   transformEncoder: () => (/* binding */ transformEncoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar mergeBytes = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nvar padBytes = (bytes, length)=>{\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\nvar fixBytes = (bytes, length)=>padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i)=>b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction createDecoder(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction createCodec(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n    if (!isFixedSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\nfunction isVariableSize(codec) {\n    return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n    if (!isVariableSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\nfunction combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize\n        });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize\n        });\n    }\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if (isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: encoder.fixedSize + sentinel.length,\n            write\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write\n    });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if (isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: decoder.fixedSize + sentinel.length,\n            read\n        });\n    }\n    return createDecoder({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read\n    });\n}\nfunction addCodecSentinel(codec, sentinel) {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\nfunction hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription\n        });\n    }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset\n        });\n    }\n}\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: prefix.fixedSize + encoder.fixedSize,\n            write\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return createEncoder({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write\n    });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: prefix.fixedSize + decoder.fixedSize,\n            read\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction offsetDecoder(decoder, config) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction offsetCodec(codec, config) {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeEncoder\"\n            });\n        }\n        return createEncoder({\n            ...encoder,\n            fixedSize\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: \"resizeEncoder\"\n                });\n            }\n            return newSize;\n        }\n    });\n}\nfunction resizeDecoder(decoder, resize) {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeDecoder\"\n            });\n        }\n        return createDecoder({\n            ...decoder,\n            fixedSize\n        });\n    }\n    return decoder;\n}\nfunction resizeCodec(codec, resize) {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftCodec(codec, offset) {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\nfunction reverseEncoder(encoder) {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction reverseDecoder(decoder) {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction reverseCodec(codec) {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n    return createEncoder({\n        ...isVariableSize(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction transformDecoder(decoder, map) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction transformCodec(codec, unmap, map) {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : codec.read\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBuQjtBQUUxbkIsNEJBQTRCO0FBRTVCLGVBQWU7QUFDZixJQUFJWSxhQUFhLENBQUNDO0lBQ2hCLE1BQU1DLHFCQUFxQkQsV0FBV0UsTUFBTSxDQUFDLENBQUNDLE1BQVFBLElBQUlDLE1BQU07SUFDaEUsSUFBSUgsbUJBQW1CRyxNQUFNLEtBQUssR0FBRztRQUNuQyxPQUFPSixXQUFXSSxNQUFNLEdBQUdKLFVBQVUsQ0FBQyxFQUFFLEdBQUcsSUFBSUs7SUFDakQ7SUFDQSxJQUFJSixtQkFBbUJHLE1BQU0sS0FBSyxHQUFHO1FBQ25DLE9BQU9ILGtCQUFrQixDQUFDLEVBQUU7SUFDOUI7SUFDQSxNQUFNSyxjQUFjTCxtQkFBbUJNLE1BQU0sQ0FBQyxDQUFDQyxPQUFPTCxNQUFRSyxRQUFRTCxJQUFJQyxNQUFNLEVBQUU7SUFDbEYsTUFBTUssU0FBUyxJQUFJSixXQUFXQztJQUM5QixJQUFJSSxTQUFTO0lBQ2JULG1CQUFtQlUsT0FBTyxDQUFDLENBQUNSO1FBQzFCTSxPQUFPRyxHQUFHLENBQUNULEtBQUtPO1FBQ2hCQSxVQUFVUCxJQUFJQyxNQUFNO0lBQ3RCO0lBQ0EsT0FBT0s7QUFDVDtBQUNBLElBQUlJLFdBQVcsQ0FBQ0MsT0FBT1Y7SUFDckIsSUFBSVUsTUFBTVYsTUFBTSxJQUFJQSxRQUFRLE9BQU9VO0lBQ25DLE1BQU1DLGNBQWMsSUFBSVYsV0FBV0QsUUFBUVksSUFBSSxDQUFDO0lBQ2hERCxZQUFZSCxHQUFHLENBQUNFO0lBQ2hCLE9BQU9DO0FBQ1Q7QUFDQSxJQUFJRSxXQUFXLENBQUNILE9BQU9WLFNBQVdTLFNBQVNDLE1BQU1WLE1BQU0sSUFBSUEsU0FBU1UsUUFBUUEsTUFBTUksS0FBSyxDQUFDLEdBQUdkLFNBQVNBO0FBQ3BHLFNBQVNlLGNBQWNDLElBQUksRUFBRU4sS0FBSyxFQUFFSixNQUFNO0lBQ3hDLE1BQU1RLFFBQVFSLFdBQVcsS0FBS1UsS0FBS2hCLE1BQU0sS0FBS1UsTUFBTVYsTUFBTSxHQUFHZ0IsT0FBT0EsS0FBS0YsS0FBSyxDQUFDUixRQUFRQSxTQUFTSSxNQUFNVixNQUFNO0lBQzVHLElBQUljLE1BQU1kLE1BQU0sS0FBS1UsTUFBTVYsTUFBTSxFQUFFLE9BQU87SUFDMUMsT0FBT1UsTUFBTU8sS0FBSyxDQUFDLENBQUNDLEdBQUdDLElBQU1ELE1BQU1KLEtBQUssQ0FBQ0ssRUFBRTtBQUM3QztBQUNBLFNBQVNDLGVBQWVDLEtBQUssRUFBRUMsT0FBTztJQUNwQyxPQUFPLGVBQWVBLFVBQVVBLFFBQVFDLFNBQVMsR0FBR0QsUUFBUUUsZ0JBQWdCLENBQUNIO0FBQy9FO0FBQ0EsU0FBU0ksY0FBY0gsT0FBTztJQUM1QixPQUFPSSxPQUFPQyxNQUFNLENBQUM7UUFDbkIsR0FBR0wsT0FBTztRQUNWTSxRQUFRLENBQUNQO1lBQ1AsTUFBTVgsUUFBUSxJQUFJVCxXQUFXbUIsZUFBZUMsT0FBT0M7WUFDbkRBLFFBQVFPLEtBQUssQ0FBQ1IsT0FBT1gsT0FBTztZQUM1QixPQUFPQTtRQUNUO0lBQ0Y7QUFDRjtBQUNBLFNBQVNvQixjQUFjQyxPQUFPO0lBQzVCLE9BQU9MLE9BQU9DLE1BQU0sQ0FBQztRQUNuQixHQUFHSSxPQUFPO1FBQ1ZDLFFBQVEsQ0FBQ3RCLE9BQU9KLFNBQVMsQ0FBQyxHQUFLeUIsUUFBUUUsSUFBSSxDQUFDdkIsT0FBT0osT0FBTyxDQUFDLEVBQUU7SUFDL0Q7QUFDRjtBQUNBLFNBQVM0QixZQUFZQyxLQUFLO0lBQ3hCLE9BQU9ULE9BQU9DLE1BQU0sQ0FBQztRQUNuQixHQUFHUSxLQUFLO1FBQ1JILFFBQVEsQ0FBQ3RCLE9BQU9KLFNBQVMsQ0FBQyxHQUFLNkIsTUFBTUYsSUFBSSxDQUFDdkIsT0FBT0osT0FBTyxDQUFDLEVBQUU7UUFDM0RzQixRQUFRLENBQUNQO1lBQ1AsTUFBTVgsUUFBUSxJQUFJVCxXQUFXbUIsZUFBZUMsT0FBT2M7WUFDbkRBLE1BQU1OLEtBQUssQ0FBQ1IsT0FBT1gsT0FBTztZQUMxQixPQUFPQTtRQUNUO0lBQ0Y7QUFDRjtBQUNBLFNBQVMwQixZQUFZRCxLQUFLO0lBQ3hCLE9BQU8sZUFBZUEsU0FBUyxPQUFPQSxNQUFNWixTQUFTLEtBQUs7QUFDNUQ7QUFDQSxTQUFTYyxrQkFBa0JGLEtBQUs7SUFDOUIsSUFBSSxDQUFDQyxZQUFZRCxRQUFRO1FBQ3ZCLE1BQU0sSUFBSXBELHVEQUFXQSxDQUFDQyx1RkFBMkNBO0lBQ25FO0FBQ0Y7QUFDQSxTQUFTc0QsZUFBZUgsS0FBSztJQUMzQixPQUFPLENBQUNDLFlBQVlEO0FBQ3RCO0FBQ0EsU0FBU0kscUJBQXFCSixLQUFLO0lBQ2pDLElBQUksQ0FBQ0csZUFBZUgsUUFBUTtRQUMxQixNQUFNLElBQUlwRCx1REFBV0EsQ0FBQ0UsMEZBQThDQTtJQUN0RTtBQUNGO0FBQ0EsU0FBU3VELGFBQWFsQixPQUFPLEVBQUVTLE9BQU87SUFDcEMsSUFBSUssWUFBWWQsYUFBYWMsWUFBWUwsVUFBVTtRQUNqRCxNQUFNLElBQUloRCx1REFBV0EsQ0FBQ0csNkdBQWlFQTtJQUN6RjtJQUNBLElBQUlrRCxZQUFZZCxZQUFZYyxZQUFZTCxZQUFZVCxRQUFRQyxTQUFTLEtBQUtRLFFBQVFSLFNBQVMsRUFBRTtRQUMzRixNQUFNLElBQUl4Qyx1REFBV0EsQ0FBQ0kscUdBQXlEQSxFQUFFO1lBQy9Fc0Qsa0JBQWtCVixRQUFRUixTQUFTO1lBQ25DbUIsa0JBQWtCcEIsUUFBUUMsU0FBUztRQUNyQztJQUNGO0lBQ0EsSUFBSSxDQUFDYSxZQUFZZCxZQUFZLENBQUNjLFlBQVlMLFlBQVlULFFBQVFxQixPQUFPLEtBQUtaLFFBQVFZLE9BQU8sRUFBRTtRQUN6RixNQUFNLElBQUk1RCx1REFBV0EsQ0FBQ0ssbUdBQXVEQSxFQUFFO1lBQzdFd0QsZ0JBQWdCYixRQUFRWSxPQUFPO1lBQy9CRSxnQkFBZ0J2QixRQUFRcUIsT0FBTztRQUNqQztJQUNGO0lBQ0EsT0FBTztRQUNMLEdBQUdaLE9BQU87UUFDVixHQUFHVCxPQUFPO1FBQ1ZVLFFBQVFELFFBQVFDLE1BQU07UUFDdEJKLFFBQVFOLFFBQVFNLE1BQU07UUFDdEJLLE1BQU1GLFFBQVFFLElBQUk7UUFDbEJKLE9BQU9QLFFBQVFPLEtBQUs7SUFDdEI7QUFDRjtBQUVBLDRCQUE0QjtBQUM1QixTQUFTaUIsbUJBQW1CeEIsT0FBTyxFQUFFeUIsUUFBUTtJQUMzQyxNQUFNbEIsUUFBUSxDQUFDUixPQUFPWCxPQUFPSjtRQUMzQixNQUFNMEMsZUFBZTFCLFFBQVFNLE1BQU0sQ0FBQ1A7UUFDcEMsSUFBSTRCLGtCQUFrQkQsY0FBY0QsYUFBYSxHQUFHO1lBQ2xELE1BQU0sSUFBSWhFLHVEQUFXQSxDQUFDVyx5R0FBNkRBLEVBQUU7Z0JBQ25Gd0QsY0FBY0Y7Z0JBQ2RHLGlCQUFpQkMsU0FBU0o7Z0JBQzFCSyxhQUFhRCxTQUFTTDtnQkFDdEJBO1lBQ0Y7UUFDRjtRQUNBckMsTUFBTUYsR0FBRyxDQUFDd0MsY0FBYzFDO1FBQ3hCQSxVQUFVMEMsYUFBYWhELE1BQU07UUFDN0JVLE1BQU1GLEdBQUcsQ0FBQ3VDLFVBQVV6QztRQUNwQkEsVUFBVXlDLFNBQVMvQyxNQUFNO1FBQ3pCLE9BQU9NO0lBQ1Q7SUFDQSxJQUFJOEIsWUFBWWQsVUFBVTtRQUN4QixPQUFPRyxjQUFjO1lBQUUsR0FBR0gsT0FBTztZQUFFQyxXQUFXRCxRQUFRQyxTQUFTLEdBQUd3QixTQUFTL0MsTUFBTTtZQUFFNkI7UUFBTTtJQUMzRjtJQUNBLE9BQU9KLGNBQWM7UUFDbkIsR0FBR0gsT0FBTztRQUNWLEdBQUdBLFFBQVFxQixPQUFPLElBQUksT0FBTztZQUFFQSxTQUFTckIsUUFBUXFCLE9BQU8sR0FBR0ksU0FBUy9DLE1BQU07UUFBQyxJQUFJLENBQUMsQ0FBQztRQUNoRndCLGtCQUFrQixDQUFDSCxRQUFVQyxRQUFRRSxnQkFBZ0IsQ0FBQ0gsU0FBUzBCLFNBQVMvQyxNQUFNO1FBQzlFNkI7SUFDRjtBQUNGO0FBQ0EsU0FBU3lCLG1CQUFtQnZCLE9BQU8sRUFBRWdCLFFBQVE7SUFDM0MsTUFBTWQsT0FBTyxDQUFDdkIsT0FBT0o7UUFDbkIsTUFBTWlELGlCQUFpQmpELFdBQVcsSUFBSUksUUFBUUEsTUFBTUksS0FBSyxDQUFDUjtRQUMxRCxNQUFNa0QsZ0JBQWdCUCxrQkFBa0JNLGdCQUFnQlI7UUFDeEQsSUFBSVMsa0JBQWtCLENBQUMsR0FBRztZQUN4QixNQUFNLElBQUl6RSx1REFBV0EsQ0FBQ1UsbUdBQXVEQSxFQUFFO2dCQUM3RWdFLGNBQWNGO2dCQUNkRyxpQkFBaUJOLFNBQVNHO2dCQUMxQkYsYUFBYUQsU0FBU0w7Z0JBQ3RCQTtZQUNGO1FBQ0Y7UUFDQSxNQUFNWSxtQkFBbUJKLGVBQWV6QyxLQUFLLENBQUMsR0FBRzBDO1FBQ2pELE9BQU87WUFBQ3pCLFFBQVFDLE1BQU0sQ0FBQzJCO1lBQW1CckQsU0FBU3FELGlCQUFpQjNELE1BQU0sR0FBRytDLFNBQVMvQyxNQUFNO1NBQUM7SUFDL0Y7SUFDQSxJQUFJb0MsWUFBWUwsVUFBVTtRQUN4QixPQUFPRCxjQUFjO1lBQUUsR0FBR0MsT0FBTztZQUFFUixXQUFXUSxRQUFRUixTQUFTLEdBQUd3QixTQUFTL0MsTUFBTTtZQUFFaUM7UUFBSztJQUMxRjtJQUNBLE9BQU9ILGNBQWM7UUFDbkIsR0FBR0MsT0FBTztRQUNWLEdBQUdBLFFBQVFZLE9BQU8sSUFBSSxPQUFPO1lBQUVBLFNBQVNaLFFBQVFZLE9BQU8sR0FBR0ksU0FBUy9DLE1BQU07UUFBQyxJQUFJLENBQUMsQ0FBQztRQUNoRmlDO0lBQ0Y7QUFDRjtBQUNBLFNBQVMyQixpQkFBaUJ6QixLQUFLLEVBQUVZLFFBQVE7SUFDdkMsT0FBT1AsYUFBYU0sbUJBQW1CWCxPQUFPWSxXQUFXTyxtQkFBbUJuQixPQUFPWTtBQUNyRjtBQUNBLFNBQVNFLGtCQUFrQnZDLEtBQUssRUFBRXFDLFFBQVE7SUFDeEMsT0FBT3JDLE1BQU1tRCxTQUFTLENBQUMsQ0FBQ0MsTUFBTUMsT0FBT2hFO1FBQ25DLElBQUlnRCxTQUFTL0MsTUFBTSxLQUFLLEdBQUcsT0FBTzhELFNBQVNmLFFBQVEsQ0FBQyxFQUFFO1FBQ3RELE9BQU9oQyxjQUFjaEIsS0FBS2dELFVBQVVnQjtJQUN0QztBQUNGO0FBQ0EsU0FBU1gsU0FBUzFDLEtBQUs7SUFDckIsT0FBT0EsTUFBTVAsTUFBTSxDQUFDLENBQUM2RCxLQUFLRixPQUFTRSxNQUFNRixLQUFLRyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTTtBQUMvRTtBQUNBLFNBQVNDLGtDQUFrQ0MsZ0JBQWdCLEVBQUUxRCxLQUFLLEVBQUVKLFNBQVMsQ0FBQztJQUM1RSxJQUFJSSxNQUFNVixNQUFNLEdBQUdNLFVBQVUsR0FBRztRQUM5QixNQUFNLElBQUl2Qix1REFBV0EsQ0FBQ00sZ0dBQW9EQSxFQUFFO1lBQzFFK0U7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTQyxzQ0FBc0NELGdCQUFnQixFQUFFRSxRQUFRLEVBQUU1RCxLQUFLLEVBQUVKLFNBQVMsQ0FBQztJQUMxRixNQUFNaUUsY0FBYzdELE1BQU1WLE1BQU0sR0FBR007SUFDbkMsSUFBSWlFLGNBQWNELFVBQVU7UUFDMUIsTUFBTSxJQUFJdkYsdURBQVdBLENBQUNPLHFGQUF5Q0EsRUFBRTtZQUMvRGlGO1lBQ0FIO1lBQ0FFO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU0UscUNBQXFDSixnQkFBZ0IsRUFBRTlELE1BQU0sRUFBRWlFLFdBQVc7SUFDakYsSUFBSWpFLFNBQVMsS0FBS0EsU0FBU2lFLGFBQWE7UUFDdEMsTUFBTSxJQUFJeEYsdURBQVdBLENBQUNRLHFGQUF5Q0EsRUFBRTtZQUMvRGdGO1lBQ0FIO1lBQ0E5RDtRQUNGO0lBQ0Y7QUFDRjtBQUVBLCtCQUErQjtBQUMvQixTQUFTbUUscUJBQXFCbkQsT0FBTyxFQUFFb0QsTUFBTTtJQUMzQyxNQUFNN0MsUUFBUSxDQUFDUixPQUFPWCxPQUFPSjtRQUMzQixNQUFNMEMsZUFBZTFCLFFBQVFNLE1BQU0sQ0FBQ1A7UUFDcENmLFNBQVNvRSxPQUFPN0MsS0FBSyxDQUFDbUIsYUFBYWhELE1BQU0sRUFBRVUsT0FBT0o7UUFDbERJLE1BQU1GLEdBQUcsQ0FBQ3dDLGNBQWMxQztRQUN4QixPQUFPQSxTQUFTMEMsYUFBYWhELE1BQU07SUFDckM7SUFDQSxJQUFJb0MsWUFBWXNDLFdBQVd0QyxZQUFZZCxVQUFVO1FBQy9DLE9BQU9HLGNBQWM7WUFBRSxHQUFHSCxPQUFPO1lBQUVDLFdBQVdtRCxPQUFPbkQsU0FBUyxHQUFHRCxRQUFRQyxTQUFTO1lBQUVNO1FBQU07SUFDNUY7SUFDQSxNQUFNOEMsZ0JBQWdCdkMsWUFBWXNDLFVBQVVBLE9BQU9uRCxTQUFTLEdBQUdtRCxPQUFPL0IsT0FBTyxJQUFJO0lBQ2pGLE1BQU1FLGlCQUFpQlQsWUFBWWQsV0FBV0EsUUFBUUMsU0FBUyxHQUFHRCxRQUFRcUIsT0FBTyxJQUFJO0lBQ3JGLE1BQU1BLFVBQVVnQyxrQkFBa0IsUUFBUTlCLG1CQUFtQixPQUFPOEIsZ0JBQWdCOUIsaUJBQWlCO0lBQ3JHLE9BQU9wQixjQUFjO1FBQ25CLEdBQUdILE9BQU87UUFDVixHQUFHcUIsWUFBWSxPQUFPO1lBQUVBO1FBQVEsSUFBSSxDQUFDLENBQUM7UUFDdENuQixrQkFBa0IsQ0FBQ0g7WUFDakIsTUFBTXVELGNBQWN4RCxlQUFlQyxPQUFPQztZQUMxQyxPQUFPRixlQUFld0QsYUFBYUYsVUFBVUU7UUFDL0M7UUFDQS9DO0lBQ0Y7QUFDRjtBQUNBLFNBQVNnRCxxQkFBcUI5QyxPQUFPLEVBQUUyQyxNQUFNO0lBQzNDLE1BQU16QyxPQUFPLENBQUN2QixPQUFPSjtRQUNuQixNQUFNLENBQUN3RSxZQUFZQyxjQUFjLEdBQUdMLE9BQU96QyxJQUFJLENBQUN2QixPQUFPSjtRQUN2RCxNQUFNMEUsT0FBT0MsT0FBT0g7UUFDcEJ4RSxTQUFTeUU7UUFDVCxJQUFJekUsU0FBUyxLQUFLSSxNQUFNVixNQUFNLEdBQUdnRixNQUFNO1lBQ3JDdEUsUUFBUUEsTUFBTUksS0FBSyxDQUFDUixRQUFRQSxTQUFTMEU7UUFDdkM7UUFDQVgsc0NBQXNDLHdCQUF3QlcsTUFBTXRFO1FBQ3BFLE9BQU87WUFBQ3FCLFFBQVFDLE1BQU0sQ0FBQ3RCO1lBQVFKLFNBQVMwRTtTQUFLO0lBQy9DO0lBQ0EsSUFBSTVDLFlBQVlzQyxXQUFXdEMsWUFBWUwsVUFBVTtRQUMvQyxPQUFPRCxjQUFjO1lBQUUsR0FBR0MsT0FBTztZQUFFUixXQUFXbUQsT0FBT25ELFNBQVMsR0FBR1EsUUFBUVIsU0FBUztZQUFFVTtRQUFLO0lBQzNGO0lBQ0EsTUFBTTBDLGdCQUFnQnZDLFlBQVlzQyxVQUFVQSxPQUFPbkQsU0FBUyxHQUFHbUQsT0FBTy9CLE9BQU8sSUFBSTtJQUNqRixNQUFNQyxpQkFBaUJSLFlBQVlMLFdBQVdBLFFBQVFSLFNBQVMsR0FBR1EsUUFBUVksT0FBTyxJQUFJO0lBQ3JGLE1BQU1BLFVBQVVnQyxrQkFBa0IsUUFBUS9CLG1CQUFtQixPQUFPK0IsZ0JBQWdCL0IsaUJBQWlCO0lBQ3JHLE9BQU9kLGNBQWM7UUFBRSxHQUFHQyxPQUFPO1FBQUUsR0FBR1ksWUFBWSxPQUFPO1lBQUVBO1FBQVEsSUFBSSxDQUFDLENBQUM7UUFBRVY7SUFBSztBQUNsRjtBQUNBLFNBQVNpRCxtQkFBbUIvQyxLQUFLLEVBQUV1QyxNQUFNO0lBQ3ZDLE9BQU9sQyxhQUFhaUMscUJBQXFCdEMsT0FBT3VDLFNBQVNHLHFCQUFxQjFDLE9BQU91QztBQUN2RjtBQUVBLHdCQUF3QjtBQUN4QixTQUFTUyxlQUFlN0QsT0FBTyxFQUFFOEQsVUFBVTtJQUN6QyxPQUFPM0QsY0FBYztRQUNuQkYsV0FBVzZEO1FBQ1h2RCxPQUFPLENBQUNSLE9BQU9YLE9BQU9KO1lBQ3BCLE1BQU0rRSxvQkFBb0IvRCxRQUFRTSxNQUFNLENBQUNQO1lBQ3pDLE1BQU1pRSxpQkFBaUJELGtCQUFrQnJGLE1BQU0sR0FBR29GLGFBQWFDLGtCQUFrQnZFLEtBQUssQ0FBQyxHQUFHc0UsY0FBY0M7WUFDeEczRSxNQUFNRixHQUFHLENBQUM4RSxnQkFBZ0JoRjtZQUMxQixPQUFPQSxTQUFTOEU7UUFDbEI7SUFDRjtBQUNGO0FBQ0EsU0FBU0csZUFBZXhELE9BQU8sRUFBRXFELFVBQVU7SUFDekMsT0FBT3RELGNBQWM7UUFDbkJQLFdBQVc2RDtRQUNYbkQsTUFBTSxDQUFDdkIsT0FBT0o7WUFDWitELHNDQUFzQyxnQkFBZ0JlLFlBQVkxRSxPQUFPSjtZQUN6RSxJQUFJQSxTQUFTLEtBQUtJLE1BQU1WLE1BQU0sR0FBR29GLFlBQVk7Z0JBQzNDMUUsUUFBUUEsTUFBTUksS0FBSyxDQUFDUixRQUFRQSxTQUFTOEU7WUFDdkM7WUFDQSxJQUFJaEQsWUFBWUwsVUFBVTtnQkFDeEJyQixRQUFRRyxTQUFTSCxPQUFPcUIsUUFBUVIsU0FBUztZQUMzQztZQUNBLE1BQU0sQ0FBQ0YsTUFBTSxHQUFHVSxRQUFRRSxJQUFJLENBQUN2QixPQUFPO1lBQ3BDLE9BQU87Z0JBQUNXO2dCQUFPZixTQUFTOEU7YUFBVztRQUNyQztJQUNGO0FBQ0Y7QUFDQSxTQUFTSSxhQUFhckQsS0FBSyxFQUFFaUQsVUFBVTtJQUNyQyxPQUFPNUMsYUFBYTJDLGVBQWVoRCxPQUFPaUQsYUFBYUcsZUFBZXBELE9BQU9pRDtBQUMvRTtBQUVBLHNCQUFzQjtBQUN0QixTQUFTSyxjQUFjbkUsT0FBTyxFQUFFb0UsTUFBTTtJQUNwQyxPQUFPakUsY0FBYztRQUNuQixHQUFHSCxPQUFPO1FBQ1ZPLE9BQU8sQ0FBQ1IsT0FBT1gsT0FBT2lGO1lBQ3BCLE1BQU1DLFlBQVksQ0FBQ3RGLFNBQVd1RixPQUFPdkYsUUFBUUksTUFBTVYsTUFBTTtZQUN6RCxNQUFNOEYsZUFBZUosT0FBT0MsU0FBUyxHQUFHRCxPQUFPQyxTQUFTLENBQUM7Z0JBQUVqRjtnQkFBT2lGO2dCQUFXQztZQUFVLEtBQUtEO1lBQzVGbkIscUNBQXFDLGlCQUFpQnNCLGNBQWNwRixNQUFNVixNQUFNO1lBQ2hGLE1BQU0rRixhQUFhekUsUUFBUU8sS0FBSyxDQUFDUixPQUFPWCxPQUFPb0Y7WUFDL0MsTUFBTUUsZ0JBQWdCTixPQUFPSyxVQUFVLEdBQUdMLE9BQU9LLFVBQVUsQ0FBQztnQkFBRXJGO2dCQUFPb0Y7Z0JBQWNDO2dCQUFZSjtnQkFBV0M7WUFBVSxLQUFLRztZQUN6SHZCLHFDQUFxQyxpQkFBaUJ3QixlQUFldEYsTUFBTVYsTUFBTTtZQUNqRixPQUFPZ0c7UUFDVDtJQUNGO0FBQ0Y7QUFDQSxTQUFTQyxjQUFjbEUsT0FBTyxFQUFFMkQsTUFBTTtJQUNwQyxPQUFPNUQsY0FBYztRQUNuQixHQUFHQyxPQUFPO1FBQ1ZFLE1BQU0sQ0FBQ3ZCLE9BQU9pRjtZQUNaLE1BQU1DLFlBQVksQ0FBQ3RGLFNBQVd1RixPQUFPdkYsUUFBUUksTUFBTVYsTUFBTTtZQUN6RCxNQUFNOEYsZUFBZUosT0FBT0MsU0FBUyxHQUFHRCxPQUFPQyxTQUFTLENBQUM7Z0JBQUVqRjtnQkFBT2lGO2dCQUFXQztZQUFVLEtBQUtEO1lBQzVGbkIscUNBQXFDLGlCQUFpQnNCLGNBQWNwRixNQUFNVixNQUFNO1lBQ2hGLE1BQU0sQ0FBQ3FCLE9BQU8wRSxXQUFXLEdBQUdoRSxRQUFRRSxJQUFJLENBQUN2QixPQUFPb0Y7WUFDaEQsTUFBTUUsZ0JBQWdCTixPQUFPSyxVQUFVLEdBQUdMLE9BQU9LLFVBQVUsQ0FBQztnQkFBRXJGO2dCQUFPb0Y7Z0JBQWNDO2dCQUFZSjtnQkFBV0M7WUFBVSxLQUFLRztZQUN6SHZCLHFDQUFxQyxpQkFBaUJ3QixlQUFldEYsTUFBTVYsTUFBTTtZQUNqRixPQUFPO2dCQUFDcUI7Z0JBQU8yRTthQUFjO1FBQy9CO0lBQ0Y7QUFDRjtBQUNBLFNBQVNFLFlBQVkvRCxLQUFLLEVBQUV1RCxNQUFNO0lBQ2hDLE9BQU9sRCxhQUFhaUQsY0FBY3RELE9BQU91RCxTQUFTTyxjQUFjOUQsT0FBT3VEO0FBQ3pFO0FBQ0EsU0FBU0csT0FBT00sUUFBUSxFQUFFQyxPQUFPO0lBQy9CLElBQUlBLFlBQVksR0FBRyxPQUFPO0lBQzFCLE9BQU8sQ0FBQ0QsV0FBV0MsVUFBVUEsT0FBTSxJQUFLQTtBQUMxQztBQUNBLFNBQVNDLGNBQWMvRSxPQUFPLEVBQUVnRixNQUFNO0lBQ3BDLElBQUlsRSxZQUFZZCxVQUFVO1FBQ3hCLE1BQU1DLFlBQVkrRSxPQUFPaEYsUUFBUUMsU0FBUztRQUMxQyxJQUFJQSxZQUFZLEdBQUc7WUFDakIsTUFBTSxJQUFJeEMsdURBQVdBLENBQUNTLCtGQUFtREEsRUFBRTtnQkFDekUrRSxhQUFhaEQ7Z0JBQ2I2QyxrQkFBa0I7WUFDcEI7UUFDRjtRQUNBLE9BQU8zQyxjQUFjO1lBQUUsR0FBR0gsT0FBTztZQUFFQztRQUFVO0lBQy9DO0lBQ0EsT0FBT0UsY0FBYztRQUNuQixHQUFHSCxPQUFPO1FBQ1ZFLGtCQUFrQixDQUFDSDtZQUNqQixNQUFNa0YsVUFBVUQsT0FBT2hGLFFBQVFFLGdCQUFnQixDQUFDSDtZQUNoRCxJQUFJa0YsVUFBVSxHQUFHO2dCQUNmLE1BQU0sSUFBSXhILHVEQUFXQSxDQUFDUywrRkFBbURBLEVBQUU7b0JBQ3pFK0UsYUFBYWdDO29CQUNibkMsa0JBQWtCO2dCQUNwQjtZQUNGO1lBQ0EsT0FBT21DO1FBQ1Q7SUFDRjtBQUNGO0FBQ0EsU0FBU0MsY0FBY3pFLE9BQU8sRUFBRXVFLE1BQU07SUFDcEMsSUFBSWxFLFlBQVlMLFVBQVU7UUFDeEIsTUFBTVIsWUFBWStFLE9BQU92RSxRQUFRUixTQUFTO1FBQzFDLElBQUlBLFlBQVksR0FBRztZQUNqQixNQUFNLElBQUl4Qyx1REFBV0EsQ0FBQ1MsK0ZBQW1EQSxFQUFFO2dCQUN6RStFLGFBQWFoRDtnQkFDYjZDLGtCQUFrQjtZQUNwQjtRQUNGO1FBQ0EsT0FBT3RDLGNBQWM7WUFBRSxHQUFHQyxPQUFPO1lBQUVSO1FBQVU7SUFDL0M7SUFDQSxPQUFPUTtBQUNUO0FBQ0EsU0FBUzBFLFlBQVl0RSxLQUFLLEVBQUVtRSxNQUFNO0lBQ2hDLE9BQU85RCxhQUFhNkQsY0FBY2xFLE9BQU9tRSxTQUFTRSxjQUFjckUsT0FBT21FO0FBQ3pFO0FBRUEsbUJBQW1CO0FBQ25CLFNBQVNJLGVBQWVwRixPQUFPLEVBQUVoQixNQUFNO0lBQ3JDLE9BQU9tRixjQUNMWSxjQUFjL0UsU0FBUyxDQUFDMEQsT0FBU0EsT0FBTzFFLFNBQ3hDO1FBQUVxRixXQUFXLENBQUMsRUFBRUEsU0FBUyxFQUFFLEdBQUtBLFlBQVlyRjtJQUFPO0FBRXZEO0FBQ0EsU0FBU3FHLGdCQUFnQnJGLE9BQU8sRUFBRWhCLE1BQU07SUFDdEMsT0FBT21GLGNBQ0xZLGNBQWMvRSxTQUFTLENBQUMwRCxPQUFTQSxPQUFPMUUsU0FDeEM7UUFBRXlGLFlBQVksQ0FBQyxFQUFFQSxVQUFVLEVBQUUsR0FBS0EsYUFBYXpGO0lBQU87QUFFMUQ7QUFDQSxTQUFTc0csZUFBZTdFLE9BQU8sRUFBRXpCLE1BQU07SUFDckMsT0FBTzJGLGNBQ0xPLGNBQWN6RSxTQUFTLENBQUNpRCxPQUFTQSxPQUFPMUUsU0FDeEM7UUFBRXFGLFdBQVcsQ0FBQyxFQUFFQSxTQUFTLEVBQUUsR0FBS0EsWUFBWXJGO0lBQU87QUFFdkQ7QUFDQSxTQUFTdUcsZ0JBQWdCOUUsT0FBTyxFQUFFekIsTUFBTTtJQUN0QyxPQUFPMkYsY0FDTE8sY0FBY3pFLFNBQVMsQ0FBQ2lELE9BQVNBLE9BQU8xRSxTQUN4QztRQUFFeUYsWUFBWSxDQUFDLEVBQUVBLFVBQVUsRUFBRSxHQUFLQSxhQUFhekY7SUFBTztBQUUxRDtBQUNBLFNBQVN3RyxhQUFhM0UsS0FBSyxFQUFFN0IsTUFBTTtJQUNqQyxPQUFPa0MsYUFBYWtFLGVBQWV2RSxPQUFPN0IsU0FBU3NHLGVBQWV6RSxPQUFPN0I7QUFDM0U7QUFDQSxTQUFTeUcsY0FBYzVFLEtBQUssRUFBRTdCLE1BQU07SUFDbEMsT0FBT2tDLGFBQWFtRSxnQkFBZ0J4RSxPQUFPN0IsU0FBU3VHLGdCQUFnQjFFLE9BQU83QjtBQUM3RTtBQUVBLHVCQUF1QjtBQUN2QixTQUFTMEcsNEJBQTRCQyxNQUFNLEVBQUVDLGtCQUFrQixFQUFFQyxZQUFZLEVBQUVDLFlBQVksRUFBRUMsZUFBZSxDQUFDO0lBQzNHLE1BQU9GLGVBQWUsRUFBRUMsYUFBYztRQUNwQyxNQUFNRSxZQUFZTCxNQUFNLENBQUNFLGFBQWE7UUFDdENELGtCQUFrQixDQUFDQyxlQUFlRSxhQUFhLEdBQUdKLE1BQU0sQ0FBQ0csYUFBYTtRQUN0RUYsa0JBQWtCLENBQUNFLGVBQWVDLGFBQWEsR0FBR0M7UUFDbERIO0lBQ0Y7SUFDQSxJQUFJQSxpQkFBaUJDLGNBQWM7UUFDakNGLGtCQUFrQixDQUFDQyxlQUFlRSxhQUFhLEdBQUdKLE1BQU0sQ0FBQ0UsYUFBYTtJQUN4RTtBQUNGO0FBQ0EsU0FBU0ksZUFBZWpHLE9BQU87SUFDN0JlLGtCQUFrQmY7SUFDbEIsT0FBT0csY0FBYztRQUNuQixHQUFHSCxPQUFPO1FBQ1ZPLE9BQU8sQ0FBQ1IsT0FBT1gsT0FBT0o7WUFDcEIsTUFBTWtILFlBQVlsRyxRQUFRTyxLQUFLLENBQUNSLE9BQU9YLE9BQU9KO1lBQzlDMEcsNEJBQ0V0RyxPQUNBQSxPQUNBSixRQUNBQSxTQUFTZ0IsUUFBUUMsU0FBUztZQUU1QixPQUFPaUc7UUFDVDtJQUNGO0FBQ0Y7QUFDQSxTQUFTQyxlQUFlMUYsT0FBTztJQUM3Qk0sa0JBQWtCTjtJQUNsQixPQUFPRCxjQUFjO1FBQ25CLEdBQUdDLE9BQU87UUFDVkUsTUFBTSxDQUFDdkIsT0FBT0o7WUFDWixNQUFNb0gsZ0JBQWdCaEgsTUFBTUksS0FBSztZQUNqQ2tHLDRCQUNFdEcsT0FDQWdILGVBQ0FwSCxRQUNBQSxTQUFTeUIsUUFBUVIsU0FBUztZQUU1QixPQUFPUSxRQUFRRSxJQUFJLENBQUN5RixlQUFlcEg7UUFDckM7SUFDRjtBQUNGO0FBQ0EsU0FBU3FILGFBQWF4RixLQUFLO0lBQ3pCLE9BQU9LLGFBQWErRSxlQUFlcEYsUUFBUXNGLGVBQWV0RjtBQUM1RDtBQUVBLHlCQUF5QjtBQUN6QixTQUFTeUYsaUJBQWlCdEcsT0FBTyxFQUFFdUcsS0FBSztJQUN0QyxPQUFPcEcsY0FBYztRQUNuQixHQUFHYSxlQUFlaEIsV0FBVztZQUFFLEdBQUdBLE9BQU87WUFBRUUsa0JBQWtCLENBQUNILFFBQVVDLFFBQVFFLGdCQUFnQixDQUFDcUcsTUFBTXhHO1FBQVEsSUFBSUMsT0FBTztRQUMxSE8sT0FBTyxDQUFDUixPQUFPWCxPQUFPSixTQUFXZ0IsUUFBUU8sS0FBSyxDQUFDZ0csTUFBTXhHLFFBQVFYLE9BQU9KO0lBQ3RFO0FBQ0Y7QUFDQSxTQUFTd0gsaUJBQWlCL0YsT0FBTyxFQUFFZ0csR0FBRztJQUNwQyxPQUFPakcsY0FBYztRQUNuQixHQUFHQyxPQUFPO1FBQ1ZFLE1BQU0sQ0FBQ3ZCLE9BQU9KO1lBQ1osTUFBTSxDQUFDZSxPQUFPbUcsVUFBVSxHQUFHekYsUUFBUUUsSUFBSSxDQUFDdkIsT0FBT0o7WUFDL0MsT0FBTztnQkFBQ3lILElBQUkxRyxPQUFPWCxPQUFPSjtnQkFBU2tIO2FBQVU7UUFDL0M7SUFDRjtBQUNGO0FBQ0EsU0FBU1EsZUFBZTdGLEtBQUssRUFBRTBGLEtBQUssRUFBRUUsR0FBRztJQUN2QyxPQUFPN0YsWUFBWTtRQUNqQixHQUFHMEYsaUJBQWlCekYsT0FBTzBGLE1BQU07UUFDakM1RixNQUFNOEYsTUFBTUQsaUJBQWlCM0YsT0FBTzRGLEtBQUs5RixJQUFJLEdBQUdFLE1BQU1GLElBQUk7SUFDNUQ7QUFDRjtBQUV1dkIsQ0FDdnZCLHVDQUF1QztDQUN2Qyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL2Rpc3QvaW5kZXgubm9kZS5tanM/NTRkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwgfSBmcm9tICdAc29sYW5hL2Vycm9ycyc7XG5cbi8vIHNyYy9hZGQtY29kZWMtc2VudGluZWwudHNcblxuLy8gc3JjL2J5dGVzLnRzXG52YXIgbWVyZ2VCeXRlcyA9IChieXRlQXJyYXlzKSA9PiB7XG4gIGNvbnN0IG5vbkVtcHR5Qnl0ZUFycmF5cyA9IGJ5dGVBcnJheXMuZmlsdGVyKChhcnIpID0+IGFyci5sZW5ndGgpO1xuICBpZiAobm9uRW1wdHlCeXRlQXJyYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBieXRlQXJyYXlzLmxlbmd0aCA/IGJ5dGVBcnJheXNbMF0gOiBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIGlmIChub25FbXB0eUJ5dGVBcnJheXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG5vbkVtcHR5Qnl0ZUFycmF5c1swXTtcbiAgfVxuICBjb25zdCB0b3RhbExlbmd0aCA9IG5vbkVtcHR5Qnl0ZUFycmF5cy5yZWR1Y2UoKHRvdGFsLCBhcnIpID0+IHRvdGFsICsgYXJyLmxlbmd0aCwgMCk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIG5vbkVtcHR5Qnl0ZUFycmF5cy5mb3JFYWNoKChhcnIpID0+IHtcbiAgICByZXN1bHQuc2V0KGFyciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIHBhZEJ5dGVzID0gKGJ5dGVzLCBsZW5ndGgpID0+IHtcbiAgaWYgKGJ5dGVzLmxlbmd0aCA+PSBsZW5ndGgpIHJldHVybiBieXRlcztcbiAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpLmZpbGwoMCk7XG4gIHBhZGRlZEJ5dGVzLnNldChieXRlcyk7XG4gIHJldHVybiBwYWRkZWRCeXRlcztcbn07XG52YXIgZml4Qnl0ZXMgPSAoYnl0ZXMsIGxlbmd0aCkgPT4gcGFkQnl0ZXMoYnl0ZXMubGVuZ3RoIDw9IGxlbmd0aCA/IGJ5dGVzIDogYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKSwgbGVuZ3RoKTtcbmZ1bmN0aW9uIGNvbnRhaW5zQnl0ZXMoZGF0YSwgYnl0ZXMsIG9mZnNldCkge1xuICBjb25zdCBzbGljZSA9IG9mZnNldCA9PT0gMCAmJiBkYXRhLmxlbmd0aCA9PT0gYnl0ZXMubGVuZ3RoID8gZGF0YSA6IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBieXRlcy5sZW5ndGgpO1xuICBpZiAoc2xpY2UubGVuZ3RoICE9PSBieXRlcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGJ5dGVzLmV2ZXJ5KChiLCBpKSA9PiBiID09PSBzbGljZVtpXSk7XG59XG5mdW5jdGlvbiBnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgZW5jb2Rlcikge1xuICByZXR1cm4gXCJmaXhlZFNpemVcIiBpbiBlbmNvZGVyID8gZW5jb2Rlci5maXhlZFNpemUgOiBlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodmFsdWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW5jb2RlcihlbmNvZGVyKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIGVuY29kZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKSk7XG4gICAgICBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgMCk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlY29kZXIoZGVjb2Rlcikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uZGVjb2RlcixcbiAgICBkZWNvZGU6IChieXRlcywgb2Zmc2V0ID0gMCkgPT4gZGVjb2Rlci5yZWFkKGJ5dGVzLCBvZmZzZXQpWzBdXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLmNvZGVjLFxuICAgIGRlY29kZTogKGJ5dGVzLCBvZmZzZXQgPSAwKSA9PiBjb2RlYy5yZWFkKGJ5dGVzLCBvZmZzZXQpWzBdLFxuICAgIGVuY29kZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGdldEVuY29kZWRTaXplKHZhbHVlLCBjb2RlYykpO1xuICAgICAgY29kZWMud3JpdGUodmFsdWUsIGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNGaXhlZFNpemUoY29kZWMpIHtcbiAgcmV0dXJuIFwiZml4ZWRTaXplXCIgaW4gY29kZWMgJiYgdHlwZW9mIGNvZGVjLmZpeGVkU2l6ZSA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGFzc2VydElzRml4ZWRTaXplKGNvZGVjKSB7XG4gIGlmICghaXNGaXhlZFNpemUoY29kZWMpKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgpO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZhcmlhYmxlU2l6ZShjb2RlYykge1xuICByZXR1cm4gIWlzRml4ZWRTaXplKGNvZGVjKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzVmFyaWFibGVTaXplKGNvZGVjKSB7XG4gIGlmICghaXNWYXJpYWJsZVNpemUoY29kZWMpKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgpO1xuICB9XG59XG5mdW5jdGlvbiBjb21iaW5lQ29kZWMoZW5jb2RlciwgZGVjb2Rlcikge1xuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikgIT09IGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIKTtcbiAgfVxuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikgJiYgaXNGaXhlZFNpemUoZGVjb2RlcikgJiYgZW5jb2Rlci5maXhlZFNpemUgIT09IGRlY29kZXIuZml4ZWRTaXplKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCwge1xuICAgICAgZGVjb2RlckZpeGVkU2l6ZTogZGVjb2Rlci5maXhlZFNpemUsXG4gICAgICBlbmNvZGVyRml4ZWRTaXplOiBlbmNvZGVyLmZpeGVkU2l6ZVxuICAgIH0pO1xuICB9XG4gIGlmICghaXNGaXhlZFNpemUoZW5jb2RlcikgJiYgIWlzRml4ZWRTaXplKGRlY29kZXIpICYmIGVuY29kZXIubWF4U2l6ZSAhPT0gZGVjb2Rlci5tYXhTaXplKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0gsIHtcbiAgICAgIGRlY29kZXJNYXhTaXplOiBkZWNvZGVyLm1heFNpemUsXG4gICAgICBlbmNvZGVyTWF4U2l6ZTogZW5jb2Rlci5tYXhTaXplXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIC4uLmVuY29kZXIsXG4gICAgZGVjb2RlOiBkZWNvZGVyLmRlY29kZSxcbiAgICBlbmNvZGU6IGVuY29kZXIuZW5jb2RlLFxuICAgIHJlYWQ6IGRlY29kZXIucmVhZCxcbiAgICB3cml0ZTogZW5jb2Rlci53cml0ZVxuICB9O1xufVxuXG4vLyBzcmMvYWRkLWNvZGVjLXNlbnRpbmVsLnRzXG5mdW5jdGlvbiBhZGRFbmNvZGVyU2VudGluZWwoZW5jb2Rlciwgc2VudGluZWwpIHtcbiAgY29uc3Qgd3JpdGUgPSAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBlbmNvZGVyQnl0ZXMgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgaWYgKGZpbmRTZW50aW5lbEluZGV4KGVuY29kZXJCeXRlcywgc2VudGluZWwpID49IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMLCB7XG4gICAgICAgIGVuY29kZWRCeXRlczogZW5jb2RlckJ5dGVzLFxuICAgICAgICBoZXhFbmNvZGVkQnl0ZXM6IGhleEJ5dGVzKGVuY29kZXJCeXRlcyksXG4gICAgICAgIGhleFNlbnRpbmVsOiBoZXhCeXRlcyhzZW50aW5lbCksXG4gICAgICAgIHNlbnRpbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgYnl0ZXMuc2V0KGVuY29kZXJCeXRlcywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gZW5jb2RlckJ5dGVzLmxlbmd0aDtcbiAgICBieXRlcy5zZXQoc2VudGluZWwsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHNlbnRpbmVsLmxlbmd0aDtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZTogZW5jb2Rlci5maXhlZFNpemUgKyBzZW50aW5lbC5sZW5ndGgsIHdyaXRlIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIC4uLmVuY29kZXIubWF4U2l6ZSAhPSBudWxsID8geyBtYXhTaXplOiBlbmNvZGVyLm1heFNpemUgKyBzZW50aW5lbC5sZW5ndGggfSA6IHt9LFxuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4gZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHZhbHVlKSArIHNlbnRpbmVsLmxlbmd0aCxcbiAgICB3cml0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZERlY29kZXJTZW50aW5lbChkZWNvZGVyLCBzZW50aW5lbCkge1xuICBjb25zdCByZWFkID0gKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBjYW5kaWRhdGVCeXRlcyA9IG9mZnNldCA9PT0gMCA/IGJ5dGVzIDogYnl0ZXMuc2xpY2Uob2Zmc2V0KTtcbiAgICBjb25zdCBzZW50aW5lbEluZGV4ID0gZmluZFNlbnRpbmVsSW5kZXgoY2FuZGlkYXRlQnl0ZXMsIHNlbnRpbmVsKTtcbiAgICBpZiAoc2VudGluZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTLCB7XG4gICAgICAgIGRlY29kZWRCeXRlczogY2FuZGlkYXRlQnl0ZXMsXG4gICAgICAgIGhleERlY29kZWRCeXRlczogaGV4Qnl0ZXMoY2FuZGlkYXRlQnl0ZXMpLFxuICAgICAgICBoZXhTZW50aW5lbDogaGV4Qnl0ZXMoc2VudGluZWwpLFxuICAgICAgICBzZW50aW5lbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHByZVNlbnRpbmVsQnl0ZXMgPSBjYW5kaWRhdGVCeXRlcy5zbGljZSgwLCBzZW50aW5lbEluZGV4KTtcbiAgICByZXR1cm4gW2RlY29kZXIuZGVjb2RlKHByZVNlbnRpbmVsQnl0ZXMpLCBvZmZzZXQgKyBwcmVTZW50aW5lbEJ5dGVzLmxlbmd0aCArIHNlbnRpbmVsLmxlbmd0aF07XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplOiBkZWNvZGVyLmZpeGVkU2l6ZSArIHNlbnRpbmVsLmxlbmd0aCwgcmVhZCB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICAuLi5kZWNvZGVyLm1heFNpemUgIT0gbnVsbCA/IHsgbWF4U2l6ZTogZGVjb2Rlci5tYXhTaXplICsgc2VudGluZWwubGVuZ3RoIH0gOiB7fSxcbiAgICByZWFkXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkQ29kZWNTZW50aW5lbChjb2RlYywgc2VudGluZWwpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhhZGRFbmNvZGVyU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSwgYWRkRGVjb2RlclNlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCkpO1xufVxuZnVuY3Rpb24gZmluZFNlbnRpbmVsSW5kZXgoYnl0ZXMsIHNlbnRpbmVsKSB7XG4gIHJldHVybiBieXRlcy5maW5kSW5kZXgoKGJ5dGUsIGluZGV4LCBhcnIpID0+IHtcbiAgICBpZiAoc2VudGluZWwubGVuZ3RoID09PSAxKSByZXR1cm4gYnl0ZSA9PT0gc2VudGluZWxbMF07XG4gICAgcmV0dXJuIGNvbnRhaW5zQnl0ZXMoYXJyLCBzZW50aW5lbCwgaW5kZXgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhleEJ5dGVzKGJ5dGVzKSB7XG4gIHJldHVybiBieXRlcy5yZWR1Y2UoKHN0ciwgYnl0ZSkgPT4gc3RyICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyhjb2RlY0Rlc2NyaXB0aW9uLCBieXRlcywgb2Zmc2V0ID0gMCkge1xuICBpZiAoYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSwge1xuICAgICAgY29kZWNEZXNjcmlwdGlvblxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKGNvZGVjRGVzY3JpcHRpb24sIGV4cGVjdGVkLCBieXRlcywgb2Zmc2V0ID0gMCkge1xuICBjb25zdCBieXRlc0xlbmd0aCA9IGJ5dGVzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGJ5dGVzTGVuZ3RoIDwgZXhwZWN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsIHtcbiAgICAgIGJ5dGVzTGVuZ3RoLFxuICAgICAgY29kZWNEZXNjcmlwdGlvbixcbiAgICAgIGV4cGVjdGVkXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShjb2RlY0Rlc2NyaXB0aW9uLCBvZmZzZXQsIGJ5dGVzTGVuZ3RoKSB7XG4gIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ5dGVzTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFLCB7XG4gICAgICBieXRlc0xlbmd0aCxcbiAgICAgIGNvZGVjRGVzY3JpcHRpb24sXG4gICAgICBvZmZzZXRcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBzcmMvYWRkLWNvZGVjLXNpemUtcHJlZml4LnRzXG5mdW5jdGlvbiBhZGRFbmNvZGVyU2l6ZVByZWZpeChlbmNvZGVyLCBwcmVmaXgpIHtcbiAgY29uc3Qgd3JpdGUgPSAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBlbmNvZGVyQnl0ZXMgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgb2Zmc2V0ID0gcHJlZml4LndyaXRlKGVuY29kZXJCeXRlcy5sZW5ndGgsIGJ5dGVzLCBvZmZzZXQpO1xuICAgIGJ5dGVzLnNldChlbmNvZGVyQnl0ZXMsIG9mZnNldCk7XG4gICAgcmV0dXJuIG9mZnNldCArIGVuY29kZXJCeXRlcy5sZW5ndGg7XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShwcmVmaXgpICYmIGlzRml4ZWRTaXplKGVuY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemU6IHByZWZpeC5maXhlZFNpemUgKyBlbmNvZGVyLmZpeGVkU2l6ZSwgd3JpdGUgfSk7XG4gIH1cbiAgY29uc3QgcHJlZml4TWF4U2l6ZSA9IGlzRml4ZWRTaXplKHByZWZpeCkgPyBwcmVmaXguZml4ZWRTaXplIDogcHJlZml4Lm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgZW5jb2Rlck1heFNpemUgPSBpc0ZpeGVkU2l6ZShlbmNvZGVyKSA/IGVuY29kZXIuZml4ZWRTaXplIDogZW5jb2Rlci5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IG1heFNpemUgPSBwcmVmaXhNYXhTaXplICE9PSBudWxsICYmIGVuY29kZXJNYXhTaXplICE9PSBudWxsID8gcHJlZml4TWF4U2l6ZSArIGVuY29kZXJNYXhTaXplIDogbnVsbDtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgLi4ubWF4U2l6ZSAhPT0gbnVsbCA/IHsgbWF4U2l6ZSB9IDoge30sXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBlbmNvZGVyU2l6ZSA9IGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKTtcbiAgICAgIHJldHVybiBnZXRFbmNvZGVkU2l6ZShlbmNvZGVyU2l6ZSwgcHJlZml4KSArIGVuY29kZXJTaXplO1xuICAgIH0sXG4gICAgd3JpdGVcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGREZWNvZGVyU2l6ZVByZWZpeChkZWNvZGVyLCBwcmVmaXgpIHtcbiAgY29uc3QgcmVhZCA9IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgW2JpZ2ludFNpemUsIGRlY29kZXJPZmZzZXRdID0gcHJlZml4LnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgY29uc3Qgc2l6ZSA9IE51bWJlcihiaWdpbnRTaXplKTtcbiAgICBvZmZzZXQgPSBkZWNvZGVyT2Zmc2V0O1xuICAgIGlmIChvZmZzZXQgPiAwIHx8IGJ5dGVzLmxlbmd0aCA+IHNpemUpIHtcbiAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzaXplKTtcbiAgICB9XG4gICAgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhcImFkZERlY29kZXJTaXplUHJlZml4XCIsIHNpemUsIGJ5dGVzKTtcbiAgICByZXR1cm4gW2RlY29kZXIuZGVjb2RlKGJ5dGVzKSwgb2Zmc2V0ICsgc2l6ZV07XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShwcmVmaXgpICYmIGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemU6IHByZWZpeC5maXhlZFNpemUgKyBkZWNvZGVyLmZpeGVkU2l6ZSwgcmVhZCB9KTtcbiAgfVxuICBjb25zdCBwcmVmaXhNYXhTaXplID0gaXNGaXhlZFNpemUocHJlZml4KSA/IHByZWZpeC5maXhlZFNpemUgOiBwcmVmaXgubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBkZWNvZGVyTWF4U2l6ZSA9IGlzRml4ZWRTaXplKGRlY29kZXIpID8gZGVjb2Rlci5maXhlZFNpemUgOiBkZWNvZGVyLm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgbWF4U2l6ZSA9IHByZWZpeE1heFNpemUgIT09IG51bGwgJiYgZGVjb2Rlck1heFNpemUgIT09IG51bGwgPyBwcmVmaXhNYXhTaXplICsgZGVjb2Rlck1heFNpemUgOiBudWxsO1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIC4uLm1heFNpemUgIT09IG51bGwgPyB7IG1heFNpemUgfSA6IHt9LCByZWFkIH0pO1xufVxuZnVuY3Rpb24gYWRkQ29kZWNTaXplUHJlZml4KGNvZGVjLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhhZGRFbmNvZGVyU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSwgYWRkRGVjb2RlclNpemVQcmVmaXgoY29kZWMsIHByZWZpeCkpO1xufVxuXG4vLyBzcmMvZml4LWNvZGVjLXNpemUudHNcbmZ1bmN0aW9uIGZpeEVuY29kZXJTaXplKGVuY29kZXIsIGZpeGVkQnl0ZXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogZml4ZWRCeXRlcyxcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB2YXJpYWJsZUJ5dGVBcnJheSA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgIGNvbnN0IGZpeGVkQnl0ZUFycmF5ID0gdmFyaWFibGVCeXRlQXJyYXkubGVuZ3RoID4gZml4ZWRCeXRlcyA/IHZhcmlhYmxlQnl0ZUFycmF5LnNsaWNlKDAsIGZpeGVkQnl0ZXMpIDogdmFyaWFibGVCeXRlQXJyYXk7XG4gICAgICBieXRlcy5zZXQoZml4ZWRCeXRlQXJyYXksIG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgZml4ZWRCeXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZml4RGVjb2RlclNpemUoZGVjb2RlciwgZml4ZWRCeXRlcykge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgZml4ZWRTaXplOiBmaXhlZEJ5dGVzLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKFwiZml4Q29kZWNTaXplXCIsIGZpeGVkQnl0ZXMsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgaWYgKG9mZnNldCA+IDAgfHwgYnl0ZXMubGVuZ3RoID4gZml4ZWRCeXRlcykge1xuICAgICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZml4ZWRCeXRlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICAgICAgYnl0ZXMgPSBmaXhCeXRlcyhieXRlcywgZGVjb2Rlci5maXhlZFNpemUpO1xuICAgICAgfVxuICAgICAgY29uc3QgW3ZhbHVlXSA9IGRlY29kZXIucmVhZChieXRlcywgMCk7XG4gICAgICByZXR1cm4gW3ZhbHVlLCBvZmZzZXQgKyBmaXhlZEJ5dGVzXTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZml4Q29kZWNTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoZml4RW5jb2RlclNpemUoY29kZWMsIGZpeGVkQnl0ZXMpLCBmaXhEZWNvZGVyU2l6ZShjb2RlYywgZml4ZWRCeXRlcykpO1xufVxuXG4vLyBzcmMvb2Zmc2V0LWNvZGVjLnRzXG5mdW5jdGlvbiBvZmZzZXRFbmNvZGVyKGVuY29kZXIsIGNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgcHJlT2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB3cmFwQnl0ZXMgPSAob2Zmc2V0KSA9PiBtb2R1bG8ob2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgbmV3UHJlT2Zmc2V0ID0gY29uZmlnLnByZU9mZnNldCA/IGNvbmZpZy5wcmVPZmZzZXQoeyBieXRlcywgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwcmVPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXRFbmNvZGVyXCIsIG5ld1ByZU9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHBvc3RPZmZzZXQgPSBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgbmV3UHJlT2Zmc2V0KTtcbiAgICAgIGNvbnN0IG5ld1Bvc3RPZmZzZXQgPSBjb25maWcucG9zdE9mZnNldCA/IGNvbmZpZy5wb3N0T2Zmc2V0KHsgYnl0ZXMsIG5ld1ByZU9mZnNldCwgcG9zdE9mZnNldCwgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwb3N0T2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RW5jb2RlclwiLCBuZXdQb3N0T2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ld1Bvc3RPZmZzZXQ7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9mZnNldERlY29kZXIoZGVjb2RlciwgY29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQ6IChieXRlcywgcHJlT2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB3cmFwQnl0ZXMgPSAob2Zmc2V0KSA9PiBtb2R1bG8ob2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgbmV3UHJlT2Zmc2V0ID0gY29uZmlnLnByZU9mZnNldCA/IGNvbmZpZy5wcmVPZmZzZXQoeyBieXRlcywgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwcmVPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXREZWNvZGVyXCIsIG5ld1ByZU9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IFt2YWx1ZSwgcG9zdE9mZnNldF0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIG5ld1ByZU9mZnNldCk7XG4gICAgICBjb25zdCBuZXdQb3N0T2Zmc2V0ID0gY29uZmlnLnBvc3RPZmZzZXQgPyBjb25maWcucG9zdE9mZnNldCh7IGJ5dGVzLCBuZXdQcmVPZmZzZXQsIHBvc3RPZmZzZXQsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcG9zdE9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldERlY29kZXJcIiwgbmV3UG9zdE9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBbdmFsdWUsIG5ld1Bvc3RPZmZzZXRdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBvZmZzZXRDb2RlYyhjb2RlYywgY29uZmlnKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMob2Zmc2V0RW5jb2Rlcihjb2RlYywgY29uZmlnKSwgb2Zmc2V0RGVjb2Rlcihjb2RlYywgY29uZmlnKSk7XG59XG5mdW5jdGlvbiBtb2R1bG8oZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgaWYgKGRpdmlzb3IgPT09IDApIHJldHVybiAwO1xuICByZXR1cm4gKGRpdmlkZW5kICUgZGl2aXNvciArIGRpdmlzb3IpICUgZGl2aXNvcjtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUVuY29kZXIoZW5jb2RlciwgcmVzaXplKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSkge1xuICAgIGNvbnN0IGZpeGVkU2l6ZSA9IHJlc2l6ZShlbmNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgaWYgKGZpeGVkU2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgYnl0ZXNMZW5ndGg6IGZpeGVkU2l6ZSxcbiAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogXCJyZXNpemVFbmNvZGVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZSB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IG5ld1NpemUgPSByZXNpemUoZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHZhbHVlKSk7XG4gICAgICBpZiAobmV3U2l6ZSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICAgIGJ5dGVzTGVuZ3RoOiBuZXdTaXplLFxuICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRW5jb2RlclwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1NpemU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgcmVzaXplKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIGNvbnN0IGZpeGVkU2l6ZSA9IHJlc2l6ZShkZWNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgaWYgKGZpeGVkU2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgYnl0ZXNMZW5ndGg6IGZpeGVkU2l6ZSxcbiAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogXCJyZXNpemVEZWNvZGVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIGZpeGVkU2l6ZSB9KTtcbiAgfVxuICByZXR1cm4gZGVjb2Rlcjtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUNvZGVjKGNvZGVjLCByZXNpemUpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhyZXNpemVFbmNvZGVyKGNvZGVjLCByZXNpemUpLCByZXNpemVEZWNvZGVyKGNvZGVjLCByZXNpemUpKTtcbn1cblxuLy8gc3JjL3BhZC1jb2RlYy50c1xuZnVuY3Rpb24gcGFkTGVmdEVuY29kZXIoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXRFbmNvZGVyKFxuICAgIHJlc2l6ZUVuY29kZXIoZW5jb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcHJlT2Zmc2V0OiAoeyBwcmVPZmZzZXQgfSkgPT4gcHJlT2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0RW5jb2RlcihlbmNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldEVuY29kZXIoXG4gICAgcmVzaXplRW5jb2RlcihlbmNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwb3N0T2Zmc2V0OiAoeyBwb3N0T2Zmc2V0IH0pID0+IHBvc3RPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkTGVmdERlY29kZXIoZGVjb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXREZWNvZGVyKFxuICAgIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcHJlT2Zmc2V0OiAoeyBwcmVPZmZzZXQgfSkgPT4gcHJlT2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0RGVjb2RlcihkZWNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldERlY29kZXIoXG4gICAgcmVzaXplRGVjb2RlcihkZWNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwb3N0T2Zmc2V0OiAoeyBwb3N0T2Zmc2V0IH0pID0+IHBvc3RPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkTGVmdENvZGVjKGNvZGVjLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhwYWRMZWZ0RW5jb2Rlcihjb2RlYywgb2Zmc2V0KSwgcGFkTGVmdERlY29kZXIoY29kZWMsIG9mZnNldCkpO1xufVxuZnVuY3Rpb24gcGFkUmlnaHRDb2RlYyhjb2RlYywgb2Zmc2V0KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocGFkUmlnaHRFbmNvZGVyKGNvZGVjLCBvZmZzZXQpLCBwYWRSaWdodERlY29kZXIoY29kZWMsIG9mZnNldCkpO1xufVxuXG4vLyBzcmMvcmV2ZXJzZS1jb2RlYy50c1xuZnVuY3Rpb24gY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKHNvdXJjZSwgdGFyZ2V0X1dJTExfTVVUQVRFLCBzb3VyY2VPZmZzZXQsIHNvdXJjZUxlbmd0aCwgdGFyZ2V0T2Zmc2V0ID0gMCkge1xuICB3aGlsZSAoc291cmNlT2Zmc2V0IDwgLS1zb3VyY2VMZW5ndGgpIHtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBzb3VyY2Vbc291cmNlT2Zmc2V0XTtcbiAgICB0YXJnZXRfV0lMTF9NVVRBVEVbc291cmNlT2Zmc2V0ICsgdGFyZ2V0T2Zmc2V0XSA9IHNvdXJjZVtzb3VyY2VMZW5ndGhdO1xuICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VMZW5ndGggKyB0YXJnZXRPZmZzZXRdID0gbGVmdFZhbHVlO1xuICAgIHNvdXJjZU9mZnNldCsrO1xuICB9XG4gIGlmIChzb3VyY2VPZmZzZXQgPT09IHNvdXJjZUxlbmd0aCkge1xuICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VPZmZzZXQgKyB0YXJnZXRPZmZzZXRdID0gc291cmNlW3NvdXJjZU9mZnNldF07XG4gIH1cbn1cbmZ1bmN0aW9uIHJldmVyc2VFbmNvZGVyKGVuY29kZXIpIHtcbiAgYXNzZXJ0SXNGaXhlZFNpemUoZW5jb2Rlcik7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IG5ld09mZnNldCA9IGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKFxuICAgICAgICBieXRlcyxcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb2Zmc2V0ICsgZW5jb2Rlci5maXhlZFNpemVcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3T2Zmc2V0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXZlcnNlRGVjb2RlcihkZWNvZGVyKSB7XG4gIGFzc2VydElzRml4ZWRTaXplKGRlY29kZXIpO1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgcmV2ZXJzZWRCeXRlcyA9IGJ5dGVzLnNsaWNlKCk7XG4gICAgICBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UoXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICByZXZlcnNlZEJ5dGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9mZnNldCArIGRlY29kZXIuZml4ZWRTaXplXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRlY29kZXIucmVhZChyZXZlcnNlZEJ5dGVzLCBvZmZzZXQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXZlcnNlQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhyZXZlcnNlRW5jb2Rlcihjb2RlYyksIHJldmVyc2VEZWNvZGVyKGNvZGVjKSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm0tY29kZWMudHNcbmZ1bmN0aW9uIHRyYW5zZm9ybUVuY29kZXIoZW5jb2RlciwgdW5tYXApIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmlzVmFyaWFibGVTaXplKGVuY29kZXIpID8geyAuLi5lbmNvZGVyLCBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh1bm1hcCh2YWx1ZSkpIH0gOiBlbmNvZGVyLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IGVuY29kZXIud3JpdGUodW5tYXAodmFsdWUpLCBieXRlcywgb2Zmc2V0KVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybURlY29kZXIoZGVjb2RlciwgbWFwKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBbdmFsdWUsIG5ld09mZnNldF0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgICByZXR1cm4gW21hcCh2YWx1ZSwgYnl0ZXMsIG9mZnNldCksIG5ld09mZnNldF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUNvZGVjKGNvZGVjLCB1bm1hcCwgbWFwKSB7XG4gIHJldHVybiBjcmVhdGVDb2RlYyh7XG4gICAgLi4udHJhbnNmb3JtRW5jb2Rlcihjb2RlYywgdW5tYXApLFxuICAgIHJlYWQ6IG1hcCA/IHRyYW5zZm9ybURlY29kZXIoY29kZWMsIG1hcCkucmVhZCA6IGNvZGVjLnJlYWRcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGFkZENvZGVjU2VudGluZWwsIGFkZENvZGVjU2l6ZVByZWZpeCwgYWRkRGVjb2RlclNlbnRpbmVsLCBhZGREZWNvZGVyU2l6ZVByZWZpeCwgYWRkRW5jb2RlclNlbnRpbmVsLCBhZGRFbmNvZGVyU2l6ZVByZWZpeCwgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYywgYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjLCBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UsIGFzc2VydElzRml4ZWRTaXplLCBhc3NlcnRJc1ZhcmlhYmxlU2l6ZSwgY29tYmluZUNvZGVjLCBjb250YWluc0J5dGVzLCBjcmVhdGVDb2RlYywgY3JlYXRlRGVjb2RlciwgY3JlYXRlRW5jb2RlciwgZml4Qnl0ZXMsIGZpeENvZGVjU2l6ZSwgZml4RGVjb2RlclNpemUsIGZpeEVuY29kZXJTaXplLCBnZXRFbmNvZGVkU2l6ZSwgaXNGaXhlZFNpemUsIGlzVmFyaWFibGVTaXplLCBtZXJnZUJ5dGVzLCBvZmZzZXRDb2RlYywgb2Zmc2V0RGVjb2Rlciwgb2Zmc2V0RW5jb2RlciwgcGFkQnl0ZXMsIHBhZExlZnRDb2RlYywgcGFkTGVmdERlY29kZXIsIHBhZExlZnRFbmNvZGVyLCBwYWRSaWdodENvZGVjLCBwYWRSaWdodERlY29kZXIsIHBhZFJpZ2h0RW5jb2RlciwgcmVzaXplQ29kZWMsIHJlc2l6ZURlY29kZXIsIHJlc2l6ZUVuY29kZXIsIHJldmVyc2VDb2RlYywgcmV2ZXJzZURlY29kZXIsIHJldmVyc2VFbmNvZGVyLCB0cmFuc2Zvcm1Db2RlYywgdHJhbnNmb3JtRGVjb2RlciwgdHJhbnNmb3JtRW5jb2RlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVkiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwiLCJtZXJnZUJ5dGVzIiwiYnl0ZUFycmF5cyIsIm5vbkVtcHR5Qnl0ZUFycmF5cyIsImZpbHRlciIsImFyciIsImxlbmd0aCIsIlVpbnQ4QXJyYXkiLCJ0b3RhbExlbmd0aCIsInJlZHVjZSIsInRvdGFsIiwicmVzdWx0Iiwib2Zmc2V0IiwiZm9yRWFjaCIsInNldCIsInBhZEJ5dGVzIiwiYnl0ZXMiLCJwYWRkZWRCeXRlcyIsImZpbGwiLCJmaXhCeXRlcyIsInNsaWNlIiwiY29udGFpbnNCeXRlcyIsImRhdGEiLCJldmVyeSIsImIiLCJpIiwiZ2V0RW5jb2RlZFNpemUiLCJ2YWx1ZSIsImVuY29kZXIiLCJmaXhlZFNpemUiLCJnZXRTaXplRnJvbVZhbHVlIiwiY3JlYXRlRW5jb2RlciIsIk9iamVjdCIsImZyZWV6ZSIsImVuY29kZSIsIndyaXRlIiwiY3JlYXRlRGVjb2RlciIsImRlY29kZXIiLCJkZWNvZGUiLCJyZWFkIiwiY3JlYXRlQ29kZWMiLCJjb2RlYyIsImlzRml4ZWRTaXplIiwiYXNzZXJ0SXNGaXhlZFNpemUiLCJpc1ZhcmlhYmxlU2l6ZSIsImFzc2VydElzVmFyaWFibGVTaXplIiwiY29tYmluZUNvZGVjIiwiZGVjb2RlckZpeGVkU2l6ZSIsImVuY29kZXJGaXhlZFNpemUiLCJtYXhTaXplIiwiZGVjb2Rlck1heFNpemUiLCJlbmNvZGVyTWF4U2l6ZSIsImFkZEVuY29kZXJTZW50aW5lbCIsInNlbnRpbmVsIiwiZW5jb2RlckJ5dGVzIiwiZmluZFNlbnRpbmVsSW5kZXgiLCJlbmNvZGVkQnl0ZXMiLCJoZXhFbmNvZGVkQnl0ZXMiLCJoZXhCeXRlcyIsImhleFNlbnRpbmVsIiwiYWRkRGVjb2RlclNlbnRpbmVsIiwiY2FuZGlkYXRlQnl0ZXMiLCJzZW50aW5lbEluZGV4IiwiZGVjb2RlZEJ5dGVzIiwiaGV4RGVjb2RlZEJ5dGVzIiwicHJlU2VudGluZWxCeXRlcyIsImFkZENvZGVjU2VudGluZWwiLCJmaW5kSW5kZXgiLCJieXRlIiwiaW5kZXgiLCJzdHIiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjIiwiY29kZWNEZXNjcmlwdGlvbiIsImFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMiLCJleHBlY3RlZCIsImJ5dGVzTGVuZ3RoIiwiYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlIiwiYWRkRW5jb2RlclNpemVQcmVmaXgiLCJwcmVmaXgiLCJwcmVmaXhNYXhTaXplIiwiZW5jb2RlclNpemUiLCJhZGREZWNvZGVyU2l6ZVByZWZpeCIsImJpZ2ludFNpemUiLCJkZWNvZGVyT2Zmc2V0Iiwic2l6ZSIsIk51bWJlciIsImFkZENvZGVjU2l6ZVByZWZpeCIsImZpeEVuY29kZXJTaXplIiwiZml4ZWRCeXRlcyIsInZhcmlhYmxlQnl0ZUFycmF5IiwiZml4ZWRCeXRlQXJyYXkiLCJmaXhEZWNvZGVyU2l6ZSIsImZpeENvZGVjU2l6ZSIsIm9mZnNldEVuY29kZXIiLCJjb25maWciLCJwcmVPZmZzZXQiLCJ3cmFwQnl0ZXMiLCJtb2R1bG8iLCJuZXdQcmVPZmZzZXQiLCJwb3N0T2Zmc2V0IiwibmV3UG9zdE9mZnNldCIsIm9mZnNldERlY29kZXIiLCJvZmZzZXRDb2RlYyIsImRpdmlkZW5kIiwiZGl2aXNvciIsInJlc2l6ZUVuY29kZXIiLCJyZXNpemUiLCJuZXdTaXplIiwicmVzaXplRGVjb2RlciIsInJlc2l6ZUNvZGVjIiwicGFkTGVmdEVuY29kZXIiLCJwYWRSaWdodEVuY29kZXIiLCJwYWRMZWZ0RGVjb2RlciIsInBhZFJpZ2h0RGVjb2RlciIsInBhZExlZnRDb2RlYyIsInBhZFJpZ2h0Q29kZWMiLCJjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UiLCJzb3VyY2UiLCJ0YXJnZXRfV0lMTF9NVVRBVEUiLCJzb3VyY2VPZmZzZXQiLCJzb3VyY2VMZW5ndGgiLCJ0YXJnZXRPZmZzZXQiLCJsZWZ0VmFsdWUiLCJyZXZlcnNlRW5jb2RlciIsIm5ld09mZnNldCIsInJldmVyc2VEZWNvZGVyIiwicmV2ZXJzZWRCeXRlcyIsInJldmVyc2VDb2RlYyIsInRyYW5zZm9ybUVuY29kZXIiLCJ1bm1hcCIsInRyYW5zZm9ybURlY29kZXIiLCJtYXAiLCJ0cmFuc2Zvcm1Db2RlYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@solana/codecs-numbers/dist/index.node.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Endian: () => (/* binding */ Endian),\n/* harmony export */   assertNumberIsBetweenForCodec: () => (/* binding */ assertNumberIsBetweenForCodec),\n/* harmony export */   getF32Codec: () => (/* binding */ getF32Codec),\n/* harmony export */   getF32Decoder: () => (/* binding */ getF32Decoder),\n/* harmony export */   getF32Encoder: () => (/* binding */ getF32Encoder),\n/* harmony export */   getF64Codec: () => (/* binding */ getF64Codec),\n/* harmony export */   getF64Decoder: () => (/* binding */ getF64Decoder),\n/* harmony export */   getF64Encoder: () => (/* binding */ getF64Encoder),\n/* harmony export */   getI128Codec: () => (/* binding */ getI128Codec),\n/* harmony export */   getI128Decoder: () => (/* binding */ getI128Decoder),\n/* harmony export */   getI128Encoder: () => (/* binding */ getI128Encoder),\n/* harmony export */   getI16Codec: () => (/* binding */ getI16Codec),\n/* harmony export */   getI16Decoder: () => (/* binding */ getI16Decoder),\n/* harmony export */   getI16Encoder: () => (/* binding */ getI16Encoder),\n/* harmony export */   getI32Codec: () => (/* binding */ getI32Codec),\n/* harmony export */   getI32Decoder: () => (/* binding */ getI32Decoder),\n/* harmony export */   getI32Encoder: () => (/* binding */ getI32Encoder),\n/* harmony export */   getI64Codec: () => (/* binding */ getI64Codec),\n/* harmony export */   getI64Decoder: () => (/* binding */ getI64Decoder),\n/* harmony export */   getI64Encoder: () => (/* binding */ getI64Encoder),\n/* harmony export */   getI8Codec: () => (/* binding */ getI8Codec),\n/* harmony export */   getI8Decoder: () => (/* binding */ getI8Decoder),\n/* harmony export */   getI8Encoder: () => (/* binding */ getI8Encoder),\n/* harmony export */   getShortU16Codec: () => (/* binding */ getShortU16Codec),\n/* harmony export */   getShortU16Decoder: () => (/* binding */ getShortU16Decoder),\n/* harmony export */   getShortU16Encoder: () => (/* binding */ getShortU16Encoder),\n/* harmony export */   getU128Codec: () => (/* binding */ getU128Codec),\n/* harmony export */   getU128Decoder: () => (/* binding */ getU128Decoder),\n/* harmony export */   getU128Encoder: () => (/* binding */ getU128Encoder),\n/* harmony export */   getU16Codec: () => (/* binding */ getU16Codec),\n/* harmony export */   getU16Decoder: () => (/* binding */ getU16Decoder),\n/* harmony export */   getU16Encoder: () => (/* binding */ getU16Encoder),\n/* harmony export */   getU32Codec: () => (/* binding */ getU32Codec),\n/* harmony export */   getU32Decoder: () => (/* binding */ getU32Decoder),\n/* harmony export */   getU32Encoder: () => (/* binding */ getU32Encoder),\n/* harmony export */   getU64Codec: () => (/* binding */ getU64Codec),\n/* harmony export */   getU64Decoder: () => (/* binding */ getU64Decoder),\n/* harmony export */   getU64Encoder: () => (/* binding */ getU64Encoder),\n/* harmony export */   getU8Codec: () => (/* binding */ getU8Codec),\n/* harmony export */   getU8Decoder: () => (/* binding */ getU8Decoder),\n/* harmony export */   getU8Encoder: () => (/* binding */ getU8Encoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\");\n\n\n// src/assertions.ts\nfunction assertNumberIsBetweenForCodec(codecDescription, min, max, value) {\n    if (value < min || value > max) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value\n        });\n    }\n}\n// src/common.ts\nvar Endian = /* @__PURE__ */ ((Endian2)=>{\n    Endian2[Endian2[\"Little\"] = 0] = \"Little\";\n    Endian2[Endian2[\"Big\"] = 1] = \"Big\";\n    return Endian2;\n})(Endian || {});\nfunction isLittleEndian(config) {\n    return config?.endian === 1 /* Big */  ? false : true;\n}\nfunction numberEncoderFactory(input) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        fixedSize: input.size,\n        write (value, bytes, offset) {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        }\n    });\n}\nfunction numberDecoderFactory(input) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        fixedSize: input.size,\n        read (bytes, offset = 0) {\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertByteArrayIsNotEmptyForCodec)(input.name, bytes, offset);\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertByteArrayHasEnoughBytesForCodec)(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [\n                input.get(view, isLittleEndian(input.config)),\n                offset + input.size\n            ];\n        }\n    });\n}\nfunction toArrayBuffer(bytes, offset, length) {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n// src/f32.ts\nvar getF32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"f32\",\n        set: (view, value, le)=>view.setFloat32(0, Number(value), le),\n        size: 4\n    });\nvar getF32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getFloat32(0, le),\n        name: \"f32\",\n        size: 4\n    });\nvar getF32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getF32Encoder(config), getF32Decoder(config));\nvar getF64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"f64\",\n        set: (view, value, le)=>view.setFloat64(0, Number(value), le),\n        size: 8\n    });\nvar getF64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getFloat64(0, le),\n        name: \"f64\",\n        size: 8\n    });\nvar getF64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getF64Encoder(config), getF64Decoder(config));\nvar getI128Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i128\",\n        range: [\n            -BigInt(\"0x7fffffffffffffffffffffffffffffff\") - 1n,\n            BigInt(\"0x7fffffffffffffffffffffffffffffff\")\n        ],\n        set: (view, value, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16\n    });\nvar getI128Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: \"i128\",\n        size: 16\n    });\nvar getI128Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI128Encoder(config), getI128Decoder(config));\nvar getI16Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i16\",\n        range: [\n            -Number(\"0x7fff\") - 1,\n            Number(\"0x7fff\")\n        ],\n        set: (view, value, le)=>view.setInt16(0, Number(value), le),\n        size: 2\n    });\nvar getI16Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getInt16(0, le),\n        name: \"i16\",\n        size: 2\n    });\nvar getI16Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI16Encoder(config), getI16Decoder(config));\nvar getI32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i32\",\n        range: [\n            -Number(\"0x7fffffff\") - 1,\n            Number(\"0x7fffffff\")\n        ],\n        set: (view, value, le)=>view.setInt32(0, Number(value), le),\n        size: 4\n    });\nvar getI32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getInt32(0, le),\n        name: \"i32\",\n        size: 4\n    });\nvar getI32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI32Encoder(config), getI32Decoder(config));\nvar getI64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i64\",\n        range: [\n            -BigInt(\"0x7fffffffffffffff\") - 1n,\n            BigInt(\"0x7fffffffffffffff\")\n        ],\n        set: (view, value, le)=>view.setBigInt64(0, BigInt(value), le),\n        size: 8\n    });\nvar getI64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getBigInt64(0, le),\n        name: \"i64\",\n        size: 8\n    });\nvar getI64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI64Encoder(config), getI64Decoder(config));\nvar getI8Encoder = ()=>numberEncoderFactory({\n        name: \"i8\",\n        range: [\n            -Number(\"0x7f\") - 1,\n            Number(\"0x7f\")\n        ],\n        set: (view, value)=>view.setInt8(0, Number(value)),\n        size: 1\n    });\nvar getI8Decoder = ()=>numberDecoderFactory({\n        get: (view)=>view.getInt8(0),\n        name: \"i8\",\n        size: 1\n    });\nvar getI8Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI8Encoder(), getI8Decoder());\nvar getShortU16Encoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        getSizeFromValue: (value)=>{\n            if (value <= 127) return 1;\n            if (value <= 16383) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value, bytes, offset)=>{\n            assertNumberIsBetweenForCodec(\"shortU16\", 0, 65535, value);\n            const shortU16Bytes = [\n                0\n            ];\n            for(let ii = 0;; ii += 1){\n                const alignedValue = Number(value) >> ii * 7;\n                if (alignedValue === 0) {\n                    break;\n                }\n                const nextSevenBits = 127 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    shortU16Bytes[ii - 1] |= 128;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        }\n    });\nvar getShortU16Decoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        maxSize: 3,\n        read: (bytes, offset)=>{\n            let value = 0;\n            let byteCount = 0;\n            while(++byteCount){\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 127 & currentByte;\n                value |= nextSevenBits << byteIndex * 7;\n                if ((currentByte & 128) === 0) {\n                    break;\n                }\n            }\n            return [\n                value,\n                offset + byteCount\n            ];\n        }\n    });\nvar getShortU16Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getShortU16Encoder(), getShortU16Decoder());\nvar getU128Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u128\",\n        range: [\n            0n,\n            BigInt(\"0xffffffffffffffffffffffffffffffff\")\n        ],\n        set: (view, value, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16\n    });\nvar getU128Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: \"u128\",\n        size: 16\n    });\nvar getU128Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU128Encoder(config), getU128Decoder(config));\nvar getU16Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u16\",\n        range: [\n            0,\n            Number(\"0xffff\")\n        ],\n        set: (view, value, le)=>view.setUint16(0, Number(value), le),\n        size: 2\n    });\nvar getU16Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getUint16(0, le),\n        name: \"u16\",\n        size: 2\n    });\nvar getU16Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU16Encoder(config), getU16Decoder(config));\nvar getU32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u32\",\n        range: [\n            0,\n            Number(\"0xffffffff\")\n        ],\n        set: (view, value, le)=>view.setUint32(0, Number(value), le),\n        size: 4\n    });\nvar getU32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getUint32(0, le),\n        name: \"u32\",\n        size: 4\n    });\nvar getU32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU32Encoder(config), getU32Decoder(config));\nvar getU64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u64\",\n        range: [\n            0n,\n            BigInt(\"0xffffffffffffffff\")\n        ],\n        set: (view, value, le)=>view.setBigUint64(0, BigInt(value), le),\n        size: 8\n    });\nvar getU64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getBigUint64(0, le),\n        name: \"u64\",\n        size: 8\n    });\nvar getU64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU64Encoder(config), getU64Decoder(config));\nvar getU8Encoder = ()=>numberEncoderFactory({\n        name: \"u8\",\n        range: [\n            0,\n            Number(\"0xff\")\n        ],\n        set: (view, value)=>view.setUint8(0, Number(value)),\n        size: 1\n    });\nvar getU8Decoder = ()=>numberDecoderFactory({\n        get: (view)=>view.getUint8(0),\n        name: \"u8\",\n        size: 1\n    });\nvar getU8Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU8Encoder(), getU8Decoder());\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtbnVtYmVycy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Y7QUFDbUU7QUFFM0osb0JBQW9CO0FBQ3BCLFNBQVNPLDhCQUE4QkMsZ0JBQWdCLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxLQUFLO0lBQ3RFLElBQUlBLFFBQVFGLE9BQU9FLFFBQVFELEtBQUs7UUFDOUIsTUFBTSxJQUFJVix1REFBV0EsQ0FBQ0MscUZBQXlDQSxFQUFFO1lBQy9ETztZQUNBRTtZQUNBRDtZQUNBRTtRQUNGO0lBQ0Y7QUFDRjtBQUVBLGdCQUFnQjtBQUNoQixJQUFJQyxTQUF5QixhQUFILEdBQUksRUFBQ0M7SUFDN0JBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDakNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDOUIsT0FBT0E7QUFDVCxHQUFHRCxVQUFVLENBQUM7QUFDZCxTQUFTRSxlQUFlQyxNQUFNO0lBQzVCLE9BQU9BLFFBQVFDLFdBQVcsRUFBRSxPQUFPLE1BQUssUUFBUTtBQUNsRDtBQUNBLFNBQVNDLHFCQUFxQkMsS0FBSztJQUNqQyxPQUFPZCxrRUFBYUEsQ0FBQztRQUNuQmUsV0FBV0QsTUFBTUUsSUFBSTtRQUNyQkMsT0FBTVYsS0FBSyxFQUFFVyxLQUFLLEVBQUVDLE1BQU07WUFDeEIsSUFBSUwsTUFBTU0sS0FBSyxFQUFFO2dCQUNmakIsOEJBQThCVyxNQUFNTyxJQUFJLEVBQUVQLE1BQU1NLEtBQUssQ0FBQyxFQUFFLEVBQUVOLE1BQU1NLEtBQUssQ0FBQyxFQUFFLEVBQUViO1lBQzVFO1lBQ0EsTUFBTWUsY0FBYyxJQUFJQyxZQUFZVCxNQUFNRSxJQUFJO1lBQzlDRixNQUFNVSxHQUFHLENBQUMsSUFBSUMsU0FBU0gs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Y2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1udW1iZXJzL2Rpc3QvaW5kZXgubm9kZS5tanM/ZDc5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0UgfSBmcm9tICdAc29sYW5hL2Vycm9ycyc7XG5pbXBvcnQgeyBjb21iaW5lQ29kZWMsIGNyZWF0ZURlY29kZXIsIGNyZWF0ZUVuY29kZXIsIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYywgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLWNvcmUnO1xuXG4vLyBzcmMvYXNzZXJ0aW9ucy50c1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVySXNCZXR3ZWVuRm9yQ29kZWMoY29kZWNEZXNjcmlwdGlvbiwgbWluLCBtYXgsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSwge1xuICAgICAgY29kZWNEZXNjcmlwdGlvbixcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL2NvbW1vbi50c1xudmFyIEVuZGlhbiA9IC8qIEBfX1BVUkVfXyAqLyAoKEVuZGlhbjIpID0+IHtcbiAgRW5kaWFuMltFbmRpYW4yW1wiTGl0dGxlXCJdID0gMF0gPSBcIkxpdHRsZVwiO1xuICBFbmRpYW4yW0VuZGlhbjJbXCJCaWdcIl0gPSAxXSA9IFwiQmlnXCI7XG4gIHJldHVybiBFbmRpYW4yO1xufSkoRW5kaWFuIHx8IHt9KTtcbmZ1bmN0aW9uIGlzTGl0dGxlRW5kaWFuKGNvbmZpZykge1xuICByZXR1cm4gY29uZmlnPy5lbmRpYW4gPT09IDEgLyogQmlnICovID8gZmFsc2UgOiB0cnVlO1xufVxuZnVuY3Rpb24gbnVtYmVyRW5jb2RlckZhY3RvcnkoaW5wdXQpIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogaW5wdXQuc2l6ZSxcbiAgICB3cml0ZSh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkge1xuICAgICAgaWYgKGlucHV0LnJhbmdlKSB7XG4gICAgICAgIGFzc2VydE51bWJlcklzQmV0d2VlbkZvckNvZGVjKGlucHV0Lm5hbWUsIGlucHV0LnJhbmdlWzBdLCBpbnB1dC5yYW5nZVsxXSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoaW5wdXQuc2l6ZSk7XG4gICAgICBpbnB1dC5zZXQobmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKSwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKGlucHV0LmNvbmZpZykpO1xuICAgICAgYnl0ZXMuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBpbnB1dC5zaXplO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBudW1iZXJEZWNvZGVyRmFjdG9yeShpbnB1dCkge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgZml4ZWRTaXplOiBpbnB1dC5zaXplLFxuICAgIHJlYWQoYnl0ZXMsIG9mZnNldCA9IDApIHtcbiAgICAgIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyhpbnB1dC5uYW1lLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoaW5wdXQubmFtZSwgaW5wdXQuc2l6ZSwgYnl0ZXMsIG9mZnNldCk7XG4gICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHRvQXJyYXlCdWZmZXIoYnl0ZXMsIG9mZnNldCwgaW5wdXQuc2l6ZSkpO1xuICAgICAgcmV0dXJuIFtpbnB1dC5nZXQodmlldywgaXNMaXR0bGVFbmRpYW4oaW5wdXQuY29uZmlnKSksIG9mZnNldCArIGlucHV0LnNpemVdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ5dGVzLCBvZmZzZXQsIGxlbmd0aCkge1xuICBjb25zdCBieXRlc09mZnNldCA9IGJ5dGVzLmJ5dGVPZmZzZXQgKyAob2Zmc2V0ID8/IDApO1xuICBjb25zdCBieXRlc0xlbmd0aCA9IGxlbmd0aCA/PyBieXRlcy5ieXRlTGVuZ3RoO1xuICByZXR1cm4gYnl0ZXMuYnVmZmVyLnNsaWNlKGJ5dGVzT2Zmc2V0LCBieXRlc09mZnNldCArIGJ5dGVzTGVuZ3RoKTtcbn1cblxuLy8gc3JjL2YzMi50c1xudmFyIGdldEYzMkVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcImYzMlwiLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0RmxvYXQzMigwLCBOdW1iZXIodmFsdWUpLCBsZSksXG4gIHNpemU6IDRcbn0pO1xudmFyIGdldEYzMkRlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRGbG9hdDMyKDAsIGxlKSxcbiAgbmFtZTogXCJmMzJcIixcbiAgc2l6ZTogNFxufSk7XG52YXIgZ2V0RjMyQ29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRGMzJFbmNvZGVyKGNvbmZpZyksIGdldEYzMkRlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0RjY0RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwiZjY0XCIsXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRGbG9hdDY0KDAsIE51bWJlcih2YWx1ZSksIGxlKSxcbiAgc2l6ZTogOFxufSk7XG52YXIgZ2V0RjY0RGVjb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIGdldDogKHZpZXcsIGxlKSA9PiB2aWV3LmdldEZsb2F0NjQoMCwgbGUpLFxuICBuYW1lOiBcImY2NFwiLFxuICBzaXplOiA4XG59KTtcbnZhciBnZXRGNjRDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEY2NEVuY29kZXIoY29uZmlnKSwgZ2V0RjY0RGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRJMTI4RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwiaTEyOFwiLFxuICByYW5nZTogWy1CaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpIC0gMW4sIEJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHtcbiAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gbGUgPyA4IDogMDtcbiAgICBjb25zdCByaWdodE9mZnNldCA9IGxlID8gMCA6IDg7XG4gICAgY29uc3QgcmlnaHRNYXNrID0gMHhmZmZmZmZmZmZmZmZmZmZmbjtcbiAgICB2aWV3LnNldEJpZ0ludDY0KGxlZnRPZmZzZXQsIEJpZ0ludCh2YWx1ZSkgPj4gNjRuLCBsZSk7XG4gICAgdmlldy5zZXRCaWdVaW50NjQocmlnaHRPZmZzZXQsIEJpZ0ludCh2YWx1ZSkgJiByaWdodE1hc2ssIGxlKTtcbiAgfSxcbiAgc2l6ZTogMTZcbn0pO1xudmFyIGdldEkxMjhEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHtcbiAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gbGUgPyA4IDogMDtcbiAgICBjb25zdCByaWdodE9mZnNldCA9IGxlID8gMCA6IDg7XG4gICAgY29uc3QgbGVmdCA9IHZpZXcuZ2V0QmlnSW50NjQobGVmdE9mZnNldCwgbGUpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdmlldy5nZXRCaWdVaW50NjQocmlnaHRPZmZzZXQsIGxlKTtcbiAgICByZXR1cm4gKGxlZnQgPDwgNjRuKSArIHJpZ2h0O1xuICB9LFxuICBuYW1lOiBcImkxMjhcIixcbiAgc2l6ZTogMTZcbn0pO1xudmFyIGdldEkxMjhDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEkxMjhFbmNvZGVyKGNvbmZpZyksIGdldEkxMjhEZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldEkxNkVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcImkxNlwiLFxuICByYW5nZTogWy1OdW1iZXIoXCIweDdmZmZcIikgLSAxLCBOdW1iZXIoXCIweDdmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0SW50MTYoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiAyXG59KTtcbnZhciBnZXRJMTZEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0SW50MTYoMCwgbGUpLFxuICBuYW1lOiBcImkxNlwiLFxuICBzaXplOiAyXG59KTtcbnZhciBnZXRJMTZDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEkxNkVuY29kZXIoY29uZmlnKSwgZ2V0STE2RGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRJMzJFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJpMzJcIixcbiAgcmFuZ2U6IFstTnVtYmVyKFwiMHg3ZmZmZmZmZlwiKSAtIDEsIE51bWJlcihcIjB4N2ZmZmZmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0SW50MzIoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiA0XG59KTtcbnZhciBnZXRJMzJEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0SW50MzIoMCwgbGUpLFxuICBuYW1lOiBcImkzMlwiLFxuICBzaXplOiA0XG59KTtcbnZhciBnZXRJMzJDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEkzMkVuY29kZXIoY29uZmlnKSwgZ2V0STMyRGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRJNjRFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJpNjRcIixcbiAgcmFuZ2U6IFstQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmXCIpIC0gMW4sIEJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRCaWdJbnQ2NCgwLCBCaWdJbnQodmFsdWUpLCBsZSksXG4gIHNpemU6IDhcbn0pO1xudmFyIGdldEk2NERlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRCaWdJbnQ2NCgwLCBsZSksXG4gIG5hbWU6IFwiaTY0XCIsXG4gIHNpemU6IDhcbn0pO1xudmFyIGdldEk2NENvZGVjID0gKGNvbmZpZyA9IHt9KSA9PiBjb21iaW5lQ29kZWMoZ2V0STY0RW5jb2Rlcihjb25maWcpLCBnZXRJNjREZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldEk4RW5jb2RlciA9ICgpID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgbmFtZTogXCJpOFwiLFxuICByYW5nZTogWy1OdW1iZXIoXCIweDdmXCIpIC0gMSwgTnVtYmVyKFwiMHg3ZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlKSA9PiB2aWV3LnNldEludDgoMCwgTnVtYmVyKHZhbHVlKSksXG4gIHNpemU6IDFcbn0pO1xudmFyIGdldEk4RGVjb2RlciA9ICgpID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgZ2V0OiAodmlldykgPT4gdmlldy5nZXRJbnQ4KDApLFxuICBuYW1lOiBcImk4XCIsXG4gIHNpemU6IDFcbn0pO1xudmFyIGdldEk4Q29kZWMgPSAoKSA9PiBjb21iaW5lQ29kZWMoZ2V0SThFbmNvZGVyKCksIGdldEk4RGVjb2RlcigpKTtcbnZhciBnZXRTaG9ydFUxNkVuY29kZXIgPSAoKSA9PiBjcmVhdGVFbmNvZGVyKHtcbiAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlIDw9IDEyNykgcmV0dXJuIDE7XG4gICAgaWYgKHZhbHVlIDw9IDE2MzgzKSByZXR1cm4gMjtcbiAgICByZXR1cm4gMztcbiAgfSxcbiAgbWF4U2l6ZTogMyxcbiAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGFzc2VydE51bWJlcklzQmV0d2VlbkZvckNvZGVjKFwic2hvcnRVMTZcIiwgMCwgNjU1MzUsIHZhbHVlKTtcbiAgICBjb25zdCBzaG9ydFUxNkJ5dGVzID0gWzBdO1xuICAgIGZvciAobGV0IGlpID0gMDsgOyBpaSArPSAxKSB7XG4gICAgICBjb25zdCBhbGlnbmVkVmFsdWUgPSBOdW1iZXIodmFsdWUpID4+IGlpICogNztcbiAgICAgIGlmIChhbGlnbmVkVmFsdWUgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0U2V2ZW5CaXRzID0gMTI3ICYgYWxpZ25lZFZhbHVlO1xuICAgICAgc2hvcnRVMTZCeXRlc1tpaV0gPSBuZXh0U2V2ZW5CaXRzO1xuICAgICAgaWYgKGlpID4gMCkge1xuICAgICAgICBzaG9ydFUxNkJ5dGVzW2lpIC0gMV0gfD0gMTI4O1xuICAgICAgfVxuICAgIH1cbiAgICBieXRlcy5zZXQoc2hvcnRVMTZCeXRlcywgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgc2hvcnRVMTZCeXRlcy5sZW5ndGg7XG4gIH1cbn0pO1xudmFyIGdldFNob3J0VTE2RGVjb2RlciA9ICgpID0+IGNyZWF0ZURlY29kZXIoe1xuICBtYXhTaXplOiAzLFxuICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgbGV0IGJ5dGVDb3VudCA9IDA7XG4gICAgd2hpbGUgKCsrYnl0ZUNvdW50KSB7XG4gICAgICBjb25zdCBieXRlSW5kZXggPSBieXRlQ291bnQgLSAxO1xuICAgICAgY29uc3QgY3VycmVudEJ5dGUgPSBieXRlc1tvZmZzZXQgKyBieXRlSW5kZXhdO1xuICAgICAgY29uc3QgbmV4dFNldmVuQml0cyA9IDEyNyAmIGN1cnJlbnRCeXRlO1xuICAgICAgdmFsdWUgfD0gbmV4dFNldmVuQml0cyA8PCBieXRlSW5kZXggKiA3O1xuICAgICAgaWYgKChjdXJyZW50Qnl0ZSAmIDEyOCkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIG9mZnNldCArIGJ5dGVDb3VudF07XG4gIH1cbn0pO1xudmFyIGdldFNob3J0VTE2Q29kZWMgPSAoKSA9PiBjb21iaW5lQ29kZWMoZ2V0U2hvcnRVMTZFbmNvZGVyKCksIGdldFNob3J0VTE2RGVjb2RlcigpKTtcbnZhciBnZXRVMTI4RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwidTEyOFwiLFxuICByYW5nZTogWzBuLCBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpXSxcbiAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB7XG4gICAgY29uc3QgbGVmdE9mZnNldCA9IGxlID8gOCA6IDA7XG4gICAgY29uc3QgcmlnaHRPZmZzZXQgPSBsZSA/IDAgOiA4O1xuICAgIGNvbnN0IHJpZ2h0TWFzayA9IDB4ZmZmZmZmZmZmZmZmZmZmZm47XG4gICAgdmlldy5zZXRCaWdVaW50NjQobGVmdE9mZnNldCwgQmlnSW50KHZhbHVlKSA+PiA2NG4sIGxlKTtcbiAgICB2aWV3LnNldEJpZ1VpbnQ2NChyaWdodE9mZnNldCwgQmlnSW50KHZhbHVlKSAmIHJpZ2h0TWFzaywgbGUpO1xuICB9LFxuICBzaXplOiAxNlxufSk7XG52YXIgZ2V0VTEyOERlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4ge1xuICAgIGNvbnN0IGxlZnRPZmZzZXQgPSBsZSA/IDggOiAwO1xuICAgIGNvbnN0IHJpZ2h0T2Zmc2V0ID0gbGUgPyAwIDogODtcbiAgICBjb25zdCBsZWZ0ID0gdmlldy5nZXRCaWdVaW50NjQobGVmdE9mZnNldCwgbGUpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdmlldy5nZXRCaWdVaW50NjQocmlnaHRPZmZzZXQsIGxlKTtcbiAgICByZXR1cm4gKGxlZnQgPDwgNjRuKSArIHJpZ2h0O1xuICB9LFxuICBuYW1lOiBcInUxMjhcIixcbiAgc2l6ZTogMTZcbn0pO1xudmFyIGdldFUxMjhDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldFUxMjhFbmNvZGVyKGNvbmZpZyksIGdldFUxMjhEZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldFUxNkVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcInUxNlwiLFxuICByYW5nZTogWzAsIE51bWJlcihcIjB4ZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRVaW50MTYoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiAyXG59KTtcbnZhciBnZXRVMTZEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0VWludDE2KDAsIGxlKSxcbiAgbmFtZTogXCJ1MTZcIixcbiAgc2l6ZTogMlxufSk7XG52YXIgZ2V0VTE2Q29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRVMTZFbmNvZGVyKGNvbmZpZyksIGdldFUxNkRlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0VTMyRW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwidTMyXCIsXG4gIHJhbmdlOiBbMCwgTnVtYmVyKFwiMHhmZmZmZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRVaW50MzIoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiA0XG59KTtcbnZhciBnZXRVMzJEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0VWludDMyKDAsIGxlKSxcbiAgbmFtZTogXCJ1MzJcIixcbiAgc2l6ZTogNFxufSk7XG52YXIgZ2V0VTMyQ29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRVMzJFbmNvZGVyKGNvbmZpZyksIGdldFUzMkRlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0VTY0RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwidTY0XCIsXG4gIHJhbmdlOiBbMG4sIEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRCaWdVaW50NjQoMCwgQmlnSW50KHZhbHVlKSwgbGUpLFxuICBzaXplOiA4XG59KTtcbnZhciBnZXRVNjREZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0QmlnVWludDY0KDAsIGxlKSxcbiAgbmFtZTogXCJ1NjRcIixcbiAgc2l6ZTogOFxufSk7XG52YXIgZ2V0VTY0Q29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRVNjRFbmNvZGVyKGNvbmZpZyksIGdldFU2NERlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0VThFbmNvZGVyID0gKCkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBuYW1lOiBcInU4XCIsXG4gIHJhbmdlOiBbMCwgTnVtYmVyKFwiMHhmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlKSA9PiB2aWV3LnNldFVpbnQ4KDAsIE51bWJlcih2YWx1ZSkpLFxuICBzaXplOiAxXG59KTtcbnZhciBnZXRVOERlY29kZXIgPSAoKSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGdldDogKHZpZXcpID0+IHZpZXcuZ2V0VWludDgoMCksXG4gIG5hbWU6IFwidThcIixcbiAgc2l6ZTogMVxufSk7XG52YXIgZ2V0VThDb2RlYyA9ICgpID0+IGNvbWJpbmVDb2RlYyhnZXRVOEVuY29kZXIoKSwgZ2V0VThEZWNvZGVyKCkpO1xuXG5leHBvcnQgeyBFbmRpYW4sIGFzc2VydE51bWJlcklzQmV0d2VlbkZvckNvZGVjLCBnZXRGMzJDb2RlYywgZ2V0RjMyRGVjb2RlciwgZ2V0RjMyRW5jb2RlciwgZ2V0RjY0Q29kZWMsIGdldEY2NERlY29kZXIsIGdldEY2NEVuY29kZXIsIGdldEkxMjhDb2RlYywgZ2V0STEyOERlY29kZXIsIGdldEkxMjhFbmNvZGVyLCBnZXRJMTZDb2RlYywgZ2V0STE2RGVjb2RlciwgZ2V0STE2RW5jb2RlciwgZ2V0STMyQ29kZWMsIGdldEkzMkRlY29kZXIsIGdldEkzMkVuY29kZXIsIGdldEk2NENvZGVjLCBnZXRJNjREZWNvZGVyLCBnZXRJNjRFbmNvZGVyLCBnZXRJOENvZGVjLCBnZXRJOERlY29kZXIsIGdldEk4RW5jb2RlciwgZ2V0U2hvcnRVMTZDb2RlYywgZ2V0U2hvcnRVMTZEZWNvZGVyLCBnZXRTaG9ydFUxNkVuY29kZXIsIGdldFUxMjhDb2RlYywgZ2V0VTEyOERlY29kZXIsIGdldFUxMjhFbmNvZGVyLCBnZXRVMTZDb2RlYywgZ2V0VTE2RGVjb2RlciwgZ2V0VTE2RW5jb2RlciwgZ2V0VTMyQ29kZWMsIGdldFUzMkRlY29kZXIsIGdldFUzMkVuY29kZXIsIGdldFU2NENvZGVjLCBnZXRVNjREZWNvZGVyLCBnZXRVNjRFbmNvZGVyLCBnZXRVOENvZGVjLCBnZXRVOERlY29kZXIsIGdldFU4RW5jb2RlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSIsImNvbWJpbmVDb2RlYyIsImNyZWF0ZURlY29kZXIiLCJjcmVhdGVFbmNvZGVyIiwiYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjIiwiYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyIsImFzc2VydE51bWJlcklzQmV0d2VlbkZvckNvZGVjIiwiY29kZWNEZXNjcmlwdGlvbiIsIm1pbiIsIm1heCIsInZhbHVlIiwiRW5kaWFuIiwiRW5kaWFuMiIsImlzTGl0dGxlRW5kaWFuIiwiY29uZmlnIiwiZW5kaWFuIiwibnVtYmVyRW5jb2RlckZhY3RvcnkiLCJpbnB1dCIsImZpeGVkU2l6ZSIsInNpemUiLCJ3cml0ZSIsImJ5dGVzIiwib2Zmc2V0IiwicmFuZ2UiLCJuYW1lIiwiYXJyYXlCdWZmZXIiLCJBcnJheUJ1ZmZlciIsInNldCIsIkRhdGFWaWV3IiwiVWludDhBcnJheSIsIm51bWJlckRlY29kZXJGYWN0b3J5IiwicmVhZCIsInZpZXciLCJ0b0FycmF5QnVmZmVyIiwiZ2V0IiwibGVuZ3RoIiwiYnl0ZXNPZmZzZXQiLCJieXRlT2Zmc2V0IiwiYnl0ZXNMZW5ndGgiLCJieXRlTGVuZ3RoIiwiYnVmZmVyIiwic2xpY2UiLCJnZXRGMzJFbmNvZGVyIiwibGUiLCJzZXRGbG9hdDMyIiwiTnVtYmVyIiwiZ2V0RjMyRGVjb2RlciIsImdldEZsb2F0MzIiLCJnZXRGMzJDb2RlYyIsImdldEY2NEVuY29kZXIiLCJzZXRGbG9hdDY0IiwiZ2V0RjY0RGVjb2RlciIsImdldEZsb2F0NjQiLCJnZXRGNjRDb2RlYyIsImdldEkxMjhFbmNvZGVyIiwiQmlnSW50IiwibGVmdE9mZnNldCIsInJpZ2h0T2Zmc2V0IiwicmlnaHRNYXNrIiwic2V0QmlnSW50NjQiLCJzZXRCaWdVaW50NjQiLCJnZXRJMTI4RGVjb2RlciIsImxlZnQiLCJnZXRCaWdJbnQ2NCIsInJpZ2h0IiwiZ2V0QmlnVWludDY0IiwiZ2V0STEyOENvZGVjIiwiZ2V0STE2RW5jb2RlciIsInNldEludDE2IiwiZ2V0STE2RGVjb2RlciIsImdldEludDE2IiwiZ2V0STE2Q29kZWMiLCJnZXRJMzJFbmNvZGVyIiwic2V0SW50MzIiLCJnZXRJMzJEZWNvZGVyIiwiZ2V0SW50MzIiLCJnZXRJMzJDb2RlYyIsImdldEk2NEVuY29kZXIiLCJnZXRJNjREZWNvZGVyIiwiZ2V0STY0Q29kZWMiLCJnZXRJOEVuY29kZXIiLCJzZXRJbnQ4IiwiZ2V0SThEZWNvZGVyIiwiZ2V0SW50OCIsImdldEk4Q29kZWMiLCJnZXRTaG9ydFUxNkVuY29kZXIiLCJnZXRTaXplRnJvbVZhbHVlIiwibWF4U2l6ZSIsInNob3J0VTE2Qnl0ZXMiLCJpaSIsImFsaWduZWRWYWx1ZSIsIm5leHRTZXZlbkJpdHMiLCJnZXRTaG9ydFUxNkRlY29kZXIiLCJieXRlQ291bnQiLCJieXRlSW5kZXgiLCJjdXJyZW50Qnl0ZSIsImdldFNob3J0VTE2Q29kZWMiLCJnZXRVMTI4RW5jb2RlciIsImdldFUxMjhEZWNvZGVyIiwiZ2V0VTEyOENvZGVjIiwiZ2V0VTE2RW5jb2RlciIsInNldFVpbnQxNiIsImdldFUxNkRlY29kZXIiLCJnZXRVaW50MTYiLCJnZXRVMTZDb2RlYyIsImdldFUzMkVuY29kZXIiLCJzZXRVaW50MzIiLCJnZXRVMzJEZWNvZGVyIiwiZ2V0VWludDMyIiwiZ2V0VTMyQ29kZWMiLCJnZXRVNjRFbmNvZGVyIiwiZ2V0VTY0RGVjb2RlciIsImdldFU2NENvZGVjIiwiZ2V0VThFbmNvZGVyIiwic2V0VWludDgiLCJnZXRVOERlY29kZXIiLCJnZXRVaW50OCIsImdldFU4Q29kZWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/errors/dist/index.node.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@solana/errors/dist/index.node.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MALFORMED_PDA: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MALFORMED_PDA),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER: () => (/* binding */ SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED: () => (/* binding */ SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY: () => (/* binding */ SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY),\n/* harmony export */   SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS: () => (/* binding */ SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_CONSTANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_CONSTANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE),\n/* harmony export */   SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES: () => (/* binding */ SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES),\n/* harmony export */   SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH),\n/* harmony export */   SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__INVALID_NONCE: () => (/* binding */ SOLANA_ERROR__INVALID_NONCE),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INVALID_PARAMS: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INVALID_PARAMS),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INVALID_REQUEST: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INVALID_REQUEST),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__PARSE_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__PARSE_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SCAN_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SCAN_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY: () => (/* binding */ SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY),\n/* harmony export */   SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__MALFORMED_BIGINT_STRING: () => (/* binding */ SOLANA_ERROR__MALFORMED_BIGINT_STRING),\n/* harmony export */   SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR: () => (/* binding */ SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR),\n/* harmony export */   SOLANA_ERROR__MALFORMED_NUMBER_STRING: () => (/* binding */ SOLANA_ERROR__MALFORMED_NUMBER_STRING),\n/* harmony export */   SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID),\n/* harmony export */   SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD: () => (/* binding */ SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD),\n/* harmony export */   SOLANA_ERROR__RPC__INTEGER_OVERFLOW: () => (/* binding */ SOLANA_ERROR__RPC__INTEGER_OVERFLOW),\n/* harmony export */   SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR: () => (/* binding */ SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR),\n/* harmony export */   SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN: () => (/* binding */ SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN),\n/* harmony export */   SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS: () => (/* binding */ SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS: () => (/* binding */ SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS),\n/* harmony export */   SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING: () => (/* binding */ SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING),\n/* harmony export */   SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES: () => (/* binding */ SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH: () => (/* binding */ SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE),\n/* harmony export */   SolanaError: () => (/* binding */ SolanaError),\n/* harmony export */   getSolanaErrorFromInstructionError: () => (/* binding */ getSolanaErrorFromInstructionError),\n/* harmony export */   getSolanaErrorFromJsonRpcError: () => (/* binding */ getSolanaErrorFromJsonRpcError),\n/* harmony export */   getSolanaErrorFromTransactionError: () => (/* binding */ getSolanaErrorFromTransactionError),\n/* harmony export */   isSolanaError: () => (/* binding */ isSolanaError),\n/* harmony export */   safeCaptureStackTrace: () => (/* binding */ safeCaptureStackTrace)\n/* harmony export */ });\n// src/codes.ts\nvar SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nvar SOLANA_ERROR__INVALID_NONCE = 2;\nvar SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nvar SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nvar SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nvar SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nvar SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nvar SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nvar SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nvar SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\nvar SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nvar SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nvar SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nvar SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nvar SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nvar SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;\nvar SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nvar SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nvar SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nvar SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nvar SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nvar SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nvar SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nvar SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nvar SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nvar SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\nvar SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;\nvar SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nvar SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\nvar SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;\nvar SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;\nvar SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nvar SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nvar SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nvar SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nvar SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\nvar SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;\nvar SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nvar SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nvar SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nvar SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nvar SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nvar SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nvar SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nvar SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nvar SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nvar SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nvar SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nvar SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nvar SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nvar SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\nvar SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;\nvar SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nvar SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nvar SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nvar SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nvar SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nvar SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nvar SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nvar SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nvar SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nvar SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nvar SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nvar SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nvar SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nvar SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nvar SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nvar SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nvar SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nvar SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nvar SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\nvar SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nvar SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\n// src/context.ts\nfunction encodeValue(value) {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join(\"%2C%20\");\n        return \"%5B\" + commaSeparatedValues + /* \"]\" */ \"%5D\";\n    } else if (typeof value === \"bigint\") {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(String(value != null && Object.getPrototypeOf(value) === null ? // Plain objects with no prototype don't have a `toString` method.\n        // Convert them before stringifying them.\n        {\n            ...value\n        } : value));\n    }\n}\nfunction encodeObjectContextEntry([key, value]) {\n    return `${key}=${encodeValue(value)}`;\n}\nfunction encodeContextObject(context) {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join(\"&\");\n    return Buffer.from(searchParamsString, \"utf8\").toString(\"base64\");\n}\n// src/messages.ts\nvar SolanaErrorMessages = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: \"Account not found at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: \"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.\",\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: \"Expected decoded account at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: \"Failed to decode account data at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: \"Accounts not found at addresses: $addresses\",\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: \"Unable to find a viable program address bump seed.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: \"$putativeAddress is not a base58-encoded address.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: \"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: \"The `CryptoKey` must be an `Ed25519` public key.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: \"$putativeOffCurveAddress is not a base58-encoded off-curve address.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: \"Invalid seeds; point must fall off the Ed25519 curve.\",\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: \"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].\",\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: \"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.\",\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: \"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.\",\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: \"Expected program derived address bump to be in the range [0, 255], got: $bump.\",\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: \"Program address cannot end with PDA marker.\",\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: \"The network has progressed past the last block for which this transaction could have been committed.\",\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: \"Codec [$codecDescription] cannot decode empty byte arrays.\",\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: \"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.\",\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: \"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: \"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: \"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: \"Encoder and decoder must either both be fixed-size or variable-size.\",\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: \"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: \"Expected a fixed-size codec, got a variable-size one.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: \"Codec [$codecDescription] expected a positive byte length, got $bytesLength.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: \"Expected a variable-size codec, got a fixed-size one.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: \"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].\",\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: \"Codec [$codecDescription] expected $expected bytes, got $bytesLength.\",\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: \"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].\",\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: \"Invalid discriminated union variant. Expected one of [$variants], got $value.\",\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: \"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.\",\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: \"Invalid literal union variant. Expected one of [$variants], got $value.\",\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: \"Expected [$codecDescription] to have $expected items, got $actual.\",\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: \"Invalid value $value for base $base with alphabet $alphabet.\",\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: \"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.\",\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: \"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.\",\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: \"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.\",\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: \"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].\",\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: \"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.\",\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: \"No random values implementation could be found.\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: \"instruction requires an uninitialized account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: \"instruction tries to borrow reference for an account which is already borrowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"instruction left account with an outstanding borrowed reference\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: \"account data too small for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: \"instruction expected an executable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: \"An account does not have enough lamports to be rent-exempt\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: \"Program arithmetic overflowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: \"Failed to serialize or deserialize account data: $encodedData\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: \"Builtin programs must consume compute units\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: \"Cross-program invocation call depth too deep\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: \"Computational budget exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: \"custom program error: #$code\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: \"instruction contains duplicate accounts\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: \"instruction modifications of multiply-passed account differ\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: \"executable accounts must be rent exempt\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: \"instruction changed executable accounts data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: \"instruction changed the balance of an executable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: \"instruction changed executable bit of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: \"instruction modified data of an account it does not own\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: \"instruction spent from the balance of an account it does not own\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: \"generic instruction error\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: \"Provided owner is not allowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: \"Account is immutable\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: \"Incorrect authority provided\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: \"incorrect program id for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: \"insufficient funds for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: \"invalid account data for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: \"Invalid account owner\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: \"invalid program argument\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: \"program returned invalid error code\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: \"invalid instruction data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: \"Failed to reallocate account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: \"Provided seeds do not result in a valid address\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: \"Accounts data allocations exceeded the maximum allowed per transaction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: \"Max accounts exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: \"Max instruction trace length exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: \"Length of the seed is too long for address generation\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: \"An account required by the instruction is missing\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: \"missing required signature for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: \"instruction illegally modified the program id of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: \"insufficient account keys for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: \"Cross-program invocation with unauthorized signer or writable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: \"Failed to create program execution environment\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: \"Program failed to compile\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: \"Program failed to complete\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: \"instruction modified data of a read-only account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: \"instruction changed the balance of a read-only account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: \"Cross-program invocation reentrancy not allowed for this instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: \"instruction modified rent epoch of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: \"sum of account balances before and after instruction do not match\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: \"instruction requires an initialized account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: \"\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: \"Unsupported program id\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: \"Unsupported sysvar\",\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: \"The instruction does not have any accounts.\",\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: \"The instruction does not have any data.\",\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: \"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.\",\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: \"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__INVALID_NONCE]: \"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: \"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: \"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: \"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: \"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: \"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: \"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: \"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: \"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: \"JSON-RPC error: The method does not exist / is not available ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: \"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: \"Minimum context slot has not been reached\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: \"Node is unhealthy; behind by $numSlotsBehind slots\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: \"No snapshot\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: \"Transaction simulation failed\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: \"Transaction history is not available from this node\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: \"Transaction signature length mismatch\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: \"Transaction signature verification failure\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: \"$__serverMessage\",\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: \"Key pair bytes must be of length 64, got $byteLength.\",\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: \"Expected private key bytes with length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: \"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.\",\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: \"The provided private key does not match the provided public key.\",\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: \"Lamports value must be in the range [0, 2e64-1]\",\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: \"`$value` cannot be parsed as a `BigInt`\",\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: \"$message\",\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: \"`$value` cannot be parsed as a `Number`\",\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: \"No nonce account could be found at address `$nonceAccountAddress`\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: \"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: \"WebSocket was closed before payload could be added to the send buffer\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: \"WebSocket connection closed\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: \"WebSocket failed to connect\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: \"Failed to obtain a subscription id from the server\",\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: \"Could not find an API plan for RPC method: `$method`\",\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: \"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.\",\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: \"HTTP error ($statusCode): $message\",\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: \"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.\",\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: \"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: \"The provided value does not implement the `KeyPairSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: \"The provided value does not implement the `MessageModifyingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: \"The provided value does not implement the `MessagePartialSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: \"The provided value does not implement any of the `MessageSigner` interfaces\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: \"The provided value does not implement the `TransactionModifyingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: \"The provided value does not implement the `TransactionPartialSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: \"The provided value does not implement the `TransactionSendingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: \"The provided value does not implement any of the `TransactionSigner` interfaces\",\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: \"More than one `TransactionSendingSigner` was identified.\",\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: \"No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.\",\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: \"Wallet account signers do not support signing multiple messages/transactions in a single operation\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: \"Cannot export a non-extractable key.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: \"No digest implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: \"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: \"This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\\n\\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: \"No signature verification implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: \"No key generation implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: \"No signing implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: \"No key export implementation could be found.\",\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: \"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"Transaction processing left an account with an outstanding borrowed reference\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: \"Account in use\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: \"Account loaded twice\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: \"Attempt to debit an account but found no record of a prior credit.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: \"This transaction has already been processed\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: \"Blockhash not found\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: \"Loader call chain is too deep\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: \"Transactions are currently disabled due to cluster maintenance\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: \"Transaction contains a duplicate instruction ($index) that is not allowed\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: \"Insufficient funds for fee\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: \"Transaction results in an account ($accountIndex) with insufficient funds for rent\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: \"This account may not be used to pay transaction fees\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: \"Transaction contains an invalid account reference\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: \"Transaction loads an address table account with invalid data\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: \"Transaction address table lookup uses an invalid index\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: \"Transaction loads an address table account with an invalid owner\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: \"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: \"This program may not be used for executing instructions\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: \"Transaction leaves an account with a lower balance than rent-exempt minimum\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: \"Transaction loads a writable account that cannot be written\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: \"Transaction exceeded max loaded accounts data size cap\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: \"Transaction requires a fee but has no signature present\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: \"Attempt to load a program that does not exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: \"Execution of the program referenced by account at index $accountIndex is temporarily restricted.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: \"ResanitizationNeeded\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: \"Transaction failed to sanitize accounts offsets correctly\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: \"Transaction did not pass signature verification\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: \"Transaction locked too many accounts\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: \"Sum of account balances before and after transaction do not match\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: \"The transaction failed with the error `$errorName`\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: \"Transaction version is unsupported\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: \"Transaction would exceed account data limit within the block\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: \"Transaction would exceed total account data limit\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: \"Transaction would exceed max account limit within the block\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: \"Transaction would exceed max Block Cost Limit\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: \"Transaction would exceed max Vote Cost Limit\",\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: \"Attempted to sign a transaction with an address that is not a signer for it\",\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: \"Transaction is missing an address at index: $index.\",\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: \"Transaction has no expected signers therefore it cannot be encoded\",\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: \"Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes\",\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: \"Transaction does not have a blockhash lifetime\",\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: \"Transaction is not a durable nonce transaction\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: \"Contents of these address lookup tables unknown: $lookupTableAddresses\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: \"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: \"No fee payer set in CompiledTransaction\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: \"Could not find program address at index $index\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: \"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: \"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more\",\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: \"Transaction is missing a fee payer.\",\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: \"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.\",\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: \"Transaction first instruction is not advance nonce account instruction.\",\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: \"Transaction with no instructions cannot be durable nonce transaction.\",\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: \"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees\",\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: \"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable\",\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: \"The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.\",\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: \"Transaction is missing signatures for addresses: $addresses.\",\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: \"Transaction version must be in the range [0, 127]. `$actualVersion` given\"\n};\n// src/message-formatter.ts\nvar START_INDEX = \"i\";\nvar TYPE = \"t\";\nfunction getHumanReadableErrorMessage(code, context = {}) {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return \"\";\n    }\n    let state;\n    function commitStateUpTo(endIndex) {\n        if (state[TYPE] === 2 /* Variable */ ) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n            fragments.push(variableName in context ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            `${context[variableName]}` : `$${variableName}`);\n        } else if (state[TYPE] === 1 /* Text */ ) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments = [];\n    messageFormatString.split(\"\").forEach((char, ii)=>{\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]: messageFormatString[0] === \"\\\\\" ? 0 /* EscapeSequence */  : messageFormatString[0] === \"$\" ? 2 /* Variable */  : 1 /* Text */ \n            };\n            return;\n        }\n        let nextState;\n        switch(state[TYPE]){\n            case 0 /* EscapeSequence */ :\n                nextState = {\n                    [START_INDEX]: ii,\n                    [TYPE]: 1 /* Text */ \n                };\n                break;\n            case 1 /* Text */ :\n                if (char === \"\\\\\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 0 /* EscapeSequence */ \n                    };\n                } else if (char === \"$\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 2 /* Variable */ \n                    };\n                }\n                break;\n            case 2 /* Variable */ :\n                if (char === \"\\\\\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 0 /* EscapeSequence */ \n                    };\n                } else if (char === \"$\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 2 /* Variable */ \n                    };\n                } else if (!char.match(/\\w/)) {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 1 /* Text */ \n                    };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join(\"\");\n}\nfunction getErrorMessage(code, context = {}) {\n    if (true) {\n        return getHumanReadableErrorMessage(code, context);\n    } else {}\n}\n// src/error.ts\nfunction isSolanaError(e, code) {\n    const isSolanaError2 = e instanceof Error && e.name === \"SolanaError\";\n    if (isSolanaError2) {\n        if (code !== void 0) {\n            return e.context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\nvar SolanaError = class extends Error {\n    constructor(...[code, contextAndErrorOptions]){\n        let context;\n        let errorOptions;\n        if (contextAndErrorOptions) {\n            const { cause, ...contextRest } = contextAndErrorOptions;\n            if (cause) {\n                errorOptions = {\n                    cause\n                };\n            }\n            if (Object.keys(contextRest).length > 0) {\n                context = contextRest;\n            }\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        /**\n   * Indicates the root cause of this {@link SolanaError}, if any.\n   *\n   * For example, a transaction error might have an instruction error as its root cause. In this\n   * case, you will be able to access the instruction error on the transaction error as `cause`.\n   */ this.cause = this.cause;\n        this.context = {\n            __code: code,\n            ...context\n        };\n        this.name = \"SolanaError\";\n    }\n};\n// src/stack-trace.ts\nfunction safeCaptureStackTrace(...args) {\n    if (\"captureStackTrace\" in Error && typeof Error.captureStackTrace === \"function\") {\n        Error.captureStackTrace(...args);\n    }\n}\n// src/rpc-enum-errors.ts\nfunction getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === \"string\") {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = errorCodeBaseOffset + codeOffset;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n// src/instruction-error.ts\nvar ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    \"GenericError\",\n    \"InvalidArgument\",\n    \"InvalidInstructionData\",\n    \"InvalidAccountData\",\n    \"AccountDataTooSmall\",\n    \"InsufficientFunds\",\n    \"IncorrectProgramId\",\n    \"MissingRequiredSignature\",\n    \"AccountAlreadyInitialized\",\n    \"UninitializedAccount\",\n    \"UnbalancedInstruction\",\n    \"ModifiedProgramId\",\n    \"ExternalAccountLamportSpend\",\n    \"ExternalAccountDataModified\",\n    \"ReadonlyLamportChange\",\n    \"ReadonlyDataModified\",\n    \"DuplicateAccountIndex\",\n    \"ExecutableModified\",\n    \"RentEpochModified\",\n    \"NotEnoughAccountKeys\",\n    \"AccountDataSizeChanged\",\n    \"AccountNotExecutable\",\n    \"AccountBorrowFailed\",\n    \"AccountBorrowOutstanding\",\n    \"DuplicateAccountOutOfSync\",\n    \"Custom\",\n    \"InvalidError\",\n    \"ExecutableDataModified\",\n    \"ExecutableLamportChange\",\n    \"ExecutableAccountNotRentExempt\",\n    \"UnsupportedProgramId\",\n    \"CallDepth\",\n    \"MissingAccount\",\n    \"ReentrancyNotAllowed\",\n    \"MaxSeedLengthExceeded\",\n    \"InvalidSeeds\",\n    \"InvalidRealloc\",\n    \"ComputationalBudgetExceeded\",\n    \"PrivilegeEscalation\",\n    \"ProgramEnvironmentSetupFailure\",\n    \"ProgramFailedToComplete\",\n    \"ProgramFailedToCompile\",\n    \"Immutable\",\n    \"IncorrectAuthority\",\n    \"BorshIoError\",\n    \"AccountNotRentExempt\",\n    \"InvalidAccountOwner\",\n    \"ArithmeticOverflow\",\n    \"UnsupportedSysvar\",\n    \"IllegalOwner\",\n    \"MaxAccountsDataAllocationsExceeded\",\n    \"MaxAccountsExceeded\",\n    \"MaxInstructionTraceLengthExceeded\",\n    \"BuiltinProgramsMustConsumeComputeUnits\"\n];\nfunction getSolanaErrorFromInstructionError(index, instructionError) {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError({\n        errorCodeBaseOffset: 4615001,\n        getErrorContext (errorCode, rpcErrorName, rpcErrorContext) {\n            if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                return {\n                    errorName: rpcErrorName,\n                    index: numberIndex,\n                    ...rpcErrorContext !== void 0 ? {\n                        instructionErrorContext: rpcErrorContext\n                    } : null\n                };\n            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                return {\n                    code: Number(rpcErrorContext),\n                    index: numberIndex\n                };\n            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n                return {\n                    encodedData: rpcErrorContext,\n                    index: numberIndex\n                };\n            }\n            return {\n                index: numberIndex\n            };\n        },\n        orderedErrorNames: ORDERED_ERROR_NAMES,\n        rpcEnumError: instructionError\n    }, getSolanaErrorFromInstructionError);\n}\n// src/transaction-error.ts\nvar ORDERED_ERROR_NAMES2 = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    \"AccountInUse\",\n    \"AccountLoadedTwice\",\n    \"AccountNotFound\",\n    \"ProgramAccountNotFound\",\n    \"InsufficientFundsForFee\",\n    \"InvalidAccountForFee\",\n    \"AlreadyProcessed\",\n    \"BlockhashNotFound\",\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    \"CallChainTooDeep\",\n    \"MissingSignatureForFee\",\n    \"InvalidAccountIndex\",\n    \"SignatureFailure\",\n    \"InvalidProgramForExecution\",\n    \"SanitizeFailure\",\n    \"ClusterMaintenance\",\n    \"AccountBorrowOutstanding\",\n    \"WouldExceedMaxBlockCostLimit\",\n    \"UnsupportedVersion\",\n    \"InvalidWritableAccount\",\n    \"WouldExceedMaxAccountCostLimit\",\n    \"WouldExceedAccountDataBlockLimit\",\n    \"TooManyAccountLocks\",\n    \"AddressLookupTableNotFound\",\n    \"InvalidAddressLookupTableOwner\",\n    \"InvalidAddressLookupTableData\",\n    \"InvalidAddressLookupTableIndex\",\n    \"InvalidRentPayingAccount\",\n    \"WouldExceedMaxVoteCostLimit\",\n    \"WouldExceedAccountDataTotalLimit\",\n    \"DuplicateInstruction\",\n    \"InsufficientFundsForRent\",\n    \"MaxLoadedAccountsDataSizeExceeded\",\n    \"InvalidLoadedAccountsDataSizeLimit\",\n    \"ResanitizationNeeded\",\n    \"ProgramExecutionTemporarilyRestricted\",\n    \"UnbalancedTransaction\"\n];\nfunction getSolanaErrorFromTransactionError(transactionError) {\n    if (typeof transactionError === \"object\" && \"InstructionError\" in transactionError) {\n        return getSolanaErrorFromInstructionError(...transactionError.InstructionError);\n    }\n    return getSolanaErrorFromRpcError({\n        errorCodeBaseOffset: 7050001,\n        getErrorContext (errorCode, rpcErrorName, rpcErrorContext) {\n            if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                return {\n                    errorName: rpcErrorName,\n                    ...rpcErrorContext !== void 0 ? {\n                        transactionErrorContext: rpcErrorContext\n                    } : null\n                };\n            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                return {\n                    index: Number(rpcErrorContext)\n                };\n            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED) {\n                return {\n                    accountIndex: Number(rpcErrorContext.account_index)\n                };\n            }\n        },\n        orderedErrorNames: ORDERED_ERROR_NAMES2,\n        rpcEnumError: transactionError\n    }, getSolanaErrorFromTransactionError);\n}\n// src/json-rpc-error.ts\nfunction getSolanaErrorFromJsonRpcError(putativeErrorResponse) {\n    let out;\n    if (isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data, message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n            const { err, ...preflightErrorContext } = data;\n            const causeObject = err ? {\n                cause: getSolanaErrorFromTransactionError(err)\n            } : null;\n            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n                ...preflightErrorContext,\n                ...causeObject\n            });\n        } else {\n            let errorContext;\n            switch(code){\n                case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n                case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n                case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n                case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n                case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                    errorContext = {\n                        __serverMessage: message\n                    };\n                    break;\n                default:\n                    if (typeof data === \"object\" && !Array.isArray(data)) {\n                        errorContext = data;\n                    }\n            }\n            out = new SolanaError(code, errorContext);\n        }\n    } else {\n        const message = typeof putativeErrorResponse === \"object\" && putativeErrorResponse !== null && \"message\" in putativeErrorResponse && typeof putativeErrorResponse.message === \"string\" ? putativeErrorResponse.message : \"Malformed JSON-RPC error with no message attribute\";\n        out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, {\n            error: putativeErrorResponse,\n            message\n        });\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\nfunction isRpcErrorResponse(value) {\n    return typeof value === \"object\" && value !== null && \"code\" in value && \"message\" in value && (typeof value.code === \"number\" || typeof value.code === \"bigint\") && typeof value.message === \"string\";\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9lcnJvcnMvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGVBQWU7QUFDZixJQUFJQSxzQ0FBc0M7QUFDMUMsSUFBSUMsOEJBQThCO0FBQ2xDLElBQUlDLHdDQUF3QztBQUM1QyxJQUFJQyxxREFBcUQ7QUFDekQsSUFBSUMsOENBQThDO0FBQ2xELElBQUlDLHNDQUFzQztBQUMxQyxJQUFJQyx3Q0FBd0M7QUFDNUMsSUFBSUMsd0NBQXdDO0FBQzVDLElBQUlDLHVDQUF1QztBQUMzQyxJQUFJQyx5Q0FBeUM7QUFDN0MsSUFBSUMsc0NBQXNDLENBQUM7QUFDM0MsSUFBSUMseUNBQXlDLENBQUM7QUFDOUMsSUFBSUMseUNBQXlDLENBQUM7QUFDOUMsSUFBSUMsMkNBQTJDLENBQUM7QUFDaEQsSUFBSUMsMENBQTBDLENBQUM7QUFDL0MsSUFBSUMsb0VBQW9FLENBQUM7QUFDekUsSUFBSUMsdUVBQXVFLENBQUM7QUFDNUUsSUFBSUMsc0VBQXNFLENBQUM7QUFDM0UsSUFBSUMsMEVBQTBFLENBQUM7QUFDL0UsSUFBSUMscUNBQXFDLENBQUM7QUFDMUMsSUFBSUMseUVBQXlFLENBQUM7QUFDOUUsSUFBSUMseUVBQXlFLENBQUM7QUFDOUUsSUFBSUMsc0VBQXNFLENBQUM7QUFDM0UsSUFBSUMsbURBQW1ELENBQUM7QUFDeEQsSUFBSUMsb0RBQW9ELENBQUM7QUFDekQsSUFBSUMsbUZB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QUtFO2dCQUNMLEtBQUtDO2dCQUNMLEtBQUtUO29CQUNIMFIsZUFBZTt3QkFBRTBCLGlCQUFpQnpDO29CQUFRO29CQUMxQztnQkFDRjtvQkFDRSxJQUFJLE9BQU9zQyxTQUFTLFlBQVksQ0FBQzVGLE1BQU1DLE9BQU8sQ0FBQzJGLE9BQU87d0JBQ3BEdkIsZUFBZXVCO29CQUNqQjtZQUNKO1lBQ0FILE1BQU0sSUFBSXpDLFlBQVkxQixNQUFNK0M7UUFDOUI7SUFDRixPQUFPO1FBQ0wsTUFBTWYsVUFBVSxPQUFPa0MsMEJBQTBCLFlBQVlBLDBCQUEwQixRQUFRLGFBQWFBLHlCQUF5QixPQUFPQSxzQkFBc0JsQyxPQUFPLEtBQUssV0FBV2tDLHNCQUFzQmxDLE9BQU8sR0FBRztRQUN6Tm1DLE1BQU0sSUFBSXpDLFlBQVk1USx3Q0FBd0M7WUFBRTRULE9BQU9SO1lBQXVCbEM7UUFBUTtJQUN4RztJQUNBQyxzQkFBc0JrQyxLQUFLRjtJQUMzQixPQUFPRTtBQUNUO0FBQ0EsU0FBU0MsbUJBQW1CM0YsS0FBSztJQUMvQixPQUFPLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLFVBQVVBLFNBQVMsYUFBYUEsU0FBVSxRQUFPQSxNQUFNdUIsSUFBSSxLQUFLLFlBQVksT0FBT3ZCLE1BQU11QixJQUFJLEtBQUssUUFBTyxLQUFNLE9BQU92QixNQUFNdUQsT0FBTyxLQUFLO0FBQ2hNO0FBRXUzWixDQUN2M1osdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvZXJyb3JzL2Rpc3QvaW5kZXgubm9kZS5tanM/OTAzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29kZXMudHNcbnZhciBTT0xBTkFfRVJST1JfX0JMT0NLX0hFSUdIVF9FWENFRURFRCA9IDE7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBTElEX05PTkNFID0gMjtcbnZhciBTT0xBTkFfRVJST1JfX05PTkNFX0FDQ09VTlRfTk9UX0ZPVU5EID0gMztcbnZhciBTT0xBTkFfRVJST1JfX0JMT0NLSEFTSF9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSA9IDQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBTElEX0JMT0NLSEFTSF9CWVRFX0xFTkdUSCA9IDU7XG52YXIgU09MQU5BX0VSUk9SX19MQU1QT1JUU19PVVRfT0ZfUkFOR0UgPSA2O1xudmFyIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0JJR0lOVF9TVFJJTkcgPSA3O1xudmFyIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX05VTUJFUl9TVFJJTkcgPSA4O1xudmFyIFNPTEFOQV9FUlJPUl9fVElNRVNUQU1QX09VVF9PRl9SQU5HRSA9IDk7XG52YXIgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfSlNPTl9SUENfRVJST1IgPSAxMDtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19QQVJTRV9FUlJPUiA9IC0zMjcwMDtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlRFUk5BTF9FUlJPUiA9IC0zMjYwMztcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1BBUkFNUyA9IC0zMjYwMjtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5EID0gLTMyNjAxO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVCA9IC0zMjYwMDtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRCA9IC0zMjAxNjtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTiA9IC0zMjAxNTtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUID0gLTMyMDE0O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIID0gLTMyMDEzO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1IgPSAtMzIwMTI7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRSA9IC0zMjAxMTtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYID0gLTMyMDEwO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQgPSAtMzIwMDk7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9UID0gLTMyMDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQgPSAtMzIwMDc7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUgPSAtMzIwMDY7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZID0gLTMyMDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFID0gLTMyMDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUgPSAtMzIwMDM7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUgPSAtMzIwMDI7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVAgPSAtMzIwMDE7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQllURV9MRU5HVEggPSAyOGU1O1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSA9IDI4MDAwMDE7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQkFTRTU4X0VOQ09ERURfQUREUkVTUyA9IDI4MDAwMDI7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfRUQyNTUxOV9QVUJMSUNfS0VZID0gMjgwMDAwMztcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFMRk9STUVEX1BEQSA9IDI4MDAwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9CVU1QX1NFRURfT1VUX09GX1JBTkdFID0gMjgwMDAwNTtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX05VTUJFUl9PRl9QREFfU0VFRFNfRVhDRUVERUQgPSAyODAwMDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfUERBX1NFRURfTEVOR1RIX0VYQ0VFREVEID0gMjgwMDAwNztcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9TRUVEU19QT0lOVF9PTl9DVVJWRSA9IDI4MDAwMDg7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0ZBSUxFRF9UT19GSU5EX1ZJQUJMRV9QREFfQlVNUF9TRUVEID0gMjgwMDAwOTtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0VORFNfV0lUSF9QREFfTUFSS0VSID0gMjgwMDAxMDtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9PRkZfQ1VSVkVfQUREUkVTUyA9IDI4MDAwMTE7XG52YXIgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fQUNDT1VOVF9OT1RfRk9VTkQgPSAzMjNlNDtcbnZhciBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19PTkVfT1JfTU9SRV9BQ0NPVU5UU19OT1RfRk9VTkQgPSAzMjMwMDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19GQUlMRURfVE9fREVDT0RFX0FDQ09VTlQgPSAzMjMwMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0RFQ09ERURfQUNDT1VOVCA9IDMyMzAwMDM7XG52YXIgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfQUxMX0FDQ09VTlRTX1RPX0JFX0RFQ09ERUQgPSAzMjMwMDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElTQUxMT1dFRF9JTl9JTlNFQ1VSRV9DT05URVhUID0gMzYxZTQ7XG52YXIgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESUdFU1RfVU5JTVBMRU1FTlRFRCA9IDM2MTAwMDE7XG52YXIgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVEID0gMzYxMDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VYUE9SVF9GVU5DVElPTl9VTklNUExFTUVOVEVEID0gMzYxMDAwMztcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0dFTkVSQVRFX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQgPSAzNjEwMDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fU0lHTl9GVU5DVElPTl9VTklNUExFTUVOVEVEID0gMzYxMDAwNTtcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1ZFUklGWV9GVU5DVElPTl9VTklNUExFTUVOVEVEID0gMzYxMDAwNjtcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0NBTk5PVF9FWFBPUlRfTk9OX0VYVFJBQ1RBQkxFX0tFWSA9IDM2MTAwMDc7XG52YXIgU09MQU5BX0VSUk9SX19DUllQVE9fX1JBTkRPTV9WQUxVRVNfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCA9IDM2MTFlMztcbnZhciBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfS0VZX1BBSVJfQllURV9MRU5HVEggPSAzNzA0ZTM7XG52YXIgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1BSSVZBVEVfS0VZX0JZVEVfTEVOR1RIID0gMzcwNDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfU0lHTkFUVVJFX0JZVEVfTEVOR1RIID0gMzcwNDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0tFWVNfX1NJR05BVFVSRV9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSA9IDM3MDQwMDM7XG52YXIgU09MQU5BX0VSUk9SX19LRVlTX19QVUJMSUNfS0VZX01VU1RfTUFUQ0hfUFJJVkFURV9LRVkgPSAzNzA0MDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfQUNDT1VOVFMgPSA0MTI4ZTM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9EQVRBID0gNDEyODAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19QUk9HUkFNX0lEX01JU01BVENIID0gNDEyODAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTktOT1dOID0gNDYxNWUzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0dFTkVSSUNfRVJST1IgPSA0NjE1MDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQVJHVU1FTlQgPSA0NjE1MDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfSU5TVFJVQ1RJT05fREFUQSA9IDQ2MTUwMDM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0RBVEEgPSA0NjE1MDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9UT09fU01BTEwgPSA0NjE1MDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EUyA9IDQ2MTUwMDY7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX1BST0dSQU1fSUQgPSA0NjE1MDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfUkVRVUlSRURfU0lHTkFUVVJFID0gNDYxNTAwODtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0FMUkVBRFlfSU5JVElBTElaRUQgPSA0NjE1MDA5O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOSU5JVElBTElaRURfQUNDT1VOVCA9IDQ2MTUwMTA7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9JTlNUUlVDVElPTiA9IDQ2MTUwMTE7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTU9ESUZJRURfUFJPR1JBTV9JRCA9IDQ2MTUwMTI7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9MQU1QT1JUX1NQRU5EID0gNDYxNTAxMztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0RBVEFfTU9ESUZJRUQgPSA0NjE1MDE0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0xBTVBPUlRfQ0hBTkdFID0gNDYxNTAxNTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9EQVRBX01PRElGSUVEID0gNDYxNTAxNjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9JTkRFWCA9IDQ2MTUwMTc7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9NT0RJRklFRCA9IDQ2MTUwMTg7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVOVF9FUE9DSF9NT0RJRklFRCA9IDQ2MTUwMTk7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTk9UX0VOT1VHSF9BQ0NPVU5UX0tFWVMgPSA0NjE1MDIwO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9TSVpFX0NIQU5HRUQgPSA0NjE1MDIxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0VYRUNVVEFCTEUgPSA0NjE1MDIyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX0ZBSUxFRCA9IDQ2MTUwMjM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkcgPSA0NjE1MDI0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX09VVF9PRl9TWU5DID0gNDYxNTAyNTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DVVNUT00gPSA0NjE1MDI2O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfRVJST1IgPSA0NjE1MDI3O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfREFUQV9NT0RJRklFRCA9IDQ2MTUwMjg7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9MQU1QT1JUX0NIQU5HRSA9IDQ2MTUwMjk7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVCA9IDQ2MTUwMzA7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfUFJPR1JBTV9JRCA9IDQ2MTUwMzE7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ0FMTF9ERVBUSCA9IDQ2MTUwMzI7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19BQ0NPVU5UID0gNDYxNTAzMztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUVOVFJBTkNZX05PVF9BTExPV0VEID0gNDYxNTAzNDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfU0VFRF9MRU5HVEhfRVhDRUVERUQgPSA0NjE1MDM1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfU0VFRFMgPSA0NjE1MDM2O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfUkVBTExPQyA9IDQ2MTUwMzc7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ09NUFVUQVRJT05BTF9CVURHRVRfRVhDRUVERUQgPSA0NjE1MDM4O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BSSVZJTEVHRV9FU0NBTEFUSU9OID0gNDYxNTAzOTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0VOVklST05NRU5UX1NFVFVQX0ZBSUxVUkUgPSA0NjE1MDQwO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBMRVRFID0gNDYxNTA0MTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QSUxFID0gNDYxNTA0MjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTU1VVEFCTEUgPSA0NjE1MDQzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9BVVRIT1JJVFkgPSA0NjE1MDQ0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JPUlNIX0lPX0VSUk9SID0gNDYxNTA0NTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVCA9IDQ2MTUwNDY7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX09XTkVSID0gNDYxNTA0NztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BUklUSE1FVElDX09WRVJGTE9XID0gNDYxNTA0ODtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9TWVNWQVIgPSA0NjE1MDQ5O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lMTEVHQUxfT1dORVIgPSA0NjE1MDUwO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19EQVRBX0FMTE9DQVRJT05TX0VYQ0VFREVEID0gNDYxNTA1MTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfRVhDRUVERUQgPSA0NjE1MDUyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9JTlNUUlVDVElPTl9UUkFDRV9MRU5HVEhfRVhDRUVERUQgPSA0NjE1MDUzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JVSUxUSU5fUFJPR1JBTVNfTVVTVF9DT05TVU1FX0NPTVBVVEVfVU5JVFMgPSA0NjE1MDU0O1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19BRERSRVNTX0NBTk5PVF9IQVZFX01VTFRJUExFX1NJR05FUlMgPSA1NTA4ZTM7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX0tFWV9QQUlSX1NJR05FUiA9IDU1MDgwMDE7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfU0lHTkVSID0gNTUwODAwMjtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9NT0RJRllJTkdfU0lHTkVSID0gNTUwODAwMztcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9QQVJUSUFMX1NJR05FUiA9IDU1MDgwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUiA9IDU1MDgwMDU7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX01PRElGWUlOR19TSUdORVIgPSA1NTA4MDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUiA9IDU1MDgwMDc7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSID0gNTUwODAwODtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0VORElOR19TSUdORVJTID0gNTUwODAwOTtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVJfTUlTU0lORyA9IDU1MDgwMTA7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX1dBTExFVF9NVUxUSVNJR05fVU5JTVBMRU1FTlRFRCA9IDU1MDgwMTE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19DQU5OT1RfUEFZX0ZFRVMgPSA1NjYzZTM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19NVVNUX05PVF9CRV9XUklUQUJMRSA9IDU2NjMwMDE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfQkxPQ0tIQVNIX0xJRkVUSU1FID0gNTY2MzAwMjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9OT05DRV9MSUZFVElNRSA9IDU2NjMwMDM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfT1VUX09GX1JBTkdFID0gNTY2MzAwNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0NPTlRFTlRTX01JU1NJTkcgPSA1NjYzMDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhfT1VUX09GX1JBTkdFID0gNTY2MzAwNjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0lOU1RSVUNUSU9OX1BST0dSQU1fQUREUkVTU19OT1RfRk9VTkQgPSA1NjYzMDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfRkVFX1BBWUVSX01JU1NJTkcgPSA1NjYzMDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1NJR05BVFVSRVNfTUlTU0lORyA9IDU2NjMwMDk7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU19NSVNTSU5HID0gNTY2MzAxMDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfTUlTU0lORyA9IDU2NjMwMTE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX1NJR05BVFVSRV9NSVNTSU5HID0gNTY2MzAxMjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0lOU1RSVUNUSU9OU19NSVNTSU5HID0gNTY2MzAxMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0ZJUlNUX0lOU1RSVUNUSU9OX01VU1RfQkVfQURWQU5DRV9OT05DRSA9IDU2NjMwMTQ7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU0VTX0NBTk5PVF9TSUdOX1RSQU5TQUNUSU9OID0gNTY2MzAxNTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19DQU5OT1RfRU5DT0RFX1dJVEhfRU1QVFlfU0lHTkFUVVJFUyA9IDU2NjMwMTY7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTUVTU0FHRV9TSUdOQVRVUkVTX01JU01BVENIID0gNTY2MzAxNztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVCA9IDU2NjMwMTg7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1dIRU5fU0lNVUxBVElOR19UT19FU1RJTUFURV9DT01QVVRFX0xJTUlUID0gNTY2MzAxOTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVQgPSA1NjYzMDIwO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOS05PV04gPSA3MDVlNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0lOX1VTRSA9IDcwNTAwMDE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9MT0FERURfVFdJQ0UgPSA3MDUwMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0ZPVU5EID0gNzA1MDAwMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0FDQ09VTlRfTk9UX0ZPVU5EID0gNzA1MDAwNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX0ZFRSA9IDcwNTAwMDU7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0ZPUl9GRUUgPSA3MDUwMDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FMUkVBRFlfUFJPQ0VTU0VEID0gNzA1MDAwNztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19CTE9DS0hBU0hfTk9UX0ZPVU5EID0gNzA1MDAwODtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DQUxMX0NIQUlOX1RPT19ERUVQID0gNzA1MDAwOTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NSVNTSU5HX1NJR05BVFVSRV9GT1JfRkVFID0gNzA1MDAxMDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfSU5ERVggPSA3MDUwMDExO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NJR05BVFVSRV9GQUlMVVJFID0gNzA1MDAxMjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1BST0dSQU1fRk9SX0VYRUNVVElPTiA9IDcwNTAwMTM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fU0FOSVRJWkVfRkFJTFVSRSA9IDcwNTAwMTQ7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0xVU1RFUl9NQUlOVEVOQU5DRSA9IDcwNTAwMTU7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkcgPSA3MDUwMDE2O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQkxPQ0tfQ09TVF9MSU1JVCA9IDcwNTAwMTc7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfVkVSU0lPTiA9IDcwNTAwMTg7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9XUklUQUJMRV9BQ0NPVU5UID0gNzA1MDAxOTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0FDQ09VTlRfQ09TVF9MSU1JVCA9IDcwNTAwMjA7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9CTE9DS19MSU1JVCA9IDcwNTAwMjE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVE9PX01BTllfQUNDT1VOVF9MT0NLUyA9IDcwNTAwMjI7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUREUkVTU19MT09LVVBfVEFCTEVfTk9UX0ZPVU5EID0gNzA1MDAyMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX09XTkVSID0gNzA1MDAyNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0RBVEEgPSA3MDUwMDI1O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVggPSA3MDUwMDI2O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfUkVOVF9QQVlJTkdfQUNDT1VOVCA9IDcwNTAwMjc7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9WT1RFX0NPU1RfTElNSVQgPSA3MDUwMDI4O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfVE9UQUxfTElNSVQgPSA3MDUwMDI5O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0RVUExJQ0FURV9JTlNUUlVDVElPTiA9IDcwNTAwMzA7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9SRU5UID0gNzA1MDAzMTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NQVhfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9FWENFRURFRCA9IDcwNTAwMzI7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0xJTUlUID0gNzA1MDAzMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19SRVNBTklUSVpBVElPTl9ORUVERUQgPSA3MDUwMDM0O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fRVhFQ1VUSU9OX1RFTVBPUkFSSUxZX1JFU1RSSUNURUQgPSA3MDUwMDM1O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfVFJBTlNBQ1RJT04gPSA3MDUwMDM2O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVkgPSA4MDc4ZTM7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEggPSA4MDc4MDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEggPSA4MDc4MDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEggPSA4MDc4MDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIID0gODA3ODAwNDtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0ggPSA4MDc4MDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0ggPSA4MDc4MDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX05VTUJFUl9PRl9JVEVNUyA9IDgwNzgwMDc7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOVU1fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UgPSA4MDc4MDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0RJU0NSSU1JTkFURURfVU5JT05fVkFSSUFOVCA9IDgwNzgwMDk7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRU5VTV9WQVJJQU5UID0gODA3ODAxMDtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSA9IDgwNzgwMTE7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFID0gODA3ODAxMjtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEggPSA4MDc4MDEzO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFID0gODA3ODAxNDtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9MSVRFUkFMX1VOSU9OX1ZBUklBTlQgPSA4MDc4MDE1O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19MSVRFUkFMX1VOSU9OX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFID0gODA3ODAxNjtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fVU5JT05fVkFSSUFOVF9PVVRfT0ZfUkFOR0UgPSA4MDc4MDE3O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0NPTlNUQU5UID0gODA3ODAxODtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfWkVST19WQUxVRV9UT19NQVRDSF9JVEVNX0ZJWEVEX1NJWkUgPSA4MDc4MDE5O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwgPSA4MDc4MDIwO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMgPSA4MDc4MDIxO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfVVNFX0xFWElDQUxfVkFMVUVTX0FTX0VOVU1fRElTQ1JJTUlOQVRPUlMgPSA4MDc4MDIyO1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX19JTlRFR0VSX09WRVJGTE9XID0gODFlNTtcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfSEVBREVSX0ZPUkJJRERFTiA9IDgxMDAwMDE7XG52YXIgU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0VSUk9SID0gODEwMDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19fQVBJX1BMQU5fTUlTU0lOR19GT1JfUlBDX01FVEhPRCA9IDgxMDAwMDM7XG52YXIgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0FOTk9UX0NSRUFURV9TVUJTQ1JJUFRJT05fUExBTiA9IDgxOWU0O1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0VYUEVDVEVEX1NFUlZFUl9TVUJTQ1JJUFRJT05fSUQgPSA4MTkwMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ0xPU0VEX0JFRk9SRV9NRVNTQUdFX0JVRkZFUkVEID0gODE5MDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NPTk5FQ1RJT05fQ0xPU0VEID0gODE5MDAwMztcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0ZBSUxFRF9UT19DT05ORUNUID0gODE5MDAwNDtcbnZhciBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9TVEFURV9NSVNTSU5HID0gOTllNTtcbnZhciBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9NVVNUX05PVF9QT0xMX0JFRk9SRV9SRVNPTFZJTkdfRVhJU1RJTkdfTUVTU0FHRV9QUk9NSVNFID0gOTkwMDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0NBQ0hFRF9BQk9SVEFCTEVfSVRFUkFCTEVfQ0FDSEVfRU5UUllfTUlTU0lORyA9IDk5MDAwMDI7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFID0gOTkwMDAwMztcbnZhciBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0RBVEFfUFVCTElTSEVSX0NIQU5ORUxfVU5JTVBMRU1FTlRFRCA9IDk5MDAwMDQ7XG5cbi8vIHNyYy9jb250ZXh0LnRzXG5mdW5jdGlvbiBlbmNvZGVWYWx1ZSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBjb21tYVNlcGFyYXRlZFZhbHVlcyA9IHZhbHVlLm1hcChlbmNvZGVWYWx1ZSkuam9pbihcbiAgICAgIFwiJTJDJTIwXCJcbiAgICAgIC8qIFwiLCBcIiAqL1xuICAgICk7XG4gICAgcmV0dXJuIFwiJTVCXCIgKyBjb21tYVNlcGFyYXRlZFZhbHVlcyArIC8qIFwiXVwiICovXG4gICAgXCIlNURcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9bmA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgIFN0cmluZyhcbiAgICAgICAgdmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBudWxsID8gKFxuICAgICAgICAgIC8vIFBsYWluIG9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgZG9uJ3QgaGF2ZSBhIGB0b1N0cmluZ2AgbWV0aG9kLlxuICAgICAgICAgIC8vIENvbnZlcnQgdGhlbSBiZWZvcmUgc3RyaW5naWZ5aW5nIHRoZW0uXG4gICAgICAgICAgeyAuLi52YWx1ZSB9XG4gICAgICAgICkgOiB2YWx1ZVxuICAgICAgKVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZU9iamVjdENvbnRleHRFbnRyeShba2V5LCB2YWx1ZV0pIHtcbiAgcmV0dXJuIGAke2tleX09JHtlbmNvZGVWYWx1ZSh2YWx1ZSl9YDtcbn1cbmZ1bmN0aW9uIGVuY29kZUNvbnRleHRPYmplY3QoY29udGV4dCkge1xuICBjb25zdCBzZWFyY2hQYXJhbXNTdHJpbmcgPSBPYmplY3QuZW50cmllcyhjb250ZXh0KS5tYXAoZW5jb2RlT2JqZWN0Q29udGV4dEVudHJ5KS5qb2luKFwiJlwiKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlYXJjaFBhcmFtc1N0cmluZywgXCJ1dGY4XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpIDtcbn1cblxuLy8gc3JjL21lc3NhZ2VzLnRzXG52YXIgU29sYW5hRXJyb3JNZXNzYWdlcyA9IHtcbiAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0FDQ09VTlRfTk9UX0ZPVU5EXTogXCJBY2NvdW50IG5vdCBmb3VuZCBhdCBhZGRyZXNzOiAkYWRkcmVzc1wiLFxuICBbU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfQUxMX0FDQ09VTlRTX1RPX0JFX0RFQ09ERURdOiBcIk5vdCBhbGwgYWNjb3VudHMgd2VyZSBkZWNvZGVkLiBFbmNvZGVkIGFjY291bnRzIGZvdW5kIGF0IGFkZHJlc3NlczogJGFkZHJlc3Nlcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0RFQ09ERURfQUNDT1VOVF06IFwiRXhwZWN0ZWQgZGVjb2RlZCBhY2NvdW50IGF0IGFkZHJlc3M6ICRhZGRyZXNzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19GQUlMRURfVE9fREVDT0RFX0FDQ09VTlRdOiBcIkZhaWxlZCB0byBkZWNvZGUgYWNjb3VudCBkYXRhIGF0IGFkZHJlc3M6ICRhZGRyZXNzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19PTkVfT1JfTU9SRV9BQ0NPVU5UU19OT1RfRk9VTkRdOiBcIkFjY291bnRzIG5vdCBmb3VuZCBhdCBhZGRyZXNzZXM6ICRhZGRyZXNzZXNcIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19GQUlMRURfVE9fRklORF9WSUFCTEVfUERBX0JVTVBfU0VFRF06IFwiVW5hYmxlIHRvIGZpbmQgYSB2aWFibGUgcHJvZ3JhbSBhZGRyZXNzIGJ1bXAgc2VlZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JBU0U1OF9FTkNPREVEX0FERFJFU1NdOiBcIiRwdXRhdGl2ZUFkZHJlc3MgaXMgbm90IGEgYmFzZTU4LWVuY29kZWQgYWRkcmVzcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JZVEVfTEVOR1RIXTogXCJFeHBlY3RlZCBiYXNlNTggZW5jb2RlZCBhZGRyZXNzIHRvIGRlY29kZSB0byBhIGJ5dGUgYXJyYXkgb2YgbGVuZ3RoIDMyLiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfRUQyNTUxOV9QVUJMSUNfS0VZXTogXCJUaGUgYENyeXB0b0tleWAgbXVzdCBiZSBhbiBgRWQyNTUxOWAgcHVibGljIGtleS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX09GRl9DVVJWRV9BRERSRVNTXTogXCIkcHV0YXRpdmVPZmZDdXJ2ZUFkZHJlc3MgaXMgbm90IGEgYmFzZTU4LWVuY29kZWQgb2ZmLWN1cnZlIGFkZHJlc3MuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9TRUVEU19QT0lOVF9PTl9DVVJWRV06IFwiSW52YWxpZCBzZWVkczsgcG9pbnQgbXVzdCBmYWxsIG9mZiB0aGUgRWQyNTUxOSBjdXJ2ZS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQUxGT1JNRURfUERBXTogXCJFeHBlY3RlZCBnaXZlbiBwcm9ncmFtIGRlcml2ZWQgYWRkcmVzcyB0byBoYXZlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBbQWRkcmVzcywgUHJvZ3JhbURlcml2ZWRBZGRyZXNzQnVtcF0uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX05VTUJFUl9PRl9QREFfU0VFRFNfRVhDRUVERURdOiBcIkEgbWF4aW11bSBvZiAkbWF4U2VlZHMgc2VlZHMsIGluY2x1ZGluZyB0aGUgYnVtcCBzZWVkLCBtYXkgYmUgc3VwcGxpZWQgd2hlbiBjcmVhdGluZyBhbiBhZGRyZXNzLiBSZWNlaXZlZDogJGFjdHVhbC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfUERBX1NFRURfTEVOR1RIX0VYQ0VFREVEXTogXCJUaGUgc2VlZCBhdCBpbmRleCAkaW5kZXggd2l0aCBsZW5ndGggJGFjdHVhbCBleGNlZWRzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiAkbWF4U2VlZExlbmd0aCBieXRlcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfQlVNUF9TRUVEX09VVF9PRl9SQU5HRV06IFwiRXhwZWN0ZWQgcHJvZ3JhbSBkZXJpdmVkIGFkZHJlc3MgYnVtcCB0byBiZSBpbiB0aGUgcmFuZ2UgWzAsIDI1NV0sIGdvdDogJGJ1bXAuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0VORFNfV0lUSF9QREFfTUFSS0VSXTogXCJQcm9ncmFtIGFkZHJlc3MgY2Fubm90IGVuZCB3aXRoIFBEQSBtYXJrZXIuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0VdOiBcIkV4cGVjdGVkIGJhc2U1OC1lbmNvZGVkIGFkZHJlc3Mgc3RyaW5nIG9mIGxlbmd0aCBpbiB0aGUgcmFuZ2UgWzMyLCA0NF0uIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0JMT0NLSEFTSF9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRV06IFwiRXhwZWN0ZWQgYmFzZTU4LWVuY29kZWQgYmxvY2thc2ggc3RyaW5nIG9mIGxlbmd0aCBpbiB0aGUgcmFuZ2UgWzMyLCA0NF0uIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0JMT0NLX0hFSUdIVF9FWENFRURFRF06IFwiVGhlIG5ldHdvcmsgaGFzIHByb2dyZXNzZWQgcGFzdCB0aGUgbGFzdCBibG9jayBmb3Igd2hpY2ggdGhpcyB0cmFuc2FjdGlvbiBjb3VsZCBoYXZlIGJlZW4gY29tbWl0dGVkLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWV06IFwiQ29kZWMgWyRjb2RlY0Rlc2NyaXB0aW9uXSBjYW5ub3QgZGVjb2RlIGVtcHR5IGJ5dGUgYXJyYXlzLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9VU0VfTEVYSUNBTF9WQUxVRVNfQVNfRU5VTV9ESVNDUklNSU5BVE9SU106IFwiRW51bSBjb2RlYyBjYW5ub3QgdXNlIGxleGljYWwgdmFsdWVzIFskc3RyaW5nVmFsdWVzXSBhcyBkaXNjcmltaW5hdG9ycy4gRWl0aGVyIHJlbW92ZSBhbGwgbGV4aWNhbCB2YWx1ZXMgb3Igc2V0IGB1c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzYCB0byBgZmFsc2VgLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTF06IFwiU2VudGluZWwgWyRoZXhTZW50aW5lbF0gbXVzdCBub3QgYmUgcHJlc2VudCBpbiBlbmNvZGVkIGJ5dGVzIFskaGV4RW5jb2RlZEJ5dGVzXS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSF06IFwiRW5jb2RlciBhbmQgZGVjb2RlciBtdXN0IGhhdmUgdGhlIHNhbWUgZml4ZWQgc2l6ZSwgZ290IFskZW5jb2RlckZpeGVkU2l6ZV0gYW5kIFskZGVjb2RlckZpeGVkU2l6ZV0uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENIXTogXCJFbmNvZGVyIGFuZCBkZWNvZGVyIG11c3QgaGF2ZSB0aGUgc2FtZSBtYXggc2l6ZSwgZ290IFskZW5jb2Rlck1heFNpemVdIGFuZCBbJGRlY29kZXJNYXhTaXplXS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIXTogXCJFbmNvZGVyIGFuZCBkZWNvZGVyIG11c3QgZWl0aGVyIGJvdGggYmUgZml4ZWQtc2l6ZSBvciB2YXJpYWJsZS1zaXplLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOVU1fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0VdOiBcIkVudW0gZGlzY3JpbWluYXRvciBvdXQgb2YgcmFuZ2UuIEV4cGVjdGVkIGEgbnVtYmVyIGluIFskZm9ybWF0dGVkVmFsaWREaXNjcmltaW5hdG9yc10sIGdvdCAkZGlzY3JpbWluYXRvci5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEhdOiBcIkV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjb2RlYywgZ290IGEgdmFyaWFibGUtc2l6ZSBvbmUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEhdOiBcIkNvZGVjIFskY29kZWNEZXNjcmlwdGlvbl0gZXhwZWN0ZWQgYSBwb3NpdGl2ZSBieXRlIGxlbmd0aCwgZ290ICRieXRlc0xlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEhdOiBcIkV4cGVjdGVkIGEgdmFyaWFibGUtc2l6ZSBjb2RlYywgZ290IGEgZml4ZWQtc2l6ZSBvbmUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfWkVST19WQUxVRV9UT19NQVRDSF9JVEVNX0ZJWEVEX1NJWkVdOiBcIkNvZGVjIFskY29kZWNEZXNjcmlwdGlvbl0gZXhwZWN0ZWQgemVyby12YWx1ZSBbJGhleFplcm9WYWx1ZV0gdG8gaGF2ZSB0aGUgc2FtZSBzaXplIGFzIHRoZSBwcm92aWRlZCBmaXhlZC1zaXplIGl0ZW0gWyRleHBlY3RlZFNpemUgYnl0ZXNdLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEhdOiBcIkNvZGVjIFskY29kZWNEZXNjcmlwdGlvbl0gZXhwZWN0ZWQgJGV4cGVjdGVkIGJ5dGVzLCBnb3QgJGJ5dGVzTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlRdOiBcIkV4cGVjdGVkIGJ5dGUgYXJyYXkgY29uc3RhbnQgWyRoZXhDb25zdGFudF0gdG8gYmUgcHJlc2VudCBpbiBkYXRhIFskaGV4RGF0YV0gYXQgb2Zmc2V0IFskb2Zmc2V0XS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0RJU0NSSU1JTkFURURfVU5JT05fVkFSSUFOVF06IFwiSW52YWxpZCBkaXNjcmltaW5hdGVkIHVuaW9uIHZhcmlhbnQuIEV4cGVjdGVkIG9uZSBvZiBbJHZhcmlhbnRzXSwgZ290ICR2YWx1ZS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVF06IFwiSW52YWxpZCBlbnVtIHZhcmlhbnQuIEV4cGVjdGVkIG9uZSBvZiBbJHN0cmluZ1ZhbHVlc10gb3IgYSBudW1iZXIgaW4gWyRmb3JtYXR0ZWROdW1lcmljYWxWYWx1ZXNdLCBnb3QgJHZhcmlhbnQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9MSVRFUkFMX1VOSU9OX1ZBUklBTlRdOiBcIkludmFsaWQgbGl0ZXJhbCB1bmlvbiB2YXJpYW50LiBFeHBlY3RlZCBvbmUgb2YgWyR2YXJpYW50c10sIGdvdCAkdmFsdWUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9OVU1CRVJfT0ZfSVRFTVNdOiBcIkV4cGVjdGVkIFskY29kZWNEZXNjcmlwdGlvbl0gdG8gaGF2ZSAkZXhwZWN0ZWQgaXRlbXMsIGdvdCAkYWN0dWFsLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFXTogXCJJbnZhbGlkIHZhbHVlICR2YWx1ZSBmb3IgYmFzZSAkYmFzZSB3aXRoIGFscGhhYmV0ICRhbHBoYWJldC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19MSVRFUkFMX1VOSU9OX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFXTogXCJMaXRlcmFsIHVuaW9uIGRpc2NyaW1pbmF0b3Igb3V0IG9mIHJhbmdlLiBFeHBlY3RlZCBhIG51bWJlciBiZXR3ZWVuICRtaW5SYW5nZSBhbmQgJG1heFJhbmdlLCBnb3QgJGRpc2NyaW1pbmF0b3IuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRV06IFwiQ29kZWMgWyRjb2RlY0Rlc2NyaXB0aW9uXSBleHBlY3RlZCBudW1iZXIgdG8gYmUgaW4gdGhlIHJhbmdlIFskbWluLCAkbWF4XSwgZ290ICR2YWx1ZS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFXTogXCJDb2RlYyBbJGNvZGVjRGVzY3JpcHRpb25dIGV4cGVjdGVkIG9mZnNldCB0byBiZSBpbiB0aGUgcmFuZ2UgWzAsICRieXRlc0xlbmd0aF0sIGdvdCAkb2Zmc2V0LlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFU106IFwiRXhwZWN0ZWQgc2VudGluZWwgWyRoZXhTZW50aW5lbF0gdG8gYmUgcHJlc2VudCBpbiBkZWNvZGVkIGJ5dGVzIFskaGV4RGVjb2RlZEJ5dGVzXS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19VTklPTl9WQVJJQU5UX09VVF9PRl9SQU5HRV06IFwiVW5pb24gdmFyaWFudCBvdXQgb2YgcmFuZ2UuIEV4cGVjdGVkIGFuIGluZGV4IGJldHdlZW4gJG1pblJhbmdlIGFuZCAkbWF4UmFuZ2UsIGdvdCAkdmFyaWFudC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ1JZUFRPX19SQU5ET01fVkFMVUVTX0ZVTkNUSU9OX1VOSU1QTEVNRU5URURdOiBcIk5vIHJhbmRvbSB2YWx1ZXMgaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0FMUkVBRFlfSU5JVElBTElaRURdOiBcImluc3RydWN0aW9uIHJlcXVpcmVzIGFuIHVuaW5pdGlhbGl6ZWQgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfRkFJTEVEXTogXCJpbnN0cnVjdGlvbiB0cmllcyB0byBib3Jyb3cgcmVmZXJlbmNlIGZvciBhbiBhY2NvdW50IHdoaWNoIGlzIGFscmVhZHkgYm9ycm93ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HXTogXCJpbnN0cnVjdGlvbiBsZWZ0IGFjY291bnQgd2l0aCBhbiBvdXRzdGFuZGluZyBib3Jyb3dlZCByZWZlcmVuY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9TSVpFX0NIQU5HRURdOiBcInByb2dyYW0gb3RoZXIgdGhhbiB0aGUgYWNjb3VudCdzIG93bmVyIGNoYW5nZWQgdGhlIHNpemUgb2YgdGhlIGFjY291bnQgZGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1RPT19TTUFMTF06IFwiYWNjb3VudCBkYXRhIHRvbyBzbWFsbCBmb3IgaW5zdHJ1Y3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0VYRUNVVEFCTEVdOiBcImluc3RydWN0aW9uIGV4cGVjdGVkIGFuIGV4ZWN1dGFibGUgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFRdOiBcIkFuIGFjY291bnQgZG9lcyBub3QgaGF2ZSBlbm91Z2ggbGFtcG9ydHMgdG8gYmUgcmVudC1leGVtcHRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FSSVRITUVUSUNfT1ZFUkZMT1ddOiBcIlByb2dyYW0gYXJpdGhtZXRpYyBvdmVyZmxvd2VkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUl06IFwiRmFpbGVkIHRvIHNlcmlhbGl6ZSBvciBkZXNlcmlhbGl6ZSBhY2NvdW50IGRhdGE6ICRlbmNvZGVkRGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQlVJTFRJTl9QUk9HUkFNU19NVVNUX0NPTlNVTUVfQ09NUFVURV9VTklUU106IFwiQnVpbHRpbiBwcm9ncmFtcyBtdXN0IGNvbnN1bWUgY29tcHV0ZSB1bml0c1wiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ0FMTF9ERVBUSF06IFwiQ3Jvc3MtcHJvZ3JhbSBpbnZvY2F0aW9uIGNhbGwgZGVwdGggdG9vIGRlZXBcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NPTVBVVEFUSU9OQUxfQlVER0VUX0VYQ0VFREVEXTogXCJDb21wdXRhdGlvbmFsIGJ1ZGdldCBleGNlZWRlZFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NXTogXCJjdXN0b20gcHJvZ3JhbSBlcnJvcjogIyRjb2RlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9JTkRFWF06IFwiaW5zdHJ1Y3Rpb24gY29udGFpbnMgZHVwbGljYXRlIGFjY291bnRzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9PVVRfT0ZfU1lOQ106IFwiaW5zdHJ1Y3Rpb24gbW9kaWZpY2F0aW9ucyBvZiBtdWx0aXBseS1wYXNzZWQgYWNjb3VudCBkaWZmZXJcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFRdOiBcImV4ZWN1dGFibGUgYWNjb3VudHMgbXVzdCBiZSByZW50IGV4ZW1wdFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9EQVRBX01PRElGSUVEXTogXCJpbnN0cnVjdGlvbiBjaGFuZ2VkIGV4ZWN1dGFibGUgYWNjb3VudHMgZGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9MQU1QT1JUX0NIQU5HRV06IFwiaW5zdHJ1Y3Rpb24gY2hhbmdlZCB0aGUgYmFsYW5jZSBvZiBhbiBleGVjdXRhYmxlIGFjY291bnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTU9ESUZJRURdOiBcImluc3RydWN0aW9uIGNoYW5nZWQgZXhlY3V0YWJsZSBiaXQgb2YgYW4gYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9EQVRBX01PRElGSUVEXTogXCJpbnN0cnVjdGlvbiBtb2RpZmllZCBkYXRhIG9mIGFuIGFjY291bnQgaXQgZG9lcyBub3Qgb3duXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0xBTVBPUlRfU1BFTkRdOiBcImluc3RydWN0aW9uIHNwZW50IGZyb20gdGhlIGJhbGFuY2Ugb2YgYW4gYWNjb3VudCBpdCBkb2VzIG5vdCBvd25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0dFTkVSSUNfRVJST1JdOiBcImdlbmVyaWMgaW5zdHJ1Y3Rpb24gZXJyb3JcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lMTEVHQUxfT1dORVJdOiBcIlByb3ZpZGVkIG93bmVyIGlzIG5vdCBhbGxvd2VkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTU1VVEFCTEVdOiBcIkFjY291bnQgaXMgaW1tdXRhYmxlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfQVVUSE9SSVRZXTogXCJJbmNvcnJlY3QgYXV0aG9yaXR5IHByb3ZpZGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfUFJPR1JBTV9JRF06IFwiaW5jb3JyZWN0IHByb2dyYW0gaWQgZm9yIGluc3RydWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNdOiBcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW5zdHJ1Y3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9EQVRBXTogXCJpbnZhbGlkIGFjY291bnQgZGF0YSBmb3IgaW5zdHJ1Y3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9PV05FUl06IFwiSW52YWxpZCBhY2NvdW50IG93bmVyXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FSR1VNRU5UXTogXCJpbnZhbGlkIHByb2dyYW0gYXJndW1lbnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfRVJST1JdOiBcInByb2dyYW0gcmV0dXJuZWQgaW52YWxpZCBlcnJvciBjb2RlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0lOU1RSVUNUSU9OX0RBVEFdOiBcImludmFsaWQgaW5zdHJ1Y3Rpb24gZGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9SRUFMTE9DXTogXCJGYWlsZWQgdG8gcmVhbGxvY2F0ZSBhY2NvdW50IGRhdGFcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfU0VFRFNdOiBcIlByb3ZpZGVkIHNlZWRzIGRvIG5vdCByZXN1bHQgaW4gYSB2YWxpZCBhZGRyZXNzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfREFUQV9BTExPQ0FUSU9OU19FWENFRURFRF06IFwiQWNjb3VudHMgZGF0YSBhbGxvY2F0aW9ucyBleGNlZWRlZCB0aGUgbWF4aW11bSBhbGxvd2VkIHBlciB0cmFuc2FjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0VYQ0VFREVEXTogXCJNYXggYWNjb3VudHMgZXhjZWVkZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9JTlNUUlVDVElPTl9UUkFDRV9MRU5HVEhfRVhDRUVERURdOiBcIk1heCBpbnN0cnVjdGlvbiB0cmFjZSBsZW5ndGggZXhjZWVkZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9TRUVEX0xFTkdUSF9FWENFRURFRF06IFwiTGVuZ3RoIG9mIHRoZSBzZWVkIGlzIHRvbyBsb25nIGZvciBhZGRyZXNzIGdlbmVyYXRpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfQUNDT1VOVF06IFwiQW4gYWNjb3VudCByZXF1aXJlZCBieSB0aGUgaW5zdHJ1Y3Rpb24gaXMgbWlzc2luZ1wiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19SRVFVSVJFRF9TSUdOQVRVUkVdOiBcIm1pc3NpbmcgcmVxdWlyZWQgc2lnbmF0dXJlIGZvciBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTU9ESUZJRURfUFJPR1JBTV9JRF06IFwiaW5zdHJ1Y3Rpb24gaWxsZWdhbGx5IG1vZGlmaWVkIHRoZSBwcm9ncmFtIGlkIG9mIGFuIGFjY291bnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX05PVF9FTk9VR0hfQUNDT1VOVF9LRVlTXTogXCJpbnN1ZmZpY2llbnQgYWNjb3VudCBrZXlzIGZvciBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJJVklMRUdFX0VTQ0FMQVRJT05dOiBcIkNyb3NzLXByb2dyYW0gaW52b2NhdGlvbiB3aXRoIHVuYXV0aG9yaXplZCBzaWduZXIgb3Igd3JpdGFibGUgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9FTlZJUk9OTUVOVF9TRVRVUF9GQUlMVVJFXTogXCJGYWlsZWQgdG8gY3JlYXRlIHByb2dyYW0gZXhlY3V0aW9uIGVudmlyb25tZW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QSUxFXTogXCJQcm9ncmFtIGZhaWxlZCB0byBjb21waWxlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QTEVURV06IFwiUHJvZ3JhbSBmYWlsZWQgdG8gY29tcGxldGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0RBVEFfTU9ESUZJRURdOiBcImluc3RydWN0aW9uIG1vZGlmaWVkIGRhdGEgb2YgYSByZWFkLW9ubHkgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfTEFNUE9SVF9DSEFOR0VdOiBcImluc3RydWN0aW9uIGNoYW5nZWQgdGhlIGJhbGFuY2Ugb2YgYSByZWFkLW9ubHkgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVFTlRSQU5DWV9OT1RfQUxMT1dFRF06IFwiQ3Jvc3MtcHJvZ3JhbSBpbnZvY2F0aW9uIHJlZW50cmFuY3kgbm90IGFsbG93ZWQgZm9yIHRoaXMgaW5zdHJ1Y3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFTlRfRVBPQ0hfTU9ESUZJRURdOiBcImluc3RydWN0aW9uIG1vZGlmaWVkIHJlbnQgZXBvY2ggb2YgYW4gYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9JTlNUUlVDVElPTl06IFwic3VtIG9mIGFjY291bnQgYmFsYW5jZXMgYmVmb3JlIGFuZCBhZnRlciBpbnN0cnVjdGlvbiBkbyBub3QgbWF0Y2hcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOSU5JVElBTElaRURfQUNDT1VOVF06IFwiaW5zdHJ1Y3Rpb24gcmVxdWlyZXMgYW4gaW5pdGlhbGl6ZWQgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5LTk9XTl06IFwiXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9QUk9HUkFNX0lEXTogXCJVbnN1cHBvcnRlZCBwcm9ncmFtIGlkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9TWVNWQVJdOiBcIlVuc3VwcG9ydGVkIHN5c3ZhclwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UU106IFwiVGhlIGluc3RydWN0aW9uIGRvZXMgbm90IGhhdmUgYW55IGFjY291bnRzLlwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9EQVRBXTogXCJUaGUgaW5zdHJ1Y3Rpb24gZG9lcyBub3QgaGF2ZSBhbnkgZGF0YS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX1BST0dSQU1fSURfTUlTTUFUQ0hdOiBcIkV4cGVjdGVkIGluc3RydWN0aW9uIHRvIGhhdmUgcHJvZ3Jlc3MgYWRkcmVzcyAkZXhwZWN0ZWRQcm9ncmFtQWRkcmVzcywgZ290ICRhY3R1YWxQcm9ncmFtQWRkcmVzcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQUxJRF9CTE9DS0hBU0hfQllURV9MRU5HVEhdOiBcIkV4cGVjdGVkIGJhc2U1OCBlbmNvZGVkIGJsb2NraGFzaCB0byBkZWNvZGUgdG8gYSBieXRlIGFycmF5IG9mIGxlbmd0aCAzMi4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQUxJRF9OT05DRV06IFwiVGhlIG5vbmNlIGAkZXhwZWN0ZWROb25jZVZhbHVlYCBpcyBubyBsb25nZXIgdmFsaWQuIEl0IGhhcyBhZHZhbmNlZCB0byBgJGFjdHVhbE5vbmNlVmFsdWVgXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0NBQ0hFRF9BQk9SVEFCTEVfSVRFUkFCTEVfQ0FDSEVfRU5UUllfTUlTU0lOR106IFwiSW52YXJpYW50IHZpb2xhdGlvbjogRm91bmQgbm8gYWJvcnRhYmxlIGl0ZXJhYmxlIGNhY2hlIGVudHJ5IGZvciBrZXkgYCRjYWNoZUtleWAuIEl0IHNob3VsZCBiZSBpbXBvc3NpYmxlIHRvIGhpdCB0aGlzIGVycm9yOyBwbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL3NvbGEubmEvd2ViM2ludmFyaWFudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19EQVRBX1BVQkxJU0hFUl9DSEFOTkVMX1VOSU1QTEVNRU5URURdOiBcIkludmFyaWFudCB2aW9sYXRpb246IFRoaXMgZGF0YSBwdWJsaXNoZXIgZG9lcyBub3QgcHVibGlzaCB0byB0aGUgY2hhbm5lbCBuYW1lZCBgJGNoYW5uZWxOYW1lYC4gU3VwcG9ydGVkIGNoYW5uZWxzIGluY2x1ZGUgJHN1cHBvcnRlZENoYW5uZWxOYW1lcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX01VU1RfTk9UX1BPTExfQkVGT1JFX1JFU09MVklOR19FWElTVElOR19NRVNTQUdFX1BST01JU0VdOiBcIkludmFyaWFudCB2aW9sYXRpb246IFdlYlNvY2tldCBtZXNzYWdlIGl0ZXJhdG9yIHN0YXRlIGlzIGNvcnJ1cHQ7IGl0ZXJhdGVkIHdpdGhvdXQgZmlyc3QgcmVzb2x2aW5nIGV4aXN0aW5nIG1lc3NhZ2UgcHJvbWlzZS4gSXQgc2hvdWxkIGJlIGltcG9zc2libGUgdG8gaGl0IHRoaXMgZXJyb3I7IHBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vc29sYS5uYS93ZWIzaW52YXJpYW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9TVEFURV9NSVNTSU5HXTogXCJJbnZhcmlhbnQgdmlvbGF0aW9uOiBXZWJTb2NrZXQgbWVzc2FnZSBpdGVyYXRvciBpcyBtaXNzaW5nIHN0YXRlIHN0b3JhZ2UuIEl0IHNob3VsZCBiZSBpbXBvc3NpYmxlIHRvIGhpdCB0aGlzIGVycm9yOyBwbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL3NvbGEubmEvd2ViM2ludmFyaWFudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFXTogXCJJbnZhcmlhbnQgdmlvbGF0aW9uOiBTd2l0Y2ggc3RhdGVtZW50IG5vbi1leGhhdXN0aXZlLiBSZWNlaXZlZCB1bmV4cGVjdGVkIHZhbHVlIGAkdW5leHBlY3RlZFZhbHVlYC4gSXQgc2hvdWxkIGJlIGltcG9zc2libGUgdG8gaGl0IHRoaXMgZXJyb3I7IHBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vc29sYS5uYS93ZWIzaW52YXJpYW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlRFUk5BTF9FUlJPUl06IFwiSlNPTi1SUEMgZXJyb3I6IEludGVybmFsIEpTT04tUlBDIGVycm9yICgkX19zZXJ2ZXJNZXNzYWdlKVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVNdOiBcIkpTT04tUlBDIGVycm9yOiBJbnZhbGlkIG1ldGhvZCBwYXJhbWV0ZXIocykgKCRfX3NlcnZlck1lc3NhZ2UpXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1JFUVVFU1RdOiBcIkpTT04tUlBDIGVycm9yOiBUaGUgSlNPTiBzZW50IGlzIG5vdCBhIHZhbGlkIGBSZXF1ZXN0YCBvYmplY3QgKCRfX3NlcnZlck1lc3NhZ2UpXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5EXTogXCJKU09OLVJQQyBlcnJvcjogVGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUgKCRfX3NlcnZlck1lc3NhZ2UpXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19QQVJTRV9FUlJPUl06IFwiSlNPTi1SUEMgZXJyb3I6IEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0ICgkX19zZXJ2ZXJNZXNzYWdlKVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0NBTl9FUlJPUl06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVBdOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRF06IFwiTWluaW11bSBjb250ZXh0IHNsb3QgaGFzIG5vdCBiZWVuIHJlYWNoZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWV06IFwiTm9kZSBpcyB1bmhlYWx0aHk7IGJlaGluZCBieSAkbnVtU2xvdHNCZWhpbmQgc2xvdHNcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVF06IFwiTm8gc25hcHNob3RcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFXTogXCJUcmFuc2FjdGlvbiBzaW11bGF0aW9uIGZhaWxlZFwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRF06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRV06IFwiVHJhbnNhY3Rpb24gaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlIGZyb20gdGhpcyBub2RlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRV06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0hdOiBcIlRyYW5zYWN0aW9uIHNpZ25hdHVyZSBsZW5ndGggbWlzbWF0Y2hcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkVdOiBcIlRyYW5zYWN0aW9uIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbHVyZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT05dOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9LRVlfUEFJUl9CWVRFX0xFTkdUSF06IFwiS2V5IHBhaXIgYnl0ZXMgbXVzdCBiZSBvZiBsZW5ndGggNjQsIGdvdCAkYnl0ZUxlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9QUklWQVRFX0tFWV9CWVRFX0xFTkdUSF06IFwiRXhwZWN0ZWQgcHJpdmF0ZSBrZXkgYnl0ZXMgd2l0aCBsZW5ndGggMzIuIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfU0lHTkFUVVJFX0JZVEVfTEVOR1RIXTogXCJFeHBlY3RlZCBiYXNlNTgtZW5jb2RlZCBzaWduYXR1cmUgdG8gZGVjb2RlIHRvIGEgYnl0ZSBhcnJheSBvZiBsZW5ndGggNjQuIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0tFWVNfX1BVQkxJQ19LRVlfTVVTVF9NQVRDSF9QUklWQVRFX0tFWV06IFwiVGhlIHByb3ZpZGVkIHByaXZhdGUga2V5IGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBwdWJsaWMga2V5LlwiLFxuICBbU09MQU5BX0VSUk9SX19LRVlTX19TSUdOQVRVUkVfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0VdOiBcIkV4cGVjdGVkIGJhc2U1OC1lbmNvZGVkIHNpZ25hdHVyZSBzdHJpbmcgb2YgbGVuZ3RoIGluIHRoZSByYW5nZSBbNjQsIDg4XS4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fTEFNUE9SVFNfT1VUX09GX1JBTkdFXTogXCJMYW1wb3J0cyB2YWx1ZSBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCwgMmU2NC0xXVwiLFxuICBbU09MQU5BX0VSUk9SX19NQUxGT1JNRURfQklHSU5UX1NUUklOR106IFwiYCR2YWx1ZWAgY2Fubm90IGJlIHBhcnNlZCBhcyBhIGBCaWdJbnRgXCIsXG4gIFtTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUl06IFwiJG1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fTUFMRk9STUVEX05VTUJFUl9TVFJJTkddOiBcImAkdmFsdWVgIGNhbm5vdCBiZSBwYXJzZWQgYXMgYSBgTnVtYmVyYFwiLFxuICBbU09MQU5BX0VSUk9SX19OT05DRV9BQ0NPVU5UX05PVF9GT1VORF06IFwiTm8gbm9uY2UgYWNjb3VudCBjb3VsZCBiZSBmb3VuZCBhdCBhZGRyZXNzIGAkbm9uY2VBY2NvdW50QWRkcmVzc2BcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NBTk5PVF9DUkVBVEVfU1VCU0NSSVBUSU9OX1BMQU5dOiBcIlRoZSBub3RpZmljYXRpb24gbmFtZSBtdXN0IGVuZCBpbiAnTm90aWZpY2F0aW9ucycgYW5kIHRoZSBBUEkgbXVzdCBzdXBwbHkgYSBzdWJzY3JpcHRpb24gcGxhbiBjcmVhdG9yIGZ1bmN0aW9uIGZvciB0aGUgbm90aWZpY2F0aW9uICckbm90aWZpY2F0aW9uTmFtZScuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NMT1NFRF9CRUZPUkVfTUVTU0FHRV9CVUZGRVJFRF06IFwiV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHBheWxvYWQgY291bGQgYmUgYWRkZWQgdG8gdGhlIHNlbmQgYnVmZmVyXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NPTk5FQ1RJT05fQ0xPU0VEXTogXCJXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfRkFJTEVEX1RPX0NPTk5FQ1RdOiBcIldlYlNvY2tldCBmYWlsZWQgdG8gY29ubmVjdFwiLFxuICBbU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fRVhQRUNURURfU0VSVkVSX1NVQlNDUklQVElPTl9JRF06IFwiRmFpbGVkIHRvIG9idGFpbiBhIHN1YnNjcmlwdGlvbiBpZCBmcm9tIHRoZSBzZXJ2ZXJcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX19BUElfUExBTl9NSVNTSU5HX0ZPUl9SUENfTUVUSE9EXTogXCJDb3VsZCBub3QgZmluZCBhbiBBUEkgcGxhbiBmb3IgUlBDIG1ldGhvZDogYCRtZXRob2RgXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19fSU5URUdFUl9PVkVSRkxPV106IFwiVGhlICRhcmd1bWVudExhYmVsIGFyZ3VtZW50IHRvIHRoZSBgJG1ldGhvZE5hbWVgIFJQQyBtZXRob2Qkb3B0aW9uYWxQYXRoTGFiZWwgd2FzIGAkdmFsdWVgLiBUaGlzIG51bWJlciBpcyB1bnNhZmUgZm9yIHVzZSB3aXRoIHRoZSBTb2xhbmEgSlNPTi1SUEMgYmVjYXVzZSBpdCBleGNlZWRzIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfRVJST1JdOiBcIkhUVFAgZXJyb3IgKCRzdGF0dXNDb2RlKTogJG1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9IRUFERVJfRk9SQklEREVOXTogXCJIVFRQIGhlYWRlcihzKSBmb3JiaWRkZW46ICRoZWFkZXJzLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvR2xvc3NhcnkvRm9yYmlkZGVuX2hlYWRlcl9uYW1lLlwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSU106IFwiTXVsdGlwbGUgZGlzdGluY3Qgc2lnbmVycyB3ZXJlIGlkZW50aWZpZWQgZm9yIGFkZHJlc3MgYCRhZGRyZXNzYC4gUGxlYXNlIGVuc3VyZSB0aGF0IHlvdSBhcmUgdXNpbmcgdGhlIHNhbWUgc2lnbmVyIGluc3RhbmNlIGZvciBlYWNoIGFkZHJlc3MuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfS0VZX1BBSVJfU0lHTkVSXTogXCJUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBgS2V5UGFpclNpZ25lcmAgaW50ZXJmYWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9NT0RJRllJTkdfU0lHTkVSXTogXCJUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBgTWVzc2FnZU1vZGlmeWluZ1NpZ25lcmAgaW50ZXJmYWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9QQVJUSUFMX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYE1lc3NhZ2VQYXJ0aWFsU2lnbmVyYCBpbnRlcmZhY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCBhbnkgb2YgdGhlIGBNZXNzYWdlU2lnbmVyYCBpbnRlcmZhY2VzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fTU9ESUZZSU5HX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYFRyYW5zYWN0aW9uTW9kaWZ5aW5nU2lnbmVyYCBpbnRlcmZhY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYFRyYW5zYWN0aW9uUGFydGlhbFNpZ25lcmAgaW50ZXJmYWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVJdOiBcIlRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGBUcmFuc2FjdGlvblNlbmRpbmdTaWduZXJgIGludGVyZmFjZVwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCBhbnkgb2YgdGhlIGBUcmFuc2FjdGlvblNpZ25lcmAgaW50ZXJmYWNlc1wiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX0NBTk5PVF9IQVZFX01VTFRJUExFX1NFTkRJTkdfU0lHTkVSU106IFwiTW9yZSB0aGFuIG9uZSBgVHJhbnNhY3Rpb25TZW5kaW5nU2lnbmVyYCB3YXMgaWRlbnRpZmllZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl9NSVNTSU5HXTogXCJObyBgVHJhbnNhY3Rpb25TZW5kaW5nU2lnbmVyYCB3YXMgaWRlbnRpZmllZC4gUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBgVHJhbnNhY3Rpb25XaXRoU2luZ2xlU2VuZGluZ1NpZ25lcmAgdHJhbnNhY3Rpb24uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fV0FMTEVUX01VTFRJU0lHTl9VTklNUExFTUVOVEVEXTogXCJXYWxsZXQgYWNjb3VudCBzaWduZXJzIGRvIG5vdCBzdXBwb3J0IHNpZ25pbmcgbXVsdGlwbGUgbWVzc2FnZXMvdHJhbnNhY3Rpb25zIGluIGEgc2luZ2xlIG9wZXJhdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19DQU5OT1RfRVhQT1JUX05PTl9FWFRSQUNUQUJMRV9LRVldOiBcIkNhbm5vdCBleHBvcnQgYSBub24tZXh0cmFjdGFibGUga2V5LlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESUdFU1RfVU5JTVBMRU1FTlRFRF06IFwiTm8gZGlnZXN0IGltcGxlbWVudGF0aW9uIGNvdWxkIGJlIGZvdW5kLlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESVNBTExPV0VEX0lOX0lOU0VDVVJFX0NPTlRFWFRdOiBcIkNyeXB0b2dyYXBoaWMgb3BlcmF0aW9ucyBhcmUgb25seSBhbGxvd2VkIGluIHNlY3VyZSBicm93c2VyIGNvbnRleHRzLiBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU2VjdXJpdHkvU2VjdXJlX0NvbnRleHRzLlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVEXTogXCJUaGlzIHJ1bnRpbWUgZG9lcyBub3Qgc3VwcG9ydCB0aGUgZ2VuZXJhdGlvbiBvZiBFZDI1NTE5IGtleSBwYWlycy5cXG5cXG5JbnN0YWxsIEBzb2xhbmEvd2ViY3J5cHRvLWVkMjU1MTktcG9seWZpbGwgYW5kIGNhbGwgaXRzIGBpbnN0YWxsYCBmdW5jdGlvbiBiZWZvcmUgZ2VuZXJhdGluZyBrZXlzIGluIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IEVkMjU1MTkuXFxuXFxuRm9yIGEgbGlzdCBvZiBydW50aW1lcyB0aGF0IGN1cnJlbnRseSBzdXBwb3J0IEVkMjU1MTkgb3BlcmF0aW9ucywgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvd2ViY3J5cHRvLXNlY3VyZS1jdXJ2ZXMvaXNzdWVzLzIwLlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FWFBPUlRfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06IFwiTm8gc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBpbXBsZW1lbnRhdGlvbiBjb3VsZCBiZSBmb3VuZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fR0VORVJBVEVfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06IFwiTm8ga2V5IGdlbmVyYXRpb24gaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1NJR05fRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06IFwiTm8gc2lnbmluZyBpbXBsZW1lbnRhdGlvbiBjb3VsZCBiZSBmb3VuZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fVkVSSUZZX0ZVTkNUSU9OX1VOSU1QTEVNRU5URURdOiBcIk5vIGtleSBleHBvcnQgaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0VdOiBcIlRpbWVzdGFtcCB2YWx1ZSBtdXN0IGJlIGluIHRoZSByYW5nZSBbLSgybiAqKiA2M24pLCAoMm4gKiogNjNuKSAtIDFdLiBgJHZhbHVlYCBnaXZlblwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkddOiBcIlRyYW5zYWN0aW9uIHByb2Nlc3NpbmcgbGVmdCBhbiBhY2NvdW50IHdpdGggYW4gb3V0c3RhbmRpbmcgYm9ycm93ZWQgcmVmZXJlbmNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0lOX1VTRV06IFwiQWNjb3VudCBpbiB1c2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTE9BREVEX1RXSUNFXTogXCJBY2NvdW50IGxvYWRlZCB0d2ljZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRk9VTkRdOiBcIkF0dGVtcHQgdG8gZGViaXQgYW4gYWNjb3VudCBidXQgZm91bmQgbm8gcmVjb3JkIG9mIGEgcHJpb3IgY3JlZGl0LlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUREUkVTU19MT09LVVBfVEFCTEVfTk9UX0ZPVU5EXTogXCJUcmFuc2FjdGlvbiBsb2FkcyBhbiBhZGRyZXNzIHRhYmxlIGFjY291bnQgdGhhdCBkb2Vzbid0IGV4aXN0XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BTFJFQURZX1BST0NFU1NFRF06IFwiVGhpcyB0cmFuc2FjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQkxPQ0tIQVNIX05PVF9GT1VORF06IFwiQmxvY2toYXNoIG5vdCBmb3VuZFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0FMTF9DSEFJTl9UT09fREVFUF06IFwiTG9hZGVyIGNhbGwgY2hhaW4gaXMgdG9vIGRlZXBcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NMVVNURVJfTUFJTlRFTkFOQ0VdOiBcIlRyYW5zYWN0aW9ucyBhcmUgY3VycmVudGx5IGRpc2FibGVkIGR1ZSB0byBjbHVzdGVyIG1haW50ZW5hbmNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT05dOiBcIlRyYW5zYWN0aW9uIGNvbnRhaW5zIGEgZHVwbGljYXRlIGluc3RydWN0aW9uICgkaW5kZXgpIHRoYXQgaXMgbm90IGFsbG93ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfRkVFXTogXCJJbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGZlZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9SRU5UXTogXCJUcmFuc2FjdGlvbiByZXN1bHRzIGluIGFuIGFjY291bnQgKCRhY2NvdW50SW5kZXgpIHdpdGggaW5zdWZmaWNpZW50IGZ1bmRzIGZvciByZW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfRk9SX0ZFRV06IFwiVGhpcyBhY2NvdW50IG1heSBub3QgYmUgdXNlZCB0byBwYXkgdHJhbnNhY3Rpb24gZmVlc1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0lOREVYXTogXCJUcmFuc2FjdGlvbiBjb250YWlucyBhbiBpbnZhbGlkIGFjY291bnQgcmVmZXJlbmNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0RBVEFdOiBcIlRyYW5zYWN0aW9uIGxvYWRzIGFuIGFkZHJlc3MgdGFibGUgYWNjb3VudCB3aXRoIGludmFsaWQgZGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWF06IFwiVHJhbnNhY3Rpb24gYWRkcmVzcyB0YWJsZSBsb29rdXAgdXNlcyBhbiBpbnZhbGlkIGluZGV4XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX09XTkVSXTogXCJUcmFuc2FjdGlvbiBsb2FkcyBhbiBhZGRyZXNzIHRhYmxlIGFjY291bnQgd2l0aCBhbiBpbnZhbGlkIG93bmVyXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfTElNSVRdOiBcIkxvYWRlZEFjY291bnRzRGF0YVNpemVMaW1pdCBzZXQgZm9yIHRyYW5zYWN0aW9uIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1BST0dSQU1fRk9SX0VYRUNVVElPTl06IFwiVGhpcyBwcm9ncmFtIG1heSBub3QgYmUgdXNlZCBmb3IgZXhlY3V0aW5nIGluc3RydWN0aW9uc1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9SRU5UX1BBWUlOR19BQ0NPVU5UXTogXCJUcmFuc2FjdGlvbiBsZWF2ZXMgYW4gYWNjb3VudCB3aXRoIGEgbG93ZXIgYmFsYW5jZSB0aGFuIHJlbnQtZXhlbXB0IG1pbmltdW1cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfV1JJVEFCTEVfQUNDT1VOVF06IFwiVHJhbnNhY3Rpb24gbG9hZHMgYSB3cml0YWJsZSBhY2NvdW50IHRoYXQgY2Fubm90IGJlIHdyaXR0ZW5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01BWF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0VYQ0VFREVEXTogXCJUcmFuc2FjdGlvbiBleGNlZWRlZCBtYXggbG9hZGVkIGFjY291bnRzIGRhdGEgc2l6ZSBjYXBcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01JU1NJTkdfU0lHTkFUVVJFX0ZPUl9GRUVdOiBcIlRyYW5zYWN0aW9uIHJlcXVpcmVzIGEgZmVlIGJ1dCBoYXMgbm8gc2lnbmF0dXJlIHByZXNlbnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fQUNDT1VOVF9OT1RfRk9VTkRdOiBcIkF0dGVtcHQgdG8gbG9hZCBhIHByb2dyYW0gdGhhdCBkb2VzIG5vdCBleGlzdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9FWEVDVVRJT05fVEVNUE9SQVJJTFlfUkVTVFJJQ1RFRF06IFwiRXhlY3V0aW9uIG9mIHRoZSBwcm9ncmFtIHJlZmVyZW5jZWQgYnkgYWNjb3VudCBhdCBpbmRleCAkYWNjb3VudEluZGV4IGlzIHRlbXBvcmFyaWx5IHJlc3RyaWN0ZWQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19SRVNBTklUSVpBVElPTl9ORUVERURdOiBcIlJlc2FuaXRpemF0aW9uTmVlZGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TQU5JVElaRV9GQUlMVVJFXTogXCJUcmFuc2FjdGlvbiBmYWlsZWQgdG8gc2FuaXRpemUgYWNjb3VudHMgb2Zmc2V0cyBjb3JyZWN0bHlcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NJR05BVFVSRV9GQUlMVVJFXTogXCJUcmFuc2FjdGlvbiBkaWQgbm90IHBhc3Mgc2lnbmF0dXJlIHZlcmlmaWNhdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVE9PX01BTllfQUNDT1VOVF9MT0NLU106IFwiVHJhbnNhY3Rpb24gbG9ja2VkIHRvbyBtYW55IGFjY291bnRzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX1RSQU5TQUNUSU9OXTogXCJTdW0gb2YgYWNjb3VudCBiYWxhbmNlcyBiZWZvcmUgYW5kIGFmdGVyIHRyYW5zYWN0aW9uIGRvIG5vdCBtYXRjaFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5LTk9XTl06IFwiVGhlIHRyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIHRoZSBlcnJvciBgJGVycm9yTmFtZWBcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1ZFUlNJT05dOiBcIlRyYW5zYWN0aW9uIHZlcnNpb24gaXMgdW5zdXBwb3J0ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfQkxPQ0tfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBhY2NvdW50IGRhdGEgbGltaXQgd2l0aGluIHRoZSBibG9ja1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9UT1RBTF9MSU1JVF06IFwiVHJhbnNhY3Rpb24gd291bGQgZXhjZWVkIHRvdGFsIGFjY291bnQgZGF0YSBsaW1pdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9BQ0NPVU5UX0NPU1RfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBtYXggYWNjb3VudCBsaW1pdCB3aXRoaW4gdGhlIGJsb2NrXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0JMT0NLX0NPU1RfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBtYXggQmxvY2sgQ29zdCBMaW1pdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9WT1RFX0NPU1RfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBtYXggVm90ZSBDb3N0IExpbWl0XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTRVNfQ0FOTk9UX1NJR05fVFJBTlNBQ1RJT05dOiBcIkF0dGVtcHRlZCB0byBzaWduIGEgdHJhbnNhY3Rpb24gd2l0aCBhbiBhZGRyZXNzIHRoYXQgaXMgbm90IGEgc2lnbmVyIGZvciBpdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU19NSVNTSU5HXTogXCJUcmFuc2FjdGlvbiBpcyBtaXNzaW5nIGFuIGFkZHJlc3MgYXQgaW5kZXg6ICRpbmRleC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0NBTk5PVF9FTkNPREVfV0lUSF9FTVBUWV9TSUdOQVRVUkVTXTogXCJUcmFuc2FjdGlvbiBoYXMgbm8gZXhwZWN0ZWQgc2lnbmVycyB0aGVyZWZvcmUgaXQgY2Fubm90IGJlIGVuY29kZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYQ0VFRFNfU0laRV9MSU1JVF06IFwiVHJhbnNhY3Rpb24gc2l6ZSAkdHJhbnNhY3Rpb25TaXplIGV4Y2VlZHMgbGltaXQgb2YgJHRyYW5zYWN0aW9uU2l6ZUxpbWl0IGJ5dGVzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9CTE9DS0hBU0hfTElGRVRJTUVdOiBcIlRyYW5zYWN0aW9uIGRvZXMgbm90IGhhdmUgYSBibG9ja2hhc2ggbGlmZXRpbWVcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX05PTkNFX0xJRkVUSU1FXTogXCJUcmFuc2FjdGlvbiBpcyBub3QgYSBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0NPTlRFTlRTX01JU1NJTkddOiBcIkNvbnRlbnRzIG9mIHRoZXNlIGFkZHJlc3MgbG9va3VwIHRhYmxlcyB1bmtub3duOiAkbG9va3VwVGFibGVBZGRyZXNzZXNcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhfT1VUX09GX1JBTkdFXTogXCJMb29rdXAgb2YgYWRkcmVzcyBhdCBpbmRleCAkaGlnaGVzdFJlcXVlc3RlZEluZGV4IGZhaWxlZCBmb3IgbG9va3VwIHRhYmxlIGAkbG9va3VwVGFibGVBZGRyZXNzYC4gSGlnaGVzdCBrbm93biBpbmRleCBpcyAkaGlnaGVzdEtub3duSW5kZXguIFRoZSBsb29rdXAgdGFibGUgbWF5IGhhdmUgYmVlbiBleHRlbmRlZCBzaW5jZSBpdHMgY29udGVudHMgd2VyZSByZXRyaWV2ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfRkVFX1BBWUVSX01JU1NJTkddOiBcIk5vIGZlZSBwYXllciBzZXQgaW4gQ29tcGlsZWRUcmFuc2FjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9JTlNUUlVDVElPTl9QUk9HUkFNX0FERFJFU1NfTk9UX0ZPVU5EXTogXCJDb3VsZCBub3QgZmluZCBwcm9ncmFtIGFkZHJlc3MgYXQgaW5kZXggJGluZGV4XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVF06IFwiRmFpbGVkIHRvIGVzdGltYXRlIHRoZSBjb21wdXRlIHVuaXQgY29uc3VtcHRpb24gZm9yIHRoaXMgdHJhbnNhY3Rpb24gbWVzc2FnZS4gVGhpcyBpcyBsaWtlbHkgYmVjYXVzZSBzaW11bGF0aW5nIHRoZSB0cmFuc2FjdGlvbiBmYWlsZWQuIEluc3BlY3QgdGhlIGBjYXVzZWAgcHJvcGVydHkgb2YgdGhpcyBlcnJvciB0byBsZWFybiBtb3JlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfV0hFTl9TSU1VTEFUSU5HX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVRdOiBcIlRyYW5zYWN0aW9uIGZhaWxlZCB3aGVuIGl0IHdhcyBzaW11bGF0ZWQgaW4gb3JkZXIgdG8gZXN0aW1hdGUgdGhlIGNvbXB1dGUgdW5pdCBjb25zdW1wdGlvbi4gVGhlIGNvbXB1dGUgdW5pdCBlc3RpbWF0ZSBwcm92aWRlZCBpcyBmb3IgYSB0cmFuc2FjdGlvbiB0aGF0IGZhaWxlZCB3aGVuIHNpbXVsYXRlZCBhbmQgbWF5IG5vdCBiZSByZXByZXNlbnRhdGl2ZSBvZiB0aGUgY29tcHV0ZSB1bml0cyB0aGlzIHRyYW5zYWN0aW9uIHdvdWxkIGNvbnN1bWUgaWYgc3VjY2Vzc2Z1bC4gSW5zcGVjdCB0aGUgYGNhdXNlYCBwcm9wZXJ0eSBvZiB0aGlzIGVycm9yIHRvIGxlYXJuIG1vcmVcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9NSVNTSU5HXTogXCJUcmFuc2FjdGlvbiBpcyBtaXNzaW5nIGEgZmVlIHBheWVyLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX1NJR05BVFVSRV9NSVNTSU5HXTogXCJDb3VsZCBub3QgZGV0ZXJtaW5lIHRoaXMgdHJhbnNhY3Rpb24ncyBzaWduYXR1cmUuIE1ha2Ugc3VyZSB0aGF0IHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBzaWduZWQgYnkgaXRzIGZlZSBwYXllci5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fRklSU1RfSU5TVFJVQ1RJT05fTVVTVF9CRV9BRFZBTkNFX05PTkNFXTogXCJUcmFuc2FjdGlvbiBmaXJzdCBpbnN0cnVjdGlvbiBpcyBub3QgYWR2YW5jZSBub25jZSBhY2NvdW50IGluc3RydWN0aW9uLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9JTlNUUlVDVElPTlNfTUlTU0lOR106IFwiVHJhbnNhY3Rpb24gd2l0aCBubyBpbnN0cnVjdGlvbnMgY2Fubm90IGJlIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb24uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX0NBTk5PVF9QQVlfRkVFU106IFwiVGhpcyB0cmFuc2FjdGlvbiBpbmNsdWRlcyBhbiBhZGRyZXNzIChgJHByb2dyYW1BZGRyZXNzYCkgd2hpY2ggaXMgYm90aCBpbnZva2VkIGFuZCBzZXQgYXMgdGhlIGZlZSBwYXllci4gUHJvZ3JhbSBhZGRyZXNzZXMgbWF5IG5vdCBwYXkgZmVlc1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19NVVNUX05PVF9CRV9XUklUQUJMRV06IFwiVGhpcyB0cmFuc2FjdGlvbiBpbmNsdWRlcyBhbiBhZGRyZXNzIChgJHByb2dyYW1BZGRyZXNzYCkgd2hpY2ggaXMgYm90aCBpbnZva2VkIGFuZCBtYXJrZWQgd3JpdGFibGUuIFByb2dyYW0gYWRkcmVzc2VzIG1heSBub3QgYmUgd3JpdGFibGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX01FU1NBR0VfU0lHTkFUVVJFU19NSVNNQVRDSF06IFwiVGhlIHRyYW5zYWN0aW9uIG1lc3NhZ2UgZXhwZWN0ZWQgdGhlIHRyYW5zYWN0aW9uIHRvIGhhdmUgJHNpZ25lckFkZHJlc3Nlc0xlbmd0aCBzaWduYXR1cmVzLCBnb3QgJHNpZ25hdHVyZXNMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19TSUdOQVRVUkVTX01JU1NJTkddOiBcIlRyYW5zYWN0aW9uIGlzIG1pc3Npbmcgc2lnbmF0dXJlcyBmb3IgYWRkcmVzc2VzOiAkYWRkcmVzc2VzLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfT1VUX09GX1JBTkdFXTogXCJUcmFuc2FjdGlvbiB2ZXJzaW9uIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswLCAxMjddLiBgJGFjdHVhbFZlcnNpb25gIGdpdmVuXCJcbn07XG5cbi8vIHNyYy9tZXNzYWdlLWZvcm1hdHRlci50c1xudmFyIFNUQVJUX0lOREVYID0gXCJpXCI7XG52YXIgVFlQRSA9IFwidFwiO1xuZnVuY3Rpb24gZ2V0SHVtYW5SZWFkYWJsZUVycm9yTWVzc2FnZShjb2RlLCBjb250ZXh0ID0ge30pIHtcbiAgY29uc3QgbWVzc2FnZUZvcm1hdFN0cmluZyA9IFNvbGFuYUVycm9yTWVzc2FnZXNbY29kZV07XG4gIGlmIChtZXNzYWdlRm9ybWF0U3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGxldCBzdGF0ZTtcbiAgZnVuY3Rpb24gY29tbWl0U3RhdGVVcFRvKGVuZEluZGV4KSB7XG4gICAgaWYgKHN0YXRlW1RZUEVdID09PSAyIC8qIFZhcmlhYmxlICovKSB7XG4gICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBtZXNzYWdlRm9ybWF0U3RyaW5nLnNsaWNlKHN0YXRlW1NUQVJUX0lOREVYXSArIDEsIGVuZEluZGV4KTtcbiAgICAgIGZyYWdtZW50cy5wdXNoKFxuICAgICAgICB2YXJpYWJsZU5hbWUgaW4gY29udGV4dCA/IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgICAgICAgYCR7Y29udGV4dFt2YXJpYWJsZU5hbWVdfWBcbiAgICAgICAgKSA6IGAkJHt2YXJpYWJsZU5hbWV9YFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlW1RZUEVdID09PSAxIC8qIFRleHQgKi8pIHtcbiAgICAgIGZyYWdtZW50cy5wdXNoKG1lc3NhZ2VGb3JtYXRTdHJpbmcuc2xpY2Uoc3RhdGVbU1RBUlRfSU5ERVhdLCBlbmRJbmRleCkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBmcmFnbWVudHMgPSBbXTtcbiAgbWVzc2FnZUZvcm1hdFN0cmluZy5zcGxpdChcIlwiKS5mb3JFYWNoKChjaGFyLCBpaSkgPT4ge1xuICAgIGlmIChpaSA9PT0gMCkge1xuICAgICAgc3RhdGUgPSB7XG4gICAgICAgIFtTVEFSVF9JTkRFWF06IDAsXG4gICAgICAgIFtUWVBFXTogbWVzc2FnZUZvcm1hdFN0cmluZ1swXSA9PT0gXCJcXFxcXCIgPyAwIC8qIEVzY2FwZVNlcXVlbmNlICovIDogbWVzc2FnZUZvcm1hdFN0cmluZ1swXSA9PT0gXCIkXCIgPyAyIC8qIFZhcmlhYmxlICovIDogMSAvKiBUZXh0ICovXG4gICAgICB9O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIHN3aXRjaCAoc3RhdGVbVFlQRV0pIHtcbiAgICAgIGNhc2UgMCAvKiBFc2NhcGVTZXF1ZW5jZSAqLzpcbiAgICAgICAgbmV4dFN0YXRlID0geyBbU1RBUlRfSU5ERVhdOiBpaSwgW1RZUEVdOiAxIC8qIFRleHQgKi8gfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEgLyogVGV4dCAqLzpcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgbmV4dFN0YXRlID0geyBbU1RBUlRfSU5ERVhdOiBpaSwgW1RZUEVdOiAwIC8qIEVzY2FwZVNlcXVlbmNlICovIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCIkXCIpIHtcbiAgICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IDIgLyogVmFyaWFibGUgKi8gfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMiAvKiBWYXJpYWJsZSAqLzpcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgbmV4dFN0YXRlID0geyBbU1RBUlRfSU5ERVhdOiBpaSwgW1RZUEVdOiAwIC8qIEVzY2FwZVNlcXVlbmNlICovIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCIkXCIpIHtcbiAgICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IDIgLyogVmFyaWFibGUgKi8gfTtcbiAgICAgICAgfSBlbHNlIGlmICghY2hhci5tYXRjaCgvXFx3LykpIHtcbiAgICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IDEgLyogVGV4dCAqLyB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobmV4dFN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgICBjb21taXRTdGF0ZVVwVG8oaWkpO1xuICAgICAgfVxuICAgICAgc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgfVxuICB9KTtcbiAgY29tbWl0U3RhdGVVcFRvKCk7XG4gIHJldHVybiBmcmFnbWVudHMuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShjb2RlLCBjb250ZXh0ID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiBnZXRIdW1hblJlYWRhYmxlRXJyb3JNZXNzYWdlKGNvZGUsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIGxldCBkZWNvZGluZ0FkdmljZU1lc3NhZ2UgPSBgU29sYW5hIGVycm9yICMke2NvZGV9OyBEZWNvZGUgdGhpcyBlcnJvciBieSBydW5uaW5nIFxcYG5weCBAc29sYW5hL2Vycm9ycyBkZWNvZGUgLS0gJHtjb2RlfWA7XG4gICAgaWYgKE9iamVjdC5rZXlzKGNvbnRleHQpLmxlbmd0aCkge1xuICAgICAgZGVjb2RpbmdBZHZpY2VNZXNzYWdlICs9IGAgJyR7ZW5jb2RlQ29udGV4dE9iamVjdChjb250ZXh0KX0nYDtcbiAgICB9XG4gICAgcmV0dXJuIGAke2RlY29kaW5nQWR2aWNlTWVzc2FnZX1cXGBgO1xuICB9XG59XG5cbi8vIHNyYy9lcnJvci50c1xuZnVuY3Rpb24gaXNTb2xhbmFFcnJvcihlLCBjb2RlKSB7XG4gIGNvbnN0IGlzU29sYW5hRXJyb3IyID0gZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubmFtZSA9PT0gXCJTb2xhbmFFcnJvclwiO1xuICBpZiAoaXNTb2xhbmFFcnJvcjIpIHtcbiAgICBpZiAoY29kZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZS5jb250ZXh0Ll9fY29kZSA9PT0gY29kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIFNvbGFuYUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhlIHJvb3QgY2F1c2Ugb2YgdGhpcyB7QGxpbmsgU29sYW5hRXJyb3J9LCBpZiBhbnkuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBhIHRyYW5zYWN0aW9uIGVycm9yIG1pZ2h0IGhhdmUgYW4gaW5zdHJ1Y3Rpb24gZXJyb3IgYXMgaXRzIHJvb3QgY2F1c2UuIEluIHRoaXNcbiAgICogY2FzZSwgeW91IHdpbGwgYmUgYWJsZSB0byBhY2Nlc3MgdGhlIGluc3RydWN0aW9uIGVycm9yIG9uIHRoZSB0cmFuc2FjdGlvbiBlcnJvciBhcyBgY2F1c2VgLlxuICAgKi9cbiAgY2F1c2UgPSB0aGlzLmNhdXNlO1xuICAvKipcbiAgICogQ29udGFpbnMgY29udGV4dCB0aGF0IGNhbiBhc3Npc3QgaW4gdW5kZXJzdGFuZGluZyBvciByZWNvdmVyaW5nIGZyb20gYSB7QGxpbmsgU29sYW5hRXJyb3J9LlxuICAgKi9cbiAgY29udGV4dDtcbiAgY29uc3RydWN0b3IoLi4uW2NvZGUsIGNvbnRleHRBbmRFcnJvck9wdGlvbnNdKSB7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgbGV0IGVycm9yT3B0aW9ucztcbiAgICBpZiAoY29udGV4dEFuZEVycm9yT3B0aW9ucykge1xuICAgICAgY29uc3QgeyBjYXVzZSwgLi4uY29udGV4dFJlc3QgfSA9IGNvbnRleHRBbmRFcnJvck9wdGlvbnM7XG4gICAgICBpZiAoY2F1c2UpIHtcbiAgICAgICAgZXJyb3JPcHRpb25zID0geyBjYXVzZSB9O1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKGNvbnRleHRSZXN0KS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0UmVzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZShjb2RlLCBjb250ZXh0KTtcbiAgICBzdXBlcihtZXNzYWdlLCBlcnJvck9wdGlvbnMpO1xuICAgIHRoaXMuY29udGV4dCA9IHtcbiAgICAgIF9fY29kZTogY29kZSxcbiAgICAgIC4uLmNvbnRleHRcbiAgICB9O1xuICAgIHRoaXMubmFtZSA9IFwiU29sYW5hRXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL3N0YWNrLXRyYWNlLnRzXG5mdW5jdGlvbiBzYWZlQ2FwdHVyZVN0YWNrVHJhY2UoLi4uYXJncykge1xuICBpZiAoXCJjYXB0dXJlU3RhY2tUcmFjZVwiIGluIEVycm9yICYmIHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoLi4uYXJncyk7XG4gIH1cbn1cblxuLy8gc3JjL3JwYy1lbnVtLWVycm9ycy50c1xuZnVuY3Rpb24gZ2V0U29sYW5hRXJyb3JGcm9tUnBjRXJyb3IoeyBlcnJvckNvZGVCYXNlT2Zmc2V0LCBnZXRFcnJvckNvbnRleHQsIG9yZGVyZWRFcnJvck5hbWVzLCBycGNFbnVtRXJyb3IgfSwgY29uc3RydWN0b3JPcHQpIHtcbiAgbGV0IHJwY0Vycm9yTmFtZTtcbiAgbGV0IHJwY0Vycm9yQ29udGV4dDtcbiAgaWYgKHR5cGVvZiBycGNFbnVtRXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICBycGNFcnJvck5hbWUgPSBycGNFbnVtRXJyb3I7XG4gIH0gZWxzZSB7XG4gICAgcnBjRXJyb3JOYW1lID0gT2JqZWN0LmtleXMocnBjRW51bUVycm9yKVswXTtcbiAgICBycGNFcnJvckNvbnRleHQgPSBycGNFbnVtRXJyb3JbcnBjRXJyb3JOYW1lXTtcbiAgfVxuICBjb25zdCBjb2RlT2Zmc2V0ID0gb3JkZXJlZEVycm9yTmFtZXMuaW5kZXhPZihycGNFcnJvck5hbWUpO1xuICBjb25zdCBlcnJvckNvZGUgPSBlcnJvckNvZGVCYXNlT2Zmc2V0ICsgY29kZU9mZnNldDtcbiAgY29uc3QgZXJyb3JDb250ZXh0ID0gZ2V0RXJyb3JDb250ZXh0KGVycm9yQ29kZSwgcnBjRXJyb3JOYW1lLCBycGNFcnJvckNvbnRleHQpO1xuICBjb25zdCBlcnIgPSBuZXcgU29sYW5hRXJyb3IoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICBzYWZlQ2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBjb25zdHJ1Y3Rvck9wdCk7XG4gIHJldHVybiBlcnI7XG59XG5cbi8vIHNyYy9pbnN0cnVjdGlvbi1lcnJvci50c1xudmFyIE9SREVSRURfRVJST1JfTkFNRVMgPSBbXG4gIC8vIEtlZXAgc3luY2VkIHdpdGggUlBDIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FuemEteHl6L2FnYXZlL2Jsb2IvbWFzdGVyL3Nkay9wcm9ncmFtL3NyYy9pbnN0cnVjdGlvbi5yc1xuICAvLyBJZiB0aGlzIGxpc3QgZXZlciBnZXRzIHRvbyBsYXJnZSwgY29uc2lkZXIgaW1wbGVtZW50aW5nIGEgY29tcHJlc3Npb24gc3RyYXRlZ3kgbGlrZSB0aGlzOlxuICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zdGV2ZWx1c2NoZXIvYWFhN2NiYmI1NDMzYjExOTc5ODM5MDhhNDA4NjBjNDdcbiAgXCJHZW5lcmljRXJyb3JcIixcbiAgXCJJbnZhbGlkQXJndW1lbnRcIixcbiAgXCJJbnZhbGlkSW5zdHJ1Y3Rpb25EYXRhXCIsXG4gIFwiSW52YWxpZEFjY291bnREYXRhXCIsXG4gIFwiQWNjb3VudERhdGFUb29TbWFsbFwiLFxuICBcIkluc3VmZmljaWVudEZ1bmRzXCIsXG4gIFwiSW5jb3JyZWN0UHJvZ3JhbUlkXCIsXG4gIFwiTWlzc2luZ1JlcXVpcmVkU2lnbmF0dXJlXCIsXG4gIFwiQWNjb3VudEFscmVhZHlJbml0aWFsaXplZFwiLFxuICBcIlVuaW5pdGlhbGl6ZWRBY2NvdW50XCIsXG4gIFwiVW5iYWxhbmNlZEluc3RydWN0aW9uXCIsXG4gIFwiTW9kaWZpZWRQcm9ncmFtSWRcIixcbiAgXCJFeHRlcm5hbEFjY291bnRMYW1wb3J0U3BlbmRcIixcbiAgXCJFeHRlcm5hbEFjY291bnREYXRhTW9kaWZpZWRcIixcbiAgXCJSZWFkb25seUxhbXBvcnRDaGFuZ2VcIixcbiAgXCJSZWFkb25seURhdGFNb2RpZmllZFwiLFxuICBcIkR1cGxpY2F0ZUFjY291bnRJbmRleFwiLFxuICBcIkV4ZWN1dGFibGVNb2RpZmllZFwiLFxuICBcIlJlbnRFcG9jaE1vZGlmaWVkXCIsXG4gIFwiTm90RW5vdWdoQWNjb3VudEtleXNcIixcbiAgXCJBY2NvdW50RGF0YVNpemVDaGFuZ2VkXCIsXG4gIFwiQWNjb3VudE5vdEV4ZWN1dGFibGVcIixcbiAgXCJBY2NvdW50Qm9ycm93RmFpbGVkXCIsXG4gIFwiQWNjb3VudEJvcnJvd091dHN0YW5kaW5nXCIsXG4gIFwiRHVwbGljYXRlQWNjb3VudE91dE9mU3luY1wiLFxuICBcIkN1c3RvbVwiLFxuICBcIkludmFsaWRFcnJvclwiLFxuICBcIkV4ZWN1dGFibGVEYXRhTW9kaWZpZWRcIixcbiAgXCJFeGVjdXRhYmxlTGFtcG9ydENoYW5nZVwiLFxuICBcIkV4ZWN1dGFibGVBY2NvdW50Tm90UmVudEV4ZW1wdFwiLFxuICBcIlVuc3VwcG9ydGVkUHJvZ3JhbUlkXCIsXG4gIFwiQ2FsbERlcHRoXCIsXG4gIFwiTWlzc2luZ0FjY291bnRcIixcbiAgXCJSZWVudHJhbmN5Tm90QWxsb3dlZFwiLFxuICBcIk1heFNlZWRMZW5ndGhFeGNlZWRlZFwiLFxuICBcIkludmFsaWRTZWVkc1wiLFxuICBcIkludmFsaWRSZWFsbG9jXCIsXG4gIFwiQ29tcHV0YXRpb25hbEJ1ZGdldEV4Y2VlZGVkXCIsXG4gIFwiUHJpdmlsZWdlRXNjYWxhdGlvblwiLFxuICBcIlByb2dyYW1FbnZpcm9ubWVudFNldHVwRmFpbHVyZVwiLFxuICBcIlByb2dyYW1GYWlsZWRUb0NvbXBsZXRlXCIsXG4gIFwiUHJvZ3JhbUZhaWxlZFRvQ29tcGlsZVwiLFxuICBcIkltbXV0YWJsZVwiLFxuICBcIkluY29ycmVjdEF1dGhvcml0eVwiLFxuICBcIkJvcnNoSW9FcnJvclwiLFxuICBcIkFjY291bnROb3RSZW50RXhlbXB0XCIsXG4gIFwiSW52YWxpZEFjY291bnRPd25lclwiLFxuICBcIkFyaXRobWV0aWNPdmVyZmxvd1wiLFxuICBcIlVuc3VwcG9ydGVkU3lzdmFyXCIsXG4gIFwiSWxsZWdhbE93bmVyXCIsXG4gIFwiTWF4QWNjb3VudHNEYXRhQWxsb2NhdGlvbnNFeGNlZWRlZFwiLFxuICBcIk1heEFjY291bnRzRXhjZWVkZWRcIixcbiAgXCJNYXhJbnN0cnVjdGlvblRyYWNlTGVuZ3RoRXhjZWVkZWRcIixcbiAgXCJCdWlsdGluUHJvZ3JhbXNNdXN0Q29uc3VtZUNvbXB1dGVVbml0c1wiXG5dO1xuZnVuY3Rpb24gZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvcihpbmRleCwgaW5zdHJ1Y3Rpb25FcnJvcikge1xuICBjb25zdCBudW1iZXJJbmRleCA9IE51bWJlcihpbmRleCk7XG4gIHJldHVybiBnZXRTb2xhbmFFcnJvckZyb21ScGNFcnJvcihcbiAgICB7XG4gICAgICBlcnJvckNvZGVCYXNlT2Zmc2V0OiA0NjE1MDAxLFxuICAgICAgZ2V0RXJyb3JDb250ZXh0KGVycm9yQ29kZSwgcnBjRXJyb3JOYW1lLCBycGNFcnJvckNvbnRleHQpIHtcbiAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5LTk9XTikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvck5hbWU6IHJwY0Vycm9yTmFtZSxcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXJJbmRleCxcbiAgICAgICAgICAgIC4uLnJwY0Vycm9yQ29udGV4dCAhPT0gdm9pZCAwID8geyBpbnN0cnVjdGlvbkVycm9yQ29udGV4dDogcnBjRXJyb3JDb250ZXh0IH0gOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NVU1RPTSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiBOdW1iZXIocnBjRXJyb3JDb250ZXh0KSxcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXJJbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JDb2RlID09PSBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmNvZGVkRGF0YTogcnBjRXJyb3JDb250ZXh0LFxuICAgICAgICAgICAgaW5kZXg6IG51bWJlckluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpbmRleDogbnVtYmVySW5kZXggfTtcbiAgICAgIH0sXG4gICAgICBvcmRlcmVkRXJyb3JOYW1lczogT1JERVJFRF9FUlJPUl9OQU1FUyxcbiAgICAgIHJwY0VudW1FcnJvcjogaW5zdHJ1Y3Rpb25FcnJvclxuICAgIH0sXG4gICAgZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvclxuICApO1xufVxuXG4vLyBzcmMvdHJhbnNhY3Rpb24tZXJyb3IudHNcbnZhciBPUkRFUkVEX0VSUk9SX05BTUVTMiA9IFtcbiAgLy8gS2VlcCBzeW5jZWQgd2l0aCBSUEMgc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYW56YS14eXovYWdhdmUvYmxvYi9tYXN0ZXIvc2RrL3NyYy90cmFuc2FjdGlvbi9lcnJvci5yc1xuICAvLyBJZiB0aGlzIGxpc3QgZXZlciBnZXRzIHRvbyBsYXJnZSwgY29uc2lkZXIgaW1wbGVtZW50aW5nIGEgY29tcHJlc3Npb24gc3RyYXRlZ3kgbGlrZSB0aGlzOlxuICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zdGV2ZWx1c2NoZXIvYWFhN2NiYmI1NDMzYjExOTc5ODM5MDhhNDA4NjBjNDdcbiAgXCJBY2NvdW50SW5Vc2VcIixcbiAgXCJBY2NvdW50TG9hZGVkVHdpY2VcIixcbiAgXCJBY2NvdW50Tm90Rm91bmRcIixcbiAgXCJQcm9ncmFtQWNjb3VudE5vdEZvdW5kXCIsXG4gIFwiSW5zdWZmaWNpZW50RnVuZHNGb3JGZWVcIixcbiAgXCJJbnZhbGlkQWNjb3VudEZvckZlZVwiLFxuICBcIkFscmVhZHlQcm9jZXNzZWRcIixcbiAgXCJCbG9ja2hhc2hOb3RGb3VuZFwiLFxuICAvLyBgSW5zdHJ1Y3Rpb25FcnJvcmAgaW50ZW50aW9uYWxseSBvbWl0dGVkOyBkZWxlZ2F0ZWQgdG8gYGdldFNvbGFuYUVycm9yRnJvbUluc3RydWN0aW9uRXJyb3JgXG4gIFwiQ2FsbENoYWluVG9vRGVlcFwiLFxuICBcIk1pc3NpbmdTaWduYXR1cmVGb3JGZWVcIixcbiAgXCJJbnZhbGlkQWNjb3VudEluZGV4XCIsXG4gIFwiU2lnbmF0dXJlRmFpbHVyZVwiLFxuICBcIkludmFsaWRQcm9ncmFtRm9yRXhlY3V0aW9uXCIsXG4gIFwiU2FuaXRpemVGYWlsdXJlXCIsXG4gIFwiQ2x1c3Rlck1haW50ZW5hbmNlXCIsXG4gIFwiQWNjb3VudEJvcnJvd091dHN0YW5kaW5nXCIsXG4gIFwiV291bGRFeGNlZWRNYXhCbG9ja0Nvc3RMaW1pdFwiLFxuICBcIlVuc3VwcG9ydGVkVmVyc2lvblwiLFxuICBcIkludmFsaWRXcml0YWJsZUFjY291bnRcIixcbiAgXCJXb3VsZEV4Y2VlZE1heEFjY291bnRDb3N0TGltaXRcIixcbiAgXCJXb3VsZEV4Y2VlZEFjY291bnREYXRhQmxvY2tMaW1pdFwiLFxuICBcIlRvb01hbnlBY2NvdW50TG9ja3NcIixcbiAgXCJBZGRyZXNzTG9va3VwVGFibGVOb3RGb3VuZFwiLFxuICBcIkludmFsaWRBZGRyZXNzTG9va3VwVGFibGVPd25lclwiLFxuICBcIkludmFsaWRBZGRyZXNzTG9va3VwVGFibGVEYXRhXCIsXG4gIFwiSW52YWxpZEFkZHJlc3NMb29rdXBUYWJsZUluZGV4XCIsXG4gIFwiSW52YWxpZFJlbnRQYXlpbmdBY2NvdW50XCIsXG4gIFwiV291bGRFeGNlZWRNYXhWb3RlQ29zdExpbWl0XCIsXG4gIFwiV291bGRFeGNlZWRBY2NvdW50RGF0YVRvdGFsTGltaXRcIixcbiAgXCJEdXBsaWNhdGVJbnN0cnVjdGlvblwiLFxuICBcIkluc3VmZmljaWVudEZ1bmRzRm9yUmVudFwiLFxuICBcIk1heExvYWRlZEFjY291bnRzRGF0YVNpemVFeGNlZWRlZFwiLFxuICBcIkludmFsaWRMb2FkZWRBY2NvdW50c0RhdGFTaXplTGltaXRcIixcbiAgXCJSZXNhbml0aXphdGlvbk5lZWRlZFwiLFxuICBcIlByb2dyYW1FeGVjdXRpb25UZW1wb3JhcmlseVJlc3RyaWN0ZWRcIixcbiAgXCJVbmJhbGFuY2VkVHJhbnNhY3Rpb25cIlxuXTtcbmZ1bmN0aW9uIGdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3IodHJhbnNhY3Rpb25FcnJvcikge1xuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uRXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJJbnN0cnVjdGlvbkVycm9yXCIgaW4gdHJhbnNhY3Rpb25FcnJvcikge1xuICAgIHJldHVybiBnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yKFxuICAgICAgLi4udHJhbnNhY3Rpb25FcnJvci5JbnN0cnVjdGlvbkVycm9yXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZ2V0U29sYW5hRXJyb3JGcm9tUnBjRXJyb3IoXG4gICAge1xuICAgICAgZXJyb3JDb2RlQmFzZU9mZnNldDogNzA1MDAwMSxcbiAgICAgIGdldEVycm9yQ29udGV4dChlcnJvckNvZGUsIHJwY0Vycm9yTmFtZSwgcnBjRXJyb3JDb250ZXh0KSB7XG4gICAgICAgIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOS05PV04pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JOYW1lOiBycGNFcnJvck5hbWUsXG4gICAgICAgICAgICAuLi5ycGNFcnJvckNvbnRleHQgIT09IHZvaWQgMCA/IHsgdHJhbnNhY3Rpb25FcnJvckNvbnRleHQ6IHJwY0Vycm9yQ29udGV4dCB9IDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JDb2RlID09PSBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT04pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXg6IE51bWJlcihycGNFcnJvckNvbnRleHQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfUkVOVCB8fCBlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fRVhFQ1VUSU9OX1RFTVBPUkFSSUxZX1JFU1RSSUNURUQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWNjb3VudEluZGV4OiBOdW1iZXIocnBjRXJyb3JDb250ZXh0LmFjY291bnRfaW5kZXgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9yZGVyZWRFcnJvck5hbWVzOiBPUkRFUkVEX0VSUk9SX05BTUVTMixcbiAgICAgIHJwY0VudW1FcnJvcjogdHJhbnNhY3Rpb25FcnJvclxuICAgIH0sXG4gICAgZ2V0U29sYW5hRXJyb3JGcm9tVHJhbnNhY3Rpb25FcnJvclxuICApO1xufVxuXG4vLyBzcmMvanNvbi1ycGMtZXJyb3IudHNcbmZ1bmN0aW9uIGdldFNvbGFuYUVycm9yRnJvbUpzb25ScGNFcnJvcihwdXRhdGl2ZUVycm9yUmVzcG9uc2UpIHtcbiAgbGV0IG91dDtcbiAgaWYgKGlzUnBjRXJyb3JSZXNwb25zZShwdXRhdGl2ZUVycm9yUmVzcG9uc2UpKSB7XG4gICAgY29uc3QgeyBjb2RlOiByYXdDb2RlLCBkYXRhLCBtZXNzYWdlIH0gPSBwdXRhdGl2ZUVycm9yUmVzcG9uc2U7XG4gICAgY29uc3QgY29kZSA9IE51bWJlcihyYXdDb2RlKTtcbiAgICBpZiAoY29kZSA9PT0gU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUpIHtcbiAgICAgIGNvbnN0IHsgZXJyLCAuLi5wcmVmbGlnaHRFcnJvckNvbnRleHQgfSA9IGRhdGE7XG4gICAgICBjb25zdCBjYXVzZU9iamVjdCA9IGVyciA/IHsgY2F1c2U6IGdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3IoZXJyKSB9IDogbnVsbDtcbiAgICAgIG91dCA9IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRSwge1xuICAgICAgICAuLi5wcmVmbGlnaHRFcnJvckNvbnRleHQsXG4gICAgICAgIC4uLmNhdXNlT2JqZWN0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGVycm9yQ29udGV4dDtcbiAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUEFSQU1TOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5EOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1BBUlNFX0VSUk9SOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1I6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVA6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEU6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQ6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRTpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTjpcbiAgICAgICAgICBlcnJvckNvbnRleHQgPSB7IF9fc2VydmVyTWVzc2FnZTogbWVzc2FnZSB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgZXJyb3JDb250ZXh0ID0gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgPSBuZXcgU29sYW5hRXJyb3IoY29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHR5cGVvZiBwdXRhdGl2ZUVycm9yUmVzcG9uc2UgPT09IFwib2JqZWN0XCIgJiYgcHV0YXRpdmVFcnJvclJlc3BvbnNlICE9PSBudWxsICYmIFwibWVzc2FnZVwiIGluIHB1dGF0aXZlRXJyb3JSZXNwb25zZSAmJiB0eXBlb2YgcHV0YXRpdmVFcnJvclJlc3BvbnNlLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBwdXRhdGl2ZUVycm9yUmVzcG9uc2UubWVzc2FnZSA6IFwiTWFsZm9ybWVkIEpTT04tUlBDIGVycm9yIHdpdGggbm8gbWVzc2FnZSBhdHRyaWJ1dGVcIjtcbiAgICBvdXQgPSBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19NQUxGT1JNRURfSlNPTl9SUENfRVJST1IsIHsgZXJyb3I6IHB1dGF0aXZlRXJyb3JSZXNwb25zZSwgbWVzc2FnZSB9KTtcbiAgfVxuICBzYWZlQ2FwdHVyZVN0YWNrVHJhY2Uob3V0LCBnZXRTb2xhbmFFcnJvckZyb21Kc29uUnBjRXJyb3IpO1xuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gaXNScGNFcnJvclJlc3BvbnNlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgXCJjb2RlXCIgaW4gdmFsdWUgJiYgXCJtZXNzYWdlXCIgaW4gdmFsdWUgJiYgKHR5cGVvZiB2YWx1ZS5jb2RlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZS5jb2RlID09PSBcImJpZ2ludFwiKSAmJiB0eXBlb2YgdmFsdWUubWVzc2FnZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IHsgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fQUNDT1VOVF9OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0FMTF9BQ0NPVU5UU19UT19CRV9ERUNPREVELCBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9ERUNPREVEX0FDQ09VTlQsIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0ZBSUxFRF9UT19ERUNPREVfQUNDT1VOVCwgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fT05FX09SX01PUkVfQUNDT1VOVFNfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRUQsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JBU0U1OF9FTkNPREVEX0FERFJFU1MsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9FRDI1NTE5X1BVQkxJQ19LRVksIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX09GRl9DVVJWRV9BRERSRVNTLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9TRUVEU19QT0lOVF9PTl9DVVJWRSwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BTEZPUk1FRF9QREEsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRCwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9QREFfU0VFRF9MRU5HVEhfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfQlVNUF9TRUVEX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9FTkRTX1dJVEhfUERBX01BUktFUiwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0JMT0NLSEFTSF9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19CTE9DS19IRUlHSFRfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfVVNFX0xFWElDQUxfVkFMVUVTX0FTX0VOVU1fRElTQ1JJTUlOQVRPUlMsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9aRVJPX1ZBTFVFX1RPX01BVENIX0lURU1fRklYRURfU0laRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0NPTlNUQU5ULCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlQsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTElURVJBTF9VTklPTl9WQVJJQU5ULCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9OVU1CRVJfT0ZfSVRFTVMsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX1NUUklOR19GT1JfQkFTRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0xJVEVSQUxfVU5JT05fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUywgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NSWVBUT19fUkFORE9NX1ZBTFVFU19GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0FMUkVBRFlfSU5JVElBTElaRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX0ZBSUxFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkcsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9TSVpFX0NIQU5HRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9UT09fU01BTEwsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0VYRUNVVEFCTEUsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBULCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BUklUSE1FVElDX09WRVJGTE9XLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQlVJTFRJTl9QUk9HUkFNU19NVVNUX0NPTlNVTUVfQ09NUFVURV9VTklUUywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ0FMTF9ERVBUSCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ09NUFVUQVRJT05BTF9CVURHRVRfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NVU1RPTSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfSU5ERVgsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX09VVF9PRl9TWU5DLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBULCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0RBVEFfTU9ESUZJRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTEFNUE9SVF9DSEFOR0UsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTU9ESUZJRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfREFUQV9NT0RJRklFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9MQU1QT1JUX1NQRU5ELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19HRU5FUklDX0VSUk9SLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTExFR0FMX09XTkVSLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTU1VVEFCTEUsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9BVVRIT1JJVFksIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9QUk9HUkFNX0lELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFMsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9EQVRBLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfT1dORVIsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQVJHVU1FTlQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfRVJST1IsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfSU5TVFJVQ1RJT05fREFUQSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9SRUFMTE9DLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1NFRURTLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfREFUQV9BTExPQ0FUSU9OU19FWENFRURFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfSU5TVFJVQ1RJT05fVFJBQ0VfTEVOR1RIX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfU0VFRF9MRU5HVEhfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfQUNDT1VOVCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19SRVFVSVJFRF9TSUdOQVRVUkUsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01PRElGSUVEX1BST0dSQU1fSUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX05PVF9FTk9VR0hfQUNDT1VOVF9LRVlTLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUklWSUxFR0VfRVNDQUxBVElPTiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9FTlZJUk9OTUVOVF9TRVRVUF9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QSUxFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QTEVURSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfREFUQV9NT0RJRklFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfTEFNUE9SVF9DSEFOR0UsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFRU5UUkFOQ1lfTk9UX0FMTE9XRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFTlRfRVBPQ0hfTU9ESUZJRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfSU5TVFJVQ1RJT04sIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOSU5JVElBTElaRURfQUNDT1VOVCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5LTk9XTiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfUFJPR1JBTV9JRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfU1lTVkFSLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0FDQ09VTlRTLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0RBVEEsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX1BST0dSQU1fSURfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fSU5WQUxJRF9CTE9DS0hBU0hfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fSU5WQUxJRF9OT05DRSwgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19DQUNIRURfQUJPUlRBQkxFX0lURVJBQkxFX0NBQ0hFX0VOVFJZX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fREFUQV9QVUJMSVNIRVJfQ0hBTk5FTF9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9NVVNUX05PVF9QT0xMX0JFRk9SRV9SRVNPTFZJTkdfRVhJU1RJTkdfTUVTU0FHRV9QUk9NSVNFLCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9TVEFURV9NSVNTSU5HLCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkUsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1BBUkFNUywgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9SRVFVRVNULCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19QQVJTRV9FUlJPUiwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0NBTl9FUlJPUiwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVAsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVULCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVELCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1QsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVELCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fSElTVE9SWV9OT1RfQVZBSUxBQkxFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRSwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OLCBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfS0VZX1BBSVJfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9QUklWQVRFX0tFWV9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1NJR05BVFVSRV9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19LRVlTX19QVUJMSUNfS0VZX01VU1RfTUFUQ0hfUFJJVkFURV9LRVksIFNPTEFOQV9FUlJPUl9fS0VZU19fU0lHTkFUVVJFX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0xBTVBPUlRTX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfQklHSU5UX1NUUklORywgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfSlNPTl9SUENfRVJST1IsIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX05VTUJFUl9TVFJJTkcsIFNPTEFOQV9FUlJPUl9fTk9OQ0VfQUNDT1VOVF9OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NBTk5PVF9DUkVBVEVfU1VCU0NSSVBUSU9OX1BMQU4sIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ0xPU0VEX0JFRk9SRV9NRVNTQUdFX0JVRkZFUkVELCBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NPTk5FQ1RJT05fQ0xPU0VELCBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0ZBSUxFRF9UT19DT05ORUNULCBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19FWFBFQ1RFRF9TRVJWRVJfU1VCU0NSSVBUSU9OX0lELCBTT0xBTkFfRVJST1JfX1JQQ19fQVBJX1BMQU5fTUlTU0lOR19GT1JfUlBDX01FVEhPRCwgU09MQU5BX0VSUk9SX19SUENfX0lOVEVHRVJfT1ZFUkZMT1csIFNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUiwgU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0hFQURFUl9GT1JCSURERU4sIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19BRERSRVNTX0NBTk5PVF9IQVZFX01VTFRJUExFX1NJR05FUlMsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9LRVlfUEFJUl9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX01PRElGWUlOR19TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1BBUlRJQUxfU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9NT0RJRllJTkdfU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fUEFSVElBTF9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX0NBTk5PVF9IQVZFX01VTFRJUExFX1NFTkRJTkdfU0lHTkVSUywgU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19XQUxMRVRfTVVMVElTSUdOX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fQ0FOTk9UX0VYUE9SVF9OT05fRVhUUkFDVEFCTEVfS0VZLCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJR0VTVF9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJU0FMTE9XRURfSU5fSU5TRUNVUkVfQ09OVEVYVCwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VYUE9SVF9GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0dFTkVSQVRFX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fU0lHTl9GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1ZFUklGWV9GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0lOX1VTRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9MT0FERURfVFdJQ0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BRERSRVNTX0xPT0tVUF9UQUJMRV9OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FMUkVBRFlfUFJPQ0VTU0VELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19CTE9DS0hBU0hfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DQUxMX0NIQUlOX1RPT19ERUVQLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DTFVTVEVSX01BSU5URU5BTkNFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT04sIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfRkVFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX1JFTlQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9GT1JfRkVFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfSU5ERVgsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfREFUQSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9PV05FUiwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1BST0dSQU1fRk9SX0VYRUNVVElPTiwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9SRU5UX1BBWUlOR19BQ0NPVU5ULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1dSSVRBQkxFX0FDQ09VTlQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01BWF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NSVNTSU5HX1NJR05BVFVSRV9GT1JfRkVFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0FDQ09VTlRfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0VYRUNVVElPTl9URU1QT1JBUklMWV9SRVNUUklDVEVELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19SRVNBTklUSVpBVElPTl9ORUVERUQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NBTklUSVpFX0ZBSUxVUkUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NJR05BVFVSRV9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19UT09fTUFOWV9BQ0NPVU5UX0xPQ0tTLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX1RSQU5TQUNUSU9OLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTktOT1dOLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9WRVJTSU9OLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX0JMT0NLX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX1RPVEFMX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0FDQ09VTlRfQ09TVF9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9CTE9DS19DT1NUX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX1ZPVEVfQ09TVF9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU0VTX0NBTk5PVF9TSUdOX1RSQU5TQUNUSU9OLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0NBTk5PVF9FTkNPREVfV0lUSF9FTVBUWV9TSUdOQVRVUkVTLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX0JMT0NLSEFTSF9MSUZFVElNRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfTk9OQ0VfTElGRVRJTUUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfQ09OVEVOVFNfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfRkVFX1BBWUVSX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfSU5TVFJVQ1RJT05fUFJPR1JBTV9BRERSRVNTX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9XSEVOX1NJTVVMQVRJTkdfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9TSUdOQVRVUkVfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9GSVJTVF9JTlNUUlVDVElPTl9NVVNUX0JFX0FEVkFOQ0VfTk9OQ0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fSU5TVFJVQ1RJT05TX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfQ0FOTk9UX1BBWV9GRUVTLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX01VU1RfTk9UX0JFX1dSSVRBQkxFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19NRVNTQUdFX1NJR05BVFVSRVNfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1NJR05BVFVSRVNfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfT1VUX09GX1JBTkdFLCBTb2xhbmFFcnJvciwgZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvciwgZ2V0U29sYW5hRXJyb3JGcm9tSnNvblJwY0Vycm9yLCBnZXRTb2xhbmFFcnJvckZyb21UcmFuc2FjdGlvbkVycm9yLCBpc1NvbGFuYUVycm9yLCBzYWZlQ2FwdHVyZVN0YWNrVHJhY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbIlNPTEFOQV9FUlJPUl9fQkxPQ0tfSEVJR0hUX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19JTlZBTElEX05PTkNFIiwiU09MQU5BX0VSUk9SX19OT05DRV9BQ0NPVU5UX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fQkxPQ0tIQVNIX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19JTlZBTElEX0JMT0NLSEFTSF9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fTEFNUE9SVFNfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19NQUxGT1JNRURfQklHSU5UX1NUUklORyIsIlNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX05VTUJFUl9TVFJJTkciLCJTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUiIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1BBUlNFX0VSUk9SIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5URVJOQUxfRVJST1IiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1BBUkFNUyIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX01FVEhPRF9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1JFUVVFU1QiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0NBTl9FUlJPUiIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEUiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWSIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVAiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JBU0U1OF9FTkNPREVEX0FERFJFU1MiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9FRDI1NTE5X1BVQkxJQ19LRVkiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFMRk9STUVEX1BEQSIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfQlVNUF9TRUVEX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfUERBX1NFRURfTEVOR1RIX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfU0VFRFNfUE9JTlRfT05fQ1VSVkUiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRUQiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0VORFNfV0lUSF9QREFfTUFSS0VSIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfT0ZGX0NVUlZFX0FERFJFU1MiLCJTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19BQ0NPVU5UX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX09ORV9PUl9NT1JFX0FDQ09VTlRTX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0ZBSUxFRF9UT19ERUNPREVfQUNDT1VOVCIsIlNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0RFQ09ERURfQUNDT1VOVCIsIlNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0FMTF9BQ0NPVU5UU19UT19CRV9ERUNPREVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESVNBTExPV0VEX0lOX0lOU0VDVVJFX0NPTlRFWFQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJR0VTVF9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FWFBPUlRfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fR0VORVJBVEVfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fU0lHTl9GVU5DVElPTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19WRVJJRllfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fQ0FOTk9UX0VYUE9SVF9OT05fRVhUUkFDVEFCTEVfS0VZIiwiU09MQU5BX0VSUk9SX19DUllQVE9fX1JBTkRPTV9WQUxVRVNfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9LRVlfUEFJUl9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9QUklWQVRFX0tFWV9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9TSUdOQVRVUkVfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0tFWVNfX1NJR05BVFVSRV9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fS0VZU19fUFVCTElDX0tFWV9NVVNUX01BVENIX1BSSVZBVEVfS0VZIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UUyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfREFUQSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX1BST0dSQU1fSURfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTktOT1dOIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fR0VORVJJQ19FUlJPUiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQVJHVU1FTlQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0lOU1RSVUNUSU9OX0RBVEEiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfREFUQSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9UT09fU01BTEwiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFMiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfUFJPR1JBTV9JRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfUkVRVUlSRURfU0lHTkFUVVJFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9BTFJFQURZX0lOSVRJQUxJWkVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5JTklUSUFMSVpFRF9BQ0NPVU5UIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9JTlNUUlVDVElPTiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01PRElGSUVEX1BST0dSQU1fSUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0xBTVBPUlRfU1BFTkQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0RBVEFfTU9ESUZJRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9MQU1QT1JUX0NIQU5HRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0RBVEFfTU9ESUZJRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9JTkRFWCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTU9ESUZJRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRU5UX0VQT0NIX01PRElGSUVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTk9UX0VOT1VHSF9BQ0NPVU5UX0tFWVMiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfU0laRV9DSEFOR0VEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRVhFQ1VUQUJMRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX0ZBSUxFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfT1VUX09GX1NZTkMiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DVVNUT00iLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0VSUk9SIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9EQVRBX01PRElGSUVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9MQU1QT1JUX0NIQU5HRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9QUk9HUkFNX0lEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ0FMTF9ERVBUSCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfQUNDT1VOVCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFRU5UUkFOQ1lfTk9UX0FMTE9XRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfU0VFRF9MRU5HVEhfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1NFRURTIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9SRUFMTE9DIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ09NUFVUQVRJT05BTF9CVURHRVRfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUklWSUxFR0VfRVNDQUxBVElPTiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRU5WSVJPTk1FTlRfU0VUVVBfRkFJTFVSRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBMRVRFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUElMRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lNTVVUQUJMRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9BVVRIT1JJVFkiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBUIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX09XTkVSIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQVJJVEhNRVRJQ19PVkVSRkxPVyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1NZU1ZBUiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lMTEVHQUxfT1dORVIiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfREFUQV9BTExPQ0FUSU9OU19FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9JTlNUUlVDVElPTl9UUkFDRV9MRU5HVEhfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CVUlMVElOX1BST0dSQU1TX01VU1RfQ09OU1VNRV9DT01QVVRFX1VOSVRTIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSUyIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9LRVlfUEFJUl9TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9NT0RJRllJTkdfU0lHTkVSIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfUEFSVElBTF9TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0lHTkVSIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX01PRElGWUlOR19TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fUEFSVElBTF9TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0VORElOR19TSUdORVJTIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fV0FMTEVUX01VTFRJU0lHTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19DQU5OT1RfUEFZX0ZFRVMiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX01VU1RfTk9UX0JFX1dSSVRBQkxFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfQkxPQ0tIQVNIX0xJRkVUSU1FIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfTk9OQ0VfTElGRVRJTUUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0NPTlRFTlRTX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfSU5TVFJVQ1RJT05fUFJPR1JBTV9BRERSRVNTX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfRkVFX1BBWUVSX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19TSUdOQVRVUkVTX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9TSUdOQVRVUkVfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fSU5TVFJVQ1RJT05TX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0ZJUlNUX0lOU1RSVUNUSU9OX01VU1RfQkVfQURWQU5DRV9OT05DRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NFU19DQU5OT1RfU0lHTl9UUkFOU0FDVElPTiIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0NBTk5PVF9FTkNPREVfV0lUSF9FTVBUWV9TSUdOQVRVUkVTIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTUVTU0FHRV9TSUdOQVRVUkVTX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfV0hFTl9TSU1VTEFUSU5HX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTktOT1dOIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9JTl9VU0UiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0xPQURFRF9UV0lDRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9BQ0NPVU5UX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfRkVFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0ZPUl9GRUUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BTFJFQURZX1BST0NFU1NFRCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0JMT0NLSEFTSF9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DQUxMX0NIQUlOX1RPT19ERUVQIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUlTU0lOR19TSUdOQVRVUkVfRk9SX0ZFRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9JTkRFWCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NJR05BVFVSRV9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9QUk9HUkFNX0ZPUl9FWEVDVVRJT04iLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TQU5JVElaRV9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0xVU1RFUl9NQUlOVEVOQU5DRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9CTE9DS19DT1NUX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfVkVSU0lPTiIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfV1JJVEFCTEVfQUNDT1VOVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQUNDT1VOVF9DT1NUX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9CTE9DS19MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1RPT19NQU5ZX0FDQ09VTlRfTE9DS1MiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BRERSRVNTX0xPT0tVUF9UQUJMRV9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX09XTkVSIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9EQVRBIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfUkVOVF9QQVlJTkdfQUNDT1VOVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfVk9URV9DT1NUX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9UT1RBTF9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0RVUExJQ0FURV9JTlNUUlVDVElPTiIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfUkVOVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01BWF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUkVTQU5JVElaQVRJT05fTkVFREVEIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9FWEVDVVRJT05fVEVNUE9SQVJJTFlfUkVTVFJJQ1RFRCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfVFJBTlNBQ1RJT04iLCJTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX05VTUJFUl9PRl9JVEVNUyIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRElTQ1JJTUlOQVRFRF9VTklPTl9WQVJJQU5UIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRU5VTV9WQVJJQU5UIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0xJVEVSQUxfVU5JT05fVkFSSUFOVCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19MSVRFUkFMX1VOSU9OX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlQiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfWkVST19WQUxVRV9UT19NQVRDSF9JVEVNX0ZJWEVEX1NJWkUiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfVVNFX0xFWElDQUxfVkFMVUVTX0FTX0VOVU1fRElTQ1JJTUlOQVRPUlMiLCJTT0xBTkFfRVJST1JfX1JQQ19fSU5URUdFUl9PVkVSRkxPVyIsIlNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9IRUFERVJfRk9SQklEREVOIiwiU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0VSUk9SIiwiU09MQU5BX0VSUk9SX19SUENfX0FQSV9QTEFOX01JU1NJTkdfRk9SX1JQQ19NRVRIT0QiLCJTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DQU5OT1RfQ1JFQVRFX1NVQlNDUklQVElPTl9QTEFOIiwiU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fRVhQRUNURURfU0VSVkVSX1NVQlNDUklQVElPTl9JRCIsIlNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ0xPU0VEX0JFRk9SRV9NRVNTQUdFX0JVRkZFUkVEIiwiU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DT05ORUNUSU9OX0NMT1NFRCIsIlNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfRkFJTEVEX1RPX0NPTk5FQ1QiLCJTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9TVEFURV9NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfTVVTVF9OT1RfUE9MTF9CRUZPUkVfUkVTT0xWSU5HX0VYSVNUSU5HX01FU1NBR0VfUFJPTUlTRSIsIlNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fQ0FDSEVEX0FCT1JUQUJMRV9JVEVSQUJMRV9DQUNIRV9FTlRSWV9NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19EQVRBX1BVQkxJU0hFUl9DSEFOTkVMX1VOSU1QTEVNRU5URUQiLCJlbmNvZGVWYWx1ZSIsInZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwiY29tbWFTZXBhcmF0ZWRWYWx1ZXMiLCJtYXAiLCJqb2luIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiU3RyaW5nIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJlbmNvZGVPYmplY3RDb250ZXh0RW50cnkiLCJrZXkiLCJlbmNvZGVDb250ZXh0T2JqZWN0IiwiY29udGV4dCIsInNlYXJjaFBhcmFtc1N0cmluZyIsImVudHJpZXMiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJTb2xhbmFFcnJvck1lc3NhZ2VzIiwiU1RBUlRfSU5ERVgiLCJUWVBFIiwiZ2V0SHVtYW5SZWFkYWJsZUVycm9yTWVzc2FnZSIsImNvZGUiLCJtZXNzYWdlRm9ybWF0U3RyaW5nIiwibGVuZ3RoIiwic3RhdGUiLCJjb21taXRTdGF0ZVVwVG8iLCJlbmRJbmRleCIsInZhcmlhYmxlTmFtZSIsInNsaWNlIiwiZnJhZ21lbnRzIiwicHVzaCIsInNwbGl0IiwiZm9yRWFjaCIsImNoYXIiLCJpaSIsIm5leHRTdGF0ZSIsIm1hdGNoIiwiZ2V0RXJyb3JNZXNzYWdlIiwicHJvY2VzcyIsImRlY29kaW5nQWR2aWNlTWVzc2FnZSIsImtleXMiLCJpc1NvbGFuYUVycm9yIiwiZSIsImlzU29sYW5hRXJyb3IyIiwiRXJyb3IiLCJuYW1lIiwiX19jb2RlIiwiU29sYW5hRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvbnRleHRBbmRFcnJvck9wdGlvbnMiLCJlcnJvck9wdGlvbnMiLCJjYXVzZSIsImNvbnRleHRSZXN0IiwibWVzc2FnZSIsInNhZmVDYXB0dXJlU3RhY2tUcmFjZSIsImFyZ3MiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImdldFNvbGFuYUVycm9yRnJvbVJwY0Vycm9yIiwiZXJyb3JDb2RlQmFzZU9mZnNldCIsImdldEVycm9yQ29udGV4dCIsIm9yZGVyZWRFcnJvck5hbWVzIiwicnBjRW51bUVycm9yIiwiY29uc3RydWN0b3JPcHQiLCJycGNFcnJvck5hbWUiLCJycGNFcnJvckNvbnRleHQiLCJjb2RlT2Zmc2V0IiwiaW5kZXhPZiIsImVycm9yQ29kZSIsImVycm9yQ29udGV4dCIsImVyciIsIk9SREVSRURfRVJST1JfTkFNRVMiLCJnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yIiwiaW5kZXgiLCJpbnN0cnVjdGlvbkVycm9yIiwibnVtYmVySW5kZXgiLCJOdW1iZXIiLCJlcnJvck5hbWUiLCJpbnN0cnVjdGlvbkVycm9yQ29udGV4dCIsImVuY29kZWREYXRhIiwiT1JERVJFRF9FUlJPUl9OQU1FUzIiLCJnZXRTb2xhbmFFcnJvckZyb21UcmFuc2FjdGlvbkVycm9yIiwidHJhbnNhY3Rpb25FcnJvciIsIkluc3RydWN0aW9uRXJyb3IiLCJ0cmFuc2FjdGlvbkVycm9yQ29udGV4dCIsImFjY291bnRJbmRleCIsImFjY291bnRfaW5kZXgiLCJnZXRTb2xhbmFFcnJvckZyb21Kc29uUnBjRXJyb3IiLCJwdXRhdGl2ZUVycm9yUmVzcG9uc2UiLCJvdXQiLCJpc1JwY0Vycm9yUmVzcG9uc2UiLCJyYXdDb2RlIiwiZGF0YSIsInByZWZsaWdodEVycm9yQ29udGV4dCIsImNhdXNlT2JqZWN0IiwiX19zZXJ2ZXJNZXNzYWdlIiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseWalletAdapter: () => (/* binding */ BaseWalletAdapter),\n/* harmony export */   EventEmitter: () => (/* reexport safe */ eventemitter3__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   WalletReadyState: () => (/* binding */ WalletReadyState),\n/* harmony export */   isIosAndRedirectable: () => (/* binding */ isIosAndRedirectable),\n/* harmony export */   scopePollingDetectionStrategy: () => (/* binding */ scopePollingDetectionStrategy)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n\n\n\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */ var WalletReadyState;\n(function(WalletReadyState) {\n    /**\n     * User-installable wallets can typically be detected by scanning for an API\n     * that they've injected into the global context. If such an API is present,\n     * we consider the wallet to have been installed.\n     */ WalletReadyState[\"Installed\"] = \"Installed\";\n    WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n    /**\n     * Loadable wallets are always available to you. Since you can load them at\n     * any time, it's meaningless to say that they have been detected.\n     */ WalletReadyState[\"Loadable\"] = \"Loadable\";\n    /**\n     * If a wallet is not supported on a given platform (eg. server-rendering, or\n     * mobile) then it will stay in the `Unsupported` state.\n     */ WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState || (WalletReadyState = {}));\nclass BaseWalletAdapter extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    get connected() {\n        return !!this.publicKey;\n    }\n    async autoConnect() {\n        await this.connect();\n    }\n    async prepareTransaction(transaction, connection, options = {}) {\n        const publicKey = this.publicKey;\n        if (!publicKey) throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError();\n        transaction.feePayer = transaction.feePayer || publicKey;\n        transaction.recentBlockhash = transaction.recentBlockhash || (await connection.getLatestBlockhash({\n            commitment: options.preflightCommitment,\n            minContextSlot: options.minContextSlot\n        })).blockhash;\n        return transaction;\n    }\n}\nfunction scopePollingDetectionStrategy(detect) {\n    // Early return when server-side rendering\n    if (true) return;\n    const disposers = [];\n    function detectAndDispose() {\n        const detected = detect();\n        if (detected) {\n            for (const dispose of disposers){\n                dispose();\n            }\n        }\n    }\n    // Strategy #1: Try detecting every second.\n    const interval = // TODO: #334 Replace with idle callback strategy.\n    setInterval(detectAndDispose, 1000);\n    disposers.push(()=>clearInterval(interval));\n    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n    if (// Implies that `DOMContentLoaded` has not yet fired.\n    document.readyState === \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", detectAndDispose, {\n            once: true\n        });\n        disposers.push(()=>document.removeEventListener(\"DOMContentLoaded\", detectAndDispose));\n    }\n    // Strategy #3: Detect after the `window` has fully loaded.\n    if (// If the `complete` state has been reached, we're too late.\n    document.readyState !== \"complete\") {\n        window.addEventListener(\"load\", detectAndDispose, {\n            once: true\n        });\n        disposers.push(()=>window.removeEventListener(\"load\", detectAndDispose));\n    }\n    // Strategy #4: Detect synchronously, now.\n    detectAndDispose();\n}\n/**\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\n * if that wallet has a universal link configured to do so\n * But should not be redirected from within a webview, eg. if they're already\n * inside a wallet's browser\n * This function can be used to identify users who are on iOS and can be redirected\n *\n * @returns true if the user can be redirected\n */ function isIosAndRedirectable() {\n    // SSR: return false\n    if (!navigator) return false;\n    const userAgent = navigator.userAgent.toLowerCase();\n    // if on iOS the user agent will contain either iPhone or iPad\n    // caveat: if requesting desktop site then this won't work\n    const isIos = userAgent.includes(\"iphone\") || userAgent.includes(\"ipad\");\n    // if in a webview then it will not include Safari\n    // note that other iOS browsers also include Safari\n    // so we will redirect only if Safari is also included\n    const isSafari = userAgent.includes(\"safari\");\n    return isIos && isSafari;\n} //# sourceMappingURL=adapter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vYWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlDO0FBQ2E7QUFDOUI7QUFDeEI7Ozs7Ozs7O0NBUUMsR0FDTSxJQUFJRSxpQkFBaUI7QUFDM0IsVUFBVUEsZ0JBQWdCO0lBQ3ZCOzs7O0tBSUMsR0FDREEsZ0JBQWdCLENBQUMsWUFBWSxHQUFHO0lBQ2hDQSxnQkFBZ0IsQ0FBQyxjQUFjLEdBQUc7SUFDbEM7OztLQUdDLEdBQ0RBLGdCQUFnQixDQUFDLFdBQVcsR0FBRztJQUMvQjs7O0tBR0MsR0FDREEsZ0JBQWdCLENBQUMsY0FBYyxHQUFHO0FBQ3RDLEdBQUdBLG9CQUFxQkEsQ0FBQUEsbUJBQW1CLENBQUM7QUFDckMsTUFBTUMsMEJBQTBCSCxxREFBWUE7SUFDL0MsSUFBSUksWUFBWTtRQUNaLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQ0MsU0FBUztJQUMzQjtJQUNBLE1BQU1DLGNBQWM7UUFDaEIsTUFBTSxJQUFJLENBQUNDLE9BQU87SUFDdEI7SUFDQSxNQUFNQyxtQkFBbUJDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQzVELE1BQU1OLFlBQVksSUFBSSxDQUFDQSxTQUFTO1FBQ2hDLElBQUksQ0FBQ0EsV0FDRCxNQUFNLElBQUlKLCtEQUF1QkE7UUFDckNRLFlBQVlHLFFBQVEsR0FBR0gsWUFBWUcsUUFBUSxJQUFJUDtRQUMvQ0ksWUFBWUksZUFBZSxHQUN2QkosWUFBWUksZUFBZSxJQUN2QixDQUFDLE1BQU1ILFdBQVdJLGtCQUFrQixDQUFDO1lBQ2pDQyxZQUFZSixRQUFRSyxtQkFBbUI7WUFDdkNDLGdCQUFnQk4sUUFBUU0sY0FBYztRQUMxQyxFQUFDLEVBQUdDLFNBQVM7UUFDckIsT0FBT1Q7SUFDWDtBQUNKO0FBQ08sU0FBU1UsOEJBQThCQyxNQUFNO0lBQ2hELDBDQUEwQztJQUMxQyxJQUFJLElBQXFELEVBQ3JEO0lBQ0osTUFBTUUsWUFBWSxFQUFFO0lBQ3BCLFNBQVNDO1FBQ0wsTUFBTUMsV0FBV0o7UUFDakIsSUFBSUksVUFBVTtZQUNWLEtBQUssTUFBTUMsV0FBV0gsVUFBVztnQkFDN0JHO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsMkNBQTJDO0lBQzNDLE1BQU1DLFdBQ04sa0RBQWtEO0lBQ2xEQyxZQUFZSixrQkFBa0I7SUFDOUJELFVBQVVNLElBQUksQ0FBQyxJQUFNQyxjQUFjSDtJQUNuQyx3RUFBd0U7SUFDeEUsSUFDQSxxREFBcUQ7SUFDckRMLFNBQVNTLFVBQVUsS0FBSyxXQUFXO1FBQy9CVCxTQUFTVSxnQkFBZ0IsQ0FBQyxvQkFBb0JSLGtCQUFrQjtZQUFFUyxNQUFNO1FBQUs7UUFDN0VWLFVBQVVNLElBQUksQ0FBQyxJQUFNUCxTQUFTWSxtQkFBbUIsQ0FBQyxvQkFBb0JWO0lBQzFFO0lBQ0EsMkRBQTJEO0lBQzNELElBQ0EsNERBQTREO0lBQzVERixTQUFTUyxVQUFVLEtBQUssWUFBWTtRQUNoQ0ksT0FBT0gsZ0JBQWdCLENBQUMsUUFBUVIsa0JBQWtCO1lBQUVTLE1BQU07UUFBSztRQUMvRFYsVUFBVU0sSUFBSSxDQUFDLElBQU1NLE9BQU9ELG1CQUFtQixDQUFDLFFBQVFWO0lBQzVEO0lBQ0EsMENBQTBDO0lBQzFDQTtBQUNKO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDTSxTQUFTWTtJQUNaLG9CQUFvQjtJQUNwQixJQUFJLENBQUNDLFdBQ0QsT0FBTztJQUNYLE1BQU1DLFlBQVlELFVBQVVDLFNBQVMsQ0FBQ0MsV0FBVztJQUNqRCw4REFBOEQ7SUFDOUQsMERBQTBEO0lBQzFELE1BQU1DLFFBQVFGLFVBQVVHLFFBQVEsQ0FBQyxhQUFhSCxVQUFVRyxRQUFRLENBQUM7SUFDakUsa0RBQWtEO0lBQ2xELG1EQUFtRDtJQUNuRCxzREFBc0Q7SUFDdEQsTUFBTUMsV0FBV0osVUFBVUcsUUFBUSxDQUFDO0lBQ3BDLE9BQU9ELFNBQVNFO0FBQ3BCLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vYWRhcHRlci5qcz80M2Q5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmV4cG9ydCB7IEV2ZW50RW1pdHRlciB9O1xuLyoqXG4gKiBBIHdhbGxldCdzIHJlYWRpbmVzcyBkZXNjcmliZXMgYSBzZXJpZXMgb2Ygc3RhdGVzIHRoYXQgdGhlIHdhbGxldCBjYW4gYmUgaW4sXG4gKiBkZXBlbmRpbmcgb24gd2hhdCBraW5kIG9mIHdhbGxldCBpdCBpcy4gQW4gaW5zdGFsbGFibGUgd2FsbGV0IChlZy4gYSBicm93c2VyXG4gKiBleHRlbnNpb24gbGlrZSBQaGFudG9tKSBtaWdodCBiZSBgSW5zdGFsbGVkYCBpZiB3ZSd2ZSBmb3VuZCB0aGUgUGhhbnRvbSBBUElcbiAqIGluIHRoZSBnbG9iYWwgc2NvcGUsIG9yIGBOb3REZXRlY3RlZGAgb3RoZXJ3aXNlLiBBIGxvYWRhYmxlLCB6ZXJvLWluc3RhbGxcbiAqIHJ1bnRpbWUgKGVnLiBUb3J1cyBXYWxsZXQpIG1pZ2h0IHNpbXBseSBzaWduYWwgdGhhdCBpdCdzIGBMb2FkYWJsZWAuIFVzZSB0aGlzXG4gKiBtZXRhZGF0YSB0byBwZXJzb25hbGl6ZSB0aGUgd2FsbGV0IGxpc3QgZm9yIGVhY2ggdXNlciAoZWcuIHRvIHNob3cgdGhlaXJcbiAqIGluc3RhbGxlZCB3YWxsZXRzIGZpcnN0KS5cbiAqL1xuZXhwb3J0IHZhciBXYWxsZXRSZWFkeVN0YXRlO1xuKGZ1bmN0aW9uIChXYWxsZXRSZWFkeVN0YXRlKSB7XG4gICAgLyoqXG4gICAgICogVXNlci1pbnN0YWxsYWJsZSB3YWxsZXRzIGNhbiB0eXBpY2FsbHkgYmUgZGV0ZWN0ZWQgYnkgc2Nhbm5pbmcgZm9yIGFuIEFQSVxuICAgICAqIHRoYXQgdGhleSd2ZSBpbmplY3RlZCBpbnRvIHRoZSBnbG9iYWwgY29udGV4dC4gSWYgc3VjaCBhbiBBUEkgaXMgcHJlc2VudCxcbiAgICAgKiB3ZSBjb25zaWRlciB0aGUgd2FsbGV0IHRvIGhhdmUgYmVlbiBpbnN0YWxsZWQuXG4gICAgICovXG4gICAgV2FsbGV0UmVhZHlTdGF0ZVtcIkluc3RhbGxlZFwiXSA9IFwiSW5zdGFsbGVkXCI7XG4gICAgV2FsbGV0UmVhZHlTdGF0ZVtcIk5vdERldGVjdGVkXCJdID0gXCJOb3REZXRlY3RlZFwiO1xuICAgIC8qKlxuICAgICAqIExvYWRhYmxlIHdhbGxldHMgYXJlIGFsd2F5cyBhdmFpbGFibGUgdG8geW91LiBTaW5jZSB5b3UgY2FuIGxvYWQgdGhlbSBhdFxuICAgICAqIGFueSB0aW1lLCBpdCdzIG1lYW5pbmdsZXNzIHRvIHNheSB0aGF0IHRoZXkgaGF2ZSBiZWVuIGRldGVjdGVkLlxuICAgICAqL1xuICAgIFdhbGxldFJlYWR5U3RhdGVbXCJMb2FkYWJsZVwiXSA9IFwiTG9hZGFibGVcIjtcbiAgICAvKipcbiAgICAgKiBJZiBhIHdhbGxldCBpcyBub3Qgc3VwcG9ydGVkIG9uIGEgZ2l2ZW4gcGxhdGZvcm0gKGVnLiBzZXJ2ZXItcmVuZGVyaW5nLCBvclxuICAgICAqIG1vYmlsZSkgdGhlbiBpdCB3aWxsIHN0YXkgaW4gdGhlIGBVbnN1cHBvcnRlZGAgc3RhdGUuXG4gICAgICovXG4gICAgV2FsbGV0UmVhZHlTdGF0ZVtcIlVuc3VwcG9ydGVkXCJdID0gXCJVbnN1cHBvcnRlZFwiO1xufSkoV2FsbGV0UmVhZHlTdGF0ZSB8fCAoV2FsbGV0UmVhZHlTdGF0ZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgQmFzZVdhbGxldEFkYXB0ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucHVibGljS2V5O1xuICAgIH1cbiAgICBhc3luYyBhdXRvQ29ubmVjdCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHRoaXMucHVibGljS2V5O1xuICAgICAgICBpZiAoIXB1YmxpY0tleSlcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHRyYW5zYWN0aW9uLmZlZVBheWVyIHx8IHB1YmxpY0tleTtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID1cbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCB8fFxuICAgICAgICAgICAgICAgIChhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCxcbiAgICAgICAgICAgICAgICAgICAgbWluQ29udGV4dFNsb3Q6IG9wdGlvbnMubWluQ29udGV4dFNsb3QsXG4gICAgICAgICAgICAgICAgfSkpLmJsb2NraGFzaDtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzY29wZVBvbGxpbmdEZXRlY3Rpb25TdHJhdGVneShkZXRlY3QpIHtcbiAgICAvLyBFYXJseSByZXR1cm4gd2hlbiBzZXJ2ZXItc2lkZSByZW5kZXJpbmdcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRpc3Bvc2VycyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRldGVjdEFuZERpc3Bvc2UoKSB7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkID0gZGV0ZWN0KCk7XG4gICAgICAgIGlmIChkZXRlY3RlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkaXNwb3NlIG9mIGRpc3Bvc2Vycykge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTdHJhdGVneSAjMTogVHJ5IGRldGVjdGluZyBldmVyeSBzZWNvbmQuXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBcbiAgICAvLyBUT0RPOiAjMzM0IFJlcGxhY2Ugd2l0aCBpZGxlIGNhbGxiYWNrIHN0cmF0ZWd5LlxuICAgIHNldEludGVydmFsKGRldGVjdEFuZERpc3Bvc2UsIDEwMDApO1xuICAgIGRpc3Bvc2Vycy5wdXNoKCgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpKTtcbiAgICAvLyBTdHJhdGVneSAjMjogRGV0ZWN0IGFzIHNvb24gYXMgdGhlIERPTSBiZWNvbWVzICdyZWFkeScvJ2ludGVyYWN0aXZlJy5cbiAgICBpZiAoXG4gICAgLy8gSW1wbGllcyB0aGF0IGBET01Db250ZW50TG9hZGVkYCBoYXMgbm90IHlldCBmaXJlZC5cbiAgICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRldGVjdEFuZERpc3Bvc2UsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgZGlzcG9zZXJzLnB1c2goKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRldGVjdEFuZERpc3Bvc2UpKTtcbiAgICB9XG4gICAgLy8gU3RyYXRlZ3kgIzM6IERldGVjdCBhZnRlciB0aGUgYHdpbmRvd2AgaGFzIGZ1bGx5IGxvYWRlZC5cbiAgICBpZiAoXG4gICAgLy8gSWYgdGhlIGBjb21wbGV0ZWAgc3RhdGUgaGFzIGJlZW4gcmVhY2hlZCwgd2UncmUgdG9vIGxhdGUuXG4gICAgZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGRldGVjdEFuZERpc3Bvc2UsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgZGlzcG9zZXJzLnB1c2goKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBkZXRlY3RBbmREaXNwb3NlKSk7XG4gICAgfVxuICAgIC8vIFN0cmF0ZWd5ICM0OiBEZXRlY3Qgc3luY2hyb25vdXNseSwgbm93LlxuICAgIGRldGVjdEFuZERpc3Bvc2UoKTtcbn1cbi8qKlxuICogVXNlcnMgb24gaU9TIGNhbiBiZSByZWRpcmVjdGVkIGludG8gYSB3YWxsZXQncyBpbi1hcHAgYnJvd3NlciBhdXRvbWF0aWNhbGx5LFxuICogaWYgdGhhdCB3YWxsZXQgaGFzIGEgdW5pdmVyc2FsIGxpbmsgY29uZmlndXJlZCB0byBkbyBzb1xuICogQnV0IHNob3VsZCBub3QgYmUgcmVkaXJlY3RlZCBmcm9tIHdpdGhpbiBhIHdlYnZpZXcsIGVnLiBpZiB0aGV5J3JlIGFscmVhZHlcbiAqIGluc2lkZSBhIHdhbGxldCdzIGJyb3dzZXJcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdXNlcnMgd2hvIGFyZSBvbiBpT1MgYW5kIGNhbiBiZSByZWRpcmVjdGVkXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdXNlciBjYW4gYmUgcmVkaXJlY3RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJb3NBbmRSZWRpcmVjdGFibGUoKSB7XG4gICAgLy8gU1NSOiByZXR1cm4gZmFsc2VcbiAgICBpZiAoIW5hdmlnYXRvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBpZiBvbiBpT1MgdGhlIHVzZXIgYWdlbnQgd2lsbCBjb250YWluIGVpdGhlciBpUGhvbmUgb3IgaVBhZFxuICAgIC8vIGNhdmVhdDogaWYgcmVxdWVzdGluZyBkZXNrdG9wIHNpdGUgdGhlbiB0aGlzIHdvbid0IHdvcmtcbiAgICBjb25zdCBpc0lvcyA9IHVzZXJBZ2VudC5pbmNsdWRlcygnaXBob25lJykgfHwgdXNlckFnZW50LmluY2x1ZGVzKCdpcGFkJyk7XG4gICAgLy8gaWYgaW4gYSB3ZWJ2aWV3IHRoZW4gaXQgd2lsbCBub3QgaW5jbHVkZSBTYWZhcmlcbiAgICAvLyBub3RlIHRoYXQgb3RoZXIgaU9TIGJyb3dzZXJzIGFsc28gaW5jbHVkZSBTYWZhcmlcbiAgICAvLyBzbyB3ZSB3aWxsIHJlZGlyZWN0IG9ubHkgaWYgU2FmYXJpIGlzIGFsc28gaW5jbHVkZWRcbiAgICBjb25zdCBpc1NhZmFyaSA9IHVzZXJBZ2VudC5pbmNsdWRlcygnc2FmYXJpJyk7XG4gICAgcmV0dXJuIGlzSW9zICYmIGlzU2FmYXJpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRlci5qcy5tYXAiXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IiLCJXYWxsZXRSZWFkeVN0YXRlIiwiQmFzZVdhbGxldEFkYXB0ZXIiLCJjb25uZWN0ZWQiLCJwdWJsaWNLZXkiLCJhdXRvQ29ubmVjdCIsImNvbm5lY3QiLCJwcmVwYXJlVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbiIsImNvbm5lY3Rpb24iLCJvcHRpb25zIiwiZmVlUGF5ZXIiLCJyZWNlbnRCbG9ja2hhc2giLCJnZXRMYXRlc3RCbG9ja2hhc2giLCJjb21taXRtZW50IiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsIm1pbkNvbnRleHRTbG90IiwiYmxvY2toYXNoIiwic2NvcGVQb2xsaW5nRGV0ZWN0aW9uU3RyYXRlZ3kiLCJkZXRlY3QiLCJkb2N1bWVudCIsImRpc3Bvc2VycyIsImRldGVjdEFuZERpc3Bvc2UiLCJkZXRlY3RlZCIsImRpc3Bvc2UiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwicHVzaCIsImNsZWFySW50ZXJ2YWwiLCJyZWFkeVN0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwid2luZG93IiwiaXNJb3NBbmRSZWRpcmVjdGFibGUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsImlzSW9zIiwiaW5jbHVkZXMiLCJpc1NhZmFyaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js":
/*!********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletAccountError: () => (/* binding */ WalletAccountError),\n/* harmony export */   WalletConfigError: () => (/* binding */ WalletConfigError),\n/* harmony export */   WalletConnectionError: () => (/* binding */ WalletConnectionError),\n/* harmony export */   WalletDisconnectedError: () => (/* binding */ WalletDisconnectedError),\n/* harmony export */   WalletDisconnectionError: () => (/* binding */ WalletDisconnectionError),\n/* harmony export */   WalletError: () => (/* binding */ WalletError),\n/* harmony export */   WalletKeypairError: () => (/* binding */ WalletKeypairError),\n/* harmony export */   WalletLoadError: () => (/* binding */ WalletLoadError),\n/* harmony export */   WalletNotConnectedError: () => (/* binding */ WalletNotConnectedError),\n/* harmony export */   WalletNotReadyError: () => (/* binding */ WalletNotReadyError),\n/* harmony export */   WalletPublicKeyError: () => (/* binding */ WalletPublicKeyError),\n/* harmony export */   WalletSendTransactionError: () => (/* binding */ WalletSendTransactionError),\n/* harmony export */   WalletSignInError: () => (/* binding */ WalletSignInError),\n/* harmony export */   WalletSignMessageError: () => (/* binding */ WalletSignMessageError),\n/* harmony export */   WalletSignTransactionError: () => (/* binding */ WalletSignTransactionError),\n/* harmony export */   WalletTimeoutError: () => (/* binding */ WalletTimeoutError),\n/* harmony export */   WalletWindowBlockedError: () => (/* binding */ WalletWindowBlockedError),\n/* harmony export */   WalletWindowClosedError: () => (/* binding */ WalletWindowClosedError)\n/* harmony export */ });\nclass WalletError extends Error {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(message, error){\n        super(message);\n        this.error = error;\n    }\n}\nclass WalletNotReadyError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletNotReadyError\";\n    }\n}\nclass WalletLoadError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletLoadError\";\n    }\n}\nclass WalletConfigError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletConfigError\";\n    }\n}\nclass WalletConnectionError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletConnectionError\";\n    }\n}\nclass WalletDisconnectedError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletDisconnectedError\";\n    }\n}\nclass WalletDisconnectionError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletDisconnectionError\";\n    }\n}\nclass WalletAccountError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletAccountError\";\n    }\n}\nclass WalletPublicKeyError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletPublicKeyError\";\n    }\n}\nclass WalletKeypairError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletKeypairError\";\n    }\n}\nclass WalletNotConnectedError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletNotConnectedError\";\n    }\n}\nclass WalletSendTransactionError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletSendTransactionError\";\n    }\n}\nclass WalletSignTransactionError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletSignTransactionError\";\n    }\n}\nclass WalletSignMessageError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletSignMessageError\";\n    }\n}\nclass WalletSignInError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletSignInError\";\n    }\n}\nclass WalletTimeoutError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletTimeoutError\";\n    }\n}\nclass WalletWindowBlockedError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletWindowBlockedError\";\n    }\n}\nclass WalletWindowClosedError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletWindowClosedError\";\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPLE1BQU1BLG9CQUFvQkM7SUFDN0IsNkVBQTZFO0lBQzdFQyxZQUFZQyxPQUFPLEVBQUVDLEtBQUssQ0FBRTtRQUN4QixLQUFLLENBQUNEO1FBQ04sSUFBSSxDQUFDQyxLQUFLLEdBQUdBO0lBQ2pCO0FBQ0o7QUFDTyxNQUFNQyw0QkFBNEJMO0lBQ3JDRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNQyx3QkFBd0JSO0lBQ2pDRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNRSwwQkFBMEJUO0lBQ25DRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNRyw4QkFBOEJWO0lBQ3ZDRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNSSxnQ0FBZ0NYO0lBQ3pDRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNSyxpQ0FBaUNaO0lBQzFDRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNTSwyQkFBMkJiO0lBQ3BDRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNTyw2QkFBNkJkO0lBQ3RDRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNUSwyQkFBMkJmO0lBQ3BDRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNUyxnQ0FBZ0NoQjtJQUN6Q0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTVUsbUNBQW1DakI7SUFDNUNFLGFBQWM7UUFDVixLQUFLLElBQUlJO1FBQ1QsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUNPLE1BQU1XLG1DQUFtQ2xCO0lBQzVDRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNWSwrQkFBK0JuQjtJQUN4Q0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTWEsMEJBQTBCcEI7SUFDbkNFLGFBQWM7UUFDVixLQUFLLElBQUlJO1FBQ1QsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUNPLE1BQU1jLDJCQUEyQnJCO0lBQ3BDRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNZSxpQ0FBaUN0QjtJQUMxQ0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTWdCLGdDQUFnQ3ZCO0lBQ3pDRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9lcnJvcnMuanM/MjczMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgV2FsbGV0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvcikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXROb3RSZWFkeUVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0Tm90UmVhZHlFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldExvYWRFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldExvYWRFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldENvbmZpZ0Vycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0Q29uZmlnRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRDb25uZWN0aW9uRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXREaXNjb25uZWN0ZWRFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldERpc2Nvbm5lY3RlZEVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0RGlzY29ubmVjdGlvbkVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0RGlzY29ubmVjdGlvbkVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0QWNjb3VudEVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0QWNjb3VudEVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0UHVibGljS2V5RXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRQdWJsaWNLZXlFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldEtleXBhaXJFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldEtleXBhaXJFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldE5vdENvbm5lY3RlZEVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldFNpZ25NZXNzYWdlRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRTaWduTWVzc2FnZUVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0U2lnbkluRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRTaWduSW5FcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldFRpbWVvdXRFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldFRpbWVvdXRFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldFdpbmRvd0Jsb2NrZWRFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldFdpbmRvd0Jsb2NrZWRFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldFdpbmRvd0Nsb3NlZEVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0V2luZG93Q2xvc2VkRXJyb3InO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOlsiV2FsbGV0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImVycm9yIiwiV2FsbGV0Tm90UmVhZHlFcnJvciIsImFyZ3VtZW50cyIsIm5hbWUiLCJXYWxsZXRMb2FkRXJyb3IiLCJXYWxsZXRDb25maWdFcnJvciIsIldhbGxldENvbm5lY3Rpb25FcnJvciIsIldhbGxldERpc2Nvbm5lY3RlZEVycm9yIiwiV2FsbGV0RGlzY29ubmVjdGlvbkVycm9yIiwiV2FsbGV0QWNjb3VudEVycm9yIiwiV2FsbGV0UHVibGljS2V5RXJyb3IiLCJXYWxsZXRLZXlwYWlyRXJyb3IiLCJXYWxsZXROb3RDb25uZWN0ZWRFcnJvciIsIldhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yIiwiV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IiLCJXYWxsZXRTaWduTWVzc2FnZUVycm9yIiwiV2FsbGV0U2lnbkluRXJyb3IiLCJXYWxsZXRUaW1lb3V0RXJyb3IiLCJXYWxsZXRXaW5kb3dCbG9ja2VkRXJyb3IiLCJXYWxsZXRXaW5kb3dDbG9zZWRFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseMessageSignerWalletAdapter: () => (/* binding */ BaseMessageSignerWalletAdapter),\n/* harmony export */   BaseSignInMessageSignerWalletAdapter: () => (/* binding */ BaseSignInMessageSignerWalletAdapter),\n/* harmony export */   BaseSignerWalletAdapter: () => (/* binding */ BaseSignerWalletAdapter)\n/* harmony export */ });\n/* harmony import */ var _adapter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transaction.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n\n\n\nclass BaseSignerWalletAdapter extends _adapter_js__WEBPACK_IMPORTED_MODULE_0__.BaseWalletAdapter {\n    async sendTransaction(transaction, connection, options = {}) {\n        let emit = true;\n        try {\n            if ((0,_transaction_js__WEBPACK_IMPORTED_MODULE_1__.isVersionedTransaction)(transaction)) {\n                if (!this.supportedTransactionVersions) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version)) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(`Sending transaction version ${transaction.version} isn't supported by this wallet`);\n                try {\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, options);\n                } catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(error?.message, error);\n                }\n            } else {\n                try {\n                    const { signers, ...sendOptions } = options;\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n                    signers?.length && transaction.partialSign(...signers);\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, sendOptions);\n                } catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(error?.message, error);\n                }\n            }\n        } catch (error) {\n            if (emit) {\n                this.emit(\"error\", error);\n            }\n            throw error;\n        }\n    }\n    async signAllTransactions(transactions) {\n        for (const transaction of transactions){\n            if ((0,_transaction_js__WEBPACK_IMPORTED_MODULE_1__.isVersionedTransaction)(transaction)) {\n                if (!this.supportedTransactionVersions) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError(`Signing versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version)) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError(`Signing transaction version ${transaction.version} isn't supported by this wallet`);\n            }\n        }\n        const signedTransactions = [];\n        for (const transaction of transactions){\n            signedTransactions.push(await this.signTransaction(transaction));\n        }\n        return signedTransactions;\n    }\n}\nclass BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {\n}\nclass BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {\n} //# sourceMappingURL=signer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vc2lnbmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFrRDtBQUNtQztBQUMzQjtBQUNuRCxNQUFNSSxnQ0FBZ0NKLDBEQUFpQkE7SUFDMUQsTUFBTUssZ0JBQWdCQyxXQUFXLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRTtRQUN6RCxJQUFJQyxPQUFPO1FBQ1gsSUFBSTtZQUNBLElBQUlOLHVFQUFzQkEsQ0FBQ0csY0FBYztnQkFDckMsSUFBSSxDQUFDLElBQUksQ0FBQ0ksNEJBQTRCLEVBQ2xDLE1BQU0sSUFBSVQsa0VBQTBCQSxDQUFDLENBQUMsNkRBQTZELENBQUM7Z0JBQ3hHLElBQUksQ0FBQyxJQUFJLENBQUNTLDRCQUE0QixDQUFDQyxHQUFHLENBQUNMLFlBQVlNLE9BQU8sR0FDMUQsTUFBTSxJQUFJWCxrRUFBMEJBLENBQUMsQ0FBQyw0QkFBNEIsRUFBRUssWUFBWU0sT0FBTyxDQUFDLCtCQUErQixDQUFDO2dCQUM1SCxJQUFJO29CQUNBTixjQUFjLE1BQU0sSUFBSSxDQUFDTyxlQUFlLENBQUNQO29CQUN6QyxNQUFNUSxpQkFBaUJSLFlBQVlTLFNBQVM7b0JBQzVDLE9BQU8sTUFBTVIsV0FBV1Msa0JBQWtCLENBQUNGLGdCQUFnQk47Z0JBQy9ELEVBQ0EsT0FBT1MsT0FBTztvQkFDViw0RkFBNEY7b0JBQzVGLElBQUlBLGlCQUFpQmYsa0VBQTBCQSxFQUFFO3dCQUM3Q08sT0FBTzt3QkFDUCxNQUFNUTtvQkFDVjtvQkFDQSxNQUFNLElBQUloQixrRUFBMEJBLENBQUNnQixPQUFPQyxTQUFTRDtnQkFDekQ7WUFDSixPQUNLO2dCQUNELElBQUk7b0JBQ0EsTUFBTSxFQUFFRSxPQUFPLEVBQUUsR0FBR0MsYUFBYSxHQUFHWjtvQkFDcENGLGNBQWMsTUFBTSxJQUFJLENBQUNlLGtCQUFrQixDQUFDZixhQUFhQyxZQUFZYTtvQkFDckVELFNBQVNHLFVBQVVoQixZQUFZaUIsV0FBVyxJQUFJSjtvQkFDOUNiLGNBQWMsTUFBTSxJQUFJLENBQUNPLGVBQWUsQ0FBQ1A7b0JBQ3pDLE1BQU1RLGlCQUFpQlIsWUFBWVMsU0FBUztvQkFDNUMsT0FBTyxNQUFNUixXQUFXUyxrQkFBa0IsQ0FBQ0YsZ0JBQWdCTTtnQkFDL0QsRUFDQSxPQUFPSCxPQUFPO29CQUNWLDRGQUE0RjtvQkFDNUYsSUFBSUEsaUJBQWlCZixrRUFBMEJBLEVBQUU7d0JBQzdDTyxPQUFPO3dCQUNQLE1BQU1RO29CQUNWO29CQUNBLE1BQU0sSUFBSWhCLGtFQUEwQkEsQ0FBQ2dCLE9BQU9DLFNBQVNEO2dCQUN6RDtZQUNKO1FBQ0osRUFDQSxPQUFPQSxPQUFPO1lBQ1YsSUFBSVIsTUFBTTtnQkFDTixJQUFJLENBQUNBLElBQUksQ0FBQyxTQUFTUTtZQUN2QjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBLE1BQU1PLG9CQUFvQkMsWUFBWSxFQUFFO1FBQ3BDLEtBQUssTUFBTW5CLGVBQWVtQixhQUFjO1lBQ3BDLElBQUl0Qix1RUFBc0JBLENBQUNHLGNBQWM7Z0JBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUNJLDRCQUE0QixFQUNsQyxNQUFNLElBQUlSLGtFQUEwQkEsQ0FBQyxDQUFDLDZEQUE2RCxDQUFDO2dCQUN4RyxJQUFJLENBQUMsSUFBSSxDQUFDUSw0QkFBNEIsQ0FBQ0MsR0FBRyxDQUFDTCxZQUFZTSxPQUFPLEdBQzFELE1BQU0sSUFBSVYsa0VBQTBCQSxDQUFDLENBQUMsNEJBQTRCLEVBQUVJLFlBQVlNLE9BQU8sQ0FBQywrQkFBK0IsQ0FBQztZQUNoSTtRQUNKO1FBQ0EsTUFBTWMscUJBQXFCLEVBQUU7UUFDN0IsS0FBSyxNQUFNcEIsZUFBZW1CLGFBQWM7WUFDcENDLG1CQUFtQkMsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDZCxlQUFlLENBQUNQO1FBQ3ZEO1FBQ0EsT0FBT29CO0lBQ1g7QUFDSjtBQUNPLE1BQU1FLHVDQUF1Q3hCO0FBQ3BEO0FBQ08sTUFBTXlCLDZDQUE2Q0Q7QUFDMUQsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9zaWduZXIuanM/N2I1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlV2FsbGV0QWRhcHRlciwgfSBmcm9tICcuL2FkYXB0ZXIuanMnO1xuaW1wb3J0IHsgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IsIFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24uanMnO1xuZXhwb3J0IGNsYXNzIEJhc2VTaWduZXJXYWxsZXRBZGFwdGVyIGV4dGVuZHMgQmFzZVdhbGxldEFkYXB0ZXIge1xuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBlbWl0ID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IoYFNlbmRpbmcgdmVyc2lvbmVkIHRyYW5zYWN0aW9ucyBpc24ndCBzdXBwb3J0ZWQgYnkgdGhpcyB3YWxsZXRgKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucy5oYXModHJhbnNhY3Rpb24udmVyc2lvbikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvcihgU2VuZGluZyB0cmFuc2FjdGlvbiB2ZXJzaW9uICR7dHJhbnNhY3Rpb24udmVyc2lvbn0gaXNuJ3Qgc3VwcG9ydGVkIGJ5IHRoaXMgd2FsbGV0YCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd1RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZXJyb3Igd2FzIHRocm93biBieSBgc2lnblRyYW5zYWN0aW9uYCwgcmV0aHJvdyBpdCBhbmQgZG9uJ3QgZW1pdCBhIGR1cGxpY2F0ZSBldmVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzaWduZXJzLCAuLi5zZW5kT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLnByZXBhcmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgc2VuZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBzaWduZXJzPy5sZW5ndGggJiYgdHJhbnNhY3Rpb24ucGFydGlhbFNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24sIHNlbmRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlcnJvciB3YXMgdGhyb3duIGJ5IGBzaWduVHJhbnNhY3Rpb25gLCByZXRocm93IGl0IGFuZCBkb24ndCBlbWl0IGEgZHVwbGljYXRlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zYWN0aW9uIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcihgU2lnbmluZyB2ZXJzaW9uZWQgdHJhbnNhY3Rpb25zIGlzbid0IHN1cHBvcnRlZCBieSB0aGlzIHdhbGxldGApO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zLmhhcyh0cmFuc2FjdGlvbi52ZXJzaW9uKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKGBTaWduaW5nIHRyYW5zYWN0aW9uIHZlcnNpb24gJHt0cmFuc2FjdGlvbi52ZXJzaW9ufSBpc24ndCBzdXBwb3J0ZWQgYnkgdGhpcyB3YWxsZXRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2FjdGlvbiBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIHNpZ25lZFRyYW5zYWN0aW9ucy5wdXNoKGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmFzZU1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyIGV4dGVuZHMgQmFzZVNpZ25lcldhbGxldEFkYXB0ZXIge1xufVxuZXhwb3J0IGNsYXNzIEJhc2VTaWduSW5NZXNzYWdlU2lnbmVyV2FsbGV0QWRhcHRlciBleHRlbmRzIEJhc2VNZXNzYWdlU2lnbmVyV2FsbGV0QWRhcHRlciB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduZXIuanMubWFwIl0sIm5hbWVzIjpbIkJhc2VXYWxsZXRBZGFwdGVyIiwiV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvciIsImlzVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJCYXNlU2lnbmVyV2FsbGV0QWRhcHRlciIsInNlbmRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwiY29ubmVjdGlvbiIsIm9wdGlvbnMiLCJlbWl0Iiwic3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucyIsImhhcyIsInZlcnNpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJyYXdUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZSIsInNlbmRSYXdUcmFuc2FjdGlvbiIsImVycm9yIiwibWVzc2FnZSIsInNpZ25lcnMiLCJzZW5kT3B0aW9ucyIsInByZXBhcmVUcmFuc2FjdGlvbiIsImxlbmd0aCIsInBhcnRpYWxTaWduIiwic2lnbkFsbFRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9ucyIsInNpZ25lZFRyYW5zYWN0aW9ucyIsInB1c2giLCJCYXNlTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIiLCJCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isWalletAdapterCompatibleStandardWallet: () => (/* binding */ isWalletAdapterCompatibleStandardWallet)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/./node_modules/@wallet-standard/features/lib/esm/connect.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/./node_modules/@wallet-standard/features/lib/esm/events.js\");\n\n\nfunction isWalletAdapterCompatibleStandardWallet(wallet) {\n    return _wallet_standard_features__WEBPACK_IMPORTED_MODULE_0__.StandardConnect in wallet.features && _wallet_standard_features__WEBPACK_IMPORTED_MODULE_1__.StandardEvents in wallet.features && (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_2__.SolanaSignAndSendTransaction in wallet.features || _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__.SolanaSignTransaction in wallet.features);\n} //# sourceMappingURL=standard.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vc3RhbmRhcmQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBd0c7QUFDM0I7QUFDdEUsU0FBU0ksd0NBQXdDQyxNQUFNO0lBQzFELE9BQVFILHNFQUFlQSxJQUFJRyxPQUFPQyxRQUFRLElBQ3RDSCxxRUFBY0EsSUFBSUUsT0FBT0MsUUFBUSxJQUNoQ04sQ0FBQUEsMEZBQTRCQSxJQUFJSyxPQUFPQyxRQUFRLElBQUlMLG1GQUFxQkEsSUFBSUksT0FBT0MsUUFBUTtBQUNwRyxFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL3N0YW5kYXJkLmpzPzdkNTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiwgU29sYW5hU2lnblRyYW5zYWN0aW9uLCB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWZlYXR1cmVzJztcbmltcG9ydCB7IFN0YW5kYXJkQ29ubmVjdCwgU3RhbmRhcmRFdmVudHMsIH0gZnJvbSAnQHdhbGxldC1zdGFuZGFyZC9mZWF0dXJlcyc7XG5leHBvcnQgZnVuY3Rpb24gaXNXYWxsZXRBZGFwdGVyQ29tcGF0aWJsZVN0YW5kYXJkV2FsbGV0KHdhbGxldCkge1xuICAgIHJldHVybiAoU3RhbmRhcmRDb25uZWN0IGluIHdhbGxldC5mZWF0dXJlcyAmJlxuICAgICAgICBTdGFuZGFyZEV2ZW50cyBpbiB3YWxsZXQuZmVhdHVyZXMgJiZcbiAgICAgICAgKFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gaW4gd2FsbGV0LmZlYXR1cmVzIHx8IFNvbGFuYVNpZ25UcmFuc2FjdGlvbiBpbiB3YWxsZXQuZmVhdHVyZXMpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YW5kYXJkLmpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uIiwiU29sYW5hU2lnblRyYW5zYWN0aW9uIiwiU3RhbmRhcmRDb25uZWN0IiwiU3RhbmRhcmRFdmVudHMiLCJpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlU3RhbmRhcmRXYWxsZXQiLCJ3YWxsZXQiLCJmZWF0dXJlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVersionedTransaction: () => (/* binding */ isVersionedTransaction)\n/* harmony export */ });\nfunction isVersionedTransaction(transaction) {\n    return \"version\" in transaction;\n} //# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLFNBQVNBLHVCQUF1QkMsV0FBVztJQUM5QyxPQUFPLGFBQWFBO0FBQ3hCLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vdHJhbnNhY3Rpb24uanM/MmRiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHJldHVybiAndmVyc2lvbicgaW4gdHJhbnNhY3Rpb247XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletAdapterNetwork: () => (/* binding */ WalletAdapterNetwork)\n/* harmony export */ });\nvar WalletAdapterNetwork;\n(function(WalletAdapterNetwork) {\n    WalletAdapterNetwork[\"Mainnet\"] = \"mainnet-beta\";\n    WalletAdapterNetwork[\"Testnet\"] = \"testnet\";\n    WalletAdapterNetwork[\"Devnet\"] = \"devnet\";\n})(WalletAdapterNetwork || (WalletAdapterNetwork = {})); //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLElBQUlBLHFCQUFxQjtBQUMvQixVQUFVQSxvQkFBb0I7SUFDM0JBLG9CQUFvQixDQUFDLFVBQVUsR0FBRztJQUNsQ0Esb0JBQW9CLENBQUMsVUFBVSxHQUFHO0lBQ2xDQSxvQkFBb0IsQ0FBQyxTQUFTLEdBQUc7QUFDckMsR0FBR0Esd0JBQXlCQSxDQUFBQSx1QkFBdUIsQ0FBQyxLQUNwRCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS90eXBlcy5qcz9jNmZjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgV2FsbGV0QWRhcHRlck5ldHdvcms7XG4oZnVuY3Rpb24gKFdhbGxldEFkYXB0ZXJOZXR3b3JrKSB7XG4gICAgV2FsbGV0QWRhcHRlck5ldHdvcmtbXCJNYWlubmV0XCJdID0gXCJtYWlubmV0LWJldGFcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIlRlc3RuZXRcIl0gPSBcInRlc3RuZXRcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIkRldm5ldFwiXSA9IFwiZGV2bmV0XCI7XG59KShXYWxsZXRBZGFwdGVyTmV0d29yayB8fCAoV2FsbGV0QWRhcHRlck5ldHdvcmsgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIldhbGxldEFkYXB0ZXJOZXR3b3JrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-phantom/lib/esm/adapter.js":
/*!************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-phantom/lib/esm/adapter.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhantomWalletAdapter: () => (/* binding */ PhantomWalletAdapter),\n/* harmony export */   PhantomWalletName: () => (/* binding */ PhantomWalletName)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n\n\nconst PhantomWalletName = \"Phantom\";\nclass PhantomWalletAdapter extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.BaseMessageSignerWalletAdapter {\n    constructor(config = {}){\n        super();\n        this.name = PhantomWalletName;\n        this.url = \"https://phantom.app\";\n        this.icon = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg==\";\n        this.supportedTransactionVersions = new Set([\n            \"legacy\",\n            0\n        ]);\n        this._readyState =  true ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported : 0;\n        this._disconnected = ()=>{\n            const wallet = this._wallet;\n            if (wallet) {\n                wallet.off(\"disconnect\", this._disconnected);\n                wallet.off(\"accountChanged\", this._accountChanged);\n                this._wallet = null;\n                this._publicKey = null;\n                this.emit(\"error\", new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletDisconnectedError());\n                this.emit(\"disconnect\");\n            }\n        };\n        this._accountChanged = (newPublicKey)=>{\n            const publicKey = this._publicKey;\n            if (!publicKey) return;\n            try {\n                newPublicKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(newPublicKey.toBytes());\n            } catch (error) {\n                this.emit(\"error\", new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletPublicKeyError(error?.message, error));\n                return;\n            }\n            if (publicKey.equals(newPublicKey)) return;\n            this._publicKey = newPublicKey;\n            this.emit(\"connect\", newPublicKey);\n        };\n        this._connecting = false;\n        this._wallet = null;\n        this._publicKey = null;\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported) {\n            if ((0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.isIosAndRedirectable)()) {\n                // when in iOS (not webview), set Phantom as loadable instead of checking for install\n                this._readyState = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Loadable;\n                this.emit(\"readyStateChange\", this._readyState);\n            } else {\n                (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.scopePollingDetectionStrategy)(()=>{\n                    if (window.phantom?.solana?.isPhantom || window.solana?.isPhantom) {\n                        this._readyState = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed;\n                        this.emit(\"readyStateChange\", this._readyState);\n                        return true;\n                    }\n                    return false;\n                });\n            }\n        }\n    }\n    get publicKey() {\n        return this._publicKey;\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    async autoConnect() {\n        // Skip autoconnect in the Loadable state\n        // We can't redirect to a universal link without user input\n        if (this.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed) {\n            await this.connect();\n        }\n    }\n    async connect() {\n        try {\n            if (this.connected || this.connecting) return;\n            if (this.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Loadable) {\n                // redirect to the Phantom /browse universal link\n                // this will open the current URL in the Phantom in-wallet browser\n                const url = encodeURIComponent(window.location.href);\n                const ref = encodeURIComponent(window.location.origin);\n                window.location.href = `https://phantom.app/ul/browse/${url}?ref=${ref}`;\n                return;\n            }\n            if (this.readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotReadyError();\n            this._connecting = true;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const wallet = window.phantom?.solana || window.solana;\n            if (!wallet.isConnected) {\n                try {\n                    await wallet.connect();\n                } catch (error) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConnectionError(error?.message, error);\n                }\n            }\n            if (!wallet.publicKey) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n            let publicKey;\n            try {\n                publicKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(wallet.publicKey.toBytes());\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletPublicKeyError(error?.message, error);\n            }\n            wallet.on(\"disconnect\", this._disconnected);\n            wallet.on(\"accountChanged\", this._accountChanged);\n            this._wallet = wallet;\n            this._publicKey = publicKey;\n            this.emit(\"connect\", publicKey);\n        } catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        } finally{\n            this._connecting = false;\n        }\n    }\n    async disconnect() {\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.off(\"disconnect\", this._disconnected);\n            wallet.off(\"accountChanged\", this._accountChanged);\n            this._wallet = null;\n            this._publicKey = null;\n            try {\n                await wallet.disconnect();\n            } catch (error) {\n                this.emit(\"error\", new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletDisconnectionError(error?.message, error));\n            }\n        }\n        this.emit(\"disconnect\");\n    }\n    async sendTransaction(transaction, connection, options = {}) {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n            try {\n                const { signers, ...sendOptions } = options;\n                if ((0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.isVersionedTransaction)(transaction)) {\n                    signers?.length && transaction.sign(signers);\n                } else {\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n                    signers?.length && transaction.partialSign(...signers);\n                }\n                sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;\n                const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);\n                return signature;\n            } catch (error) {\n                if (error instanceof _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletError) throw error;\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSendTransactionError(error?.message, error);\n            }\n        } catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n    async signTransaction(transaction) {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n            try {\n                return await wallet.signTransaction(transaction) || transaction;\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n    async signAllTransactions(transactions) {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n            try {\n                return await wallet.signAllTransactions(transactions) || transactions;\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n    async signMessage(message) {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n            try {\n                const { signature } = await wallet.signMessage(message);\n                return signature;\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignMessageError(error?.message, error);\n            }\n        } catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n} //# sourceMappingURL=adapter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1waGFudG9tL2xpYi9lc20vYWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTRhO0FBQ2hZO0FBQ3JDLE1BQU1pQixvQkFBb0IsVUFBVTtBQUNwQyxNQUFNQyw2QkFBNkJsQix1RkFBOEJBO0lBQ3BFbUIsWUFBWUMsU0FBUyxDQUFDLENBQUMsQ0FBRTtRQUNyQixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxJQUFJLEdBQUdKO1FBQ1osSUFBSSxDQUFDSyxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsNEJBQTRCLEdBQUcsSUFBSUMsSUFBSTtZQUFDO1lBQVU7U0FBRTtRQUN6RCxJQUFJLENBQUNDLFdBQVcsR0FBRyxLQUFxRCxHQUNsRWQseUVBQWdCQSxDQUFDZ0IsV0FBVyxHQUM1QmhCLENBQTRCO1FBQ2xDLElBQUksQ0FBQ2tCLGFBQWEsR0FBRztZQUNqQixNQUFNQyxTQUFTLElBQUksQ0FBQ0MsT0FBTztZQUMzQixJQUFJRCxRQUFRO2dCQUNSQSxPQUFPRSxHQUFHLENBQUMsY0FBYyxJQUFJLENBQUNILGFBQWE7Z0JBQzNDQyxPQUFPRSxHQUFHLENBQUMsa0JBQWtCLElBQUksQ0FBQ0MsZUFBZTtnQkFDakQsSUFBSSxDQUFDRixPQUFPLEdBQUc7Z0JBQ2YsSUFBSSxDQUFDRyxVQUFVLEdBQUc7Z0JBQ2xCLElBQUksQ0FBQ0MsSUFBSSxDQUFDLFNBQVMsSUFBSTlCLGdGQUF1QkE7Z0JBQzlDLElBQUksQ0FBQzhCLElBQUksQ0FBQztZQUNkO1FBQ0o7UUFDQSxJQUFJLENBQUNGLGVBQWUsR0FBRyxDQUFDRztZQUNwQixNQUFNQyxZQUFZLElBQUksQ0FBQ0gsVUFBVTtZQUNqQyxJQUFJLENBQUNHLFdBQ0Q7WUFDSixJQUFJO2dCQUNBRCxlQUFlLElBQUlyQixzREFBU0EsQ0FBQ3FCLGFBQWFFLE9BQU87WUFDckQsRUFDQSxPQUFP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QVksRUFBRTtRQUNwQyxJQUFJO1lBQ0EsTUFBTWhELFNBQVMsSUFBSSxDQUFDQyxPQUFPO1lBQzNCLElBQUksQ0FBQ0QsUUFDRCxNQUFNLElBQUl0QixnRkFBdUJBO1lBQ3JDLElBQUk7Z0JBQ0EsT0FBTyxNQUFPc0IsT0FBTytDLG1CQUFtQixDQUFDQyxpQkFBa0JBO1lBQy9ELEVBQ0EsT0FBT3ZDLE9BQU87Z0JBQ1YsTUFBTSxJQUFJekIsbUZBQTBCQSxDQUFDeUIsT0FBT0MsU0FBU0Q7WUFDekQ7UUFDSixFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJLENBQUNKLElBQUksQ0FBQyxTQUFTSTtZQUNuQixNQUFNQTtRQUNWO0lBQ0o7SUFDQSxNQUFNd0MsWUFBWXZDLE9BQU8sRUFBRTtRQUN2QixJQUFJO1lBQ0EsTUFBTVYsU0FBUyxJQUFJLENBQUNDLE9BQU87WUFDM0IsSUFBSSxDQUFDRCxRQUNELE1BQU0sSUFBSXRCLGdGQUF1QkE7WUFDckMsSUFBSTtnQkFDQSxNQUFNLEVBQUVrRSxTQUFTLEVBQUUsR0FBRyxNQUFNNUMsT0FBT2lELFdBQVcsQ0FBQ3ZDO2dCQUMvQyxPQUFPa0M7WUFDWCxFQUNBLE9BQU9uQyxPQUFPO2dCQUNWLE1BQU0sSUFBSTFCLCtFQUFzQkEsQ0FBQzBCLE9BQU9DLFNBQVNEO1lBQ3JEO1FBQ0osRUFDQSxPQUFPQSxPQUFPO1lBQ1YsSUFBSSxDQUFDSixJQUFJLENBQUMsU0FBU0k7WUFDbkIsTUFBTUE7UUFDVjtJQUNKO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXBoYW50b20vbGliL2VzbS9hZGFwdGVyLmpzPzNhODEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZU1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyLCBpc0lvc0FuZFJlZGlyZWN0YWJsZSwgaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiwgc2NvcGVQb2xsaW5nRGV0ZWN0aW9uU3RyYXRlZ3ksIFdhbGxldEFjY291bnRFcnJvciwgV2FsbGV0Q29ubmVjdGlvbkVycm9yLCBXYWxsZXREaXNjb25uZWN0ZWRFcnJvciwgV2FsbGV0RGlzY29ubmVjdGlvbkVycm9yLCBXYWxsZXRFcnJvciwgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IsIFdhbGxldE5vdFJlYWR5RXJyb3IsIFdhbGxldFB1YmxpY0tleUVycm9yLCBXYWxsZXRSZWFkeVN0YXRlLCBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvciwgV2FsbGV0U2lnbk1lc3NhZ2VFcnJvciwgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IsIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlJztcbmltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5leHBvcnQgY29uc3QgUGhhbnRvbVdhbGxldE5hbWUgPSAnUGhhbnRvbSc7XG5leHBvcnQgY2xhc3MgUGhhbnRvbVdhbGxldEFkYXB0ZXIgZXh0ZW5kcyBCYXNlTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IFBoYW50b21XYWxsZXROYW1lO1xuICAgICAgICB0aGlzLnVybCA9ICdodHRwczovL3BoYW50b20uYXBwJztcbiAgICAgICAgdGhpcy5pY29uID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeE1EZ2lJR2hsYVdkb2REMGlNVEE0SWlCMmFXVjNRbTk0UFNJd0lEQWdNVEE0SURFd09DSWdabWxzYkQwaWJtOXVaU0krQ2p4eVpXTjBJSGRwWkhSb1BTSXhNRGdpSUdobGFXZG9kRDBpTVRBNElpQnllRDBpTWpZaUlHWnBiR3c5SWlOQlFqbEdSaklpTHo0S1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAwTmk0MU1qWTNJRFk1TGpreU1qbEROREl1TURBMU5DQTNOaTQ0TlRBNUlETTBMalF5T1RJZ09EVXVOakU0TWlBeU5DNHpORGdnT0RVdU5qRTRNa014T1M0MU9ESTBJRGcxTGpZeE9ESWdNVFVnT0RNdU5qVTJNeUF4TlNBM05TNHhNelF5UXpFMUlEVXpMalF6TURVZ05EUXVOak15TmlBeE9TNDRNekkzSURjeUxqRXlOamdnTVRrdU9ETXlOME00Tnk0M05qZ2dNVGt1T0RNeU55QTVOQ0F6TUM0Mk9EUTJJRGswSURRekxqQXdOemxET1RRZ05UZ3VPREkxT0NBNE15NDNNelUxSURjMkxqa3hNaklnTnpNdU5UTXlNU0EzTmk0NU1USXlRemN3TGpJNU16a2dOell1T1RFeU1pQTJPQzQzTURVeklEYzFMakV6TkRJZ05qZ3VOekExTXlBM01pNHpNVFJETmpndU56QTFNeUEzTVM0MU56Z3pJRFk0TGpneU56VWdOekF1TnpneE1pQTJPUzR3TnpFNUlEWTVMamt5TWpsRE5qVXVOVGc1TXlBM05TNDROams1SURVNExqZzJPRFVnT0RFdU16ZzNPQ0ExTWk0MU56VTBJRGd4TGpNNE56aERORGN1T1RreklEZ3hMak00TnpnZ05EVXVOamN4TXlBM09DNDFNRFl6SURRMUxqWTNNVE1nTnpRdU5EVTVPRU0wTlM0Mk56RXpJRGN5TGprNE9EUWdORFV1T1RjMk9DQTNNUzQwTlRVMklEUTJMalV5TmpjZ05qa3VPVEl5T1ZwTk9ETXVOamMyTVNBME1pNDFOemswUXpnekxqWTNOakVnTkRZdU1UY3dOQ0E0TVM0MU5UYzFJRFEzTGprMk5UZ2dOemt1TVRnM05TQTBOeTQ1TmpVNFF6YzJMamM0TVRZZ05EY3VPVFkxT0NBM05DNDJPVGc1SURRMkxqRTNNRFFnTnpRdU5qazRPU0EwTWk0MU56azBRemMwTGpZNU9Ea2dNemd1T1RnNE5TQTNOaTQzT0RFMklETTNMakU1TXpFZ056a3VNVGczTlNBek55NHhPVE14UXpneExqVTFOelVnTXpjdU1Ua3pNU0E0TXk0Mk56WXhJRE00TGprNE9EVWdPRE11TmpjMk1TQTBNaTQxTnprMFdrMDNNQzR5TVRBeklEUXlMalUzT1RWRE56QXVNakV3TXlBME5pNHhOekEwSURZNExqQTVNVFlnTkRjdU9UWTFPQ0EyTlM0M01qRTJJRFEzTGprMk5UaEROak11TXpFMU55QTBOeTQ1TmpVNElEWXhMakl6TXlBME5pNHhOekEwSURZeExqSXpNeUEwTWk0MU56azFRell4TGpJek15QXpPQzQ1T0RnMUlEWXpMak14TlRjZ016Y3VNVGt6TVNBMk5TNDNNakUySURNM0xqRTVNekZETmpndU1Ea3hOaUF6Tnk0eE9UTXhJRGN3TGpJeE1ETWdNemd1T1RnNE5TQTNNQzR5TVRBeklEUXlMalUzT1RWYUlpQm1hV3hzUFNJalJrWkdSRVk0SWk4K0Nqd3ZjM1puUGc9PSc7XG4gICAgICAgIHRoaXMuc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucyA9IG5ldyBTZXQoWydsZWdhY3knLCAwXSk7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IFdhbGxldFJlYWR5U3RhdGUuVW5zdXBwb3J0ZWRcbiAgICAgICAgICAgIDogV2FsbGV0UmVhZHlTdGF0ZS5Ob3REZXRlY3RlZDtcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fd2FsbGV0O1xuICAgICAgICAgICAgaWYgKHdhbGxldCkge1xuICAgICAgICAgICAgICAgIHdhbGxldC5vZmYoJ2Rpc2Nvbm5lY3QnLCB0aGlzLl9kaXNjb25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHdhbGxldC5vZmYoJ2FjY291bnRDaGFuZ2VkJywgdGhpcy5fYWNjb3VudENoYW5nZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dhbGxldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHVibGljS2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IFdhbGxldERpc2Nvbm5lY3RlZEVycm9yKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9hY2NvdW50Q2hhbmdlZCA9IChuZXdQdWJsaWNLZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHRoaXMuX3B1YmxpY0tleTtcbiAgICAgICAgICAgIGlmICghcHVibGljS2V5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV3UHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShuZXdQdWJsaWNLZXkudG9CeXRlcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgV2FsbGV0UHVibGljS2V5RXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHB1YmxpY0tleS5lcXVhbHMobmV3UHVibGljS2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSBuZXdQdWJsaWNLZXk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBuZXdQdWJsaWNLZXkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3dhbGxldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBpZiAoaXNJb3NBbmRSZWRpcmVjdGFibGUoKSkge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gaW4gaU9TIChub3Qgd2VidmlldyksIHNldCBQaGFudG9tIGFzIGxvYWRhYmxlIGluc3RlYWQgb2YgY2hlY2tpbmcgZm9yIGluc3RhbGxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5U3RhdGVDaGFuZ2UnLCB0aGlzLl9yZWFkeVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjb3BlUG9sbGluZ0RldGVjdGlvblN0cmF0ZWd5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5waGFudG9tPy5zb2xhbmE/LmlzUGhhbnRvbSB8fCB3aW5kb3cuc29sYW5hPy5pc1BoYW50b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHlTdGF0ZUNoYW5nZScsIHRoaXMuX3JlYWR5U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXk7XG4gICAgfVxuICAgIGdldCBjb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGluZztcbiAgICB9XG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICAgIH1cbiAgICBhc3luYyBhdXRvQ29ubmVjdCgpIHtcbiAgICAgICAgLy8gU2tpcCBhdXRvY29ubmVjdCBpbiB0aGUgTG9hZGFibGUgc3RhdGVcbiAgICAgICAgLy8gV2UgY2FuJ3QgcmVkaXJlY3QgdG8gYSB1bml2ZXJzYWwgbGluayB3aXRob3V0IHVzZXIgaW5wdXRcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQgfHwgdGhpcy5jb25uZWN0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyByZWRpcmVjdCB0byB0aGUgUGhhbnRvbSAvYnJvd3NlIHVuaXZlcnNhbCBsaW5rXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG9wZW4gdGhlIGN1cnJlbnQgVVJMIGluIHRoZSBQaGFudG9tIGluLXdhbGxldCBicm93c2VyXG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBlbmNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBgaHR0cHM6Ly9waGFudG9tLmFwcC91bC9icm93c2UvJHt1cmx9P3JlZj0ke3JlZn1gO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RSZWFkeUVycm9yKCk7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBjb25zdCB3YWxsZXQgPSB3aW5kb3cucGhhbnRvbT8uc29sYW5hIHx8IHdpbmRvdy5zb2xhbmE7XG4gICAgICAgICAgICBpZiAoIXdhbGxldC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdhbGxldC5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29ubmVjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF3YWxsZXQucHVibGljS2V5KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRBY2NvdW50RXJyb3IoKTtcbiAgICAgICAgICAgIGxldCBwdWJsaWNLZXk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkod2FsbGV0LnB1YmxpY0tleS50b0J5dGVzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFB1YmxpY0tleUVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YWxsZXQub24oJ2Rpc2Nvbm5lY3QnLCB0aGlzLl9kaXNjb25uZWN0ZWQpO1xuICAgICAgICAgICAgd2FsbGV0Lm9uKCdhY2NvdW50Q2hhbmdlZCcsIHRoaXMuX2FjY291bnRDaGFuZ2VkKTtcbiAgICAgICAgICAgIHRoaXMuX3dhbGxldCA9IHdhbGxldDtcbiAgICAgICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IHB1YmxpY0tleTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fd2FsbGV0O1xuICAgICAgICBpZiAod2FsbGV0KSB7XG4gICAgICAgICAgICB3YWxsZXQub2ZmKCdkaXNjb25uZWN0JywgdGhpcy5fZGlzY29ubmVjdGVkKTtcbiAgICAgICAgICAgIHdhbGxldC5vZmYoJ2FjY291bnRDaGFuZ2VkJywgdGhpcy5fYWNjb3VudENoYW5nZWQpO1xuICAgICAgICAgICAgdGhpcy5fd2FsbGV0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHdhbGxldC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IFdhbGxldERpc2Nvbm5lY3Rpb25FcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX3dhbGxldDtcbiAgICAgICAgICAgIGlmICghd2FsbGV0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNpZ25lcnMsIC4uLnNlbmRPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBzaWduZXJzPy5sZW5ndGggJiYgdHJhbnNhY3Rpb24uc2lnbihzaWduZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gKGF3YWl0IHRoaXMucHJlcGFyZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCBzZW5kT3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBzaWduZXJzPy5sZW5ndGggJiYgdHJhbnNhY3Rpb24ucGFydGlhbFNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbmRPcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgPSBzZW5kT3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IGNvbm5lY3Rpb24uY29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNpZ25hdHVyZSB9ID0gYXdhaXQgd2FsbGV0LnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHNlbmRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgV2FsbGV0RXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fd2FsbGV0O1xuICAgICAgICAgICAgaWYgKCF3YWxsZXQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYXdhaXQgd2FsbGV0LnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpIHx8IHRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX3dhbGxldDtcbiAgICAgICAgICAgIGlmICghd2FsbGV0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGF3YWl0IHdhbGxldC5zaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykpIHx8IHRyYW5zYWN0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX3dhbGxldDtcbiAgICAgICAgICAgIGlmICghd2FsbGV0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNpZ25hdHVyZSB9ID0gYXdhaXQgd2FsbGV0LnNpZ25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2lnbk1lc3NhZ2VFcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRlci5qcy5tYXAiXSwibmFtZXMiOlsiQmFzZU1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyIiwiaXNJb3NBbmRSZWRpcmVjdGFibGUiLCJpc1ZlcnNpb25lZFRyYW5zYWN0aW9uIiwic2NvcGVQb2xsaW5nRGV0ZWN0aW9uU3RyYXRlZ3kiLCJXYWxsZXRBY2NvdW50RXJyb3IiLCJXYWxsZXRDb25uZWN0aW9uRXJyb3IiLCJXYWxsZXREaXNjb25uZWN0ZWRFcnJvciIsIldhbGxldERpc2Nvbm5lY3Rpb25FcnJvciIsIldhbGxldEVycm9yIiwiV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IiLCJXYWxsZXROb3RSZWFkeUVycm9yIiwiV2FsbGV0UHVibGljS2V5RXJyb3IiLCJXYWxsZXRSZWFkeVN0YXRlIiwiV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJXYWxsZXRTaWduTWVzc2FnZUVycm9yIiwiV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IiLCJQdWJsaWNLZXkiLCJQaGFudG9tV2FsbGV0TmFtZSIsIlBoYW50b21XYWxsZXRBZGFwdGVyIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJuYW1lIiwidXJsIiwiaWNvbiIsInN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMiLCJTZXQiLCJfcmVhZHlTdGF0ZSIsImRvY3VtZW50IiwiVW5zdXBwb3J0ZWQiLCJOb3REZXRlY3RlZCIsIl9kaXNjb25uZWN0ZWQiLCJ3YWxsZXQiLCJfd2FsbGV0Iiwib2ZmIiwiX2FjY291bnRDaGFuZ2VkIiwiX3B1YmxpY0tleSIsImVtaXQiLCJuZXdQdWJsaWNLZXkiLCJwdWJsaWNLZXkiLCJ0b0J5dGVzIiwiZXJyb3IiLCJtZXNzYWdlIiwiZXF1YWxzIiwiX2Nvbm5lY3RpbmciLCJMb2FkYWJsZSIsIndpbmRvdyIsInBoYW50b20iLCJzb2xhbmEiLCJpc1BoYW50b20iLCJJbnN0YWxsZWQiLCJjb25uZWN0aW5nIiwicmVhZHlTdGF0ZSIsImF1dG9Db25uZWN0IiwiY29ubmVjdCIsImNvbm5lY3RlZCIsImVuY29kZVVSSUNvbXBvbmVudCIsImxvY2F0aW9uIiwiaHJlZiIsInJlZiIsIm9yaWdpbiIsImlzQ29ubmVjdGVkIiwib24iLCJkaXNjb25uZWN0Iiwic2VuZFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb24iLCJjb25uZWN0aW9uIiwib3B0aW9ucyIsInNpZ25lcnMiLCJzZW5kT3B0aW9ucyIsImxlbmd0aCIsInNpZ24iLCJwcmVwYXJlVHJhbnNhY3Rpb24iLCJwYXJ0aWFsU2lnbiIsInByZWZsaWdodENvbW1pdG1lbnQiLCJjb21taXRtZW50Iiwic2lnbmF0dXJlIiwic2lnbkFuZFNlbmRUcmFuc2FjdGlvbiIsInNpZ25UcmFuc2FjdGlvbiIsInNpZ25BbGxUcmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbnMiLCJzaWduTWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-phantom/lib/esm/adapter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Button.js":
/*!************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Button.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ Button)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst Button = (props)=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n        className: `wallet-adapter-button ${props.className || \"\"}`,\n        disabled: props.disabled,\n        style: props.style,\n        onClick: props.onClick,\n        tabIndex: props.tabIndex || 0,\n        type: \"button\"\n    }, props.startIcon && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"i\", {\n        className: \"wallet-adapter-button-start-icon\"\n    }, props.startIcon), props.children, props.endIcon && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"i\", {\n        className: \"wallet-adapter-button-end-icon\"\n    }, props.endIcon));\n}; //# sourceMappingURL=Button.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL0J1dHRvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQjtBQUNuQixNQUFNQyxTQUFTLENBQUNDO0lBQ25CLHFCQUFRRixnREFBbUIsQ0FBQyxVQUFVO1FBQUVJLFdBQVcsQ0FBQyxzQkFBc0IsRUFBRUYsTUFBTUUsU0FBUyxJQUFJLEdBQUcsQ0FBQztRQUFFQyxVQUFVSCxNQUFNRyxRQUFRO1FBQUVDLE9BQU9KLE1BQU1JLEtBQUs7UUFBRUMsU0FBU0wsTUFBTUssT0FBTztRQUFFQyxVQUFVTixNQUFNTSxRQUFRLElBQUk7UUFBR0MsTUFBTTtJQUFTLEdBQ3JOUCxNQUFNUSxTQUFTLGtCQUFJVixnREFBbUIsQ0FBQyxLQUFLO1FBQUVJLFdBQVc7SUFBbUMsR0FBR0YsTUFBTVEsU0FBUyxHQUM5R1IsTUFBTVMsUUFBUSxFQUNkVCxNQUFNVSxPQUFPLGtCQUFJWixnREFBbUIsQ0FBQyxLQUFLO1FBQUVJLFdBQVc7SUFBaUMsR0FBR0YsTUFBTVUsT0FBTztBQUNoSCxFQUFFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL0J1dHRvbi5qcz82MDVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgY29uc3QgQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBgd2FsbGV0LWFkYXB0ZXItYnV0dG9uICR7cHJvcHMuY2xhc3NOYW1lIHx8ICcnfWAsIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCwgc3R5bGU6IHByb3BzLnN0eWxlLCBvbkNsaWNrOiBwcm9wcy5vbkNsaWNrLCB0YWJJbmRleDogcHJvcHMudGFiSW5kZXggfHwgMCwgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICBwcm9wcy5zdGFydEljb24gJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImlcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItYnV0dG9uLXN0YXJ0LWljb25cIiB9LCBwcm9wcy5zdGFydEljb24pLFxuICAgICAgICBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgcHJvcHMuZW5kSWNvbiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaVwiLCB7IGNsYXNzTmFtZTogXCJ3YWxsZXQtYWRhcHRlci1idXR0b24tZW5kLWljb25cIiB9LCBwcm9wcy5lbmRJY29uKSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1dHRvbi5qcy5tYXAiXSwibmFtZXMiOlsiUmVhY3QiLCJCdXR0b24iLCJwcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJkaXNhYmxlZCIsInN0eWxlIiwib25DbGljayIsInRhYkluZGV4IiwidHlwZSIsInN0YXJ0SWNvbiIsImNoaWxkcmVuIiwiZW5kSWNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Button.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Collapse.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Collapse.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collapse: () => (/* binding */ Collapse)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst Collapse = ({ id, children, expanded = false })=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const instant = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const transition = \"height 250ms ease-out\";\n    const openCollapse = ()=>{\n        const node = ref.current;\n        if (!node) return;\n        requestAnimationFrame(()=>{\n            node.style.height = node.scrollHeight + \"px\";\n        });\n    };\n    const closeCollapse = ()=>{\n        const node = ref.current;\n        if (!node) return;\n        requestAnimationFrame(()=>{\n            node.style.height = node.offsetHeight + \"px\";\n            node.style.overflow = \"hidden\";\n            requestAnimationFrame(()=>{\n                node.style.height = \"0\";\n            });\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (expanded) {\n            openCollapse();\n        } else {\n            closeCollapse();\n        }\n    }, [\n        expanded\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        const node = ref.current;\n        if (!node) return;\n        function handleComplete() {\n            if (!node) return;\n            node.style.overflow = expanded ? \"initial\" : \"hidden\";\n            if (expanded) {\n                node.style.height = \"auto\";\n            }\n        }\n        function handleTransitionEnd(event) {\n            if (node && event.target === node && event.propertyName === \"height\") {\n                handleComplete();\n            }\n        }\n        if (instant.current) {\n            handleComplete();\n            instant.current = false;\n        }\n        node.addEventListener(\"transitionend\", handleTransitionEnd);\n        return ()=>node.removeEventListener(\"transitionend\", handleTransitionEnd);\n    }, [\n        expanded\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"wallet-adapter-collapse\",\n        id: id,\n        ref: ref,\n        role: \"region\",\n        style: {\n            height: 0,\n            transition: instant.current ? undefined : transition\n        }\n    }, children);\n}; //# sourceMappingURL=Collapse.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL0NvbGxhcHNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVEO0FBQ2hELE1BQU1HLFdBQVcsQ0FBQyxFQUFFQyxFQUFFLEVBQUVDLFFBQVEsRUFBRUMsV0FBVyxLQUFLLEVBQUU7SUFDdkQsTUFBTUMsTUFBTUwsNkNBQU1BLENBQUM7SUFDbkIsTUFBTU0sVUFBVU4sNkNBQU1BLENBQUM7SUFDdkIsTUFBTU8sYUFBYTtJQUNuQixNQUFNQyxlQUFlO1FBQ2pCLE1BQU1DLE9BQU9KLElBQUlLLE9BQU87UUFDeEIsSUFBSSxDQUFDRCxNQUNEO1FBQ0pFLHNCQUFzQjtZQUNsQkYsS0FBS0csS0FBSyxDQUFDQyxNQUFNLEdBQUdKLEtBQUtLLFlBQVksR0FBRztRQUM1QztJQUNKO0lBQ0EsTUFBTUMsZ0JBQWdCO1FBQ2xCLE1BQU1OLE9BQU9KLElBQUlLLE9BQU87UUFDeEIsSUFBSSxDQUFDRCxNQUNEO1FBQ0pFLHNCQUFzQjtZQUNsQkYsS0FBS0csS0FBSyxDQUFDQyxNQUFNLEdBQUdKLEtBQUtPLFlBQVksR0FBRztZQUN4Q1AsS0FBS0csS0FBSyxDQUFDSyxRQUFRLEdBQUc7WUFDdEJOLHNCQUFzQjtnQkFDbEJGLEtBQUtHLEtBQUssQ0FBQ0MsTUFBTSxHQUFHO1lBQ3hCO1FBQ0o7SUFDSjtJQUNBZCxzREFBZUEsQ0FBQztRQUNaLElBQUlLLFVBQVU7WUFDVkk7UUFDSixPQUNLO1lBQ0RPO1FBQ0o7SUFDSixHQUFHO1FBQUNYO0tBQVM7SUFDYkwsc0RBQWVBLENBQUM7UUFDWixNQUFNVSxPQUFPSixJQUFJSyxPQUFPO1FBQ3hCLElBQUksQ0FBQ0QsTUFDRDtRQUNKLFNBQVNTO1lBQ0wsSUFBSSxDQUFDVCxNQUNEO1lBQ0pBLEtBQUtHLEtBQUssQ0FBQ0ssUUFBUSxHQUFHYixXQUFXLFlBQVk7WUFDN0MsSUFBSUEsVUFBVTtnQkFDVkssS0FBS0csS0FBSyxDQUFDQyxNQUFNLEdBQUc7WUFDeEI7UUFDSjtRQUNBLFNBQVNNLG9CQUFvQkMsS0FBSztZQUM5QixJQUFJWCxRQUFRVyxNQUFNQyxNQUFNLEtBQUtaLFFBQVFXLE1BQU1FLFlBQVksS0FBSyxVQUFVO2dCQUNsRUo7WUFDSjtRQUNKO1FBQ0EsSUFBSVosUUFBUUksT0FBTyxFQUFFO1lBQ2pCUTtZQUNBWixRQUFRSSxPQUFPLEdBQUc7UUFDdEI7UUFDQUQsS0FBS2MsZ0JBQWdCLENBQUMsaUJBQWlCSjtRQUN2QyxPQUFPLElBQU1WLEtBQUtlLG1CQUFtQixDQUFDLGlCQUFpQkw7SUFDM0QsR0FBRztRQUFDZjtLQUFTO0lBQ2IscUJBQVFOLGdEQUFtQixDQUFDLE9BQU87UUFBRTRCLFdBQVc7UUFBMkJ4QixJQUFJQTtRQUFJRyxLQUFLQTtRQUFLc0IsTUFBTTtRQUFVZixPQUFPO1lBQUVDLFFBQVE7WUFBR04sWUFBWUQsUUFBUUksT0FBTyxHQUFHa0IsWUFBWXJCO1FBQVc7SUFBRSxHQUFHSjtBQUMvTCxFQUFFLENBQ0Ysb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL0NvbGxhcHNlLmpzPzE2YjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IENvbGxhcHNlID0gKHsgaWQsIGNoaWxkcmVuLCBleHBhbmRlZCA9IGZhbHNlIH0pID0+IHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaW5zdGFudCA9IHVzZVJlZih0cnVlKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gJ2hlaWdodCAyNTBtcyBlYXNlLW91dCc7XG4gICAgY29uc3Qgb3BlbkNvbGxhcHNlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gbm9kZS5zY3JvbGxIZWlnaHQgKyAncHgnO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNsb3NlQ29sbGFwc2UgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBub2RlLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICAgICAgICBub2RlLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gJzAnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICAgICAgICBvcGVuQ29sbGFwc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NlQ29sbGFwc2UoKTtcbiAgICAgICAgfVxuICAgIH0sIFtleHBhbmRlZF0pO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVDb21wbGV0ZSgpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBub2RlLnN0eWxlLm92ZXJmbG93ID0gZXhwYW5kZWQgPyAnaW5pdGlhbCcgOiAnaGlkZGVuJztcbiAgICAgICAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVRyYW5zaXRpb25FbmQoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2RlICYmIGV2ZW50LnRhcmdldCA9PT0gbm9kZSAmJiBldmVudC5wcm9wZXJ0eU5hbWUgPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdGFudC5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVDb21wbGV0ZSgpO1xuICAgICAgICAgICAgaW5zdGFudC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVUcmFuc2l0aW9uRW5kKTtcbiAgICB9LCBbZXhwYW5kZWRdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItY29sbGFwc2VcIiwgaWQ6IGlkLCByZWY6IHJlZiwgcm9sZTogXCJyZWdpb25cIiwgc3R5bGU6IHsgaGVpZ2h0OiAwLCB0cmFuc2l0aW9uOiBpbnN0YW50LmN1cnJlbnQgPyB1bmRlZmluZWQgOiB0cmFuc2l0aW9uIH0gfSwgY2hpbGRyZW4pKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xsYXBzZS5qcy5tYXAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCJDb2xsYXBzZSIsImlkIiwiY2hpbGRyZW4iLCJleHBhbmRlZCIsInJlZiIsImluc3RhbnQiLCJ0cmFuc2l0aW9uIiwib3BlbkNvbGxhcHNlIiwibm9kZSIsImN1cnJlbnQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzdHlsZSIsImhlaWdodCIsInNjcm9sbEhlaWdodCIsImNsb3NlQ29sbGFwc2UiLCJvZmZzZXRIZWlnaHQiLCJvdmVyZmxvdyIsImhhbmRsZUNvbXBsZXRlIiwiaGFuZGxlVHJhbnNpdGlvbkVuZCIsImV2ZW50IiwidGFyZ2V0IiwicHJvcGVydHlOYW1lIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwicm9sZSIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Collapse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletIcon.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletIcon.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletIcon: () => (/* binding */ WalletIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst WalletIcon = ({ wallet, ...props })=>{\n    return wallet && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n        src: wallet.adapter.icon,\n        alt: `${wallet.adapter.name} icon`,\n        ...props\n    });\n}; //# sourceMappingURL=WalletIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL1dhbGxldEljb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEI7QUFDbkIsTUFBTUMsYUFBYSxDQUFDLEVBQUVDLE1BQU0sRUFBRSxHQUFHQyxPQUFPO0lBQzNDLE9BQU9ELHdCQUFVRixnREFBbUIsQ0FBQyxPQUFPO1FBQUVLLEtBQUtILE9BQU9JLE9BQU8sQ0FBQ0MsSUFBSTtRQUFFQyxLQUFLLENBQUMsRUFBRU4sT0FBT0ksT0FBTyxDQUFDRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQUUsR0FBR04sS0FBSztJQUFDO0FBQ3pILEVBQUUsQ0FDRixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vV2FsbGV0SWNvbi5qcz9jN2JkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgY29uc3QgV2FsbGV0SWNvbiA9ICh7IHdhbGxldCwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIHJldHVybiB3YWxsZXQgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7IHNyYzogd2FsbGV0LmFkYXB0ZXIuaWNvbiwgYWx0OiBgJHt3YWxsZXQuYWRhcHRlci5uYW1lfSBpY29uYCwgLi4ucHJvcHMgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2FsbGV0SWNvbi5qcy5tYXAiXSwibmFtZXMiOlsiUmVhY3QiLCJXYWxsZXRJY29uIiwid2FsbGV0IiwicHJvcHMiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwiYWRhcHRlciIsImljb24iLCJhbHQiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletIcon.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletListItem.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletListItem.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletListItem: () => (/* binding */ WalletListItem)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Button.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Button.js\");\n/* harmony import */ var _WalletIcon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WalletIcon.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletIcon.js\");\n\n\n\n\nconst WalletListItem = ({ handleClick, tabIndex, wallet })=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"li\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Button_js__WEBPACK_IMPORTED_MODULE_1__.Button, {\n        onClick: handleClick,\n        startIcon: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletIcon_js__WEBPACK_IMPORTED_MODULE_2__.WalletIcon, {\n            wallet: wallet\n        }),\n        tabIndex: tabIndex\n    }, wallet.adapter.name, wallet.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, \"Detected\")));\n}; //# sourceMappingURL=WalletListItem.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL1dhbGxldExpc3RJdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStEO0FBQ3JDO0FBQ1c7QUFDUTtBQUN0QyxNQUFNSSxpQkFBaUIsQ0FBQyxFQUFFQyxXQUFXLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFO0lBQzVELHFCQUFRTixnREFBbUIsQ0FBQyxNQUFNLG9CQUM5QkEsZ0RBQW1CLENBQUNDLDhDQUFNQSxFQUFFO1FBQUVPLFNBQVNKO1FBQWFLLHlCQUFXVCxnREFBbUIsQ0FBQ0Usc0RBQVVBLEVBQUU7WUFBRUksUUFBUUE7UUFBTztRQUFJRCxVQUFVQTtJQUFTLEdBQ25JQyxPQUFPSSxPQUFPLENBQUNDLElBQUksRUFDbkJMLE9BQU9NLFVBQVUsS0FBS2IseUVBQWdCQSxDQUFDYyxTQUFTLGtCQUFJYixnREFBbUIsQ0FBQyxRQUFRLE1BQU07QUFDbEcsRUFBRSxDQUNGLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS9XYWxsZXRMaXN0SXRlbS5qcz8wZGIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdhbGxldFJlYWR5U3RhdGUgfSBmcm9tICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJy4vQnV0dG9uLmpzJztcbmltcG9ydCB7IFdhbGxldEljb24gfSBmcm9tICcuL1dhbGxldEljb24uanMnO1xuZXhwb3J0IGNvbnN0IFdhbGxldExpc3RJdGVtID0gKHsgaGFuZGxlQ2xpY2ssIHRhYkluZGV4LCB3YWxsZXQgfSkgPT4ge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCB7IG9uQ2xpY2s6IGhhbmRsZUNsaWNrLCBzdGFydEljb246IFJlYWN0LmNyZWF0ZUVsZW1lbnQoV2FsbGV0SWNvbiwgeyB3YWxsZXQ6IHdhbGxldCB9KSwgdGFiSW5kZXg6IHRhYkluZGV4IH0sXG4gICAgICAgICAgICB3YWxsZXQuYWRhcHRlci5uYW1lLFxuICAgICAgICAgICAgd2FsbGV0LnJlYWR5U3RhdGUgPT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiRGV0ZWN0ZWRcIikpKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2FsbGV0TGlzdEl0ZW0uanMubWFwIl0sIm5hbWVzIjpbIldhbGxldFJlYWR5U3RhdGUiLCJSZWFjdCIsIkJ1dHRvbiIsIldhbGxldEljb24iLCJXYWxsZXRMaXN0SXRlbSIsImhhbmRsZUNsaWNrIiwidGFiSW5kZXgiLCJ3YWxsZXQiLCJjcmVhdGVFbGVtZW50Iiwib25DbGljayIsInN0YXJ0SWNvbiIsImFkYXB0ZXIiLCJuYW1lIiwicmVhZHlTdGF0ZSIsIkluc3RhbGxlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletListItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModal.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModal.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletModal: () => (/* binding */ WalletModal)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _Collapse_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Collapse.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Collapse.js\");\n/* harmony import */ var _WalletListItem_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WalletListItem.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletListItem.js\");\n/* harmony import */ var _WalletSVG_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WalletSVG.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletSVG.js\");\n/* harmony import */ var _useWalletModal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useWalletModal.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/useWalletModal.js\");\n\n\n\n\n\n\n\n\nconst WalletModal = ({ className = \"\", container = \"body\" })=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { wallets, select } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_2__.useWallet)();\n    const { setVisible } = (0,_useWalletModal_js__WEBPACK_IMPORTED_MODULE_3__.useWalletModal)();\n    const [expanded, setExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [fadeIn, setFadeIn] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [portal, setPortal] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [listedWallets, collapsedWallets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const installed = [];\n        const notInstalled = [];\n        for (const wallet of wallets){\n            if (wallet.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed) {\n                installed.push(wallet);\n            } else {\n                notInstalled.push(wallet);\n            }\n        }\n        return installed.length ? [\n            installed,\n            notInstalled\n        ] : [\n            notInstalled,\n            []\n        ];\n    }, [\n        wallets\n    ]);\n    const hideModal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setFadeIn(false);\n        setTimeout(()=>setVisible(false), 150);\n    }, [\n        setVisible\n    ]);\n    const handleClose = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.preventDefault();\n        hideModal();\n    }, [\n        hideModal\n    ]);\n    const handleWalletClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event, walletName)=>{\n        select(walletName);\n        handleClose(event);\n    }, [\n        select,\n        handleClose\n    ]);\n    const handleCollapseClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>setExpanded(!expanded), [\n        expanded\n    ]);\n    const handleTabKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        const node = ref.current;\n        if (!node) return;\n        // here we query all focusable elements\n        const focusableElements = node.querySelectorAll(\"button\");\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const firstElement = focusableElements[0];\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const lastElement = focusableElements[focusableElements.length - 1];\n        if (event.shiftKey) {\n            // if going backward by pressing tab and firstElement is active, shift focus to last focusable element\n            if (document.activeElement === firstElement) {\n                lastElement.focus();\n                event.preventDefault();\n            }\n        } else {\n            // if going forward by pressing tab and lastElement is active, shift focus to first focusable element\n            if (document.activeElement === lastElement) {\n                firstElement.focus();\n                event.preventDefault();\n            }\n        }\n    }, [\n        ref\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        const handleKeyDown = (event)=>{\n            if (event.key === \"Escape\") {\n                hideModal();\n            } else if (event.key === \"Tab\") {\n                handleTabKey(event);\n            }\n        };\n        // Get original overflow\n        const { overflow } = window.getComputedStyle(document.body);\n        // Hack to enable fade in animation after mount\n        setTimeout(()=>setFadeIn(true), 0);\n        // Prevent scrolling on mount\n        document.body.style.overflow = \"hidden\";\n        // Listen for keydown events\n        window.addEventListener(\"keydown\", handleKeyDown, false);\n        return ()=>{\n            // Re-enable scrolling when component unmounts\n            document.body.style.overflow = overflow;\n            window.removeEventListener(\"keydown\", handleKeyDown, false);\n        };\n    }, [\n        hideModal,\n        handleTabKey\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>setPortal(document.querySelector(container)), [\n        container\n    ]);\n    return portal && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        \"aria-labelledby\": \"wallet-adapter-modal-title\",\n        \"aria-modal\": \"true\",\n        className: `wallet-adapter-modal ${fadeIn && \"wallet-adapter-modal-fade-in\"} ${className}`,\n        ref: ref,\n        role: \"dialog\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"wallet-adapter-modal-container\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"wallet-adapter-modal-wrapper\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n        onClick: handleClose,\n        className: \"wallet-adapter-modal-button-close\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        width: \"14\",\n        height: \"14\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z\"\n    }))), listedWallets.length ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h1\", {\n        className: \"wallet-adapter-modal-title\"\n    }, \"Connect a wallet on Solana to continue\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ul\", {\n        className: \"wallet-adapter-modal-list\"\n    }, listedWallets.map((wallet)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletListItem_js__WEBPACK_IMPORTED_MODULE_5__.WalletListItem, {\n            key: wallet.adapter.name,\n            handleClick: (event)=>handleWalletClick(event, wallet.adapter.name),\n            wallet: wallet\n        })), collapsedWallets.length ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Collapse_js__WEBPACK_IMPORTED_MODULE_6__.Collapse, {\n        expanded: expanded,\n        id: \"wallet-adapter-modal-collapse\"\n    }, collapsedWallets.map((wallet)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletListItem_js__WEBPACK_IMPORTED_MODULE_5__.WalletListItem, {\n            key: wallet.adapter.name,\n            handleClick: (event)=>handleWalletClick(event, wallet.adapter.name),\n            tabIndex: expanded ? 0 : -1,\n            wallet: wallet\n        }))) : null), collapsedWallets.length ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n        className: \"wallet-adapter-modal-list-more\",\n        onClick: handleCollapseClick,\n        tabIndex: 0\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, expanded ? \"Less \" : \"More \", \"options\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        width: \"13\",\n        height: \"7\",\n        viewBox: \"0 0 13 7\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        className: `${expanded ? \"wallet-adapter-modal-list-more-icon-rotate\" : \"\"}`\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z\"\n    }))) : null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h1\", {\n        className: \"wallet-adapter-modal-title\"\n    }, \"You'll need a wallet on Solana to continue\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"wallet-adapter-modal-middle\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletSVG_js__WEBPACK_IMPORTED_MODULE_7__.WalletSVG, null)), collapsedWallets.length ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n        className: \"wallet-adapter-modal-list-more\",\n        onClick: handleCollapseClick,\n        tabIndex: 0\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, expanded ? \"Hide \" : \"Already have a wallet? View \", \"options\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        width: \"13\",\n        height: \"7\",\n        viewBox: \"0 0 13 7\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        className: `${expanded ? \"wallet-adapter-modal-list-more-icon-rotate\" : \"\"}`\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z\"\n    }))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Collapse_js__WEBPACK_IMPORTED_MODULE_6__.Collapse, {\n        expanded: expanded,\n        id: \"wallet-adapter-modal-collapse\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ul\", {\n        className: \"wallet-adapter-modal-list\"\n    }, collapsedWallets.map((wallet)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletListItem_js__WEBPACK_IMPORTED_MODULE_5__.WalletListItem, {\n            key: wallet.adapter.name,\n            handleClick: (event)=>handleWalletClick(event, wallet.adapter.name),\n            tabIndex: expanded ? 0 : -1,\n            wallet: wallet\n        }))))) : null))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"wallet-adapter-modal-overlay\",\n        onMouseDown: handleClose\n    })), portal);\n}; //# sourceMappingURL=WalletModal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL1dhbGxldE1vZGFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErRDtBQUNOO0FBQzhCO0FBQzlDO0FBQ0E7QUFDWTtBQUNWO0FBQ1U7QUFDOUMsTUFBTWEsY0FBYyxDQUFDLEVBQUVDLFlBQVksRUFBRSxFQUFFQyxZQUFZLE1BQU0sRUFBRTtJQUM5RCxNQUFNQyxNQUFNViw2Q0FBTUEsQ0FBQztJQUNuQixNQUFNLEVBQUVXLE9BQU8sRUFBRUMsTUFBTSxFQUFFLEdBQUdqQix1RUFBU0E7SUFDckMsTUFBTSxFQUFFa0IsVUFBVSxFQUFFLEdBQUdQLGtFQUFjQTtJQUNyQyxNQUFNLENBQUNRLFVBQVVDLFlBQVksR0FBR2QsK0NBQVFBLENBQUM7SUFDekMsTUFBTSxDQUFDZSxRQUFRQyxVQUFVLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUNpQixRQUFRQyxVQUFVLEdBQUdsQiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUNtQixlQUFlQyxpQkFBaUIsR0FBR3RCLDhDQUFPQSxDQUFDO1FBQzlDLE1BQU11QixZQUFZLEVBQUU7UUFDcEIsTUFBTUMsZUFBZSxFQUFFO1FBQ3ZCLEtBQUssTUFBTUMsVUFBVWIsUUFBUztZQUMxQixJQUFJYSxPQUFPQyxVQUFVLEtBQUsvQix5RUFBZ0JBLENBQUNnQyxTQUFTLEVBQUU7Z0JBQ2xESixVQUFVSyxJQUFJLENBQUNIO1lBQ25CLE9BQ0s7Z0JBQ0RELGFBQWFJLElBQUksQ0FBQ0g7WUFDdEI7UUFDSjtRQUNBLE9BQU9GLFVBQVVNLE1BQU0sR0FBRztZQUFDTjtZQUFXQztTQUFhLEdBQUc7WUFBQ0E7WUFBYyxFQUFFO1NBQUM7SUFDNUUsR0FBRztRQUFDWjtLQUFRO0lBQ1osTUFBTWtCLFlBQVloQyxrREFBV0EsQ0FBQztRQUMxQm9CLFVBQVU7UUFDVmEsV0FBVyxJQUFNakIsV0FBVyxRQUFRO0lBQ3hDLEdBQUc7UUFBQ0E7S0FBVztJQUNmLE1BQU1rQixjQUFjbEMsa0RBQVdBLENBQUMsQ0FBQ21DO1FBQzdCQSxNQUFNQyxjQUFjO1FBQ3BCSjtJQUNKLEdBQUc7UUFBQ0E7S0FBVTtJQUNkLE1BQU1LLG9CQUFvQnJDLGtEQUFXQSxDQUFDLENBQUNtQyxPQUFPRztRQUMxQ3ZCLE9BQU91QjtRQUNQSixZQUFZQztJQUNoQixHQUFHO1FBQUNwQjtRQUFRbUI7S0FBWTtJQUN4QixNQUFNSyxzQkFBc0J2QyxrREFBV0EsQ0FBQyxJQUFNa0IsWUFBWSxDQUFDRCxXQUFXO1FBQUNBO0tBQVM7SUFDaEYsTUFBTXVCLGVBQWV4QyxrREFBV0EsQ0FBQyxDQUFDbUM7UUFDOUIsTUFBTU0sT0FBTzVCLElBQUk2QixPQUFPO1FBQ3hCLElBQUksQ0FBQ0QsTUFDRDtRQUNKLHVDQUF1QztRQUN2QyxNQUFNRSxvQkFBb0JGLEtBQUtHLGdCQUFnQixDQUFDO1FBQ2hELG9FQUFvRTtRQUNwRSxNQUFNQyxlQUFlRixpQkFBaUIsQ0FBQyxFQUFFO1FBQ3pDLG9FQUFvRTtRQUNwRSxNQUFNRyxjQUFjSCxpQkFBaUIsQ0FBQ0Esa0JBQWtCWixNQUFNLEdBQUcsRUFBRTtRQUNuRSxJQUFJSSxNQUFNWSxRQUFRLEVBQUU7WUFDaEIsc0dBQXNHO1lBQ3RHLElBQUlDLFNBQVNDLGFBQWEsS0FBS0osY0FBYztnQkFDekNDLFlBQVlJLEtBQUs7Z0JBQ2pCZixNQUFNQyxjQUFjO1lBQ3hCO1FBQ0osT0FDSztZQUNELHFHQUFxRztZQUNyRyxJQUFJWSxTQUFTQyxhQUFhLEtBQUtILGFBQWE7Z0JBQ3hDRCxhQUFhSyxLQUFLO2dCQUNsQmYsTUFBTUMsY0FBYztZQUN4QjtRQUNKO0lBQ0osR0FBRztRQUFDdkI7S0FBSTtJQUNSWixzREFBZUEsQ0FBQztRQUNaLE1BQU1rRCxnQkFBZ0IsQ0FBQ2hCO1lBQ25CLElBQUlBLE1BQU1pQixHQUFHLEtBQUssVUFBVTtnQkFDeEJwQjtZQUNKLE9BQ0ssSUFBSUcsTUFBTWlCLEdBQUcsS0FBSyxPQUFPO2dCQUMxQlosYUFBYUw7WUFDakI7UUFDSjtRQUNBLHdCQUF3QjtRQUN4QixNQUFNLEVBQUVrQixRQUFRLEVBQUUsR0FBR0MsT0FBT0MsZ0JBQWdCLENBQUNQLFNBQVNRLElBQUk7UUFDMUQsK0NBQStDO1FBQy9DdkIsV0FBVyxJQUFNYixVQUFVLE9BQU87UUFDbEMsNkJBQTZCO1FBQzdCNEIsU0FBU1EsSUFBSSxDQUFDQyxLQUFLLENBQUNKLFFBQVEsR0FBRztRQUMvQiw0QkFBNEI7UUFDNUJDLE9BQU9JLGdCQUFnQixDQUFDLFdBQVdQLGVBQWU7UUFDbEQsT0FBTztZQUNILDhDQUE4QztZQUM5Q0gsU0FBU1EsSUFBSSxDQUFDQyxLQUFLLENBQUNKLFFBQVEsR0FBR0E7WUFDL0JDLE9BQU9LLG1CQUFtQixDQUFDLFdBQVdSLGVBQWU7UUFDekQ7SUFDSixHQUFHO1FBQUNuQjtRQUFXUTtLQUFhO0lBQzVCdkMsc0RBQWVBLENBQUMsSUFBTXFCLFVBQVUwQixTQUFTWSxhQUFhLENBQUNoRCxhQUFhO1FBQUNBO0tBQVU7SUFDL0UsT0FBUVMsd0JBQ0poQix1REFBWUEsZUFBQ04sZ0RBQW1CLENBQUMsT0FBTztRQUFFLG1CQUFtQjtRQUE4QixjQUFjO1FBQVFZLFdBQVcsQ0FBQyxxQkFBcUIsRUFBRVEsVUFBVSwrQkFBK0IsQ0FBQyxFQUFFUixVQUFVLENBQUM7UUFBRUUsS0FBS0E7UUFBS2lELE1BQU07SUFBUyxpQkFDbE8vRCxnREFBbUIsQ0FBQyxPQUFPO1FBQUVZLFdBQVc7SUFBaUMsaUJBQ3JFWixnREFBbUIsQ0FBQyxPQUFPO1FBQUVZLFdBQVc7SUFBK0IsaUJBQ25FWixnREFBbUIsQ0FBQyxVQUFVO1FBQUVnRSxTQUFTN0I7UUFBYXZCLFdBQVc7SUFBb0MsaUJBQ2pHWixnREFBbUIsQ0FBQyxPQUFPO1FBQUVpRSxPQUFPO1FBQU1DLFFBQVE7SUFBSyxpQkFDbkRsRSxnREFBbUIsQ0FBQyxRQUFRO1FBQUVtRSxHQUFHO0lBQXNJLE1BQy9LM0MsY0FBY1EsTUFBTSxpQkFBSWhDLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLG9CQUN4REEsZ0RBQW1CLENBQUMsTUFBTTtRQUFFWSxXQUFXO0lBQTZCLEdBQUcseURBQ3ZFWixnREFBbUIsQ0FBQyxNQUFNO1FBQUVZLFdBQVc7SUFBNEIsR0FDL0RZLGNBQWM2QyxHQUFHLENBQUMsQ0FBQ3pDLHVCQUFZNUIsZ0RBQW1CLENBQUNRLDhEQUFjQSxFQUFFO1lBQUU2QyxLQUFLekIsT0FBTzBDLE9BQU8sQ0FBQ0MsSUFBSTtZQUFFQyxhQUFhLENBQUNwQyxRQUFVRSxrQkFBa0JGLE9BQU9SLE9BQU8wQyxPQUFPLENBQUNDLElBQUk7WUFBRzNDLFFBQVFBO1FBQU8sS0FDckxILGlCQUFpQk8sTUFBTSxpQkFBSWhDLGdEQUFtQixDQUFDTyxrREFBUUEsRUFBRTtRQUFFVyxVQUFVQTtRQUFVdUQsSUFBSTtJQUFnQyxHQUFHaEQsaUJBQWlCNEMsR0FBRyxDQUFDLENBQUN6Qyx1QkFBWTVCLGdEQUFtQixDQUFDUSw4REFBY0EsRUFBRTtZQUFFNkMsS0FBS3pCLE9BQU8wQyxPQUFPLENBQUNDLElBQUk7WUFBRUMsYUFBYSxDQUFDcEMsUUFBVUUsa0JBQWtCRixPQUFPUixPQUFPMEMsT0FBTyxDQUFDQyxJQUFJO1lBQUdHLFVBQVV4RCxXQUFXLElBQUksQ0FBQztZQUFHVSxRQUFRQTtRQUFPLE9BQVMsT0FDeFZILGlCQUFpQk8sTUFBTSxpQkFBSWhDLGdEQUFtQixDQUFDLFVBQVU7UUFBRVksV0FBVztRQUFrQ29ELFNBQVN4QjtRQUFxQmtDLFVBQVU7SUFBRSxpQkFDOUkxRSxnREFBbUIsQ0FBQyxRQUFRLE1BQ3hCa0IsV0FBVyxVQUFVLFNBQ3JCLDBCQUNKbEIsZ0RBQW1CLENBQUMsT0FBTztRQUFFaUUsT0FBTztRQUFNQyxRQUFRO1FBQUtTLFNBQVM7UUFBWUMsT0FBTztRQUE4QmhFLFdBQVcsQ0FBQyxFQUFFTSxXQUFXLCtDQUErQyxHQUFHLENBQUM7SUFBQyxpQkFDMUxsQixnREFBbUIsQ0FBQyxRQUFRO1FBQUVtRSxHQUFHO0lBQTRULE9BQVEsc0JBQVVuRSxnREFBbUIsQ0FBQ0EsMkNBQWMsRUFBRSxvQkFDM1pBLGdEQUFtQixDQUFDLE1BQU07UUFBRVksV0FBVztJQUE2QixHQUFHLDZEQUN2RVosZ0RBQW1CLENBQUMsT0FBTztRQUFFWSxXQUFXO0lBQThCLGlCQUNsRVosZ0RBQW1CLENBQUNTLG9EQUFTQSxFQUFFLFFBQ25DZ0IsaUJBQWlCTyxNQUFNLGlCQUFJaEMsZ0RBQW1CLENBQUNBLDJDQUFjLEVBQUUsb0JBQzNEQSxnREFBbUIsQ0FBQyxVQUFVO1FBQUVZLFdBQVc7UUFBa0NvRCxTQUFTeEI7UUFBcUJrQyxVQUFVO0lBQUUsaUJBQ25IMUUsZ0RBQW1CLENBQUMsUUFBUSxNQUN4QmtCLFdBQVcsVUFBVSxnQ0FDckIsMEJBQ0psQixnREFBbUIsQ0FBQyxPQUFPO1FBQUVpRSxPQUFPO1FBQU1DLFFBQVE7UUFBS1MsU0FBUztRQUFZQyxPQUFPO1FBQThCaEUsV0FBVyxDQUFDLEVBQUVNLFdBQVcsK0NBQStDLEdBQUcsQ0FBQztJQUFDLGlCQUMxTGxCLGdEQUFtQixDQUFDLFFBQVE7UUFBRW1FLEdBQUc7SUFBNFQsb0JBQ3JXbkUsZ0RBQW1CLENBQUNPLGtEQUFRQSxFQUFFO1FBQUVXLFVBQVVBO1FBQVV1RCxJQUFJO0lBQWdDLGlCQUNwRnpFLGdEQUFtQixDQUFDLE1BQU07UUFBRVksV0FBVztJQUE0QixHQUFHYSxpQkFBaUI0QyxHQUFHLENBQUMsQ0FBQ3pDLHVCQUFZNUIsZ0RBQW1CLENBQUNRLDhEQUFjQSxFQUFFO1lBQUU2QyxLQUFLekIsT0FBTzBDLE9BQU8sQ0FBQ0MsSUFBSTtZQUFFQyxhQUFhLENBQUNwQyxRQUFVRSxrQkFBa0JGLE9BQU9SLE9BQU8wQyxPQUFPLENBQUNDLElBQUk7WUFBR0csVUFBVXhELFdBQVcsSUFBSSxDQUFDO1lBQUdVLFFBQVFBO1FBQU8sU0FBVyx1QkFDMVQ1QixnREFBbUIsQ0FBQyxPQUFPO1FBQUVZLFdBQVc7UUFBZ0NpRSxhQUFhMUM7SUFBWSxLQUFLYjtBQUNsSCxFQUFFLENBQ0YsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL1dhbGxldE1vZGFsLmpzPzM3NzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV2FsbGV0UmVhZHlTdGF0ZSB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZSc7XG5pbXBvcnQgeyB1c2VXYWxsZXQgfSBmcm9tICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0JztcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IENvbGxhcHNlIH0gZnJvbSAnLi9Db2xsYXBzZS5qcyc7XG5pbXBvcnQgeyBXYWxsZXRMaXN0SXRlbSB9IGZyb20gJy4vV2FsbGV0TGlzdEl0ZW0uanMnO1xuaW1wb3J0IHsgV2FsbGV0U1ZHIH0gZnJvbSAnLi9XYWxsZXRTVkcuanMnO1xuaW1wb3J0IHsgdXNlV2FsbGV0TW9kYWwgfSBmcm9tICcuL3VzZVdhbGxldE1vZGFsLmpzJztcbmV4cG9ydCBjb25zdCBXYWxsZXRNb2RhbCA9ICh7IGNsYXNzTmFtZSA9ICcnLCBjb250YWluZXIgPSAnYm9keScgfSkgPT4ge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IHdhbGxldHMsIHNlbGVjdCB9ID0gdXNlV2FsbGV0KCk7XG4gICAgY29uc3QgeyBzZXRWaXNpYmxlIH0gPSB1c2VXYWxsZXRNb2RhbCgpO1xuICAgIGNvbnN0IFtleHBhbmRlZCwgc2V0RXhwYW5kZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtmYWRlSW4sIHNldEZhZGVJbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3BvcnRhbCwgc2V0UG9ydGFsXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtsaXN0ZWRXYWxsZXRzLCBjb2xsYXBzZWRXYWxsZXRzXSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YWxsZWQgPSBbXTtcbiAgICAgICAgY29uc3Qgbm90SW5zdGFsbGVkID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgd2FsbGV0IG9mIHdhbGxldHMpIHtcbiAgICAgICAgICAgIGlmICh3YWxsZXQucmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpIHtcbiAgICAgICAgICAgICAgICBpbnN0YWxsZWQucHVzaCh3YWxsZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm90SW5zdGFsbGVkLnB1c2god2FsbGV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFsbGVkLmxlbmd0aCA/IFtpbnN0YWxsZWQsIG5vdEluc3RhbGxlZF0gOiBbbm90SW5zdGFsbGVkLCBbXV07XG4gICAgfSwgW3dhbGxldHNdKTtcbiAgICBjb25zdCBoaWRlTW9kYWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldEZhZGVJbihmYWxzZSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0VmlzaWJsZShmYWxzZSksIDE1MCk7XG4gICAgfSwgW3NldFZpc2libGVdKTtcbiAgICBjb25zdCBoYW5kbGVDbG9zZSA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBoaWRlTW9kYWwoKTtcbiAgICB9LCBbaGlkZU1vZGFsXSk7XG4gICAgY29uc3QgaGFuZGxlV2FsbGV0Q2xpY2sgPSB1c2VDYWxsYmFjaygoZXZlbnQsIHdhbGxldE5hbWUpID0+IHtcbiAgICAgICAgc2VsZWN0KHdhbGxldE5hbWUpO1xuICAgICAgICBoYW5kbGVDbG9zZShldmVudCk7XG4gICAgfSwgW3NlbGVjdCwgaGFuZGxlQ2xvc2VdKTtcbiAgICBjb25zdCBoYW5kbGVDb2xsYXBzZUNsaWNrID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0RXhwYW5kZWQoIWV4cGFuZGVkKSwgW2V4cGFuZGVkXSk7XG4gICAgY29uc3QgaGFuZGxlVGFiS2V5ID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBoZXJlIHdlIHF1ZXJ5IGFsbCBmb2N1c2FibGUgZWxlbWVudHNcbiAgICAgICAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1swXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1tmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAvLyBpZiBnb2luZyBiYWNrd2FyZCBieSBwcmVzc2luZyB0YWIgYW5kIGZpcnN0RWxlbWVudCBpcyBhY3RpdmUsIHNoaWZ0IGZvY3VzIHRvIGxhc3QgZm9jdXNhYmxlIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmaXJzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBsYXN0RWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBnb2luZyBmb3J3YXJkIGJ5IHByZXNzaW5nIHRhYiBhbmQgbGFzdEVsZW1lbnQgaXMgYWN0aXZlLCBzaGlmdCBmb2N1cyB0byBmaXJzdCBmb2N1c2FibGUgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGxhc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtyZWZdKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIGhpZGVNb2RhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZVRhYktleShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEdldCBvcmlnaW5hbCBvdmVyZmxvd1xuICAgICAgICBjb25zdCB7IG92ZXJmbG93IH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgLy8gSGFjayB0byBlbmFibGUgZmFkZSBpbiBhbmltYXRpb24gYWZ0ZXIgbW91bnRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRGYWRlSW4odHJ1ZSksIDApO1xuICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiBtb3VudFxuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIC8vIExpc3RlbiBmb3Iga2V5ZG93biBldmVudHNcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBSZS1lbmFibGUgc2Nyb2xsaW5nIHdoZW4gY29tcG9uZW50IHVubW91bnRzXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24sIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaGlkZU1vZGFsLCBoYW5kbGVUYWJLZXldKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4gc2V0UG9ydGFsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKSksIFtjb250YWluZXJdKTtcbiAgICByZXR1cm4gKHBvcnRhbCAmJlxuICAgICAgICBjcmVhdGVQb3J0YWwoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtdGl0bGVcIiwgXCJhcmlhLW1vZGFsXCI6IFwidHJ1ZVwiLCBjbGFzc05hbWU6IGB3YWxsZXQtYWRhcHRlci1tb2RhbCAke2ZhZGVJbiAmJiAnd2FsbGV0LWFkYXB0ZXItbW9kYWwtZmFkZS1pbid9ICR7Y2xhc3NOYW1lfWAsIHJlZjogcmVmLCByb2xlOiBcImRpYWxvZ1wiIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJ3YWxsZXQtYWRhcHRlci1tb2RhbC13cmFwcGVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IG9uQ2xpY2s6IGhhbmRsZUNsb3NlLCBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtYnV0dG9uLWNsb3NlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB3aWR0aDogXCIxNFwiLCBoZWlnaHQ6IFwiMTRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTQgMTIuNDYxIDguMyA2Ljc3Mmw1LjIzNC01LjIzM0wxMi4wMDYgMCA2Ljc3MiA1LjIzNCAxLjU0IDAgMCAxLjUzOWw1LjIzNCA1LjIzM0wwIDEyLjAwNmwxLjUzOSAxLjUyOEw2Ljc3MiA4LjNsNS42OSA1LjdMMTQgMTIuNDYxelwiIH0pKSksXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlZFdhbGxldHMubGVuZ3RoID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtdGl0bGVcIiB9LCBcIkNvbm5lY3QgYSB3YWxsZXQgb24gU29sYW5hIHRvIGNvbnRpbnVlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWxpc3RcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlZFdhbGxldHMubWFwKCh3YWxsZXQpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldExpc3RJdGVtLCB7IGtleTogd2FsbGV0LmFkYXB0ZXIubmFtZSwgaGFuZGxlQ2xpY2s6IChldmVudCkgPT4gaGFuZGxlV2FsbGV0Q2xpY2soZXZlbnQsIHdhbGxldC5hZGFwdGVyLm5hbWUpLCB3YWxsZXQ6IHdhbGxldCB9KSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZFdhbGxldHMubGVuZ3RoID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29sbGFwc2UsIHsgZXhwYW5kZWQ6IGV4cGFuZGVkLCBpZDogXCJ3YWxsZXQtYWRhcHRlci1tb2RhbC1jb2xsYXBzZVwiIH0sIGNvbGxhcHNlZFdhbGxldHMubWFwKCh3YWxsZXQpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldExpc3RJdGVtLCB7IGtleTogd2FsbGV0LmFkYXB0ZXIubmFtZSwgaGFuZGxlQ2xpY2s6IChldmVudCkgPT4gaGFuZGxlV2FsbGV0Q2xpY2soZXZlbnQsIHdhbGxldC5hZGFwdGVyLm5hbWUpLCB0YWJJbmRleDogZXhwYW5kZWQgPyAwIDogLTEsIHdhbGxldDogd2FsbGV0IH0pKSkpKSA6IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkV2FsbGV0cy5sZW5ndGggPyAoUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogXCJ3YWxsZXQtYWRhcHRlci1tb2RhbC1saXN0LW1vcmVcIiwgb25DbGljazogaGFuZGxlQ29sbGFwc2VDbGljaywgdGFiSW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZCA/ICdMZXNzICcgOiAnTW9yZSAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9wdGlvbnNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHdpZHRoOiBcIjEzXCIsIGhlaWdodDogXCI3XCIsIHZpZXdCb3g6IFwiMCAwIDEzIDdcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgY2xhc3NOYW1lOiBgJHtleHBhbmRlZCA/ICd3YWxsZXQtYWRhcHRlci1tb2RhbC1saXN0LW1vcmUtaWNvbi1yb3RhdGUnIDogJyd9YCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTAuNzE0MTggMS42MjZMNS44MzMyMyA2LjI2MTg4QzUuOTE1NzQgNi4zMzY1NyA2LjAxODEgNi4zOTY1MiA2LjEzMzI3IDYuNDM3NjJDNi4yNDg0NCA2LjQ3ODcyIDYuMzczNzEgNi41IDYuNTAwNDggNi41QzYuNjI3MjUgNi41IDYuNzUyNTIgNi40Nzg3MiA2Ljg2NzcgNi40Mzc2MkM2Ljk4Mjg3IDYuMzk2NTIgNy4wODUyMyA2LjMzNjU3IDcuMTY3NzQgNi4yNjE4OEwxMi4yODY4IDEuNjI2QzEyLjc3NTMgMS4xODM1IDEyLjM3MDMgMC41IDExLjYxOTUgMC41SDEuMzc5OTdDMC42MjkyMTYgMC41IDAuMjI0MTc1IDEuMTgzNSAwLjcxNDE4IDEuNjI2WlwiIH0pKSkpIDogbnVsbCkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtdGl0bGVcIiB9LCBcIllvdSdsbCBuZWVkIGEgd2FsbGV0IG9uIFNvbGFuYSB0byBjb250aW51ZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtbWlkZGxlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldFNWRywgbnVsbCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkV2FsbGV0cy5sZW5ndGggPyAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWxpc3QtbW9yZVwiLCBvbkNsaWNrOiBoYW5kbGVDb2xsYXBzZUNsaWNrLCB0YWJJbmRleDogMCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPyAnSGlkZSAnIDogJ0FscmVhZHkgaGF2ZSBhIHdhbGxldD8gVmlldyAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcHRpb25zXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgd2lkdGg6IFwiMTNcIiwgaGVpZ2h0OiBcIjdcIiwgdmlld0JveDogXCIwIDAgMTMgN1wiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBjbGFzc05hbWU6IGAke2V4cGFuZGVkID8gJ3dhbGxldC1hZGFwdGVyLW1vZGFsLWxpc3QtbW9yZS1pY29uLXJvdGF0ZScgOiAnJ31gIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTAuNzE0MTggMS42MjZMNS44MzMyMyA2LjI2MTg4QzUuOTE1NzQgNi4zMzY1NyA2LjAxODEgNi4zOTY1MiA2LjEzMzI3IDYuNDM3NjJDNi4yNDg0NCA2LjQ3ODcyIDYuMzczNzEgNi41IDYuNTAwNDggNi41QzYuNjI3MjUgNi41IDYuNzUyNTIgNi40Nzg3MiA2Ljg2NzcgNi40Mzc2MkM2Ljk4Mjg3IDYuMzk2NTIgNy4wODUyMyA2LjMzNjU3IDcuMTY3NzQgNi4yNjE4OEwxMi4yODY4IDEuNjI2QzEyLjc3NTMgMS4xODM1IDEyLjM3MDMgMC41IDExLjYxOTUgMC41SDEuMzc5OTdDMC42MjkyMTYgMC41IDAuMjI0MTc1IDEuMTgzNSAwLjcxNDE4IDEuNjI2WlwiIH0pKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb2xsYXBzZSwgeyBleHBhbmRlZDogZXhwYW5kZWQsIGlkOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWNvbGxhcHNlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWxpc3RcIiB9LCBjb2xsYXBzZWRXYWxsZXRzLm1hcCgod2FsbGV0KSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChXYWxsZXRMaXN0SXRlbSwgeyBrZXk6IHdhbGxldC5hZGFwdGVyLm5hbWUsIGhhbmRsZUNsaWNrOiAoZXZlbnQpID0+IGhhbmRsZVdhbGxldENsaWNrKGV2ZW50LCB3YWxsZXQuYWRhcHRlci5uYW1lKSwgdGFiSW5kZXg6IGV4cGFuZGVkID8gMCA6IC0xLCB3YWxsZXQ6IHdhbGxldCB9KSkpKSkpKSA6IG51bGwpKSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJ3YWxsZXQtYWRhcHRlci1tb2RhbC1vdmVybGF5XCIsIG9uTW91c2VEb3duOiBoYW5kbGVDbG9zZSB9KSksIHBvcnRhbCkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdhbGxldE1vZGFsLmpzLm1hcCJdLCJuYW1lcyI6WyJXYWxsZXRSZWFkeVN0YXRlIiwidXNlV2FsbGV0IiwiUmVhY3QiLCJ1c2VDYWxsYmFjayIsInVzZUxheW91dEVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImNyZWF0ZVBvcnRhbCIsIkNvbGxhcHNlIiwiV2FsbGV0TGlzdEl0ZW0iLCJXYWxsZXRTVkciLCJ1c2VXYWxsZXRNb2RhbCIsIldhbGxldE1vZGFsIiwiY2xhc3NOYW1lIiwiY29udGFpbmVyIiwicmVmIiwid2FsbGV0cyIsInNlbGVjdCIsInNldFZpc2libGUiLCJleHBhbmRlZCIsInNldEV4cGFuZGVkIiwiZmFkZUluIiwic2V0RmFkZUluIiwicG9ydGFsIiwic2V0UG9ydGFsIiwibGlzdGVkV2FsbGV0cyIsImNvbGxhcHNlZFdhbGxldHMiLCJpbnN0YWxsZWQiLCJub3RJbnN0YWxsZWQiLCJ3YWxsZXQiLCJyZWFkeVN0YXRlIiwiSW5zdGFsbGVkIiwicHVzaCIsImxlbmd0aCIsImhpZGVNb2RhbCIsInNldFRpbWVvdXQiLCJoYW5kbGVDbG9zZSIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVXYWxsZXRDbGljayIsIndhbGxldE5hbWUiLCJoYW5kbGVDb2xsYXBzZUNsaWNrIiwiaGFuZGxlVGFiS2V5Iiwibm9kZSIsImN1cnJlbnQiLCJmb2N1c2FibGVFbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmaXJzdEVsZW1lbnQiLCJsYXN0RWxlbWVudCIsInNoaWZ0S2V5IiwiZG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiZm9jdXMiLCJoYW5kbGVLZXlEb3duIiwia2V5Iiwib3ZlcmZsb3ciLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiYm9keSIsInN0eWxlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCIsInJvbGUiLCJvbkNsaWNrIiwid2lkdGgiLCJoZWlnaHQiLCJkIiwiRnJhZ21lbnQiLCJtYXAiLCJhZGFwdGVyIiwibmFtZSIsImhhbmRsZUNsaWNrIiwiaWQiLCJ0YWJJbmRleCIsInZpZXdCb3giLCJ4bWxucyIsIm9uTW91c2VEb3duIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModalProvider.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModalProvider.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletModalProvider: () => (/* binding */ WalletModalProvider)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _useWalletModal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useWalletModal.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/useWalletModal.js\");\n/* harmony import */ var _WalletModal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WalletModal.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModal.js\");\n\n\n\nconst WalletModalProvider = ({ children, ...props })=>{\n    const [visible, setVisible] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_useWalletModal_js__WEBPACK_IMPORTED_MODULE_1__.WalletModalContext.Provider, {\n        value: {\n            visible,\n            setVisible\n        }\n    }, children, visible && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletModal_js__WEBPACK_IMPORTED_MODULE_2__.WalletModal, {\n        ...props\n    }));\n}; //# sourceMappingURL=WalletModalProvider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL1dhbGxldE1vZGFsUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3QztBQUNpQjtBQUNWO0FBQ3hDLE1BQU1JLHNCQUFzQixDQUFDLEVBQUVDLFFBQVEsRUFBRSxHQUFHQyxPQUFPO0lBQ3RELE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHUCwrQ0FBUUEsQ0FBQztJQUN2QyxxQkFBUUQsZ0RBQW1CLENBQUNFLGtFQUFrQkEsQ0FBQ1EsUUFBUSxFQUFFO1FBQUVDLE9BQU87WUFDMURKO1lBQ0FDO1FBQ0o7SUFBRSxHQUNGSCxVQUNBRSx5QkFBV1AsZ0RBQW1CLENBQUNHLHdEQUFXQSxFQUFFO1FBQUUsR0FBR0csS0FBSztJQUFDO0FBQy9ELEVBQUUsQ0FDRiwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vV2FsbGV0TW9kYWxQcm92aWRlci5qcz8xYzEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFdhbGxldE1vZGFsQ29udGV4dCB9IGZyb20gJy4vdXNlV2FsbGV0TW9kYWwuanMnO1xuaW1wb3J0IHsgV2FsbGV0TW9kYWwgfSBmcm9tICcuL1dhbGxldE1vZGFsLmpzJztcbmV4cG9ydCBjb25zdCBXYWxsZXRNb2RhbFByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldE1vZGFsQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZToge1xuICAgICAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgICAgIHNldFZpc2libGUsXG4gICAgICAgIH0gfSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHZpc2libGUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChXYWxsZXRNb2RhbCwgeyAuLi5wcm9wcyB9KSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdhbGxldE1vZGFsUHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJXYWxsZXRNb2RhbENvbnRleHQiLCJXYWxsZXRNb2RhbCIsIldhbGxldE1vZGFsUHJvdmlkZXIiLCJjaGlsZHJlbiIsInByb3BzIiwidmlzaWJsZSIsInNldFZpc2libGUiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModalProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletSVG.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletSVG.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletSVG: () => (/* binding */ WalletSVG)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst WalletSVG = ()=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        width: \"97\",\n        height: \"96\",\n        viewBox: \"0 0 97 96\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n        cx: \"48.5\",\n        cy: \"48\",\n        r: \"48\",\n        fill: \"url(#paint0_linear_880_5115)\",\n        fillOpacity: \"0.1\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n        cx: \"48.5\",\n        cy: \"48\",\n        r: \"47\",\n        stroke: \"url(#paint1_linear_880_5115)\",\n        strokeOpacity: \"0.4\",\n        strokeWidth: \"2\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n        clipPath: \"url(#clip0_880_5115)\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M65.5769 28.1523H31.4231C27.6057 28.1523 24.5 31.258 24.5 35.0754V60.9215C24.5 64.7389 27.6057 67.8446 31.4231 67.8446H65.5769C69.3943 67.8446 72.5 64.7389 72.5 60.9215V35.0754C72.5 31.258 69.3943 28.1523 65.5769 28.1523ZM69.7308 52.1523H59.5769C57.2865 52.1523 55.4231 50.289 55.4231 47.9985C55.4231 45.708 57.2864 43.8446 59.5769 43.8446H69.7308V52.1523ZM69.7308 41.0754H59.5769C55.7595 41.0754 52.6539 44.1811 52.6539 47.9985C52.6539 51.8159 55.7595 54.9215 59.5769 54.9215H69.7308V60.9215C69.7308 63.2119 67.8674 65.0754 65.5769 65.0754H31.4231C29.1327 65.0754 27.2692 63.212 27.2692 60.9215V35.0754C27.2692 32.785 29.1326 30.9215 31.4231 30.9215H65.5769C67.8673 30.9215 69.7308 32.7849 69.7308 35.0754V41.0754Z\",\n        fill: \"url(#paint2_linear_880_5115)\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M61.4231 46.6172H59.577C58.8123 46.6172 58.1924 47.2371 58.1924 48.0018C58.1924 48.7665 58.8123 49.3863 59.577 49.3863H61.4231C62.1878 49.3863 62.8077 48.7664 62.8077 48.0018C62.8077 47.2371 62.1878 46.6172 61.4231 46.6172Z\",\n        fill: \"url(#paint3_linear_880_5115)\"\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", {\n        id: \"paint0_linear_880_5115\",\n        x1: \"3.41664\",\n        y1: \"98.0933\",\n        x2: \"103.05\",\n        y2: \"8.42498\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        stopColor: \"#9945FF\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.14\",\n        stopColor: \"#8A53F4\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.42\",\n        stopColor: \"#6377D6\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.79\",\n        stopColor: \"#24B0A7\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.99\",\n        stopColor: \"#00D18C\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"#00D18C\"\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", {\n        id: \"paint1_linear_880_5115\",\n        x1: \"3.41664\",\n        y1: \"98.0933\",\n        x2: \"103.05\",\n        y2: \"8.42498\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        stopColor: \"#9945FF\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.14\",\n        stopColor: \"#8A53F4\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.42\",\n        stopColor: \"#6377D6\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.79\",\n        stopColor: \"#24B0A7\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.99\",\n        stopColor: \"#00D18C\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"#00D18C\"\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", {\n        id: \"paint2_linear_880_5115\",\n        x1: \"25.9583\",\n        y1: \"68.7101\",\n        x2: \"67.2337\",\n        y2: \"23.7879\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        stopColor: \"#9945FF\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.14\",\n        stopColor: \"#8A53F4\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.42\",\n        stopColor: \"#6377D6\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.79\",\n        stopColor: \"#24B0A7\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.99\",\n        stopColor: \"#00D18C\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"#00D18C\"\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", {\n        id: \"paint3_linear_880_5115\",\n        x1: \"58.3326\",\n        y1: \"49.4467\",\n        x2: \"61.0002\",\n        y2: \"45.4453\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        stopColor: \"#9945FF\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.14\",\n        stopColor: \"#8A53F4\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.42\",\n        stopColor: \"#6377D6\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.79\",\n        stopColor: \"#24B0A7\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.99\",\n        stopColor: \"#00D18C\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"#00D18C\"\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n        id: \"clip0_880_5115\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        width: \"48\",\n        height: \"48\",\n        fill: \"white\",\n        transform: \"translate(24.5 24)\"\n    }))));\n}; //# sourceMappingURL=WalletSVG.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL1dhbGxldFNWRy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQjtBQUNuQixNQUFNQyxZQUFZO0lBQ3JCLHFCQUFRRCxnREFBbUIsQ0FBQyxPQUFPO1FBQUVHLE9BQU87UUFBTUMsUUFBUTtRQUFNQyxTQUFTO1FBQWFDLE1BQU07UUFBUUMsT0FBTztJQUE2QixpQkFDcElQLGdEQUFtQixDQUFDLFVBQVU7UUFBRVEsSUFBSTtRQUFRQyxJQUFJO1FBQU1DLEdBQUc7UUFBTUosTUFBTTtRQUFnQ0ssYUFBYTtJQUFNLGtCQUN4SFgsZ0RBQW1CLENBQUMsVUFBVTtRQUFFUSxJQUFJO1FBQVFDLElBQUk7UUFBTUMsR0FBRztRQUFNRSxRQUFRO1FBQWdDQyxlQUFlO1FBQU9DLGFBQWE7SUFBSSxrQkFDOUlkLGdEQUFtQixDQUFDLEtBQUs7UUFBRWUsVUFBVTtJQUF1QixpQkFDeERmLGdEQUFtQixDQUFDLFFBQVE7UUFBRWdCLEdBQUc7UUFBK3NCVixNQUFNO0lBQStCLGtCQUNyeEJOLGdEQUFtQixDQUFDLFFBQVE7UUFBRWdCLEdBQUc7UUFBbU9WLE1BQU07SUFBK0IsbUJBQzdTTixnREFBbUIsQ0FBQyxRQUFRLG9CQUN4QkEsZ0RBQW1CLENBQUMsa0JBQWtCO1FBQUVpQixJQUFJO1FBQTBCQyxJQUFJO1FBQVdDLElBQUk7UUFBV0MsSUFBSTtRQUFVQyxJQUFJO1FBQVdDLGVBQWU7SUFBaUIsaUJBQzdKdEIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFdUIsV0FBVztJQUFVLGtCQUNuRHZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBUUQsV0FBVztJQUFVLGtCQUNuRXZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBUUQsV0FBVztJQUFVLGtCQUNuRXZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBUUQsV0FBVztJQUFVLGtCQUNuRXZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBUUQsV0FBVztJQUFVLGtCQUNuRXZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBS0QsV0FBVztJQUFVLG1CQUNwRXZCLGdEQUFtQixDQUFDLGtCQUFrQjtRQUFFaUIsSUFBSTtRQUEwQkMsSUFBSTtRQUFXQyxJQUFJO1FBQVdDLElBQUk7UUFBVUMsSUFBSTtRQUFXQyxlQUFlO0lBQWlCLGlCQUM3SnRCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXVCLFdBQVc7SUFBVSxrQkFDbkR2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQVFELFdBQVc7SUFBVSxrQkFDbkV2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQVFELFdBQVc7SUFBVSxrQkFDbkV2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQVFELFdBQVc7SUFBVSxrQkFDbkV2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQVFELFdBQVc7SUFBVSxrQkFDbkV2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQUtELFdBQVc7SUFBVSxtQkFDcEV2QixnREFBbUIsQ0FBQyxrQkFBa0I7UUFBRWlCLElBQUk7UUFBMEJDLElBQUk7UUFBV0MsSUFBSTtRQUFXQyxJQUFJO1FBQVdDLElBQUk7UUFBV0MsZUFBZTtJQUFpQixpQkFDOUp0QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV1QixXQUFXO0lBQVUsa0JBQ25EdkIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFd0IsUUFBUTtRQUFRRCxXQUFXO0lBQVUsa0JBQ25FdkIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFd0IsUUFBUTtRQUFRRCxXQUFXO0lBQVUsa0JBQ25FdkIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFd0IsUUFBUTtRQUFRRCxXQUFXO0lBQVUsa0JBQ25FdkIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFd0IsUUFBUTtRQUFRRCxXQUFXO0lBQVUsa0JBQ25FdkIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFd0IsUUFBUTtRQUFLRCxXQUFXO0lBQVUsbUJBQ3BFdkIsZ0RBQW1CLENBQUMsa0JBQWtCO1FBQUVpQixJQUFJO1FBQTBCQyxJQUFJO1FBQVdDLElBQUk7UUFBV0MsSUFBSTtRQUFXQyxJQUFJO1FBQVdDLGVBQWU7SUFBaUIsaUJBQzlKdEIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFdUIsV0FBVztJQUFVLGtCQUNuRHZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBUUQsV0FBVztJQUFVLGtCQUNuRXZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBUUQsV0FBVztJQUFVLGtCQUNuRXZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBUUQsV0FBVztJQUFVLGtCQUNuRXZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBUUQsV0FBVztJQUFVLGtCQUNuRXZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBS0QsV0FBVztJQUFVLG1CQUNwRXZCLGdEQUFtQixDQUFDLFlBQVk7UUFBRWlCLElBQUk7SUFBaUIsaUJBQ25EakIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFRyxPQUFPO1FBQU1DLFFBQVE7UUFBTUUsTUFBTTtRQUFTbUIsV0FBVztJQUFxQjtBQUN4SCxFQUFFLENBQ0YscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL1dhbGxldFNWRy5qcz80NzQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgY29uc3QgV2FsbGV0U1ZHID0gKCkgPT4ge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHdpZHRoOiBcIjk3XCIsIGhlaWdodDogXCI5NlwiLCB2aWV3Qm94OiBcIjAgMCA5NyA5NlwiLCBmaWxsOiBcIm5vbmVcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHsgY3g6IFwiNDguNVwiLCBjeTogXCI0OFwiLCByOiBcIjQ4XCIsIGZpbGw6IFwidXJsKCNwYWludDBfbGluZWFyXzg4MF81MTE1KVwiLCBmaWxsT3BhY2l0eTogXCIwLjFcIiB9KSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7IGN4OiBcIjQ4LjVcIiwgY3k6IFwiNDhcIiwgcjogXCI0N1wiLCBzdHJva2U6IFwidXJsKCNwYWludDFfbGluZWFyXzg4MF81MTE1KVwiLCBzdHJva2VPcGFjaXR5OiBcIjAuNFwiLCBzdHJva2VXaWR0aDogXCIyXCIgfSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgY2xpcFBhdGg6IFwidXJsKCNjbGlwMF84ODBfNTExNSlcIiB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk02NS41NzY5IDI4LjE1MjNIMzEuNDIzMUMyNy42MDU3IDI4LjE1MjMgMjQuNSAzMS4yNTggMjQuNSAzNS4wNzU0VjYwLjkyMTVDMjQuNSA2NC43Mzg5IDI3LjYwNTcgNjcuODQ0NiAzMS40MjMxIDY3Ljg0NDZINjUuNTc2OUM2OS4zOTQzIDY3Ljg0NDYgNzIuNSA2NC43Mzg5IDcyLjUgNjAuOTIxNVYzNS4wNzU0QzcyLjUgMzEuMjU4IDY5LjM5NDMgMjguMTUyMyA2NS41NzY5IDI4LjE1MjNaTTY5LjczMDggNTIuMTUyM0g1OS41NzY5QzU3LjI4NjUgNTIuMTUyMyA1NS40MjMxIDUwLjI4OSA1NS40MjMxIDQ3Ljk5ODVDNTUuNDIzMSA0NS43MDggNTcuMjg2NCA0My44NDQ2IDU5LjU3NjkgNDMuODQ0Nkg2OS43MzA4VjUyLjE1MjNaTTY5LjczMDggNDEuMDc1NEg1OS41NzY5QzU1Ljc1OTUgNDEuMDc1NCA1Mi42NTM5IDQ0LjE4MTEgNTIuNjUzOSA0Ny45OTg1QzUyLjY1MzkgNTEuODE1OSA1NS43NTk1IDU0LjkyMTUgNTkuNTc2OSA1NC45MjE1SDY5LjczMDhWNjAuOTIxNUM2OS43MzA4IDYzLjIxMTkgNjcuODY3NCA2NS4wNzU0IDY1LjU3NjkgNjUuMDc1NEgzMS40MjMxQzI5LjEzMjcgNjUuMDc1NCAyNy4yNjkyIDYzLjIxMiAyNy4yNjkyIDYwLjkyMTVWMzUuMDc1NEMyNy4yNjkyIDMyLjc4NSAyOS4xMzI2IDMwLjkyMTUgMzEuNDIzMSAzMC45MjE1SDY1LjU3NjlDNjcuODY3MyAzMC45MjE1IDY5LjczMDggMzIuNzg0OSA2OS43MzA4IDM1LjA3NTRWNDEuMDc1NFpcIiwgZmlsbDogXCJ1cmwoI3BhaW50Ml9saW5lYXJfODgwXzUxMTUpXCIgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTYxLjQyMzEgNDYuNjE3Mkg1OS41NzdDNTguODEyMyA0Ni42MTcyIDU4LjE5MjQgNDcuMjM3MSA1OC4xOTI0IDQ4LjAwMThDNTguMTkyNCA0OC43NjY1IDU4LjgxMjMgNDkuMzg2MyA1OS41NzcgNDkuMzg2M0g2MS40MjMxQzYyLjE4NzggNDkuMzg2MyA2Mi44MDc3IDQ4Ljc2NjQgNjIuODA3NyA0OC4wMDE4QzYyLjgwNzcgNDcuMjM3MSA2Mi4xODc4IDQ2LjYxNzIgNjEuNDIzMSA0Ni42MTcyWlwiLCBmaWxsOiBcInVybCgjcGFpbnQzX2xpbmVhcl84ODBfNTExNSlcIiB9KSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIG51bGwsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZWFyR3JhZGllbnRcIiwgeyBpZDogXCJwYWludDBfbGluZWFyXzg4MF81MTE1XCIsIHgxOiBcIjMuNDE2NjRcIiwgeTE6IFwiOTguMDkzM1wiLCB4MjogXCIxMDMuMDVcIiwgeTI6IFwiOC40MjQ5OFwiLCBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IHN0b3BDb2xvcjogXCIjOTk0NUZGXCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC4xNFwiLCBzdG9wQ29sb3I6IFwiIzhBNTNGNFwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuNDJcIiwgc3RvcENvbG9yOiBcIiM2Mzc3RDZcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjc5XCIsIHN0b3BDb2xvcjogXCIjMjRCMEE3XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC45OVwiLCBzdG9wQ29sb3I6IFwiIzAwRDE4Q1wiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjFcIiwgc3RvcENvbG9yOiBcIiMwMEQxOENcIiB9KSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZWFyR3JhZGllbnRcIiwgeyBpZDogXCJwYWludDFfbGluZWFyXzg4MF81MTE1XCIsIHgxOiBcIjMuNDE2NjRcIiwgeTE6IFwiOTguMDkzM1wiLCB4MjogXCIxMDMuMDVcIiwgeTI6IFwiOC40MjQ5OFwiLCBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IHN0b3BDb2xvcjogXCIjOTk0NUZGXCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC4xNFwiLCBzdG9wQ29sb3I6IFwiIzhBNTNGNFwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuNDJcIiwgc3RvcENvbG9yOiBcIiM2Mzc3RDZcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjc5XCIsIHN0b3BDb2xvcjogXCIjMjRCMEE3XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC45OVwiLCBzdG9wQ29sb3I6IFwiIzAwRDE4Q1wiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjFcIiwgc3RvcENvbG9yOiBcIiMwMEQxOENcIiB9KSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZWFyR3JhZGllbnRcIiwgeyBpZDogXCJwYWludDJfbGluZWFyXzg4MF81MTE1XCIsIHgxOiBcIjI1Ljk1ODNcIiwgeTE6IFwiNjguNzEwMVwiLCB4MjogXCI2Ny4yMzM3XCIsIHkyOiBcIjIzLjc4NzlcIiwgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBzdG9wQ29sb3I6IFwiIzk5NDVGRlwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuMTRcIiwgc3RvcENvbG9yOiBcIiM4QTUzRjRcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjQyXCIsIHN0b3BDb2xvcjogXCIjNjM3N0Q2XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC43OVwiLCBzdG9wQ29sb3I6IFwiIzI0QjBBN1wiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuOTlcIiwgc3RvcENvbG9yOiBcIiMwMEQxOENcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIxXCIsIHN0b3BDb2xvcjogXCIjMDBEMThDXCIgfSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVhckdyYWRpZW50XCIsIHsgaWQ6IFwicGFpbnQzX2xpbmVhcl84ODBfNTExNVwiLCB4MTogXCI1OC4zMzI2XCIsIHkxOiBcIjQ5LjQ0NjdcIiwgeDI6IFwiNjEuMDAwMlwiLCB5MjogXCI0NS40NDUzXCIsIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIiB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgc3RvcENvbG9yOiBcIiM5OTQ1RkZcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjE0XCIsIHN0b3BDb2xvcjogXCIjOEE1M0Y0XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC40MlwiLCBzdG9wQ29sb3I6IFwiIzYzNzdENlwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuNzlcIiwgc3RvcENvbG9yOiBcIiMyNEIwQTdcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjk5XCIsIHN0b3BDb2xvcjogXCIjMDBEMThDXCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMVwiLCBzdG9wQ29sb3I6IFwiIzAwRDE4Q1wiIH0pKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiLCB7IGlkOiBcImNsaXAwXzg4MF81MTE1XCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7IHdpZHRoOiBcIjQ4XCIsIGhlaWdodDogXCI0OFwiLCBmaWxsOiBcIndoaXRlXCIsIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoMjQuNSAyNClcIiB9KSkpKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2FsbGV0U1ZHLmpzLm1hcCJdLCJuYW1lcyI6WyJSZWFjdCIsIldhbGxldFNWRyIsImNyZWF0ZUVsZW1lbnQiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdCb3giLCJmaWxsIiwieG1sbnMiLCJjeCIsImN5IiwiciIsImZpbGxPcGFjaXR5Iiwic3Ryb2tlIiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdpZHRoIiwiY2xpcFBhdGgiLCJkIiwiaWQiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImdyYWRpZW50VW5pdHMiLCJzdG9wQ29sb3IiLCJvZmZzZXQiLCJ0cmFuc2Zvcm0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletSVG.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/useWalletModal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/useWalletModal.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletModalContext: () => (/* binding */ WalletModalContext),\n/* harmony export */   useWalletModal: () => (/* binding */ useWalletModal)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst DEFAULT_CONTEXT = {\n    setVisible (_open) {\n        console.error(constructMissingProviderErrorMessage(\"call\", \"setVisible\"));\n    },\n    visible: false\n};\nObject.defineProperty(DEFAULT_CONTEXT, \"visible\", {\n    get () {\n        console.error(constructMissingProviderErrorMessage(\"read\", \"visible\"));\n        return false;\n    }\n});\nfunction constructMissingProviderErrorMessage(action, valueName) {\n    return \"You have tried to \" + ` ${action} \"${valueName}\"` + \" on a WalletModalContext without providing one.\" + \" Make sure to render a WalletModalProvider\" + \" as an ancestor of the component that uses \" + \"WalletModalContext\";\n}\nconst WalletModalContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(DEFAULT_CONTEXT);\nfunction useWalletModal() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(WalletModalContext);\n} //# sourceMappingURL=useWalletModal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL3VzZVdhbGxldE1vZGFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrRDtBQUNsRCxNQUFNRSxrQkFBa0I7SUFDcEJDLFlBQVdDLEtBQUs7UUFDWkMsUUFBUUMsS0FBSyxDQUFDQyxxQ0FBcUMsUUFBUTtJQUMvRDtJQUNBQyxTQUFTO0FBQ2I7QUFDQUMsT0FBT0MsY0FBYyxDQUFDUixpQkFBaUIsV0FBVztJQUM5Q1M7UUFDSU4sUUFBUUMsS0FBSyxDQUFDQyxxQ0FBcUMsUUFBUTtRQUMzRCxPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNBLHFDQUFxQ0ssTUFBTSxFQUFFQyxTQUFTO0lBQzNELE9BQVEsdUJBQ0osQ0FBQyxDQUFDLEVBQUVELE9BQU8sRUFBRSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxHQUMzQixvREFDQSwrQ0FDQSxnREFDQTtBQUNSO0FBQ08sTUFBTUMsbUNBQXFCZCxvREFBYUEsQ0FBQ0UsaUJBQWlCO0FBQzFELFNBQVNhO0lBQ1osT0FBT2QsaURBQVVBLENBQUNhO0FBQ3RCLEVBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL3VzZVdhbGxldE1vZGFsLmpzP2YyMGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmNvbnN0IERFRkFVTFRfQ09OVEVYVCA9IHtcbiAgICBzZXRWaXNpYmxlKF9vcGVuKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY29uc3RydWN0TWlzc2luZ1Byb3ZpZGVyRXJyb3JNZXNzYWdlKCdjYWxsJywgJ3NldFZpc2libGUnKSk7XG4gICAgfSxcbiAgICB2aXNpYmxlOiBmYWxzZSxcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoREVGQVVMVF9DT05URVhULCAndmlzaWJsZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY29uc3RydWN0TWlzc2luZ1Byb3ZpZGVyRXJyb3JNZXNzYWdlKCdyZWFkJywgJ3Zpc2libGUnKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxufSk7XG5mdW5jdGlvbiBjb25zdHJ1Y3RNaXNzaW5nUHJvdmlkZXJFcnJvck1lc3NhZ2UoYWN0aW9uLCB2YWx1ZU5hbWUpIHtcbiAgICByZXR1cm4gKCdZb3UgaGF2ZSB0cmllZCB0byAnICtcbiAgICAgICAgYCAke2FjdGlvbn0gXCIke3ZhbHVlTmFtZX1cImAgK1xuICAgICAgICAnIG9uIGEgV2FsbGV0TW9kYWxDb250ZXh0IHdpdGhvdXQgcHJvdmlkaW5nIG9uZS4nICtcbiAgICAgICAgJyBNYWtlIHN1cmUgdG8gcmVuZGVyIGEgV2FsbGV0TW9kYWxQcm92aWRlcicgK1xuICAgICAgICAnIGFzIGFuIGFuY2VzdG9yIG9mIHRoZSBjb21wb25lbnQgdGhhdCB1c2VzICcgK1xuICAgICAgICAnV2FsbGV0TW9kYWxDb250ZXh0Jyk7XG59XG5leHBvcnQgY29uc3QgV2FsbGV0TW9kYWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dChERUZBVUxUX0NPTlRFWFQpO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVdhbGxldE1vZGFsKCkge1xuICAgIHJldHVybiB1c2VDb250ZXh0KFdhbGxldE1vZGFsQ29udGV4dCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VXYWxsZXRNb2RhbC5qcy5tYXAiXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJERUZBVUxUX0NPTlRFWFQiLCJzZXRWaXNpYmxlIiwiX29wZW4iLCJjb25zb2xlIiwiZXJyb3IiLCJjb25zdHJ1Y3RNaXNzaW5nUHJvdmlkZXJFcnJvck1lc3NhZ2UiLCJ2aXNpYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJhY3Rpb24iLCJ2YWx1ZU5hbWUiLCJXYWxsZXRNb2RhbENvbnRleHQiLCJ1c2VXYWxsZXRNb2RhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/useWalletModal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionProvider: () => (/* binding */ ConnectionProvider)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _useConnection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useConnection.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n\n\n\nconst ConnectionProvider = ({ children, endpoint, config = {\n    commitment: \"confirmed\"\n} })=>{\n    const connection = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(endpoint, config), [\n        endpoint,\n        config\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_useConnection_js__WEBPACK_IMPORTED_MODULE_2__.ConnectionContext.Provider, {\n        value: {\n            connection\n        }\n    }, children);\n}; //# sourceMappingURL=ConnectionProvider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL0Nvbm5lY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZDO0FBQ047QUFDZ0I7QUFDaEQsTUFBTUkscUJBQXFCLENBQUMsRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLFNBQVM7SUFBRUMsWUFBWTtBQUFZLENBQUMsRUFBRztJQUM1RixNQUFNQyxhQUFhUCw4Q0FBT0EsQ0FBQyxJQUFNLElBQUlGLHVEQUFVQSxDQUFDTSxVQUFVQyxTQUFTO1FBQUNEO1FBQVVDO0tBQU87SUFDckYscUJBQU9OLGdEQUFtQixDQUFDRSxnRUFBaUJBLENBQUNRLFFBQVEsRUFBRTtRQUFFQyxPQUFPO1lBQUVIO1FBQVc7SUFBRSxHQUFHSjtBQUN0RixFQUFFLENBQ0YsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL0Nvbm5lY3Rpb25Qcm92aWRlci5qcz9iYjJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDb25uZWN0aW9uQ29udGV4dCB9IGZyb20gJy4vdXNlQ29ubmVjdGlvbi5qcyc7XG5leHBvcnQgY29uc3QgQ29ubmVjdGlvblByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIGVuZHBvaW50LCBjb25maWcgPSB7IGNvbW1pdG1lbnQ6ICdjb25maXJtZWQnIH0sIH0pID0+IHtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gdXNlTWVtbygoKSA9PiBuZXcgQ29ubmVjdGlvbihlbmRwb2ludCwgY29uZmlnKSwgW2VuZHBvaW50LCBjb25maWddKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyBjb25uZWN0aW9uIH0gfSwgY2hpbGRyZW4pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbm5lY3Rpb25Qcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiQ29ubmVjdGlvbiIsIlJlYWN0IiwidXNlTWVtbyIsIkNvbm5lY3Rpb25Db250ZXh0IiwiQ29ubmVjdGlvblByb3ZpZGVyIiwiY2hpbGRyZW4iLCJlbmRwb2ludCIsImNvbmZpZyIsImNvbW1pdG1lbnQiLCJjb25uZWN0aW9uIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletProvider: () => (/* binding */ WalletProvider)\n/* harmony export */ });\n/* harmony import */ var _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana-mobile/wallet-adapter-mobile */ \"(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\");\n/* harmony import */ var _solana_wallet_standard_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-standard-wallet-adapter-react */ \"(ssr)/./node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _getEnvironment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getEnvironment.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js\");\n/* harmony import */ var _getInferredClusterFromEndpoint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getInferredClusterFromEndpoint.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js\");\n/* harmony import */ var _useConnection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useConnection.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n/* harmony import */ var _useLocalStorage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./useLocalStorage.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js\");\n/* harmony import */ var _WalletProviderBase_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WalletProviderBase.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js\");\n\n\n\n\n\n\n\n\nlet _userAgent;\nfunction getUserAgent() {\n    if (_userAgent === undefined) {\n        _userAgent = globalThis.navigator?.userAgent ?? null;\n    }\n    return _userAgent;\n}\nfunction getIsMobile(adapters) {\n    const userAgentString = getUserAgent();\n    return (0,_getEnvironment_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        adapters,\n        userAgentString\n    }) === _getEnvironment_js__WEBPACK_IMPORTED_MODULE_2__.Environment.MOBILE_WEB;\n}\nfunction getUriForAppIdentity() {\n    const location = globalThis.location;\n    if (!location) return;\n    return `${location.protocol}//${location.host}`;\n}\nfunction WalletProvider({ children, wallets: adapters, autoConnect, localStorageKey = \"walletName\", onError }) {\n    const { connection } = (0,_useConnection_js__WEBPACK_IMPORTED_MODULE_3__.useConnection)();\n    const adaptersWithStandardAdapters = (0,_solana_wallet_standard_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__.useStandardWalletAdapters)(adapters);\n    const mobileWalletAdapter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!getIsMobile(adaptersWithStandardAdapters)) {\n            return null;\n        }\n        const existingMobileWalletAdapter = adaptersWithStandardAdapters.find((adapter)=>adapter.name === _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName);\n        if (existingMobileWalletAdapter) {\n            return existingMobileWalletAdapter;\n        }\n        return new _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapter({\n            addressSelector: (0,_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.createDefaultAddressSelector)(),\n            appIdentity: {\n                uri: getUriForAppIdentity()\n            },\n            authorizationResultCache: (0,_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.createDefaultAuthorizationResultCache)(),\n            cluster: (0,_getInferredClusterFromEndpoint_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(connection?.rpcEndpoint),\n            onWalletNotFound: (0,_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.createDefaultWalletNotFoundHandler)()\n        });\n    }, [\n        adaptersWithStandardAdapters,\n        connection?.rpcEndpoint\n    ]);\n    const adaptersWithMobileWalletAdapter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n            return adaptersWithStandardAdapters;\n        }\n        return [\n            mobileWalletAdapter,\n            ...adaptersWithStandardAdapters\n        ];\n    }, [\n        adaptersWithStandardAdapters,\n        mobileWalletAdapter\n    ]);\n    const [walletName, setWalletName] = (0,_useLocalStorage_js__WEBPACK_IMPORTED_MODULE_6__.useLocalStorage)(localStorageKey, null);\n    const adapter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>adaptersWithMobileWalletAdapter.find((a)=>a.name === walletName) ?? null, [\n        adaptersWithMobileWalletAdapter,\n        walletName\n    ]);\n    const changeWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((nextWalletName)=>{\n        if (walletName === nextWalletName) return;\n        if (adapter && // Selecting a wallet other than the mobile wallet adapter is not\n        // sufficient reason to call `disconnect` on the mobile wallet adapter.\n        // Calling `disconnect` on the mobile wallet adapter causes the entire\n        // authorization store to be wiped.\n        adapter.name !== _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName) {\n            adapter.disconnect();\n        }\n        setWalletName(nextWalletName);\n    }, [\n        adapter,\n        setWalletName,\n        walletName\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!adapter) return;\n        function handleDisconnect() {\n            if (isUnloadingRef.current) return;\n            setWalletName(null);\n        }\n        adapter.on(\"disconnect\", handleDisconnect);\n        return ()=>{\n            adapter.off(\"disconnect\", handleDisconnect);\n        };\n    }, [\n        adapter,\n        adaptersWithStandardAdapters,\n        setWalletName,\n        walletName\n    ]);\n    const hasUserSelectedAWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const handleAutoConnectRequest = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!autoConnect || !adapter) return;\n        return async ()=>{\n            // If autoConnect is true or returns true, use the default autoConnect behavior.\n            if (autoConnect === true || await autoConnect(adapter)) {\n                if (hasUserSelectedAWallet.current) {\n                    await adapter.connect();\n                } else {\n                    await adapter.autoConnect();\n                }\n            }\n        };\n    }, [\n        autoConnect,\n        adapter\n    ]);\n    const isUnloadingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (walletName === _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n            isUnloadingRef.current = false;\n            return;\n        }\n        function handleBeforeUnload() {\n            isUnloadingRef.current = true;\n        }\n        /**\n         * Some wallets fire disconnection events when the window unloads. Since there's no way to\n         * distinguish between a disconnection event received because a user initiated it, and one\n         * that was received because they've closed the window, we have to track window unload\n         * events themselves. Downstream components use this information to decide whether to act\n         * upon or drop wallet events and errors.\n         */ window.addEventListener(\"beforeunload\", handleBeforeUnload);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", handleBeforeUnload);\n        };\n    }, [\n        adaptersWithStandardAdapters,\n        walletName\n    ]);\n    const handleConnectError = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (adapter) {\n            // If any error happens while connecting, unset the adapter.\n            changeWallet(null);\n        }\n    }, [\n        adapter,\n        changeWallet\n    ]);\n    const selectWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((walletName)=>{\n        hasUserSelectedAWallet.current = true;\n        changeWallet(walletName);\n    }, [\n        changeWallet\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_WalletProviderBase_js__WEBPACK_IMPORTED_MODULE_7__.WalletProviderBase, {\n        wallets: adaptersWithMobileWalletAdapter,\n        adapter: adapter,\n        isUnloadingRef: isUnloadingRef,\n        onAutoConnectRequest: handleAutoConnectRequest,\n        onConnectError: handleConnectError,\n        onError: onError,\n        onSelectWallet: selectWallet\n    }, children);\n} //# sourceMappingURL=WalletProvider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL1dhbGxldFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFnTztBQUN2STtBQUNsQjtBQUNMO0FBQ2U7QUFDOUI7QUFDSTtBQUNNO0FBQzdELElBQUlpQjtBQUNKLFNBQVNDO0lBQ0wsSUFBSUQsZUFBZUUsV0FBVztRQUMxQkYsYUFBYUcsV0FBV0MsU0FBUyxFQUFFQyxhQUFhO0lBQ3BEO0lBQ0EsT0FBT0w7QUFDWDtBQUNBLFNBQVNNLFlBQVlDLFFBQVE7SUFDekIsTUFBTUMsa0JBQWtCUDtJQUN4QixPQUFPUCw4REFBY0EsQ0FBQztRQUFFYTtRQUFVQztJQUFnQixPQUFPYiwyREFBV0EsQ0FBQ2MsVUFBVTtBQUNuRjtBQUNBLFNBQVNDO0lBQ0wsTUFBTUMsV0FBV1IsV0FBV1EsUUFBUTtJQUNwQyxJQUFJLENBQUNBLFVBQ0Q7SUFDSixPQUFPLENBQUMsRUFBRUEsU0FBU0MsUUFBUSxDQUFDLEVBQUUsRUFBRUQsU0FBU0UsSUFBSSxDQUFDLENBQUM7QUFDbkQ7QUFDTyxTQUFTQyxlQUFlLEVBQUVDLFFBQVEsRUFBRUMsU0FBU1QsUUFBUSxFQUFFVSxXQUFXLEVBQUVDLGtCQUFrQixZQUFZLEVBQUVDLE9BQU8sRUFBRztJQUNqSCxNQUFNLEVBQUVDLFVBQVUsRUFBRSxHQUFHdkIsZ0VBQWFBO0lBQ3BDLE1BQU13QiwrQkFBK0JqQyx1R0FBeUJBLENBQUNtQjtJQUMvRCxNQUFNZSxzQkFBc0I5Qiw4Q0FBT0EsQ0FBQztRQUNoQyxJQUFJLENBQUNjLFlBQVllLCtCQUErQjtZQUM1QyxPQUFPO1FBQ1g7UUFDQSxNQUFNRSw4QkFBOEJGLDZCQUE2QkcsSUFBSSxDQUFDLENBQUNDLFVBQVlBLFFBQVFDLElBQUksS0FBS3ZDLHFHQUFtQ0E7UUFDdkksSUFBSW9DLDZCQUE2QjtZQUM3QixPQUFPQTtRQUNYO1FBQ0EsT0FBTyxJQUFJckMsMkZBQXlC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UWxELGdEQUFtQixDQUFDVSxzRUFBa0JBLEVBQUU7UUFBRWlCLFNBQVNrQjtRQUFpQ1QsU0FBU0E7UUFBU2tCLGdCQUFnQkE7UUFBZ0JjLHNCQUFzQlQ7UUFBMEJVLGdCQUFnQko7UUFBb0JuQyxTQUFTQTtRQUFTd0MsZ0JBQWdCSjtJQUFhLEdBQUd4QztBQUN4UixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9XYWxsZXRQcm92aWRlci5qcz9mM2E5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZURlZmF1bHRBZGRyZXNzU2VsZWN0b3IsIGNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUsIGNyZWF0ZURlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXIsIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXIsIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lLCB9IGZyb20gJ0Bzb2xhbmEtbW9iaWxlL3dhbGxldC1hZGFwdGVyLW1vYmlsZSc7XG5pbXBvcnQgeyB1c2VTdGFuZGFyZFdhbGxldEFkYXB0ZXJzIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtd2FsbGV0LWFkYXB0ZXItcmVhY3QnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBnZXRFbnZpcm9ubWVudCwgeyBFbnZpcm9ubWVudCB9IGZyb20gJy4vZ2V0RW52aXJvbm1lbnQuanMnO1xuaW1wb3J0IGdldEluZmVycmVkQ2x1c3RlckZyb21FbmRwb2ludCBmcm9tICcuL2dldEluZmVycmVkQ2x1c3RlckZyb21FbmRwb2ludC5qcyc7XG5pbXBvcnQgeyB1c2VDb25uZWN0aW9uIH0gZnJvbSAnLi91c2VDb25uZWN0aW9uLmpzJztcbmltcG9ydCB7IHVzZUxvY2FsU3RvcmFnZSB9IGZyb20gJy4vdXNlTG9jYWxTdG9yYWdlLmpzJztcbmltcG9ydCB7IFdhbGxldFByb3ZpZGVyQmFzZSB9IGZyb20gJy4vV2FsbGV0UHJvdmlkZXJCYXNlLmpzJztcbmxldCBfdXNlckFnZW50O1xuZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICAgIGlmIChfdXNlckFnZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3VzZXJBZ2VudCA9IGdsb2JhbFRoaXMubmF2aWdhdG9yPy51c2VyQWdlbnQgPz8gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF91c2VyQWdlbnQ7XG59XG5mdW5jdGlvbiBnZXRJc01vYmlsZShhZGFwdGVycykge1xuICAgIGNvbnN0IHVzZXJBZ2VudFN0cmluZyA9IGdldFVzZXJBZ2VudCgpO1xuICAgIHJldHVybiBnZXRFbnZpcm9ubWVudCh7IGFkYXB0ZXJzLCB1c2VyQWdlbnRTdHJpbmcgfSkgPT09IEVudmlyb25tZW50Lk1PQklMRV9XRUI7XG59XG5mdW5jdGlvbiBnZXRVcmlGb3JBcHBJZGVudGl0eSgpIHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IGdsb2JhbFRoaXMubG9jYXRpb247XG4gICAgaWYgKCFsb2NhdGlvbilcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiBgJHtsb2NhdGlvbi5wcm90b2NvbH0vLyR7bG9jYXRpb24uaG9zdH1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIFdhbGxldFByb3ZpZGVyKHsgY2hpbGRyZW4sIHdhbGxldHM6IGFkYXB0ZXJzLCBhdXRvQ29ubmVjdCwgbG9jYWxTdG9yYWdlS2V5ID0gJ3dhbGxldE5hbWUnLCBvbkVycm9yLCB9KSB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSB1c2VDb25uZWN0aW9uKCk7XG4gICAgY29uc3QgYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycyA9IHVzZVN0YW5kYXJkV2FsbGV0QWRhcHRlcnMoYWRhcHRlcnMpO1xuICAgIGNvbnN0IG1vYmlsZVdhbGxldEFkYXB0ZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFnZXRJc01vYmlsZShhZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhpc3RpbmdNb2JpbGVXYWxsZXRBZGFwdGVyID0gYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycy5maW5kKChhZGFwdGVyKSA9PiBhZGFwdGVyLm5hbWUgPT09IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nTW9iaWxlV2FsbGV0QWRhcHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nTW9iaWxlV2FsbGV0QWRhcHRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXIoe1xuICAgICAgICAgICAgYWRkcmVzc1NlbGVjdG9yOiBjcmVhdGVEZWZhdWx0QWRkcmVzc1NlbGVjdG9yKCksXG4gICAgICAgICAgICBhcHBJZGVudGl0eToge1xuICAgICAgICAgICAgICAgIHVyaTogZ2V0VXJpRm9yQXBwSWRlbnRpdHkoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uUmVzdWx0Q2FjaGU6IGNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUoKSxcbiAgICAgICAgICAgIGNsdXN0ZXI6IGdldEluZmVycmVkQ2x1c3RlckZyb21FbmRwb2ludChjb25uZWN0aW9uPy5ycGNFbmRwb2ludCksXG4gICAgICAgICAgICBvbldhbGxldE5vdEZvdW5kOiBjcmVhdGVEZWZhdWx0V2FsbGV0Tm90Rm91bmRIYW5kbGVyKCksXG4gICAgICAgIH0pO1xuICAgIH0sIFthZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzLCBjb25uZWN0aW9uPy5ycGNFbmRwb2ludF0pO1xuICAgIGNvbnN0IGFkYXB0ZXJzV2l0aE1vYmlsZVdhbGxldEFkYXB0ZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKG1vYmlsZVdhbGxldEFkYXB0ZXIgPT0gbnVsbCB8fCBhZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzLmluZGV4T2YobW9iaWxlV2FsbGV0QWRhcHRlcikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW21vYmlsZVdhbGxldEFkYXB0ZXIsIC4uLmFkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnNdO1xuICAgIH0sIFthZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzLCBtb2JpbGVXYWxsZXRBZGFwdGVyXSk7XG4gICAgY29uc3QgW3dhbGxldE5hbWUsIHNldFdhbGxldE5hbWVdID0gdXNlTG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZUtleSwgbnVsbCk7XG4gICAgY29uc3QgYWRhcHRlciA9IHVzZU1lbW8oKCkgPT4gYWRhcHRlcnNXaXRoTW9iaWxlV2FsbGV0QWRhcHRlci5maW5kKChhKSA9PiBhLm5hbWUgPT09IHdhbGxldE5hbWUpID8/IG51bGwsIFthZGFwdGVyc1dpdGhNb2JpbGVXYWxsZXRBZGFwdGVyLCB3YWxsZXROYW1lXSk7XG4gICAgY29uc3QgY2hhbmdlV2FsbGV0ID0gdXNlQ2FsbGJhY2soKG5leHRXYWxsZXROYW1lKSA9PiB7XG4gICAgICAgIGlmICh3YWxsZXROYW1lID09PSBuZXh0V2FsbGV0TmFtZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGFkYXB0ZXIgJiZcbiAgICAgICAgICAgIC8vIFNlbGVjdGluZyBhIHdhbGxldCBvdGhlciB0aGFuIHRoZSBtb2JpbGUgd2FsbGV0IGFkYXB0ZXIgaXMgbm90XG4gICAgICAgICAgICAvLyBzdWZmaWNpZW50IHJlYXNvbiB0byBjYWxsIGBkaXNjb25uZWN0YCBvbiB0aGUgbW9iaWxlIHdhbGxldCBhZGFwdGVyLlxuICAgICAgICAgICAgLy8gQ2FsbGluZyBgZGlzY29ubmVjdGAgb24gdGhlIG1vYmlsZSB3YWxsZXQgYWRhcHRlciBjYXVzZXMgdGhlIGVudGlyZVxuICAgICAgICAgICAgLy8gYXV0aG9yaXphdGlvbiBzdG9yZSB0byBiZSB3aXBlZC5cbiAgICAgICAgICAgIGFkYXB0ZXIubmFtZSAhPT0gU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUpIHtcbiAgICAgICAgICAgIGFkYXB0ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHNldFdhbGxldE5hbWUobmV4dFdhbGxldE5hbWUpO1xuICAgIH0sIFthZGFwdGVyLCBzZXRXYWxsZXROYW1lLCB3YWxsZXROYW1lXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFhZGFwdGVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVEaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgaWYgKGlzVW5sb2FkaW5nUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0V2FsbGV0TmFtZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBhZGFwdGVyLm9uKCdkaXNjb25uZWN0JywgaGFuZGxlRGlzY29ubmVjdCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBhZGFwdGVyLm9mZignZGlzY29ubmVjdCcsIGhhbmRsZURpc2Nvbm5lY3QpO1xuICAgICAgICB9O1xuICAgIH0sIFthZGFwdGVyLCBhZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzLCBzZXRXYWxsZXROYW1lLCB3YWxsZXROYW1lXSk7XG4gICAgY29uc3QgaGFzVXNlclNlbGVjdGVkQVdhbGxldCA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgaGFuZGxlQXV0b0Nvbm5lY3RSZXF1ZXN0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghYXV0b0Nvbm5lY3QgfHwgIWFkYXB0ZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBhdXRvQ29ubmVjdCBpcyB0cnVlIG9yIHJldHVybnMgdHJ1ZSwgdXNlIHRoZSBkZWZhdWx0IGF1dG9Db25uZWN0IGJlaGF2aW9yLlxuICAgICAgICAgICAgaWYgKGF1dG9Db25uZWN0ID09PSB0cnVlIHx8IChhd2FpdCBhdXRvQ29ubmVjdChhZGFwdGVyKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVXNlclNlbGVjdGVkQVdhbGxldC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGFkYXB0ZXIuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWRhcHRlci5hdXRvQ29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbYXV0b0Nvbm5lY3QsIGFkYXB0ZXJdKTtcbiAgICBjb25zdCBpc1VubG9hZGluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHdhbGxldE5hbWUgPT09IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lICYmIGdldElzTW9iaWxlKGFkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnMpKSB7XG4gICAgICAgICAgICBpc1VubG9hZGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQmVmb3JlVW5sb2FkKCkge1xuICAgICAgICAgICAgaXNVbmxvYWRpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbWUgd2FsbGV0cyBmaXJlIGRpc2Nvbm5lY3Rpb24gZXZlbnRzIHdoZW4gdGhlIHdpbmRvdyB1bmxvYWRzLiBTaW5jZSB0aGVyZSdzIG5vIHdheSB0b1xuICAgICAgICAgKiBkaXN0aW5ndWlzaCBiZXR3ZWVuIGEgZGlzY29ubmVjdGlvbiBldmVudCByZWNlaXZlZCBiZWNhdXNlIGEgdXNlciBpbml0aWF0ZWQgaXQsIGFuZCBvbmVcbiAgICAgICAgICogdGhhdCB3YXMgcmVjZWl2ZWQgYmVjYXVzZSB0aGV5J3ZlIGNsb3NlZCB0aGUgd2luZG93LCB3ZSBoYXZlIHRvIHRyYWNrIHdpbmRvdyB1bmxvYWRcbiAgICAgICAgICogZXZlbnRzIHRoZW1zZWx2ZXMuIERvd25zdHJlYW0gY29tcG9uZW50cyB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZWNpZGUgd2hldGhlciB0byBhY3RcbiAgICAgICAgICogdXBvbiBvciBkcm9wIHdhbGxldCBldmVudHMgYW5kIGVycm9ycy5cbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBoYW5kbGVCZWZvcmVVbmxvYWQpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGhhbmRsZUJlZm9yZVVubG9hZCk7XG4gICAgICAgIH07XG4gICAgfSwgW2FkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnMsIHdhbGxldE5hbWVdKTtcbiAgICBjb25zdCBoYW5kbGVDb25uZWN0RXJyb3IgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChhZGFwdGVyKSB7XG4gICAgICAgICAgICAvLyBJZiBhbnkgZXJyb3IgaGFwcGVucyB3aGlsZSBjb25uZWN0aW5nLCB1bnNldCB0aGUgYWRhcHRlci5cbiAgICAgICAgICAgIGNoYW5nZVdhbGxldChudWxsKTtcbiAgICAgICAgfVxuICAgIH0sIFthZGFwdGVyLCBjaGFuZ2VXYWxsZXRdKTtcbiAgICBjb25zdCBzZWxlY3RXYWxsZXQgPSB1c2VDYWxsYmFjaygod2FsbGV0TmFtZSkgPT4ge1xuICAgICAgICBoYXNVc2VyU2VsZWN0ZWRBV2FsbGV0LmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBjaGFuZ2VXYWxsZXQod2FsbGV0TmFtZSk7XG4gICAgfSwgW2NoYW5nZVdhbGxldF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChXYWxsZXRQcm92aWRlckJhc2UsIHsgd2FsbGV0czogYWRhcHRlcnNXaXRoTW9iaWxlV2FsbGV0QWRhcHRlciwgYWRhcHRlcjogYWRhcHRlciwgaXNVbmxvYWRpbmdSZWY6IGlzVW5sb2FkaW5nUmVmLCBvbkF1dG9Db25uZWN0UmVxdWVzdDogaGFuZGxlQXV0b0Nvbm5lY3RSZXF1ZXN0LCBvbkNvbm5lY3RFcnJvcjogaGFuZGxlQ29ubmVjdEVycm9yLCBvbkVycm9yOiBvbkVycm9yLCBvblNlbGVjdFdhbGxldDogc2VsZWN0V2FsbGV0IH0sIGNoaWxkcmVuKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XYWxsZXRQcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiY3JlYXRlRGVmYXVsdEFkZHJlc3NTZWxlY3RvciIsImNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUiLCJjcmVhdGVEZWZhdWx0V2FsbGV0Tm90Rm91bmRIYW5kbGVyIiwiU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlciIsIlNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lIiwidXNlU3RhbmRhcmRXYWxsZXRBZGFwdGVycyIsIlJlYWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwiZ2V0RW52aXJvbm1lbnQiLCJFbnZpcm9ubWVudCIsImdldEluZmVycmVkQ2x1c3RlckZyb21FbmRwb2ludCIsInVzZUNvbm5lY3Rpb24iLCJ1c2VMb2NhbFN0b3JhZ2UiLCJXYWxsZXRQcm92aWRlckJhc2UiLCJfdXNlckFnZW50IiwiZ2V0VXNlckFnZW50IiwidW5kZWZpbmVkIiwiZ2xvYmFsVGhpcyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImdldElzTW9iaWxlIiwiYWRhcHRlcnMiLCJ1c2VyQWdlbnRTdHJpbmciLCJNT0JJTEVfV0VCIiwiZ2V0VXJpRm9yQXBwSWRlbnRpdHkiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiaG9zdCIsIldhbGxldFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ3YWxsZXRzIiwiYXV0b0Nvbm5lY3QiLCJsb2NhbFN0b3JhZ2VLZXkiLCJvbkVycm9yIiwiY29ubmVjdGlvbiIsImFkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnMiLCJtb2JpbGVXYWxsZXRBZGFwdGVyIiwiZXhpc3RpbmdNb2JpbGVXYWxsZXRBZGFwdGVyIiwiZmluZCIsImFkYXB0ZXIiLCJuYW1lIiwiYWRkcmVzc1NlbGVjdG9yIiwiYXBwSWRlbnRpdHkiLCJ1cmkiLCJhdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUiLCJjbHVzdGVyIiwicnBjRW5kcG9pbnQiLCJvbldhbGxldE5vdEZvdW5kIiwiYWRhcHRlcnNXaXRoTW9iaWxlV2FsbGV0QWRhcHRlciIsImluZGV4T2YiLCJ3YWxsZXROYW1lIiwic2V0V2FsbGV0TmFtZSIsImEiLCJjaGFuZ2VXYWxsZXQiLCJuZXh0V2FsbGV0TmFtZSIsImRpc2Nvbm5lY3QiLCJoYW5kbGVEaXNjb25uZWN0IiwiaXNVbmxvYWRpbmdSZWYiLCJjdXJyZW50Iiwib24iLCJvZmYiLCJoYXNVc2VyU2VsZWN0ZWRBV2FsbGV0IiwiaGFuZGxlQXV0b0Nvbm5lY3RSZXF1ZXN0IiwiY29ubmVjdCIsImhhbmRsZUJlZm9yZVVubG9hZCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlQ29ubmVjdEVycm9yIiwic2VsZWN0V2FsbGV0IiwiY3JlYXRlRWxlbWVudCIsIm9uQXV0b0Nvbm5lY3RSZXF1ZXN0Iiwib25Db25uZWN0RXJyb3IiLCJvblNlbGVjdFdhbGxldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletProviderBase: () => (/* binding */ WalletProviderBase)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js\");\n/* harmony import */ var _useWallet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useWallet.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n\n\n\n\nfunction WalletProviderBase({ children, wallets: adapters, adapter, isUnloadingRef, onAutoConnectRequest, onConnectError, onError, onSelectWallet }) {\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [connecting, setConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const isDisconnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [disconnecting, setDisconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [publicKey, setPublicKey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>adapter?.publicKey ?? null);\n    const [connected, setConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>adapter?.connected ?? false);\n    /**\n     * Store the error handlers as refs so that a change in the\n     * custom error handler does not recompute other dependencies.\n     */ const onErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onError);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        onErrorRef.current = onError;\n        return ()=>{\n            onErrorRef.current = undefined;\n        };\n    }, [\n        onError\n    ]);\n    const handleErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)((error, adapter)=>{\n        if (!isUnloadingRef.current) {\n            if (onErrorRef.current) {\n                onErrorRef.current(error, adapter);\n            } else {\n                console.error(error, adapter);\n                if (error instanceof _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotReadyError && \"undefined\" !== \"undefined\" && 0) {}\n            }\n        }\n        return error;\n    });\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>adapters.map((adapter)=>({\n                adapter,\n                readyState: adapter.readyState\n            })).filter(({ readyState })=>readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported));\n    // When the adapters change, start to listen for changes to their `readyState`\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // When the adapters change, wrap them to conform to the `Wallet` interface\n        setWallets((wallets)=>adapters.map((adapter, index)=>{\n                const wallet = wallets[index];\n                // If the wallet hasn't changed, return the same instance\n                return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState ? wallet : {\n                    adapter: adapter,\n                    readyState: adapter.readyState\n                };\n            }).filter(({ readyState })=>readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported));\n        function handleReadyStateChange(readyState) {\n            setWallets((prevWallets)=>{\n                const index = prevWallets.findIndex(({ adapter })=>adapter === this);\n                if (index === -1) return prevWallets;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const { adapter } = prevWallets[index];\n                return [\n                    ...prevWallets.slice(0, index),\n                    {\n                        adapter,\n                        readyState\n                    },\n                    ...prevWallets.slice(index + 1)\n                ].filter(({ readyState })=>readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported);\n            });\n        }\n        adapters.forEach((adapter)=>adapter.on(\"readyStateChange\", handleReadyStateChange, adapter));\n        return ()=>{\n            adapters.forEach((adapter)=>adapter.off(\"readyStateChange\", handleReadyStateChange, adapter));\n        };\n    }, [\n        adapter,\n        adapters\n    ]);\n    const wallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>wallets.find((wallet)=>wallet.adapter === adapter) ?? null, [\n        adapter,\n        wallets\n    ]);\n    // Setup and teardown event listeners when the adapter changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!adapter) return;\n        const handleConnect = (publicKey)=>{\n            setPublicKey(publicKey);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(true);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n        const handleDisconnect = ()=>{\n            if (isUnloadingRef.current) return;\n            setPublicKey(null);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(false);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n        const handleError = (error)=>{\n            handleErrorRef.current(error, adapter);\n        };\n        adapter.on(\"connect\", handleConnect);\n        adapter.on(\"disconnect\", handleDisconnect);\n        adapter.on(\"error\", handleError);\n        return ()=>{\n            adapter.off(\"connect\", handleConnect);\n            adapter.off(\"disconnect\", handleDisconnect);\n            adapter.off(\"error\", handleError);\n            handleDisconnect();\n        };\n    }, [\n        adapter,\n        isUnloadingRef\n    ]);\n    // When the adapter changes, clear the `autoConnect` tracking flag\n    const didAttemptAutoConnectRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            didAttemptAutoConnectRef.current = false;\n        };\n    }, [\n        adapter\n    ]);\n    // If auto-connect is enabled, request to connect when the adapter changes and is ready\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (didAttemptAutoConnectRef.current || isConnectingRef.current || connected || !onAutoConnectRequest || !(wallet?.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed || wallet?.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Loadable)) return;\n        isConnectingRef.current = true;\n        setConnecting(true);\n        didAttemptAutoConnectRef.current = true;\n        (async function() {\n            try {\n                await onAutoConnectRequest();\n            } catch  {\n                onConnectError();\n            // Drop the error. It will be caught by `handleError` anyway.\n            } finally{\n                setConnecting(false);\n                isConnectingRef.current = false;\n            }\n        })();\n    }, [\n        connected,\n        onAutoConnectRequest,\n        onConnectError,\n        wallet\n    ]);\n    // Send a transaction using the provided connection\n    const sendTransaction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (transaction, connection, options)=>{\n        if (!adapter) throw handleErrorRef.current(new _errors_js__WEBPACK_IMPORTED_MODULE_3__.WalletNotSelectedError());\n        if (!connected) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n        return await adapter.sendTransaction(transaction, connection, options);\n    }, [\n        adapter,\n        connected\n    ]);\n    // Sign a transaction if the wallet supports it\n    const signTransaction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>adapter && \"signTransaction\" in adapter ? async (transaction)=>{\n            if (!connected) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n            return await adapter.signTransaction(transaction);\n        } : undefined, [\n        adapter,\n        connected\n    ]);\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>adapter && \"signAllTransactions\" in adapter ? async (transactions)=>{\n            if (!connected) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n            return await adapter.signAllTransactions(transactions);\n        } : undefined, [\n        adapter,\n        connected\n    ]);\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>adapter && \"signMessage\" in adapter ? async (message)=>{\n            if (!connected) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n            return await adapter.signMessage(message);\n        } : undefined, [\n        adapter,\n        connected\n    ]);\n    // Sign in if the wallet supports it\n    const signIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>adapter && \"signIn\" in adapter ? async (input)=>{\n            return await adapter.signIn(input);\n        } : undefined, [\n        adapter\n    ]);\n    const handleConnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (isConnectingRef.current || isDisconnectingRef.current || wallet?.adapter.connected) return;\n        if (!wallet) throw handleErrorRef.current(new _errors_js__WEBPACK_IMPORTED_MODULE_3__.WalletNotSelectedError());\n        const { adapter, readyState } = wallet;\n        if (!(readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed || readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Loadable)) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotReadyError(), adapter);\n        isConnectingRef.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect();\n        } catch (e) {\n            onConnectError();\n            throw e;\n        } finally{\n            setConnecting(false);\n            isConnectingRef.current = false;\n        }\n    }, [\n        onConnectError,\n        wallet\n    ]);\n    const handleDisconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (isDisconnectingRef.current) return;\n        if (!adapter) return;\n        isDisconnectingRef.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        } finally{\n            setDisconnecting(false);\n            isDisconnectingRef.current = false;\n        }\n    }, [\n        adapter\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_useWallet_js__WEBPACK_IMPORTED_MODULE_4__.WalletContext.Provider, {\n        value: {\n            autoConnect: !!onAutoConnectRequest,\n            wallets,\n            wallet,\n            publicKey,\n            connected,\n            connecting,\n            disconnecting,\n            select: onSelectWallet,\n            connect: handleConnect,\n            disconnect: handleDisconnect,\n            sendTransaction,\n            signTransaction,\n            signAllTransactions,\n            signMessage,\n            signIn\n        }\n    }, children);\n} //# sourceMappingURL=WalletProviderBase.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL1dhbGxldFByb3ZpZGVyQmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBOEc7QUFDN0I7QUFDNUI7QUFDTjtBQUN4QyxTQUFTVyxtQkFBbUIsRUFBRUMsUUFBUSxFQUFFQyxTQUFTQyxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFQyxvQkFBb0IsRUFBRUMsY0FBYyxFQUFFQyxPQUFPLEVBQUVDLGNBQWMsRUFBRztJQUN2SixNQUFNQyxrQkFBa0JkLDZDQUFNQSxDQUFDO0lBQy9CLE1BQU0sQ0FBQ2UsWUFBWUMsY0FBYyxHQUFHZiwrQ0FBUUEsQ0FBQztJQUM3QyxNQUFNZ0IscUJBQXFCakIsNkNBQU1BLENBQUM7SUFDbEMsTUFBTSxDQUFDa0IsZUFBZUMsaUJBQWlCLEdBQUdsQiwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNtQixXQUFXQyxhQUFhLEdBQUdwQiwrQ0FBUUEsQ0FBQyxJQUFNTyxTQUFTWSxhQUFhO0lBQ3ZFLE1BQU0sQ0FBQ0UsV0FBV0MsYUFBYSxHQUFHdEIsK0NBQVFBLENBQUMsSUFBTU8sU0FBU2MsYUFBYTtJQUN2RTs7O0tBR0MsR0FDRCxNQUFNRSxhQUFheEIsNkNBQU1BLENBQUNZO0lBQzFCZCxnREFBU0EsQ0FBQztRQUNOMEIsV0FBV0MsT0FBTyxHQUFHYjtRQUNyQixPQUFPO1lBQ0hZLFdBQVdDLE9BQU8sR0FBR0M7UUFDekI7SUFDSixHQUFHO1FBQUNkO0tBQVE7SUFDWixNQUFNZSxpQkFBaUIzQiw2Q0FBTUEsQ0FBQyxDQUFDNEIsT0FBT3BCO1FBQ2xDLElBQUksQ0FBQ0MsZUFBZWdCLE9BQU8sRUFBRTtZQUN6QixJQUFJRCxXQUFXQyxPQUFPLEVBQUU7Z0JBQ3BCRCxXQUFXQyxPQUFPLENBQUNHLE9BQU9wQjtZQUM5QixPQUNLO2dCQUNEcUIsUUFBUUQsS0FBSyxDQUFDQSxPQUFPcEI7Z0JBQ3JCLElBQUlv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akI7WUFDVG1CLFlBQVlsQjtZQUNaSztZQUNBSTtZQUNBQztZQUNBRTtZQUNBRTtRQUNKO0lBQUUsR0FBRzFEO0FBQ2IsRUFDQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vV2FsbGV0UHJvdmlkZXJCYXNlLmpzP2RhYWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IsIFdhbGxldE5vdFJlYWR5RXJyb3IsIFdhbGxldFJlYWR5U3RhdGUsIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlJztcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgV2FsbGV0Tm90U2VsZWN0ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IFdhbGxldENvbnRleHQgfSBmcm9tICcuL3VzZVdhbGxldC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gV2FsbGV0UHJvdmlkZXJCYXNlKHsgY2hpbGRyZW4sIHdhbGxldHM6IGFkYXB0ZXJzLCBhZGFwdGVyLCBpc1VubG9hZGluZ1JlZiwgb25BdXRvQ29ubmVjdFJlcXVlc3QsIG9uQ29ubmVjdEVycm9yLCBvbkVycm9yLCBvblNlbGVjdFdhbGxldCwgfSkge1xuICAgIGNvbnN0IGlzQ29ubmVjdGluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgW2Nvbm5lY3RpbmcsIHNldENvbm5lY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGlzRGlzY29ubmVjdGluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgW2Rpc2Nvbm5lY3RpbmcsIHNldERpc2Nvbm5lY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtwdWJsaWNLZXksIHNldFB1YmxpY0tleV0gPSB1c2VTdGF0ZSgoKSA9PiBhZGFwdGVyPy5wdWJsaWNLZXkgPz8gbnVsbCk7XG4gICAgY29uc3QgW2Nvbm5lY3RlZCwgc2V0Q29ubmVjdGVkXSA9IHVzZVN0YXRlKCgpID0+IGFkYXB0ZXI/LmNvbm5lY3RlZCA/PyBmYWxzZSk7XG4gICAgLyoqXG4gICAgICogU3RvcmUgdGhlIGVycm9yIGhhbmRsZXJzIGFzIHJlZnMgc28gdGhhdCBhIGNoYW5nZSBpbiB0aGVcbiAgICAgKiBjdXN0b20gZXJyb3IgaGFuZGxlciBkb2VzIG5vdCByZWNvbXB1dGUgb3RoZXIgZGVwZW5kZW5jaWVzLlxuICAgICAqL1xuICAgIGNvbnN0IG9uRXJyb3JSZWYgPSB1c2VSZWYob25FcnJvcik7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgb25FcnJvclJlZi5jdXJyZW50ID0gb25FcnJvcjtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG9uRXJyb3JSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICB9LCBbb25FcnJvcl0pO1xuICAgIGNvbnN0IGhhbmRsZUVycm9yUmVmID0gdXNlUmVmKChlcnJvciwgYWRhcHRlcikgPT4ge1xuICAgICAgICBpZiAoIWlzVW5sb2FkaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmIChvbkVycm9yUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yUmVmLmN1cnJlbnQoZXJyb3IsIGFkYXB0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvciwgYWRhcHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgV2FsbGV0Tm90UmVhZHlFcnJvciAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBhZGFwdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKGFkYXB0ZXIudXJsLCAnX2JsYW5rJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9KTtcbiAgICAvLyBXcmFwIGFkYXB0ZXJzIHRvIGNvbmZvcm0gdG8gdGhlIGBXYWxsZXRgIGludGVyZmFjZVxuICAgIGNvbnN0IFt3YWxsZXRzLCBzZXRXYWxsZXRzXSA9IHVzZVN0YXRlKCgpID0+IGFkYXB0ZXJzXG4gICAgICAgIC5tYXAoKGFkYXB0ZXIpID0+ICh7XG4gICAgICAgIGFkYXB0ZXIsXG4gICAgICAgIHJlYWR5U3RhdGU6IGFkYXB0ZXIucmVhZHlTdGF0ZSxcbiAgICB9KSlcbiAgICAgICAgLmZpbHRlcigoeyByZWFkeVN0YXRlIH0pID0+IHJlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuVW5zdXBwb3J0ZWQpKTtcbiAgICAvLyBXaGVuIHRoZSBhZGFwdGVycyBjaGFuZ2UsIHN0YXJ0IHRvIGxpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGVpciBgcmVhZHlTdGF0ZWBcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBXaGVuIHRoZSBhZGFwdGVycyBjaGFuZ2UsIHdyYXAgdGhlbSB0byBjb25mb3JtIHRvIHRoZSBgV2FsbGV0YCBpbnRlcmZhY2VcbiAgICAgICAgc2V0V2FsbGV0cygod2FsbGV0cykgPT4gYWRhcHRlcnNcbiAgICAgICAgICAgIC5tYXAoKGFkYXB0ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXQgPSB3YWxsZXRzW2luZGV4XTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB3YWxsZXQgaGFzbid0IGNoYW5nZWQsIHJldHVybiB0aGUgc2FtZSBpbnN0YW5jZVxuICAgICAgICAgICAgcmV0dXJuIHdhbGxldCAmJiB3YWxsZXQuYWRhcHRlciA9PT0gYWRhcHRlciAmJiB3YWxsZXQucmVhZHlTdGF0ZSA9PT0gYWRhcHRlci5yZWFkeVN0YXRlXG4gICAgICAgICAgICAgICAgPyB3YWxsZXRcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgYWRhcHRlcjogYWRhcHRlcixcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlTdGF0ZTogYWRhcHRlci5yZWFkeVN0YXRlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKCh7IHJlYWR5U3RhdGUgfSkgPT4gcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5VbnN1cHBvcnRlZCkpO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZWFkeVN0YXRlQ2hhbmdlKHJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHNldFdhbGxldHMoKHByZXZXYWxsZXRzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcmV2V2FsbGV0cy5maW5kSW5kZXgoKHsgYWRhcHRlciB9KSA9PiBhZGFwdGVyID09PSB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldldhbGxldHM7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICBjb25zdCB7IGFkYXB0ZXIgfSA9IHByZXZXYWxsZXRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAuLi5wcmV2V2FsbGV0cy5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgICAgICAgICAgIHsgYWRhcHRlciwgcmVhZHlTdGF0ZSB9LFxuICAgICAgICAgICAgICAgICAgICAuLi5wcmV2V2FsbGV0cy5zbGljZShpbmRleCArIDEpLFxuICAgICAgICAgICAgICAgIF0uZmlsdGVyKCh7IHJlYWR5U3RhdGUgfSkgPT4gcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5VbnN1cHBvcnRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhZGFwdGVycy5mb3JFYWNoKChhZGFwdGVyKSA9PiBhZGFwdGVyLm9uKCdyZWFkeVN0YXRlQ2hhbmdlJywgaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSwgYWRhcHRlcikpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYWRhcHRlcnMuZm9yRWFjaCgoYWRhcHRlcikgPT4gYWRhcHRlci5vZmYoJ3JlYWR5U3RhdGVDaGFuZ2UnLCBoYW5kbGVSZWFkeVN0YXRlQ2hhbmdlLCBhZGFwdGVyKSk7XG4gICAgICAgIH07XG4gICAgfSwgW2FkYXB0ZXIsIGFkYXB0ZXJzXSk7XG4gICAgY29uc3Qgd2FsbGV0ID0gdXNlTWVtbygoKSA9PiB3YWxsZXRzLmZpbmQoKHdhbGxldCkgPT4gd2FsbGV0LmFkYXB0ZXIgPT09IGFkYXB0ZXIpID8/IG51bGwsIFthZGFwdGVyLCB3YWxsZXRzXSk7XG4gICAgLy8gU2V0dXAgYW5kIHRlYXJkb3duIGV2ZW50IGxpc3RlbmVycyB3aGVuIHRoZSBhZGFwdGVyIGNoYW5nZXNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWFkYXB0ZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGhhbmRsZUNvbm5lY3QgPSAocHVibGljS2V5KSA9PiB7XG4gICAgICAgICAgICBzZXRQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHNldENvbm5lY3RlZCh0cnVlKTtcbiAgICAgICAgICAgIGlzRGlzY29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBzZXREaXNjb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlRGlzY29ubmVjdCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1VubG9hZGluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNldFB1YmxpY0tleShudWxsKTtcbiAgICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHNldENvbm5lY3RlZChmYWxzZSk7XG4gICAgICAgICAgICBpc0Rpc2Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgc2V0RGlzY29ubmVjdGluZyhmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvclJlZi5jdXJyZW50KGVycm9yLCBhZGFwdGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWRhcHRlci5vbignY29ubmVjdCcsIGhhbmRsZUNvbm5lY3QpO1xuICAgICAgICBhZGFwdGVyLm9uKCdkaXNjb25uZWN0JywgaGFuZGxlRGlzY29ubmVjdCk7XG4gICAgICAgIGFkYXB0ZXIub24oJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYWRhcHRlci5vZmYoJ2Nvbm5lY3QnLCBoYW5kbGVDb25uZWN0KTtcbiAgICAgICAgICAgIGFkYXB0ZXIub2ZmKCdkaXNjb25uZWN0JywgaGFuZGxlRGlzY29ubmVjdCk7XG4gICAgICAgICAgICBhZGFwdGVyLm9mZignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICBoYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgfSwgW2FkYXB0ZXIsIGlzVW5sb2FkaW5nUmVmXSk7XG4gICAgLy8gV2hlbiB0aGUgYWRhcHRlciBjaGFuZ2VzLCBjbGVhciB0aGUgYGF1dG9Db25uZWN0YCB0cmFja2luZyBmbGFnXG4gICAgY29uc3QgZGlkQXR0ZW1wdEF1dG9Db25uZWN0UmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZGlkQXR0ZW1wdEF1dG9Db25uZWN0UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbYWRhcHRlcl0pO1xuICAgIC8vIElmIGF1dG8tY29ubmVjdCBpcyBlbmFibGVkLCByZXF1ZXN0IHRvIGNvbm5lY3Qgd2hlbiB0aGUgYWRhcHRlciBjaGFuZ2VzIGFuZCBpcyByZWFkeVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkaWRBdHRlbXB0QXV0b0Nvbm5lY3RSZWYuY3VycmVudCB8fFxuICAgICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgfHxcbiAgICAgICAgICAgIGNvbm5lY3RlZCB8fFxuICAgICAgICAgICAgIW9uQXV0b0Nvbm5lY3RSZXF1ZXN0IHx8XG4gICAgICAgICAgICAhKHdhbGxldD8ucmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQgfHwgd2FsbGV0Py5yZWFkeVN0YXRlID09PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBzZXRDb25uZWN0aW5nKHRydWUpO1xuICAgICAgICBkaWRBdHRlbXB0QXV0b0Nvbm5lY3RSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uQXV0b0Nvbm5lY3RSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgb25Db25uZWN0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICAvLyBEcm9wIHRoZSBlcnJvci4gSXQgd2lsbCBiZSBjYXVnaHQgYnkgYGhhbmRsZUVycm9yYCBhbnl3YXkuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH0sIFtjb25uZWN0ZWQsIG9uQXV0b0Nvbm5lY3RSZXF1ZXN0LCBvbkNvbm5lY3RFcnJvciwgd2FsbGV0XSk7XG4gICAgLy8gU2VuZCBhIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBjb25uZWN0aW9uXG4gICAgY29uc3Qgc2VuZFRyYW5zYWN0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmICghYWRhcHRlcilcbiAgICAgICAgICAgIHRocm93IGhhbmRsZUVycm9yUmVmLmN1cnJlbnQobmV3IFdhbGxldE5vdFNlbGVjdGVkRXJyb3IoKSk7XG4gICAgICAgIGlmICghY29ubmVjdGVkKVxuICAgICAgICAgICAgdGhyb3cgaGFuZGxlRXJyb3JSZWYuY3VycmVudChuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKSwgYWRhcHRlcik7XG4gICAgICAgIHJldHVybiBhd2FpdCBhZGFwdGVyLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgfSwgW2FkYXB0ZXIsIGNvbm5lY3RlZF0pO1xuICAgIC8vIFNpZ24gYSB0cmFuc2FjdGlvbiBpZiB0aGUgd2FsbGV0IHN1cHBvcnRzIGl0XG4gICAgY29uc3Qgc2lnblRyYW5zYWN0aW9uID0gdXNlTWVtbygoKSA9PiBhZGFwdGVyICYmICdzaWduVHJhbnNhY3Rpb24nIGluIGFkYXB0ZXJcbiAgICAgICAgPyBhc3luYyAodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGVkKVxuICAgICAgICAgICAgICAgIHRocm93IGhhbmRsZUVycm9yUmVmLmN1cnJlbnQobmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCksIGFkYXB0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZCwgW2FkYXB0ZXIsIGNvbm5lY3RlZF0pO1xuICAgIC8vIFNpZ24gbXVsdGlwbGUgdHJhbnNhY3Rpb25zIGlmIHRoZSB3YWxsZXQgc3VwcG9ydHMgaXRcbiAgICBjb25zdCBzaWduQWxsVHJhbnNhY3Rpb25zID0gdXNlTWVtbygoKSA9PiBhZGFwdGVyICYmICdzaWduQWxsVHJhbnNhY3Rpb25zJyBpbiBhZGFwdGVyXG4gICAgICAgID8gYXN5bmMgKHRyYW5zYWN0aW9ucykgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgaGFuZGxlRXJyb3JSZWYuY3VycmVudChuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKSwgYWRhcHRlcik7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYWRhcHRlci5zaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQsIFthZGFwdGVyLCBjb25uZWN0ZWRdKTtcbiAgICAvLyBTaWduIGFuIGFyYml0cmFyeSBtZXNzYWdlIGlmIHRoZSB3YWxsZXQgc3VwcG9ydHMgaXRcbiAgICBjb25zdCBzaWduTWVzc2FnZSA9IHVzZU1lbW8oKCkgPT4gYWRhcHRlciAmJiAnc2lnbk1lc3NhZ2UnIGluIGFkYXB0ZXJcbiAgICAgICAgPyBhc3luYyAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgaGFuZGxlRXJyb3JSZWYuY3VycmVudChuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKSwgYWRhcHRlcik7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYWRhcHRlci5zaWduTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZCwgW2FkYXB0ZXIsIGNvbm5lY3RlZF0pO1xuICAgIC8vIFNpZ24gaW4gaWYgdGhlIHdhbGxldCBzdXBwb3J0cyBpdFxuICAgIGNvbnN0IHNpZ25JbiA9IHVzZU1lbW8oKCkgPT4gYWRhcHRlciAmJiAnc2lnbkluJyBpbiBhZGFwdGVyXG4gICAgICAgID8gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYWRhcHRlci5zaWduSW4oaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkLCBbYWRhcHRlcl0pO1xuICAgIGNvbnN0IGhhbmRsZUNvbm5lY3QgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCB8fCBpc0Rpc2Nvbm5lY3RpbmdSZWYuY3VycmVudCB8fCB3YWxsZXQ/LmFkYXB0ZXIuY29ubmVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXdhbGxldClcbiAgICAgICAgICAgIHRocm93IGhhbmRsZUVycm9yUmVmLmN1cnJlbnQobmV3IFdhbGxldE5vdFNlbGVjdGVkRXJyb3IoKSk7XG4gICAgICAgIGNvbnN0IHsgYWRhcHRlciwgcmVhZHlTdGF0ZSB9ID0gd2FsbGV0O1xuICAgICAgICBpZiAoIShyZWFkeVN0YXRlID09PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCB8fCByZWFkeVN0YXRlID09PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlKSlcbiAgICAgICAgICAgIHRocm93IGhhbmRsZUVycm9yUmVmLmN1cnJlbnQobmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKSwgYWRhcHRlcik7XG4gICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgc2V0Q29ubmVjdGluZyh0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGFkYXB0ZXIuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvbkNvbm5lY3RFcnJvcigpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldENvbm5lY3RpbmcoZmFsc2UpO1xuICAgICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNvbm5lY3RFcnJvciwgd2FsbGV0XSk7XG4gICAgY29uc3QgaGFuZGxlRGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGlzRGlzY29ubmVjdGluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWFkYXB0ZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlzRGlzY29ubmVjdGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgc2V0RGlzY29ubmVjdGluZyh0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGFkYXB0ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0RGlzY29ubmVjdGluZyhmYWxzZSk7XG4gICAgICAgICAgICBpc0Rpc2Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwgW2FkYXB0ZXJdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoV2FsbGV0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZToge1xuICAgICAgICAgICAgYXV0b0Nvbm5lY3Q6ICEhb25BdXRvQ29ubmVjdFJlcXVlc3QsXG4gICAgICAgICAgICB3YWxsZXRzLFxuICAgICAgICAgICAgd2FsbGV0LFxuICAgICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICAgICAgY29ubmVjdGVkLFxuICAgICAgICAgICAgY29ubmVjdGluZyxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3RpbmcsXG4gICAgICAgICAgICBzZWxlY3Q6IG9uU2VsZWN0V2FsbGV0LFxuICAgICAgICAgICAgY29ubmVjdDogaGFuZGxlQ29ubmVjdCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IGhhbmRsZURpc2Nvbm5lY3QsXG4gICAgICAgICAgICBzZW5kVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBzaWduVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBzaWduQWxsVHJhbnNhY3Rpb25zLFxuICAgICAgICAgICAgc2lnbk1lc3NhZ2UsXG4gICAgICAgICAgICBzaWduSW4sXG4gICAgICAgIH0gfSwgY2hpbGRyZW4pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdhbGxldFByb3ZpZGVyQmFzZS5qcy5tYXAiXSwibmFtZXMiOlsiV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IiLCJXYWxsZXROb3RSZWFkeUVycm9yIiwiV2FsbGV0UmVhZHlTdGF0ZSIsIlJlYWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlU3RhdGUiLCJXYWxsZXROb3RTZWxlY3RlZEVycm9yIiwiV2FsbGV0Q29udGV4dCIsIldhbGxldFByb3ZpZGVyQmFzZSIsImNoaWxkcmVuIiwid2FsbGV0cyIsImFkYXB0ZXJzIiwiYWRhcHRlciIsImlzVW5sb2FkaW5nUmVmIiwib25BdXRvQ29ubmVjdFJlcXVlc3QiLCJvbkNvbm5lY3RFcnJvciIsIm9uRXJyb3IiLCJvblNlbGVjdFdhbGxldCIsImlzQ29ubmVjdGluZ1JlZiIsImNvbm5lY3RpbmciLCJzZXRDb25uZWN0aW5nIiwiaXNEaXNjb25uZWN0aW5nUmVmIiwiZGlzY29ubmVjdGluZyIsInNldERpc2Nvbm5lY3RpbmciLCJwdWJsaWNLZXkiLCJzZXRQdWJsaWNLZXkiLCJjb25uZWN0ZWQiLCJzZXRDb25uZWN0ZWQiLCJvbkVycm9yUmVmIiwiY3VycmVudCIsInVuZGVmaW5lZCIsImhhbmRsZUVycm9yUmVmIiwiZXJyb3IiLCJjb25zb2xlIiwid2luZG93Iiwib3BlbiIsInVybCIsInNldFdhbGxldHMiLCJtYXAiLCJyZWFkeVN0YXRlIiwiZmlsdGVyIiwiVW5zdXBwb3J0ZWQiLCJpbmRleCIsIndhbGxldCIsImhhbmRsZVJlYWR5U3RhdGVDaGFuZ2UiLCJwcmV2V2FsbGV0cyIsImZpbmRJbmRleCIsInNsaWNlIiwiZm9yRWFjaCIsIm9uIiwib2ZmIiwiZmluZCIsImhhbmRsZUNvbm5lY3QiLCJoYW5kbGVEaXNjb25uZWN0IiwiaGFuZGxlRXJyb3IiLCJkaWRBdHRlbXB0QXV0b0Nvbm5lY3RSZWYiLCJJbnN0YWxsZWQiLCJMb2FkYWJsZSIsInNlbmRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwiY29ubmVjdGlvbiIsIm9wdGlvbnMiLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduQWxsVHJhbnNhY3Rpb25zIiwidHJhbnNhY3Rpb25zIiwic2lnbk1lc3NhZ2UiLCJtZXNzYWdlIiwic2lnbkluIiwiaW5wdXQiLCJjb25uZWN0IiwiZSIsImRpc2Nvbm5lY3QiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImF1dG9Db25uZWN0Iiwic2VsZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletNotSelectedError: () => (/* binding */ WalletNotSelectedError)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n\nclass WalletNotSelectedError extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__.WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletNotSelectedError\";\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwRDtBQUNuRCxNQUFNQywrQkFBK0JELG9FQUFXQTtJQUNuREUsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL2Vycm9ycy5qcz80YzgzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdhbGxldEVycm9yIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlJztcbmV4cG9ydCBjbGFzcyBXYWxsZXROb3RTZWxlY3RlZEVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0Tm90U2VsZWN0ZWRFcnJvcic7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJXYWxsZXRFcnJvciIsIldhbGxldE5vdFNlbGVjdGVkRXJyb3IiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsIm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   \"default\": () => (/* binding */ getEnvironment)\n/* harmony export */ });\n/* harmony import */ var _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana-mobile/wallet-adapter-mobile */ \"(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n\n\nvar Environment;\n(function(Environment) {\n    Environment[Environment[\"DESKTOP_WEB\"] = 0] = \"DESKTOP_WEB\";\n    Environment[Environment[\"MOBILE_WEB\"] = 1] = \"MOBILE_WEB\";\n})(Environment || (Environment = {}));\nfunction isWebView(userAgentString) {\n    return /(WebView|Version\\/.+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)|; wv\\).+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+))/i.test(userAgentString);\n}\nfunction getEnvironment({ adapters, userAgentString }) {\n    if (adapters.some((adapter)=>adapter.name !== _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName && adapter.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletReadyState.Installed)) {\n        /**\n         * There are only two ways a browser extension adapter should be able to reach `Installed` status:\n         *\n         *     1. Its browser extension is installed.\n         *     2. The app is running on a mobile wallet's in-app browser.\n         *\n         * In either case, we consider the environment to be desktop-like.\n         */ return Environment.DESKTOP_WEB;\n    }\n    if (userAgentString && // Step 1: Check whether we're on a platform that supports MWA at all.\n    /android/i.test(userAgentString) && // Step 2: Determine that we are *not* running in a WebView.\n    !isWebView(userAgentString)) {\n        return Environment.MOBILE_WEB;\n    } else {\n        return Environment.DESKTOP_WEB;\n    }\n} //# sourceMappingURL=getEnvironment.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL2dldEVudmlyb25tZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMkY7QUFDNUI7QUFDeEQsSUFBSUUsWUFBWTtBQUN0QixVQUFVQSxXQUFXO0lBQ2xCQSxXQUFXLENBQUNBLFdBQVcsQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHO0lBQzlDQSxXQUFXLENBQUNBLFdBQVcsQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHO0FBQ2pELEdBQUdBLGVBQWdCQSxDQUFBQSxjQUFjLENBQUM7QUFDbEMsU0FBU0MsVUFBVUMsZUFBZTtJQUM5QixPQUFPLDBHQUEwR0MsSUFBSSxDQUFDRDtBQUMxSDtBQUNlLFNBQVNFLGVBQWUsRUFBRUMsUUFBUSxFQUFFSCxlQUFlLEVBQUU7SUFDaEUsSUFBSUcsU0FBU0MsSUFBSSxDQUFDLENBQUNDLFVBQVlBLFFBQVFDLElBQUksS0FBS1YscUdBQW1DQSxJQUMvRVMsUUFBUUUsVUFBVSxLQUFLVix5RUFBZ0JBLENBQUNXLFNBQVMsR0FBRztRQUNwRDs7Ozs7OztTQU9DLEdBQ0QsT0FBT1YsWUFBWVcsV0FBVztJQUNsQztJQUNBLElBQUlULG1CQUNBLHNFQUFzRTtJQUN0RSxXQUFXQyxJQUFJLENBQUNELG9CQUNoQiw0REFBNEQ7SUFDNUQsQ0FBQ0QsVUFBVUMsa0JBQWtCO1FBQzdCLE9BQU9GLFlBQVlZLFVBQVU7SUFDakMsT0FDSztRQUNELE9BQU9aLFlBQVlXLFdBQVc7SUFDbEM7QUFDSixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9nZXRFbnZpcm9ubWVudC5qcz84ZmZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lIH0gZnJvbSAnQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlJztcbmltcG9ydCB7IFdhbGxldFJlYWR5U3RhdGUgfSBmcm9tICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UnO1xuZXhwb3J0IHZhciBFbnZpcm9ubWVudDtcbihmdW5jdGlvbiAoRW52aXJvbm1lbnQpIHtcbiAgICBFbnZpcm9ubWVudFtFbnZpcm9ubWVudFtcIkRFU0tUT1BfV0VCXCJdID0gMF0gPSBcIkRFU0tUT1BfV0VCXCI7XG4gICAgRW52aXJvbm1lbnRbRW52aXJvbm1lbnRbXCJNT0JJTEVfV0VCXCJdID0gMV0gPSBcIk1PQklMRV9XRUJcIjtcbn0pKEVudmlyb25tZW50IHx8IChFbnZpcm9ubWVudCA9IHt9KSk7XG5mdW5jdGlvbiBpc1dlYlZpZXcodXNlckFnZW50U3RyaW5nKSB7XG4gICAgcmV0dXJuIC8oV2ViVmlld3xWZXJzaW9uXFwvLisoQ2hyb21lKVxcLyhcXGQrKVxcLihcXGQrKVxcLihcXGQrKVxcLihcXGQrKXw7IHd2XFwpLisoQ2hyb21lKVxcLyhcXGQrKVxcLihcXGQrKVxcLihcXGQrKVxcLihcXGQrKSkvaS50ZXN0KHVzZXJBZ2VudFN0cmluZyk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudCh7IGFkYXB0ZXJzLCB1c2VyQWdlbnRTdHJpbmcgfSkge1xuICAgIGlmIChhZGFwdGVycy5zb21lKChhZGFwdGVyKSA9PiBhZGFwdGVyLm5hbWUgIT09IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lICYmXG4gICAgICAgIGFkYXB0ZXIucmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVyZSBhcmUgb25seSB0d28gd2F5cyBhIGJyb3dzZXIgZXh0ZW5zaW9uIGFkYXB0ZXIgc2hvdWxkIGJlIGFibGUgdG8gcmVhY2ggYEluc3RhbGxlZGAgc3RhdHVzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgMS4gSXRzIGJyb3dzZXIgZXh0ZW5zaW9uIGlzIGluc3RhbGxlZC5cbiAgICAgICAgICogICAgIDIuIFRoZSBhcHAgaXMgcnVubmluZyBvbiBhIG1vYmlsZSB3YWxsZXQncyBpbi1hcHAgYnJvd3Nlci5cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gZWl0aGVyIGNhc2UsIHdlIGNvbnNpZGVyIHRoZSBlbnZpcm9ubWVudCB0byBiZSBkZXNrdG9wLWxpa2UuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gRW52aXJvbm1lbnQuREVTS1RPUF9XRUI7XG4gICAgfVxuICAgIGlmICh1c2VyQWdlbnRTdHJpbmcgJiZcbiAgICAgICAgLy8gU3RlcCAxOiBDaGVjayB3aGV0aGVyIHdlJ3JlIG9uIGEgcGxhdGZvcm0gdGhhdCBzdXBwb3J0cyBNV0EgYXQgYWxsLlxuICAgICAgICAvYW5kcm9pZC9pLnRlc3QodXNlckFnZW50U3RyaW5nKSAmJlxuICAgICAgICAvLyBTdGVwIDI6IERldGVybWluZSB0aGF0IHdlIGFyZSAqbm90KiBydW5uaW5nIGluIGEgV2ViVmlldy5cbiAgICAgICAgIWlzV2ViVmlldyh1c2VyQWdlbnRTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBFbnZpcm9ubWVudC5NT0JJTEVfV0VCO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEVudmlyb25tZW50LkRFU0tUT1BfV0VCO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEVudmlyb25tZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSIsIldhbGxldFJlYWR5U3RhdGUiLCJFbnZpcm9ubWVudCIsImlzV2ViVmlldyIsInVzZXJBZ2VudFN0cmluZyIsInRlc3QiLCJnZXRFbnZpcm9ubWVudCIsImFkYXB0ZXJzIiwic29tZSIsImFkYXB0ZXIiLCJuYW1lIiwicmVhZHlTdGF0ZSIsIkluc3RhbGxlZCIsIkRFU0tUT1BfV0VCIiwiTU9CSUxFX1dFQiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getInferredClusterFromEndpoint)\n/* harmony export */ });\nfunction getInferredClusterFromEndpoint(endpoint) {\n    if (!endpoint) {\n        return \"mainnet-beta\";\n    }\n    if (/devnet/i.test(endpoint)) {\n        return \"devnet\";\n    } else if (/testnet/i.test(endpoint)) {\n        return \"testnet\";\n    } else {\n        return \"mainnet-beta\";\n    }\n} //# sourceMappingURL=getInferredClusterFromEndpoint.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL2dldEluZmVycmVkQ2x1c3RlckZyb21FbmRwb2ludC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWUsU0FBU0EsK0JBQStCQyxRQUFRO0lBQzNELElBQUksQ0FBQ0EsVUFBVTtRQUNYLE9BQU87SUFDWDtJQUNBLElBQUksVUFBVUMsSUFBSSxDQUFDRCxXQUFXO1FBQzFCLE9BQU87SUFDWCxPQUNLLElBQUksV0FBV0MsSUFBSSxDQUFDRCxXQUFXO1FBQ2hDLE9BQU87SUFDWCxPQUNLO1FBQ0QsT0FBTztJQUNYO0FBQ0osRUFDQSwwREFBMEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vZ2V0SW5mZXJyZWRDbHVzdGVyRnJvbUVuZHBvaW50LmpzP2U2ZGEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SW5mZXJyZWRDbHVzdGVyRnJvbUVuZHBvaW50KGVuZHBvaW50KSB7XG4gICAgaWYgKCFlbmRwb2ludCkge1xuICAgICAgICByZXR1cm4gJ21haW5uZXQtYmV0YSc7XG4gICAgfVxuICAgIGlmICgvZGV2bmV0L2kudGVzdChlbmRwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuICdkZXZuZXQnO1xuICAgIH1cbiAgICBlbHNlIGlmICgvdGVzdG5ldC9pLnRlc3QoZW5kcG9pbnQpKSB7XG4gICAgICAgIHJldHVybiAndGVzdG5ldCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJ21haW5uZXQtYmV0YSc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0SW5mZXJyZWRDbHVzdGVyRnJvbUVuZHBvaW50LmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRJbmZlcnJlZENsdXN0ZXJGcm9tRW5kcG9pbnQiLCJlbmRwb2ludCIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionContext: () => (/* binding */ ConnectionContext),\n/* harmony export */   useConnection: () => (/* binding */ useConnection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst ConnectionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nfunction useConnection() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ConnectionContext);\n} //# sourceMappingURL=useConnection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL3VzZUNvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtEO0FBQzNDLE1BQU1FLGtDQUFvQkYsb0RBQWFBLENBQUMsQ0FBQyxHQUFHO0FBQzVDLFNBQVNHO0lBQ1osT0FBT0YsaURBQVVBLENBQUNDO0FBQ3RCLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL3VzZUNvbm5lY3Rpb24uanM/ZjRhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IENvbm5lY3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XG5leHBvcnQgZnVuY3Rpb24gdXNlQ29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gdXNlQ29udGV4dChDb25uZWN0aW9uQ29udGV4dCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VDb25uZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsIkNvbm5lY3Rpb25Db250ZXh0IiwidXNlQ29ubmVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLocalStorage: () => (/* binding */ useLocalStorage)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction useLocalStorage(key, defaultState) {\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>{\n        try {\n            const value = localStorage.getItem(key);\n            if (value) return JSON.parse(value);\n        } catch (error) {\n            if (false) {}\n        }\n        return defaultState;\n    });\n    const value = state[0];\n    const isFirstRenderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isFirstRenderRef.current) {\n            isFirstRenderRef.current = false;\n            return;\n        }\n        try {\n            if (value === null) {\n                localStorage.removeItem(key);\n            } else {\n                localStorage.setItem(key, JSON.stringify(value));\n            }\n        } catch (error) {\n            if (false) {}\n        }\n    }, [\n        value,\n        key\n    ]);\n    return state;\n} //# sourceMappingURL=useLocalStorage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL3VzZUxvY2FsU3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDtBQUM3QyxTQUFTRyxnQkFBZ0JDLEdBQUcsRUFBRUMsWUFBWTtJQUM3QyxNQUFNQyxRQUFRSiwrQ0FBUUEsQ0FBQztRQUNuQixJQUFJO1lBQ0EsTUFBTUssUUFBUUMsYUFBYUMsT0FBTyxDQUFDTDtZQUNuQyxJQUFJRyxPQUNBLE9BQU9HLEtBQUtDLEtBQUssQ0FBQ0o7UUFDMUIsRUFDQSxPQUFPSyxPQUFPO1lBQ1YsSUFBSSxLQUFrQixFQUFhLEVBRWxDO1FBQ0w7UUFDQSxPQUFPUDtJQUNYO0lBQ0EsTUFBTUUsUUFBUUQsS0FBSyxDQUFDLEVBQUU7SUFDdEIsTUFBTVEsbUJBQW1CYiw2Q0FBTUEsQ0FBQztJQUNoQ0QsZ0RBQVNBLENBQUM7UUFDTixJQUFJYyxpQkFBaUJDLE9BQU8sRUFBRTtZQUMxQkQsaUJBQWlCQyxPQUFPLEdBQUc7WUFDM0I7UUFDSjtRQUNBLElBQUk7WUFDQSxJQUFJUixVQUFVLE1BQU07Z0JBQ2hCQyxhQUFhUSxVQUFVLENBQUNaO1lBQzVCLE9BQ0s7Z0JBQ0RJLGFBQWFTLE9BQU8sQ0FBQ2IsS0FBS00sS0FBS1EsU0FBUyxDQUFDWDtZQUM3QztRQUNKLEVBQ0EsT0FBT0ssT0FBTztZQUNWLElBQUksS0FBa0IsRUFBYSxFQUVsQztRQUNMO0lBQ0osR0FBRztRQUFDTDtRQUFPSDtLQUFJO0lBQ2YsT0FBT0U7QUFDWCxFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS91c2VMb2NhbFN0b3JhZ2UuanM/NzQ3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYWxTdG9yYWdlKGtleSwgZGVmYXVsdFN0YXRlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VTdGF0ZSgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdGF0ZTtcbiAgICB9KTtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YXRlWzBdO1xuICAgIGNvbnN0IGlzRmlyc3RSZW5kZXJSZWYgPSB1c2VSZWYodHJ1ZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGlzRmlyc3RSZW5kZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaXNGaXJzdFJlbmRlclJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFt2YWx1ZSwga2V5XSk7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlTG9jYWxTdG9yYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUxvY2FsU3RvcmFnZSIsImtleSIsImRlZmF1bHRTdGF0ZSIsInN0YXRlIiwidmFsdWUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJjb25zb2xlIiwiaXNGaXJzdFJlbmRlclJlZiIsImN1cnJlbnQiLCJyZW1vdmVJdGVtIiwic2V0SXRlbSIsInN0cmluZ2lmeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js":
/*!************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletContext: () => (/* binding */ WalletContext),\n/* harmony export */   useWallet: () => (/* binding */ useWallet)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst EMPTY_ARRAY = [];\nconst DEFAULT_CONTEXT = {\n    autoConnect: false,\n    connecting: false,\n    connected: false,\n    disconnecting: false,\n    select () {\n        logMissingProviderError(\"call\", \"select\");\n    },\n    connect () {\n        return Promise.reject(logMissingProviderError(\"call\", \"connect\"));\n    },\n    disconnect () {\n        return Promise.reject(logMissingProviderError(\"call\", \"disconnect\"));\n    },\n    sendTransaction () {\n        return Promise.reject(logMissingProviderError(\"call\", \"sendTransaction\"));\n    },\n    signTransaction () {\n        return Promise.reject(logMissingProviderError(\"call\", \"signTransaction\"));\n    },\n    signAllTransactions () {\n        return Promise.reject(logMissingProviderError(\"call\", \"signAllTransactions\"));\n    },\n    signMessage () {\n        return Promise.reject(logMissingProviderError(\"call\", \"signMessage\"));\n    },\n    signIn () {\n        return Promise.reject(logMissingProviderError(\"call\", \"signIn\"));\n    }\n};\nObject.defineProperty(DEFAULT_CONTEXT, \"wallets\", {\n    get () {\n        logMissingProviderError(\"read\", \"wallets\");\n        return EMPTY_ARRAY;\n    }\n});\nObject.defineProperty(DEFAULT_CONTEXT, \"wallet\", {\n    get () {\n        logMissingProviderError(\"read\", \"wallet\");\n        return null;\n    }\n});\nObject.defineProperty(DEFAULT_CONTEXT, \"publicKey\", {\n    get () {\n        logMissingProviderError(\"read\", \"publicKey\");\n        return null;\n    }\n});\nfunction logMissingProviderError(action, property) {\n    const error = new Error(`You have tried to ${action} \"${property}\" on a WalletContext without providing one. ` + \"Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext.\");\n    console.error(error);\n    return error;\n}\nconst WalletContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(DEFAULT_CONTEXT);\nfunction useWallet() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(WalletContext);\n} //# sourceMappingURL=useWallet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL3VzZVdhbGxldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0Q7QUFDbEQsTUFBTUUsY0FBYyxFQUFFO0FBQ3RCLE1BQU1DLGtCQUFrQjtJQUNwQkMsYUFBYTtJQUNiQyxZQUFZO0lBQ1pDLFdBQVc7SUFDWEMsZUFBZTtJQUNmQztRQUNJQyx3QkFBd0IsUUFBUTtJQUNwQztJQUNBQztRQUNJLE9BQU9DLFFBQVFDLE1BQU0sQ0FBQ0gsd0JBQXdCLFFBQVE7SUFDMUQ7SUFDQUk7UUFDSSxPQUFPRixRQUFRQyxNQUFNLENBQUNILHdCQUF3QixRQUFRO0lBQzFEO0lBQ0FLO1FBQ0ksT0FBT0gsUUFBUUMsTUFBTSxDQUFDSCx3QkFBd0IsUUFBUTtJQUMxRDtJQUNBTTtRQUNJLE9BQU9KLFFBQVFDLE1BQU0sQ0FBQ0gsd0JBQXdCLFFBQVE7SUFDMUQ7SUFDQU87UUFDSSxPQUFPTCxRQUFRQyxNQUFNLENBQUNILHdCQUF3QixRQUFRO0lBQzFEO0lBQ0FRO1FBQ0ksT0FBT04sUUFBUUMsTUFBTSxDQUFDSCx3QkFBd0IsUUFBUTtJQUMxRDtJQUNBUztRQUNJLE9BQU9QLFFBQVFDLE1BQU0sQ0FBQ0gsd0JBQXdCLFFBQVE7SUFDMUQ7QUFDSjtBQUNBVSxPQUFPQyxjQUFjLENBQUNqQixpQkFBaUIsV0FBVztJQUM5Q2tCO1FBQ0laLHdCQUF3QixRQUFRO1FBQ2hDLE9BQU9QO0lBQ1g7QUFDSjtBQUNBaUIsT0FBT0MsY0FBYyxDQUFDakIsaUJBQWlCLFVBQVU7SUFDN0NrQjtRQUNJWix3QkFBd0IsUUFBUTtRQUNoQyxPQUFPO0lBQ1g7QUFDSjtBQUNBVSxPQUFPQyxjQUFjLENBQUNqQixpQkFBaUIsYUFBYTtJQUNoRGtCO1FBQ0laLHdCQUF3QixRQUFRO1FBQ2hDLE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU0Esd0JBQXdCYSxNQUFNLEVBQUVDLFFBQVE7SUFDN0MsTUFBTUMsUUFBUSxJQUFJQyxNQUFNLENBQUMsa0JBQWtCLEVBQUVILE9BQU8sRUFBRSxFQUFFQyxTQUFTLDRDQUE0QyxDQUFDLEdBQzFHO0lBQ0pHLFFBQVFGLEtBQUssQ0FBQ0E7SUFDZCxPQUFPQTtBQUNYO0FBQ08sTUFBTUcsOEJBQWdCM0Isb0RBQWFBLENBQUNHLGlCQUFpQjtBQUNyRCxTQUFTeUI7SUFDWixPQUFPM0IsaURBQVVBLENBQUMwQjtBQUN0QixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS91c2VXYWxsZXQuanM/OTk3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuY29uc3QgRU1QVFlfQVJSQVkgPSBbXTtcbmNvbnN0IERFRkFVTFRfQ09OVEVYVCA9IHtcbiAgICBhdXRvQ29ubmVjdDogZmFsc2UsXG4gICAgY29ubmVjdGluZzogZmFsc2UsXG4gICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICBkaXNjb25uZWN0aW5nOiBmYWxzZSxcbiAgICBzZWxlY3QoKSB7XG4gICAgICAgIGxvZ01pc3NpbmdQcm92aWRlckVycm9yKCdjYWxsJywgJ3NlbGVjdCcpO1xuICAgIH0sXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGxvZ01pc3NpbmdQcm92aWRlckVycm9yKCdjYWxsJywgJ2Nvbm5lY3QnKSk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobG9nTWlzc2luZ1Byb3ZpZGVyRXJyb3IoJ2NhbGwnLCAnZGlzY29ubmVjdCcpKTtcbiAgICB9LFxuICAgIHNlbmRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGxvZ01pc3NpbmdQcm92aWRlckVycm9yKCdjYWxsJywgJ3NlbmRUcmFuc2FjdGlvbicpKTtcbiAgICB9LFxuICAgIHNpZ25UcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGxvZ01pc3NpbmdQcm92aWRlckVycm9yKCdjYWxsJywgJ3NpZ25UcmFuc2FjdGlvbicpKTtcbiAgICB9LFxuICAgIHNpZ25BbGxUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChsb2dNaXNzaW5nUHJvdmlkZXJFcnJvcignY2FsbCcsICdzaWduQWxsVHJhbnNhY3Rpb25zJykpO1xuICAgIH0sXG4gICAgc2lnbk1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChsb2dNaXNzaW5nUHJvdmlkZXJFcnJvcignY2FsbCcsICdzaWduTWVzc2FnZScpKTtcbiAgICB9LFxuICAgIHNpZ25JbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGxvZ01pc3NpbmdQcm92aWRlckVycm9yKCdjYWxsJywgJ3NpZ25JbicpKTtcbiAgICB9LFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShERUZBVUxUX0NPTlRFWFQsICd3YWxsZXRzJywge1xuICAgIGdldCgpIHtcbiAgICAgICAgbG9nTWlzc2luZ1Byb3ZpZGVyRXJyb3IoJ3JlYWQnLCAnd2FsbGV0cycpO1xuICAgICAgICByZXR1cm4gRU1QVFlfQVJSQVk7XG4gICAgfSxcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KERFRkFVTFRfQ09OVEVYVCwgJ3dhbGxldCcsIHtcbiAgICBnZXQoKSB7XG4gICAgICAgIGxvZ01pc3NpbmdQcm92aWRlckVycm9yKCdyZWFkJywgJ3dhbGxldCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoREVGQVVMVF9DT05URVhULCAncHVibGljS2V5Jywge1xuICAgIGdldCgpIHtcbiAgICAgICAgbG9nTWlzc2luZ1Byb3ZpZGVyRXJyb3IoJ3JlYWQnLCAncHVibGljS2V5Jyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG59KTtcbmZ1bmN0aW9uIGxvZ01pc3NpbmdQcm92aWRlckVycm9yKGFjdGlvbiwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgWW91IGhhdmUgdHJpZWQgdG8gJHthY3Rpb259IFwiJHtwcm9wZXJ0eX1cIiBvbiBhIFdhbGxldENvbnRleHQgd2l0aG91dCBwcm92aWRpbmcgb25lLiBgICtcbiAgICAgICAgJ01ha2Ugc3VyZSB0byByZW5kZXIgYSBXYWxsZXRQcm92aWRlciBhcyBhbiBhbmNlc3RvciBvZiB0aGUgY29tcG9uZW50IHRoYXQgdXNlcyBXYWxsZXRDb250ZXh0LicpO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbmV4cG9ydCBjb25zdCBXYWxsZXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dChERUZBVUxUX0NPTlRFWFQpO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVdhbGxldCgpIHtcbiAgICByZXR1cm4gdXNlQ29udGV4dChXYWxsZXRDb250ZXh0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZVdhbGxldC5qcy5tYXAiXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJFTVBUWV9BUlJBWSIsIkRFRkFVTFRfQ09OVEVYVCIsImF1dG9Db25uZWN0IiwiY29ubmVjdGluZyIsImNvbm5lY3RlZCIsImRpc2Nvbm5lY3RpbmciLCJzZWxlY3QiLCJsb2dNaXNzaW5nUHJvdmlkZXJFcnJvciIsImNvbm5lY3QiLCJQcm9taXNlIiwicmVqZWN0IiwiZGlzY29ubmVjdCIsInNlbmRUcmFuc2FjdGlvbiIsInNpZ25UcmFuc2FjdGlvbiIsInNpZ25BbGxUcmFuc2FjdGlvbnMiLCJzaWduTWVzc2FnZSIsInNpZ25JbiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiYWN0aW9uIiwicHJvcGVydHkiLCJlcnJvciIsIkVycm9yIiwiY29uc29sZSIsIldhbGxldENvbnRleHQiLCJ1c2VXYWxsZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-solflare/lib/esm/adapter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-solflare/lib/esm/adapter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolflareWalletAdapter: () => (/* binding */ SolflareWalletAdapter),\n/* harmony export */   SolflareWalletName: () => (/* binding */ SolflareWalletName)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _metamask_detect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./metamask/detect.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/detect.js\");\n\n\n\nconst SolflareWalletName = \"Solflare\";\nclass SolflareWalletAdapter extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.BaseMessageSignerWalletAdapter {\n    constructor(config = {}){\n        super();\n        this.name = SolflareWalletName;\n        this.url = \"https://solflare.com\";\n        this.icon = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJTIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMjA1MGE7c3Ryb2tlOiNmZmVmNDY7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLXdpZHRoOi41cHg7fS5jbHMtMntmaWxsOiNmZmVmNDY7fTwvc3R5bGU+PC9kZWZzPjxyZWN0IGNsYXNzPSJjbHMtMiIgeD0iMCIgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiByeD0iMTIiIHJ5PSIxMiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTI0LjIzLDI2LjQybDIuNDYtMi4zOCw0LjU5LDEuNWMzLjAxLDEsNC41MSwyLjg0LDQuNTEsNS40MywwLDEuOTYtLjc1LDMuMjYtMi4yNSw0LjkzbC0uNDYuNS4xNy0xLjE3Yy42Ny00LjI2LS41OC02LjA5LTQuNzItNy40M2wtNC4zLTEuMzhoMFpNMTguMDUsMTEuODVsMTIuNTIsNC4xNy0yLjcxLDIuNTktNi41MS0yLjE3Yy0yLjI1LS43NS0zLjAxLTEuOTYtMy4zLTQuNTF2LS4wOGgwWk0xNy4zLDMzLjA2bDIuODQtMi43MSw1LjM0LDEuNzVjMi44LjkyLDMuNzYsMi4xMywzLjQ2LDUuMThsLTExLjY1LTQuMjJoMFpNMTMuNzEsMjAuOTVjMC0uNzkuNDItMS41NCwxLjEzLTIuMTcuNzUsMS4wOSwyLjA1LDIuMDUsNC4wOSwyLjcxbDQuNDIsMS40Ni0yLjQ2LDIuMzgtNC4zNC0xLjQyYy0yLS42Ny0yLjg0LTEuNjctMi44NC0yLjk2TTI2LjgyLDQyLjg3YzkuMTgtNi4wOSwxNC4xMS0xMC4yMywxNC4xMS0xNS4zMiwwLTMuMzgtMi01LjI2LTYuNDMtNi43MmwtMy4zNC0xLjEzLDkuMTQtOC43Ny0xLjg0LTEuOTYtMi43MSwyLjM4LTEyLjgxLTQuMjJjLTMuOTcsMS4yOS04Ljk3LDUuMDktOC45Nyw4Ljg5LDAsLjQyLjA0LjgzLjE3LDEuMjktMy4zLDEuODgtNC42MywzLjYzLTQuNjMsNS44LDAsMi4wNSwxLjA5LDQuMDksNC41NSw1LjIybDIuNzUuOTItOS41Miw5LjE0LDEuODQsMS45NiwyLjk2LTIuNzEsMTQuNzMsNS4yMmgwWiIvPjwvc3ZnPg==\";\n        this.supportedTransactionVersions = new Set([\n            \"legacy\",\n            0\n        ]);\n        this._readyState =  true ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported : 0;\n        this._disconnected = ()=>{\n            const wallet = this._wallet;\n            if (wallet) {\n                wallet.off(\"disconnect\", this._disconnected);\n                this._wallet = null;\n                this._publicKey = null;\n                this.emit(\"error\", new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletDisconnectedError());\n                this.emit(\"disconnect\");\n            }\n        };\n        this._accountChanged = (newPublicKey)=>{\n            if (!newPublicKey) return;\n            const publicKey = this._publicKey;\n            if (!publicKey) return;\n            try {\n                newPublicKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(newPublicKey.toBytes());\n            } catch (error) {\n                this.emit(\"error\", new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletPublicKeyError(error?.message, error));\n                return;\n            }\n            if (publicKey.equals(newPublicKey)) return;\n            this._publicKey = newPublicKey;\n            this.emit(\"connect\", newPublicKey);\n        };\n        this._connecting = false;\n        this._publicKey = null;\n        this._wallet = null;\n        this._config = config;\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported) {\n            (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.scopePollingDetectionStrategy)(()=>{\n                if (window.solflare?.isSolflare || window.SolflareApp) {\n                    this._readyState = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed;\n                    this.emit(\"readyStateChange\", this._readyState);\n                    return true;\n                }\n                return false;\n            });\n            (0,_metamask_detect_js__WEBPACK_IMPORTED_MODULE_4__.detectAndRegisterSolflareMetaMaskWallet)();\n        }\n    }\n    get publicKey() {\n        return this._publicKey;\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get connected() {\n        return !!this._wallet?.connected;\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    async autoConnect() {\n        // Skip autoconnect in the Loadable state on iOS\n        // We can't redirect to a universal link without user input\n        if (!(this.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Loadable && (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.isIosAndRedirectable)())) {\n            await this.connect();\n        }\n    }\n    async connect() {\n        try {\n            if (this.connected || this.connecting) return;\n            if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Loadable && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotReadyError();\n            // redirect to the Solflare /browse universal link\n            // this will open the current URL in the Solflare in-wallet browser\n            if (this.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Loadable && (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.isIosAndRedirectable)()) {\n                const url = encodeURIComponent(window.location.href);\n                const ref = encodeURIComponent(window.location.origin);\n                window.location.href = `https://solflare.com/ul/v1/browse/${url}?ref=${ref}`;\n                return;\n            }\n            let SolflareClass;\n            try {\n                SolflareClass = (await __webpack_require__.e(/*! import() */ \"vendor-chunks/@solflare-wallet\").then(__webpack_require__.bind(__webpack_require__, /*! @solflare-wallet/sdk */ \"(ssr)/./node_modules/@solflare-wallet/sdk/lib/esm/index.js\"))).default;\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletLoadError(error?.message, error);\n            }\n            let wallet;\n            try {\n                wallet = new SolflareClass({\n                    network: this._config.network\n                });\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError(error?.message, error);\n            }\n            this._connecting = true;\n            if (!wallet.connected) {\n                try {\n                    await wallet.connect();\n                } catch (error) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConnectionError(error?.message, error);\n                }\n            }\n            if (!wallet.publicKey) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConnectionError();\n            let publicKey;\n            try {\n                publicKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(wallet.publicKey.toBytes());\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletPublicKeyError(error?.message, error);\n            }\n            wallet.on(\"disconnect\", this._disconnected);\n            wallet.on(\"accountChanged\", this._accountChanged);\n            this._wallet = wallet;\n            this._publicKey = publicKey;\n            this.emit(\"connect\", publicKey);\n        } catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        } finally{\n            this._connecting = false;\n        }\n    }\n    async disconnect() {\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.off(\"disconnect\", this._disconnected);\n            wallet.off(\"accountChanged\", this._accountChanged);\n            this._wallet = null;\n            this._publicKey = null;\n            try {\n                await wallet.disconnect();\n            } catch (error) {\n                this.emit(\"error\", new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletDisconnectionError(error?.message, error));\n            }\n        }\n        this.emit(\"disconnect\");\n    }\n    async sendTransaction(transaction, connection, options = {}) {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n            try {\n                const { signers, ...sendOptions } = options;\n                if ((0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.isVersionedTransaction)(transaction)) {\n                    signers?.length && transaction.sign(signers);\n                } else {\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n                    signers?.length && transaction.partialSign(...signers);\n                }\n                sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;\n                return await wallet.signAndSendTransaction(transaction, sendOptions);\n            } catch (error) {\n                if (error instanceof _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletError) throw error;\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSendTransactionError(error?.message, error);\n            }\n        } catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n    async signTransaction(transaction) {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n            try {\n                return await wallet.signTransaction(transaction) || transaction;\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n    async signAllTransactions(transactions) {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n            try {\n                return await wallet.signAllTransactions(transactions) || transactions;\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n    async signMessage(message) {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n            try {\n                return await wallet.signMessage(message, \"utf8\");\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignMessageError(error?.message, error);\n            }\n        } catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n} //# sourceMappingURL=adapter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1zb2xmbGFyZS9saWIvZXNtL2FkYXB0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBNGI7QUFDaFo7QUFDbUM7QUFDeEUsTUFBTW1CLHFCQUFxQixXQUFXO0FBQ3RDLE1BQU1DLDhCQUE4QnBCLHVGQUE4QkE7SUFDckVxQixZQUFZQyxTQUFTLENBQUMsQ0FBQyxDQUFFO1FBQ3JCLEtBQUs7UUFDTCxJQUFJLENBQUNDLElBQUksR0FBR0o7UUFDWixJQUFJLENBQUNLLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyw0QkFBNEIsR0FBRyxJQUFJQyxJQUFJO1lBQUM7WUFBVTtTQUFFO1FBQ3pELElBQUksQ0FBQ0MsV0FBVyxHQUFHLEtBQXFELEdBQ2xFbEIseUVBQWdCQSxDQUFDb0IsV0FBVyxHQUM1QnBCLENBQXlCO1FBQy9CLElBQUksQ0FBQ3NCLGFBQWEsR0FBRztZQUNqQixNQUFNQyxTQUFTLElBQUksQ0FBQ0MsT0FBTztZQUMzQixJQUFJRCxRQUFRO2dCQUNSQSxPQUFPRSxHQUFHLENBQUMsY0FBYyxJQUFJLENBQUNILGFBQWE7Z0JBQzNDLElBQUksQ0FBQ0UsT0FBTyxHQUFHO2dCQUNmLElBQUksQ0FBQ0UsVUFBVSxHQUFHO2dCQUNsQixJQUFJLENBQUNDLElBQUksQ0FBQyxTQUFTLElBQUlsQyxnRkFBdUJBO2dCQUM5QyxJQUFJLENBQUNrQyxJQUFJLENBQUM7WUFDZDtRQUNKO1FBQ0EsSUFBSSxDQUFDQyxlQUFlLEdBQUcsQ0FBQ0M7WUFDcEIsSUFBSSxDQUFDQSxjQUNEO1lBQ0osTUFBTUMsWUFBWSxJQUFJLENBQUNKLFVBQVU7WUFDakMsSUFBSSxDQUFDSSxXQUNEO1lBQ0osSUFBSTtnQkFDQUQsZUFBZSxJQUFJdEIsc0RBQVNBLENBQUNzQixhQUFhRSxPQUFPO1lBQ3JELEVBQ0EsT0FBT0MsT0FBTztnQkFDVixJQUFJ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b2xhbmEvd2FsbGV0LWFkYXB0ZXItc29sZmxhcmUvbGliL2VzbS9hZGFwdGVyLmpzPzVmMmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZU1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyLCBXYWxsZXRDb25maWdFcnJvciwgV2FsbGV0Q29ubmVjdGlvbkVycm9yLCBXYWxsZXREaXNjb25uZWN0ZWRFcnJvciwgV2FsbGV0RGlzY29ubmVjdGlvbkVycm9yLCBXYWxsZXRFcnJvciwgV2FsbGV0TG9hZEVycm9yLCBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciwgV2FsbGV0Tm90UmVhZHlFcnJvciwgV2FsbGV0UHVibGljS2V5RXJyb3IsIFdhbGxldFJlYWR5U3RhdGUsIFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yLCBXYWxsZXRTaWduTWVzc2FnZUVycm9yLCBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvciwgaXNJb3NBbmRSZWRpcmVjdGFibGUsIGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24sIHNjb3BlUG9sbGluZ0RldGVjdGlvblN0cmF0ZWd5LCB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZSc7XG5pbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgZGV0ZWN0QW5kUmVnaXN0ZXJTb2xmbGFyZU1ldGFNYXNrV2FsbGV0IH0gZnJvbSAnLi9tZXRhbWFzay9kZXRlY3QuanMnO1xuZXhwb3J0IGNvbnN0IFNvbGZsYXJlV2FsbGV0TmFtZSA9ICdTb2xmbGFyZSc7XG5leHBvcnQgY2xhc3MgU29sZmxhcmVXYWxsZXRBZGFwdGVyIGV4dGVuZHMgQmFzZU1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBTb2xmbGFyZVdhbGxldE5hbWU7XG4gICAgICAgIHRoaXMudXJsID0gJ2h0dHBzOi8vc29sZmxhcmUuY29tJztcbiAgICAgICAgdGhpcy5pY29uID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpUHo0OGMzWm5JR2xrUFNKVElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0ExTUNBMU1DSStQR1JsWm5NK1BITjBlV3hsUGk1amJITXRNWHRtYVd4c09pTXdNakExTUdFN2MzUnliMnRsT2lObVptVm1ORFk3YzNSeWIydGxMVzFwZEdWeWJHbHRhWFE2TVRBN2MzUnliMnRsTFhkcFpIUm9PaTQxY0hnN2ZTNWpiSE10TW50bWFXeHNPaU5tWm1WbU5EWTdmVHd2YzNSNWJHVStQQzlrWldaelBqeHlaV04wSUdOc1lYTnpQU0pqYkhNdE1pSWdlRDBpTUNJZ2QybGtkR2c5SWpVd0lpQm9aV2xuYUhROUlqVXdJaUJ5ZUQwaU1USWlJSEo1UFNJeE1pSXZQanh3WVhSb0lHTnNZWE56UFNKamJITXRNU0lnWkQwaVRUSTBMakl6TERJMkxqUXliREl1TkRZdE1pNHpPQ3cwTGpVNUxERXVOV016TGpBeExERXNOQzQxTVN3eUxqZzBMRFF1TlRFc05TNDBNeXd3TERFdU9UWXRMamMxTERNdU1qWXRNaTR5TlN3MExqa3piQzB1TkRZdU5TNHhOeTB4TGpFM1l5NDJOeTAwTGpJMkxTNDFPQzAyTGpBNUxUUXVOekl0Tnk0ME0yd3ROQzR6TFRFdU16aG9NRnBOTVRndU1EVXNNVEV1T0RWc01USXVOVElzTkM0eE55MHlMamN4TERJdU5Ua3ROaTQxTVMweUxqRTNZeTB5TGpJMUxTNDNOUzB6TGpBeExURXVPVFl0TXk0ekxUUXVOVEYyTFM0d09HZ3dXazB4Tnk0ekxETXpMakEyYkRJdU9EUXRNaTQzTVN3MUxqTTBMREV1TnpWak1pNDRMamt5TERNdU56WXNNaTR4TXl3ekxqUTJMRFV1TVRoc0xURXhMalkxTFRRdU1qSm9NRnBOTVRNdU56RXNNakF1T1RWak1DMHVOemt1TkRJdE1TNDFOQ3d4TGpFekxUSXVNVGN1TnpVc01TNHdPU3d5TGpBMUxESXVNRFVzTkM0d09Td3lMamN4YkRRdU5ESXNNUzQwTmkweUxqUTJMREl1TXpndE5DNHpOQzB4TGpReVl5MHlMUzQyTnkweUxqZzBMVEV1TmpjdE1pNDROQzB5TGprMlRUSTJMamd5TERReUxqZzNZemt1TVRndE5pNHdPU3d4TkM0eE1TMHhNQzR5TXl3eE5DNHhNUzB4TlM0ek1pd3dMVE11TXpndE1pMDFMakkyTFRZdU5ETXROaTQzTW13dE15NHpOQzB4TGpFekxEa3VNVFF0T0M0M055MHhMamcwTFRFdU9UWXRNaTQzTVN3eUxqTTRMVEV5TGpneExUUXVNakpqTFRNdU9UY3NNUzR5T1MwNExqazNMRFV1TURrdE9DNDVOeXc0TGpnNUxEQXNMalF5TGpBMExqZ3pMakUzTERFdU1qa3RNeTR6TERFdU9EZ3ROQzQyTXl3ekxqWXpMVFF1TmpNc05TNDRMREFzTWk0d05Td3hMakE1TERRdU1Ea3NOQzQxTlN3MUxqSXliREl1TnpVdU9USXRPUzQxTWl3NUxqRTBMREV1T0RRc01TNDVOaXd5TGprMkxUSXVOekVzTVRRdU56TXNOUzR5TW1nd1dpSXZQand2YzNablBnPT0nO1xuICAgICAgICB0aGlzLnN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMgPSBuZXcgU2V0KFsnbGVnYWN5JywgMF0pO1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkXG4gICAgICAgICAgICA6IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGU7XG4gICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX3dhbGxldDtcbiAgICAgICAgICAgIGlmICh3YWxsZXQpIHtcbiAgICAgICAgICAgICAgICB3YWxsZXQub2ZmKCdkaXNjb25uZWN0JywgdGhpcy5fZGlzY29ubmVjdGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93YWxsZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBXYWxsZXREaXNjb25uZWN0ZWRFcnJvcigpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYWNjb3VudENoYW5nZWQgPSAobmV3UHVibGljS2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5ld1B1YmxpY0tleSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSB0aGlzLl9wdWJsaWNLZXk7XG4gICAgICAgICAgICBpZiAoIXB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ld1B1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkobmV3UHVibGljS2V5LnRvQnl0ZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IFdhbGxldFB1YmxpY0tleUVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwdWJsaWNLZXkuZXF1YWxzKG5ld1B1YmxpY0tleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fcHVibGljS2V5ID0gbmV3UHVibGljS2V5O1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JywgbmV3UHVibGljS2V5KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLl93YWxsZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBzY29wZVBvbGxpbmdEZXRlY3Rpb25TdHJhdGVneSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5zb2xmbGFyZT8uaXNTb2xmbGFyZSB8fCB3aW5kb3cuU29sZmxhcmVBcHApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5U3RhdGVDaGFuZ2UnLCB0aGlzLl9yZWFkeVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGV0ZWN0QW5kUmVnaXN0ZXJTb2xmbGFyZU1ldGFNYXNrV2FsbGV0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleTtcbiAgICB9XG4gICAgZ2V0IGNvbm5lY3RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW5nO1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl93YWxsZXQ/LmNvbm5lY3RlZDtcbiAgICB9XG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICAgIH1cbiAgICBhc3luYyBhdXRvQ29ubmVjdCgpIHtcbiAgICAgICAgLy8gU2tpcCBhdXRvY29ubmVjdCBpbiB0aGUgTG9hZGFibGUgc3RhdGUgb24gaU9TXG4gICAgICAgIC8vIFdlIGNhbid0IHJlZGlyZWN0IHRvIGEgdW5pdmVyc2FsIGxpbmsgd2l0aG91dCB1c2VyIGlucHV0XG4gICAgICAgIGlmICghKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSAmJiBpc0lvc0FuZFJlZGlyZWN0YWJsZSgpKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCB8fCB0aGlzLmNvbm5lY3RpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUgJiYgdGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKTtcbiAgICAgICAgICAgIC8vIHJlZGlyZWN0IHRvIHRoZSBTb2xmbGFyZSAvYnJvd3NlIHVuaXZlcnNhbCBsaW5rXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgb3BlbiB0aGUgY3VycmVudCBVUkwgaW4gdGhlIFNvbGZsYXJlIGluLXdhbGxldCBicm93c2VyXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlICYmIGlzSW9zQW5kUmVkaXJlY3RhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBlbmNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IGVuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGBodHRwczovL3NvbGZsYXJlLmNvbS91bC92MS9icm93c2UvJHt1cmx9P3JlZj0ke3JlZn1gO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBTb2xmbGFyZUNsYXNzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBTb2xmbGFyZUNsYXNzID0gKGF3YWl0IGltcG9ydCgnQHNvbGZsYXJlLXdhbGxldC9zZGsnKSkuZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRMb2FkRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB3YWxsZXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdhbGxldCA9IG5ldyBTb2xmbGFyZUNsYXNzKHsgbmV0d29yazogdGhpcy5fY29uZmlnLm5ldHdvcmsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29uZmlnRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF3YWxsZXQuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd2FsbGV0LmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXdhbGxldC5wdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcigpO1xuICAgICAgICAgICAgbGV0IHB1YmxpY0tleTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHVibGljS2V5ID0gbmV3IFB1YmxpY0tleSh3YWxsZXQucHVibGljS2V5LnRvQnl0ZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0UHVibGljS2V5RXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhbGxldC5vbignZGlzY29ubmVjdCcsIHRoaXMuX2Rpc2Nvbm5lY3RlZCk7XG4gICAgICAgICAgICB3YWxsZXQub24oJ2FjY291bnRDaGFuZ2VkJywgdGhpcy5fYWNjb3VudENoYW5nZWQpO1xuICAgICAgICAgICAgdGhpcy5fd2FsbGV0ID0gd2FsbGV0O1xuICAgICAgICAgICAgdGhpcy5fcHVibGljS2V5ID0gcHVibGljS2V5O1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JywgcHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSB0aGlzLl93YWxsZXQ7XG4gICAgICAgIGlmICh3YWxsZXQpIHtcbiAgICAgICAgICAgIHdhbGxldC5vZmYoJ2Rpc2Nvbm5lY3QnLCB0aGlzLl9kaXNjb25uZWN0ZWQpO1xuICAgICAgICAgICAgd2FsbGV0Lm9mZignYWNjb3VudENoYW5nZWQnLCB0aGlzLl9hY2NvdW50Q2hhbmdlZCk7XG4gICAgICAgICAgICB0aGlzLl93YWxsZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcHVibGljS2V5ID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgd2FsbGV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgV2FsbGV0RGlzY29ubmVjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fd2FsbGV0O1xuICAgICAgICAgICAgaWYgKCF3YWxsZXQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVycywgLi4uc2VuZE9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcnM/Lmxlbmd0aCAmJiB0cmFuc2FjdGlvbi5zaWduKHNpZ25lcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSAoYXdhaXQgdGhpcy5wcmVwYXJlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIHNlbmRPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcnM/Lmxlbmd0aCAmJiB0cmFuc2FjdGlvbi5wYXJ0aWFsU2lnbiguLi5zaWduZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VuZE9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCA9IHNlbmRPcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgfHwgY29ubmVjdGlvbi5jb21taXRtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB3YWxsZXQuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2VuZE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgV2FsbGV0RXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fd2FsbGV0O1xuICAgICAgICAgICAgaWYgKCF3YWxsZXQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYXdhaXQgd2FsbGV0LnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpIHx8IHRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX3dhbGxldDtcbiAgICAgICAgICAgIGlmICghd2FsbGV0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGF3YWl0IHdhbGxldC5zaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykpIHx8IHRyYW5zYWN0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX3dhbGxldDtcbiAgICAgICAgICAgIGlmICghd2FsbGV0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgd2FsbGV0LnNpZ25NZXNzYWdlKG1lc3NhZ2UsICd1dGY4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2lnbk1lc3NhZ2VFcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRlci5qcy5tYXAiXSwibmFtZXMiOlsiQmFzZU1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyIiwiV2FsbGV0Q29uZmlnRXJyb3IiLCJXYWxsZXRDb25uZWN0aW9uRXJyb3IiLCJXYWxsZXREaXNjb25uZWN0ZWRFcnJvciIsIldhbGxldERpc2Nvbm5lY3Rpb25FcnJvciIsIldhbGxldEVycm9yIiwiV2FsbGV0TG9hZEVycm9yIiwiV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IiLCJXYWxsZXROb3RSZWFkeUVycm9yIiwiV2FsbGV0UHVibGljS2V5RXJyb3IiLCJXYWxsZXRSZWFkeVN0YXRlIiwiV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJXYWxsZXRTaWduTWVzc2FnZUVycm9yIiwiV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IiLCJpc0lvc0FuZFJlZGlyZWN0YWJsZSIsImlzVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJzY29wZVBvbGxpbmdEZXRlY3Rpb25TdHJhdGVneSIsIlB1YmxpY0tleSIsImRldGVjdEFuZFJlZ2lzdGVyU29sZmxhcmVNZXRhTWFza1dhbGxldCIsIlNvbGZsYXJlV2FsbGV0TmFtZSIsIlNvbGZsYXJlV2FsbGV0QWRhcHRlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwibmFtZSIsInVybCIsImljb24iLCJzdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zIiwiU2V0IiwiX3JlYWR5U3RhdGUiLCJkb2N1bWVudCIsIlVuc3VwcG9ydGVkIiwiTG9hZGFibGUiLCJfZGlzY29ubmVjdGVkIiwid2FsbGV0IiwiX3dhbGxldCIsIm9mZiIsIl9wdWJsaWNLZXkiLCJlbWl0IiwiX2FjY291bnRDaGFuZ2VkIiwibmV3UHVibGljS2V5IiwicHVibGljS2V5IiwidG9CeXRlcyIsImVycm9yIiwibWVzc2FnZSIsImVxdWFscyIsIl9jb25uZWN0aW5nIiwiX2NvbmZpZyIsIndpbmRvdyIsInNvbGZsYXJlIiwiaXNTb2xmbGFyZSIsIlNvbGZsYXJlQXBwIiwiSW5zdGFsbGVkIiwiY29ubmVjdGluZyIsImNvbm5lY3RlZCIsInJlYWR5U3RhdGUiLCJhdXRvQ29ubmVjdCIsImNvbm5lY3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJsb2NhdGlvbiIsImhyZWYiLCJyZWYiLCJvcmlnaW4iLCJTb2xmbGFyZUNsYXNzIiwiZGVmYXVsdCIsIm5ldHdvcmsiLCJvbiIsImRpc2Nvbm5lY3QiLCJzZW5kVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbiIsImNvbm5lY3Rpb24iLCJvcHRpb25zIiwic2lnbmVycyIsInNlbmRPcHRpb25zIiwibGVuZ3RoIiwic2lnbiIsInByZXBhcmVUcmFuc2FjdGlvbiIsInBhcnRpYWxTaWduIiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsImNvbW1pdG1lbnQiLCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uIiwic2lnblRyYW5zYWN0aW9uIiwic2lnbkFsbFRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9ucyIsInNpZ25NZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-solflare/lib/esm/adapter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/detect.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/detect.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectAndRegisterSolflareMetaMaskWallet: () => (/* binding */ detectAndRegisterSolflareMetaMaskWallet)\n/* harmony export */ });\n/* harmony import */ var _wallet_standard_wallet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wallet-standard/wallet */ \"(ssr)/./node_modules/@wallet-standard/wallet/lib/esm/register.js\");\n/* harmony import */ var _wallet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wallet.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/wallet.js\");\n\n\nlet registered = false;\nfunction register() {\n    if (registered) return;\n    (0,_wallet_standard_wallet__WEBPACK_IMPORTED_MODULE_0__.registerWallet)(new _wallet_js__WEBPACK_IMPORTED_MODULE_1__.SolflareMetaMaskWallet());\n    registered = true;\n}\n/** @internal */ async function detectAndRegisterSolflareMetaMaskWallet() {\n    const id = \"solflare-detect-metamask\";\n    function postMessage() {\n        window.postMessage({\n            target: \"metamask-contentscript\",\n            data: {\n                name: \"metamask-provider\",\n                data: {\n                    id,\n                    jsonrpc: \"2.0\",\n                    method: \"wallet_getSnaps\"\n                }\n            }\n        }, window.location.origin);\n    }\n    function onMessage(event) {\n        const message = event.data;\n        if (message?.target === \"metamask-inpage\" && message.data?.name === \"metamask-provider\") {\n            if (message.data.data?.id === id) {\n                window.removeEventListener(\"message\", onMessage);\n                if (!message.data.data.error) {\n                    register();\n                }\n            } else {\n                postMessage();\n            }\n        }\n    }\n    window.addEventListener(\"message\", onMessage);\n    window.setTimeout(()=>window.removeEventListener(\"message\", onMessage), 5000);\n    postMessage();\n} //# sourceMappingURL=detect.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1zb2xmbGFyZS9saWIvZXNtL21ldGFtYXNrL2RldGVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUQ7QUFDSjtBQUNyRCxJQUFJRSxhQUFhO0FBQ2pCLFNBQVNDO0lBQ0wsSUFBSUQsWUFDQTtJQUNKRix1RUFBY0EsQ0FBQyxJQUFJQyw4REFBc0JBO0lBQ3pDQyxhQUFhO0FBQ2pCO0FBQ0EsY0FBYyxHQUNQLGVBQWVFO0lBQ2xCLE1BQU1DLEtBQUs7SUFDWCxTQUFTQztRQUNMQyxPQUFPRCxXQUFXLENBQUM7WUFDZkUsUUFBUTtZQUNSQyxNQUFNO2dCQUNGQyxNQUFNO2dCQUNORCxNQUFNO29CQUNGSjtvQkFDQU0sU0FBUztvQkFDVEMsUUFBUTtnQkFDWjtZQUNKO1FBQ0osR0FBR0wsT0FBT00sUUFBUSxDQUFDQyxNQUFNO0lBQzdCO0lBQ0EsU0FBU0MsVUFBVUMsS0FBSztRQUNwQixNQUFNQyxVQUFVRCxNQUFNUCxJQUFJO1FBQzFCLElBQUlRLFNBQVNULFdBQVcscUJBQXFCUyxRQUFRUixJQUFJLEVBQUVDLFNBQVMscUJBQXFCO1lBQ3JGLElBQUlPLFFBQVFSLElBQUksQ0FBQ0EsSUFBSSxFQUFFSixPQUFPQSxJQUFJO2dCQUM5QkUsT0FBT1csbUJBQW1CLENBQUMsV0FBV0g7Z0JBQ3RDLElBQUksQ0FBQ0UsUUFBUVIsSUFBSSxDQUFDQSxJQUFJLENBQUNVLEtBQUssRUFBRTtvQkFDMUJoQjtnQkFDSjtZQUNKLE9BQ0s7Z0JBQ0RHO1lBQ0o7UUFDSjtJQUNKO0lBQ0FDLE9BQU9hLGdCQUFnQixDQUFDLFdBQVdMO0lBQ25DUixPQUFPYyxVQUFVLENBQUMsSUFBTWQsT0FBT1csbUJBQW1CLENBQUMsV0FBV0gsWUFBWTtJQUMxRVQ7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItc29sZmxhcmUvbGliL2VzbS9tZXRhbWFzay9kZXRlY3QuanM/ZWE3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWdpc3RlcldhbGxldCB9IGZyb20gJ0B3YWxsZXQtc3RhbmRhcmQvd2FsbGV0JztcbmltcG9ydCB7IFNvbGZsYXJlTWV0YU1hc2tXYWxsZXQgfSBmcm9tICcuL3dhbGxldC5qcyc7XG5sZXQgcmVnaXN0ZXJlZCA9IGZhbHNlO1xuZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgaWYgKHJlZ2lzdGVyZWQpXG4gICAgICAgIHJldHVybjtcbiAgICByZWdpc3RlcldhbGxldChuZXcgU29sZmxhcmVNZXRhTWFza1dhbGxldCgpKTtcbiAgICByZWdpc3RlcmVkID0gdHJ1ZTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXRlY3RBbmRSZWdpc3RlclNvbGZsYXJlTWV0YU1hc2tXYWxsZXQoKSB7XG4gICAgY29uc3QgaWQgPSAnc29sZmxhcmUtZGV0ZWN0LW1ldGFtYXNrJztcbiAgICBmdW5jdGlvbiBwb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHRhcmdldDogJ21ldGFtYXNrLWNvbnRlbnRzY3JpcHQnLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdtZXRhbWFzay1wcm92aWRlcicsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9nZXRTbmFwcycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGlmIChtZXNzYWdlPy50YXJnZXQgPT09ICdtZXRhbWFzay1pbnBhZ2UnICYmIG1lc3NhZ2UuZGF0YT8ubmFtZSA9PT0gJ21ldGFtYXNrLXByb3ZpZGVyJykge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YS5kYXRhPy5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmRhdGEuZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlKSwgNTAwMCk7XG4gICAgcG9zdE1lc3NhZ2UoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdC5qcy5tYXAiXSwibmFtZXMiOlsicmVnaXN0ZXJXYWxsZXQiLCJTb2xmbGFyZU1ldGFNYXNrV2FsbGV0IiwicmVnaXN0ZXJlZCIsInJlZ2lzdGVyIiwiZGV0ZWN0QW5kUmVnaXN0ZXJTb2xmbGFyZU1ldGFNYXNrV2FsbGV0IiwiaWQiLCJwb3N0TWVzc2FnZSIsIndpbmRvdyIsInRhcmdldCIsImRhdGEiLCJuYW1lIiwianNvbnJwYyIsIm1ldGhvZCIsImxvY2F0aW9uIiwib3JpZ2luIiwib25NZXNzYWdlIiwiZXZlbnQiLCJtZXNzYWdlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImVycm9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNldFRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/detect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/icon.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/icon.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   icon: () => (/* binding */ icon)\n/* harmony export */ });\n/** @internal */ const icon = \"data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMxIiB2aWV3Qm94PSIwIDAgMzEgMzEiIHdpZHRoPSIzMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIwLjI1IiB4Mj0iMjYuNTcxIiB5MT0iMjcuMTczIiB5Mj0iMTkuODU4Ij48c3RvcCBvZmZzZXQ9Ii4wOCIgc3RvcC1jb2xvcj0iIzk5NDVmZiIvPjxzdG9wIG9mZnNldD0iLjMiIHN0b3AtY29sb3I9IiM4NzUyZjMiLz48c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjNTQ5N2Q1Ii8+PHN0b3Agb2Zmc2V0PSIuNiIgc3RvcC1jb2xvcj0iIzQzYjRjYSIvPjxzdG9wIG9mZnNldD0iLjcyIiBzdG9wLWNvbG9yPSIjMjhlMGI5Ii8+PHN0b3Agb2Zmc2V0PSIuOTciIHN0b3AtY29sb3I9IiMxOWZiOWIiLz48L2xpbmVhckdyYWRpZW50PjxnIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iLjA5NCI+PHBhdGggZD0ibTI2LjEwOSAzLjY0My05LjM2OSA2Ljk1OSAxLjczMy00LjEwNSA3LjYzNy0yLjg1M3oiIGZpbGw9IiNlMjc2MWIiIHN0cm9rZT0iI2UyNzYxYiIvPjxnIGZpbGw9IiNlNDc2MWIiIHN0cm9rZT0iI2U0NzYxYiI+PHBhdGggZD0ibTQuNDgxIDMuNjQzIDkuMjk0IDcuMDI0LTEuNjQ4LTQuMTcxem0xOC4yNTggMTYuMTMtMi40OTUgMy44MjMgNS4zMzkgMS40NjkgMS41MzUtNS4yMDctNC4zNzgtLjA4NXptLTE5LjI0Ny4wODUgMS41MjUgNS4yMDcgNS4zMzktMS40NjktMi40OTUtMy44MjN6Ii8+PHBhdGggZD0ibTEwLjA1NSAxMy4zMTMtMS40ODggMi4yNTEgNS4zMDEuMjM1LS4xODgtNS42OTd6bTEwLjQ4IDAtMy42NzItMy4yNzctLjEyMiA1Ljc2MyA1LjI5Mi0uMjM1LTEuNDk3LTIuMjUxem0tMTAuMTc4IDEwLjI4MyAzLjE4My0xLjU1NC0yLjc0OS0yLjE0Ny0uNDMzIDMuNzAxem02LjY5NS0xLjU1NCAzLjE5MiAxLjU1NC0uNDQzLTMuNzAxeiIvPjwvZz48cGF0aCBkPSJtMjAuMjQ0IDIzLjU5Ni0zLjE5Mi0xLjU1NC4yNTQgMi4wODEtLjAyOC44NzZ6bS05Ljg4NyAwIDIuOTY2IDEuNDAzLS4wMTktLjg3Ni4yMzUtMi4wODEtMy4xODMgMS41NTR6IiBmaWxsPSIjZDdjMWIzIiBzdHJva2U9IiNkN2MxYjMiLz48cGF0aCBkPSJtMTMuMzY5IDE4LjUyMS0yLjY1NS0uNzgxIDEuODc0LS44NTd6bTMuODUxIDAgLjc4MS0xLjYzOCAxLjg4My44NTctMi42NjUuNzgxeiIgZmlsbD0iIzIzMzQ0NyIgc3Ryb2tlPSIjMjMzNDQ3Ii8+PHBhdGggZD0ibTEwLjM1NyAyMy41OTYuNDUyLTMuODIzLTIuOTQ3LjA4NXptOS40MzUtMy44MjMuNDUyIDMuODIzIDIuNDk1LTMuNzM4em0yLjI0MS00LjIwOS01LjI5Mi4yMzUuNDkgMi43MjEuNzgyLTEuNjM4IDEuODgzLjg1N3ptLTExLjMxOCAyLjE3NSAxLjg4My0uODU3Ljc3MiAxLjYzOC40OTktMi43MjEtNS4zMDEtLjIzNXoiIGZpbGw9IiNjZDYxMTYiIHN0cm9rZT0iI2NkNjExNiIvPjxwYXRoIGQ9Im04LjU2NyAxNS41NjQgMi4yMjIgNC4zMzEtLjA3NS0yLjE1NnptMTEuMzI4IDIuMTc1LS4wOTQgMi4xNTYgMi4yMzItNC4zMzEtMi4xMzcgMi4xNzV6bS02LjAyNi0xLjk0LS40OTkgMi43MjEuNjIxIDMuMjExLjE0MS00LjIyOC0uMjY0LTEuNzA0em0yLjg3MiAwLS4yNTQgMS42OTUuMTEzIDQuMjM3LjYzMS0zLjIxMXoiIGZpbGw9IiNlNDc1MWYiIHN0cm9rZT0iI2U0NzUxZiIvPjxwYXRoIGQ9Im0xNy4yMyAxOC41Mi0uNjMxIDMuMjExLjQ1Mi4zMTEgMi43NS0yLjE0Ny4wOTQtMi4xNTZ6bS02LjUxNi0uNzgxLjA3NSAyLjE1NiAyLjc1IDIuMTQ3LjQ1Mi0uMzExLS42MjItMy4yMTF6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48cGF0aCBkPSJtMTcuMjc3IDI0Ljk5OS4wMjgtLjg3Ni0uMjM1LS4yMDdoLTMuNTVsLS4yMTcuMjA3LjAxOS44NzYtMi45NjYtMS40MDMgMS4wMzYuODQ4IDIuMSAxLjQ1OWgzLjYwNmwyLjEwOS0xLjQ1OSAxLjAzNi0uODQ4eiIgZmlsbD0iI2MwYWQ5ZSIgc3Ryb2tlPSIjYzBhZDllIi8+PHBhdGggZD0ibTE3LjA1MSAyMi4wNDItLjQ1Mi0uMzExaC0yLjYwOGwtLjQ1Mi4zMTEtLjIzNSAyLjA4MS4yMTctLjIwN2gzLjU1bC4yMzUuMjA3LS4yNTQtMi4wODF6IiBmaWxsPSIjMTYxNjE2IiBzdHJva2U9IiMxNjE2MTYiLz48cGF0aCBkPSJtMjYuNTA1IDExLjA1My44LTMuODQyLTEuMTk2LTMuNTY5LTkuMDU4IDYuNzIzIDMuNDg0IDIuOTQ3IDQuOTI1IDEuNDQxIDEuMDkyLTEuMjcxLS40NzEtLjMzOS43NTMtLjY4Ny0uNTg0LS40NTIuNzUzLS41NzQtLjQ5OS0uMzc3em0tMjMuMjExLTMuODQxLjggMy44NDItLjUwOC4zNzcuNzUzLjU3NC0uNTc0LjQ1Mi43NTMuNjg3LS40NzEuMzM5IDEuMDgzIDEuMjcxIDQuOTI1LTEuNDQxIDMuNDg0LTIuOTQ3LTkuMDU5LTYuNzIzeiIgZmlsbD0iIzc2M2QxNiIgc3Ryb2tlPSIjNzYzZDE2Ii8+PHBhdGggZD0ibTI1LjQ2IDE0Ljc1NC00LjkyNS0xLjQ0MSAxLjQ5NyAyLjI1MS0yLjIzMiA0LjMzMSAyLjkzOC0uMDM4aDQuMzc4bC0xLjY1Ny01LjEwNHptLTE1LjQwNS0xLjQ0MS00LjkyNSAxLjQ0MS0xLjYzOCA1LjEwNGg0LjM2OWwyLjkyOC4wMzgtMi4yMjItNC4zMzEgMS40ODgtMi4yNTF6bTYuNjg1IDIuNDg2LjMxMS01LjQzMyAxLjQzMS0zLjg3aC02LjM1NmwxLjQxMyAzLjg3LjMyOSA1LjQzMy4xMTMgMS43MTQuMDA5IDQuMjE5aDIuNjFsLjAxOS00LjIxOS4xMjItMS43MTR6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48L2c+PGNpcmNsZSBjeD0iMjMuNSIgY3k9IjIzLjUiIGZpbGw9IiMwMDAiIHI9IjYuNSIvPjxwYXRoIGQ9Im0yNy40NzMgMjUuNTQ1LTEuMzEgMS4zNjhjLS4wMjkuMDMtLjA2My4wNTMtLjEwMS4wN2EuMzEuMzEgMCAwIDEgLS4xMjEuMDI0aC02LjIwOWMtLjAzIDAtLjA1OS0uMDA4LS4wODMtLjAyNGEuMTUuMTUgMCAwIDEgLS4wNTYtLjA2NWMtLjAxMi0uMDI2LS4wMTUtLjA1Ni0uMDEtLjA4NHMuMDE4LS4wNTUuMDM5LS4wNzZsMS4zMTEtMS4zNjhjLjAyOC0uMDMuMDYzLS4wNTMuMTAxLS4wNjlhLjMxLjMxIDAgMCAxIC4xMjEtLjAyNWg2LjIwOGMuMDMgMCAuMDU5LjAwOC4wODMuMDI0YS4xNS4xNSAwIDAgMSAuMDU2LjA2NWMuMDEyLjAyNi4wMTUuMDU2LjAxLjA4NHMtLjAxOC4wNTUtLjAzOS4wNzZ6bS0xLjMxLTIuNzU2Yy0uMDI5LS4wMy0uMDYzLS4wNTMtLjEwMS0uMDdhLjMxLjMxIDAgMCAwIC0uMTIxLS4wMjRoLTYuMjA5Yy0uMDMgMC0uMDU5LjAwOC0uMDgzLjAyNHMtLjA0NC4wMzgtLjA1Ni4wNjUtLjAxNS4wNTYtLjAxLjA4NC4wMTguMDU1LjAzOS4wNzZsMS4zMTEgMS4zNjhjLjAyOC4wMy4wNjMuMDUzLjEwMS4wNjlhLjMxLjMxIDAgMCAwIC4xMjEuMDI1aDYuMjA4Yy4wMyAwIC4wNTktLjAwOC4wODMtLjAyNGEuMTUuMTUgMCAwIDAgLjA1Ni0uMDY1Yy4wMTItLjAyNi4wMTUtLjA1Ni4wMS0uMDg0cy0uMDE4LS4wNTUtLjAzOS0uMDc2em0tNi40MzEtLjk4M2g2LjIwOWEuMzEuMzEgMCAwIDAgLjEyMS0uMDI0Yy4wMzgtLjAxNi4wNzMtLjA0LjEwMS0uMDdsMS4zMS0xLjM2OGMuMDItLjAyMS4wMzQtLjA0Ny4wMzktLjA3NnMuMDAxLS4wNTgtLjAxLS4wODRhLjE1LjE1IDAgMCAwIC0uMDU2LS4wNjVjLS4wMjUtLjAxNi0uMDU0LS4wMjQtLjA4My0uMDI0aC02LjIwOGEuMzEuMzEgMCAwIDAgLS4xMjEuMDI1Yy0uMDM4LjAxNi0uMDcyLjA0LS4xMDEuMDY5bC0xLjMxIDEuMzY4Yy0uMDIuMDIxLS4wMzQuMDQ3LS4wMzkuMDc2cy0uMDAxLjA1OC4wMS4wODQuMDMxLjA0OS4wNTYuMDY1LjA1NC4wMjQuMDgzLjAyNHoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=\"; //# sourceMappingURL=icon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1zb2xmbGFyZS9saWIvZXNtL21ldGFtYXNrL2ljb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGNBQWMsR0FDUCxNQUFNQSxPQUFPLHFqS0FBcWpLLENBQ3prSyxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXNvbGZsYXJlL2xpYi9lc20vbWV0YW1hc2svaWNvbi5qcz9hZDkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpY29uID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5Qm1hV3hzUFNKdWIyNWxJaUJvWldsbmFIUTlJak14SWlCMmFXVjNRbTk0UFNJd0lEQWdNekVnTXpFaUlIZHBaSFJvUFNJek1TSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklpQjRiV3h1Y3pwNGJHbHVhejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOTRiR2x1YXlJK1BHeHBibVZoY2tkeVlXUnBaVzUwSUdsa1BTSmhJaUJuY21Ga2FXVnVkRlZ1YVhSelBTSjFjMlZ5VTNCaFkyVlBibFZ6WlNJZ2VERTlJakl3TGpJMUlpQjRNajBpTWpZdU5UY3hJaUI1TVQwaU1qY3VNVGN6SWlCNU1qMGlNVGt1T0RVNElqNDhjM1J2Y0NCdlptWnpaWFE5SWk0d09DSWdjM1J2Y0MxamIyeHZjajBpSXprNU5EVm1aaUl2UGp4emRHOXdJRzltWm5ObGREMGlMak1pSUhOMGIzQXRZMjlzYjNJOUlpTTROelV5WmpNaUx6NDhjM1J2Y0NCdlptWnpaWFE5SWk0MUlpQnpkRzl3TFdOdmJHOXlQU0lqTlRRNU4yUTFJaTgrUEhOMGIzQWdiMlptYzJWMFBTSXVOaUlnYzNSdmNDMWpiMnh2Y2owaUl6UXpZalJqWVNJdlBqeHpkRzl3SUc5bVpuTmxkRDBpTGpjeUlpQnpkRzl3TFdOdmJHOXlQU0lqTWpobE1HSTVJaTgrUEhOMGIzQWdiMlptYzJWMFBTSXVPVGNpSUhOMGIzQXRZMjlzYjNJOUlpTXhPV1ppT1dJaUx6NDhMMnhwYm1WaGNrZHlZV1JwWlc1MFBqeG5JSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUlITjBjbTlyWlMxM2FXUjBhRDBpTGpBNU5DSStQSEJoZEdnZ1pEMGliVEkyTGpFd09TQXpMalkwTXkwNUxqTTJPU0EyTGprMU9TQXhMamN6TXkwMExqRXdOU0EzTGpZek55MHlMamcxTTNvaUlHWnBiR3c5SWlObE1qYzJNV0lpSUhOMGNtOXJaVDBpSTJVeU56WXhZaUl2UGp4bklHWnBiR3c5SWlObE5EYzJNV0lpSUhOMGNtOXJaVDBpSTJVME56WXhZaUkrUEhCaGRHZ2daRDBpYlRRdU5EZ3hJRE11TmpReklEa3VNamswSURjdU1ESTBMVEV1TmpRNExUUXVNVGN4ZW0weE9DNHlOVGdnTVRZdU1UTXRNaTQwT1RVZ015NDRNak1nTlM0ek16a2dNUzQwTmprZ01TNDFNelV0TlM0eU1EY3ROQzR6TnpndExqQTROWHB0TFRFNUxqSTBOeTR3T0RVZ01TNDFNalVnTlM0eU1EY2dOUzR6TXprdE1TNDBOamt0TWk0ME9UVXRNeTQ0TWpONklpOCtQSEJoZEdnZ1pEMGliVEV3TGpBMU5TQXhNeTR6TVRNdE1TNDBPRGdnTWk0eU5URWdOUzR6TURFdU1qTTFMUzR4T0RndE5TNDJPVGQ2YlRFd0xqUTRJREF0TXk0Mk56SXRNeTR5TnpjdExqRXlNaUExTGpjMk15QTFMakk1TWkwdU1qTTFMVEV1TkRrM0xUSXVNalV4ZW0wdE1UQXVNVGM0SURFd0xqSTRNeUF6TGpFNE15MHhMalUxTkMweUxqYzBPUzB5TGpFME55MHVORE16SURNdU56QXhlbTAyTGpZNU5TMHhMalUxTkNBekxqRTVNaUF4TGpVMU5DMHVORFF6TFRNdU56QXhlaUl2UGp3dlp6NDhjR0YwYUNCa1BTSnRNakF1TWpRMElESXpMalU1TmkwekxqRTVNaTB4TGpVMU5DNHlOVFFnTWk0d09ERXRMakF5T0M0NE56WjZiUzA1TGpnNE55QXdJREl1T1RZMklERXVOREF6TFM0d01Ua3RMamczTmk0eU16VXRNaTR3T0RFdE15NHhPRE1nTVM0MU5UUjZJaUJtYVd4c1BTSWpaRGRqTVdJeklpQnpkSEp2YTJVOUlpTmtOMk14WWpNaUx6NDhjR0YwYUNCa1BTSnRNVE11TXpZNUlERTRMalV5TVMweUxqWTFOUzB1TnpneElERXVPRGMwTFM0NE5UZDZiVE11T0RVeElEQWdMamM0TVMweExqWXpPQ0F4TGpnNE15NDROVGN0TWk0Mk5qVXVOemd4ZWlJZ1ptbHNiRDBpSXpJek16UTBOeUlnYzNSeWIydGxQU0lqTWpNek5EUTNJaTgrUEhCaGRHZ2daRDBpYlRFd0xqTTFOeUF5TXk0MU9UWXVORFV5TFRNdU9ESXpMVEl1T1RRM0xqQTROWHB0T1M0ME16VXRNeTQ0TWpNdU5EVXlJRE11T0RJeklESXVORGsxTFRNdU56TTRlbTB5TGpJME1TMDBMakl3T1MwMUxqSTVNaTR5TXpVdU5Ea2dNaTQzTWpFdU56Z3lMVEV1TmpNNElERXVPRGd6TGpnMU4zcHRMVEV4TGpNeE9DQXlMakUzTlNBeExqZzRNeTB1T0RVM0xqYzNNaUF4TGpZek9DNDBPVGt0TWk0M01qRXROUzR6TURFdExqSXpOWG9pSUdacGJHdzlJaU5qWkRZeE1UWWlJSE4wY205clpUMGlJMk5rTmpFeE5pSXZQanh3WVhSb0lHUTlJbTA0TGpVMk55QXhOUzQxTmpRZ01pNHlNaklnTkM0ek16RXRMakEzTlMweUxqRTFObnB0TVRFdU16STRJREl1TVRjMUxTNHdPVFFnTWk0eE5UWWdNaTR5TXpJdE5DNHpNekV0TWk0eE16Y2dNaTR4TnpWNmJTMDJMakF5TmkweExqazBMUzQwT1RrZ01pNDNNakV1TmpJeElETXVNakV4TGpFME1TMDBMakl5T0MwdU1qWTBMVEV1TnpBMGVtMHlMamczTWlBd0xTNHlOVFFnTVM0Mk9UVXVNVEV6SURRdU1qTTNMall6TVMwekxqSXhNWG9pSUdacGJHdzlJaU5sTkRjMU1XWWlJSE4wY205clpUMGlJMlUwTnpVeFppSXZQanh3WVhSb0lHUTlJbTB4Tnk0eU15QXhPQzQxTWkwdU5qTXhJRE11TWpFeExqUTFNaTR6TVRFZ01pNDNOUzB5TGpFME55NHdPVFF0TWk0eE5UWjZiUzAyTGpVeE5pMHVOemd4TGpBM05TQXlMakUxTmlBeUxqYzFJREl1TVRRM0xqUTFNaTB1TXpFeExTNDJNakl0TXk0eU1URjZJaUJtYVd4c1BTSWpaalk0TlRGaUlpQnpkSEp2YTJVOUlpTm1OamcxTVdJaUx6NDhjR0YwYUNCa1BTSnRNVGN1TWpjM0lESTBMams1T1M0d01qZ3RMamczTmkwdU1qTTFMUzR5TURkb0xUTXVOVFZzTFM0eU1UY3VNakEzTGpBeE9TNDROell0TWk0NU5qWXRNUzQwTURNZ01TNHdNell1T0RRNElESXVNU0F4TGpRMU9XZ3pMall3Tm13eUxqRXdPUzB4TGpRMU9TQXhMakF6TmkwdU9EUTRlaUlnWm1sc2JEMGlJMk13WVdRNVpTSWdjM1J5YjJ0bFBTSWpZekJoWkRsbElpOCtQSEJoZEdnZ1pEMGliVEUzTGpBMU1TQXlNaTR3TkRJdExqUTFNaTB1TXpFeGFDMHlMall3T0d3dExqUTFNaTR6TVRFdExqSXpOU0F5TGpBNE1TNHlNVGN0TGpJd04yZ3pMalUxYkM0eU16VXVNakEzTFM0eU5UUXRNaTR3T0RGNklpQm1hV3hzUFNJak1UWXhOakUySWlCemRISnZhMlU5SWlNeE5qRTJNVFlpTHo0OGNHRjBhQ0JrUFNKdE1qWXVOVEExSURFeExqQTFNeTQ0TFRNdU9EUXlMVEV1TVRrMkxUTXVOVFk1TFRrdU1EVTRJRFl1TnpJeklETXVORGcwSURJdU9UUTNJRFF1T1RJMUlERXVORFF4SURFdU1Ea3lMVEV1TWpjeExTNDBOekV0TGpNek9TNDNOVE10TGpZNE55MHVOVGcwTFM0ME5USXVOelV6TFM0MU56UXRMalE1T1MwdU16YzNlbTB0TWpNdU1qRXhMVE11T0RReExqZ2dNeTQ0TkRJdExqVXdPQzR6TnpjdU56VXpMalUzTkMwdU5UYzBMalExTWk0M05UTXVOamczTFM0ME56RXVNek01SURFdU1EZ3pJREV1TWpjeElEUXVPVEkxTFRFdU5EUXhJRE11TkRnMExUSXVPVFEzTFRrdU1EVTVMVFl1TnpJemVpSWdabWxzYkQwaUl6YzJNMlF4TmlJZ2MzUnliMnRsUFNJak56WXpaREUySWk4K1BIQmhkR2dnWkQwaWJUSTFMalEySURFMExqYzFOQzAwTGpreU5TMHhMalEwTVNBeExqUTVOeUF5TGpJMU1TMHlMakl6TWlBMExqTXpNU0F5TGprek9DMHVNRE00YURRdU16YzRiQzB4TGpZMU55MDFMakV3TkhwdExURTFMalF3TlMweExqUTBNUzAwTGpreU5TQXhMalEwTVMweExqWXpPQ0ExTGpFd05HZzBMak0yT1d3eUxqa3lPQzR3TXpndE1pNHlNakl0TkM0ek16RWdNUzQwT0RndE1pNHlOVEY2YlRZdU5qZzFJREl1TkRnMkxqTXhNUzAxTGpRek15QXhMalF6TVMwekxqZzNhQzAyTGpNMU5td3hMalF4TXlBekxqZzNMak15T1NBMUxqUXpNeTR4TVRNZ01TNDNNVFF1TURBNUlEUXVNakU1YURJdU5qRnNMakF4T1MwMExqSXhPUzR4TWpJdE1TNDNNVFI2SWlCbWFXeHNQU0lqWmpZNE5URmlJaUJ6ZEhKdmEyVTlJaU5tTmpnMU1XSWlMejQ4TDJjK1BHTnBjbU5zWlNCamVEMGlNak11TlNJZ1kzazlJakl6TGpVaUlHWnBiR3c5SWlNd01EQWlJSEk5SWpZdU5TSXZQanh3WVhSb0lHUTlJbTB5Tnk0ME56TWdNalV1TlRRMUxURXVNekVnTVM0ek5qaGpMUzR3TWprdU1ETXRMakEyTXk0d05UTXRMakV3TVM0d04yRXVNekV1TXpFZ01DQXdJREVnTFM0eE1qRXVNREkwYUMwMkxqSXdPV010TGpBeklEQXRMakExT1MwdU1EQTRMUzR3T0RNdExqQXlOR0V1TVRVdU1UVWdNQ0F3SURFZ0xTNHdOVFl0TGpBMk5XTXRMakF4TWkwdU1ESTJMUzR3TVRVdExqQTFOaTB1TURFdExqQTROSE11TURFNExTNHdOVFV1TURNNUxTNHdOelpzTVM0ek1URXRNUzR6TmpoakxqQXlPQzB1TURNdU1EWXpMUzR3TlRNdU1UQXhMUzR3TmpsaExqTXhMak14SURBZ01DQXhJQzR4TWpFdExqQXlOV2cyTGpJd09HTXVNRE1nTUNBdU1EVTVMakF3T0M0d09ETXVNREkwWVM0eE5TNHhOU0F3SURBZ01TQXVNRFUyTGpBMk5XTXVNREV5TGpBeU5pNHdNVFV1TURVMkxqQXhMakE0TkhNdExqQXhPQzR3TlRVdExqQXpPUzR3TnpaNmJTMHhMak14TFRJdU56VTJZeTB1TURJNUxTNHdNeTB1TURZekxTNHdOVE10TGpFd01TMHVNRGRoTGpNeExqTXhJREFnTUNBd0lDMHVNVEl4TFM0d01qUm9MVFl1TWpBNVl5MHVNRE1nTUMwdU1EVTVMakF3T0MwdU1EZ3pMakF5TkhNdExqQTBOQzR3TXpndExqQTFOaTR3TmpVdExqQXhOUzR3TlRZdExqQXhMakE0TkM0d01UZ3VNRFUxTGpBek9TNHdOelpzTVM0ek1URWdNUzR6TmpoakxqQXlPQzR3TXk0d05qTXVNRFV6TGpFd01TNHdOamxoTGpNeExqTXhJREFnTUNBd0lDNHhNakV1TURJMWFEWXVNakE0WXk0d015QXdJQzR3TlRrdExqQXdPQzR3T0RNdExqQXlOR0V1TVRVdU1UVWdNQ0F3SURBZ0xqQTFOaTB1TURZMVl5NHdNVEl0TGpBeU5pNHdNVFV0TGpBMU5pNHdNUzB1TURnMGN5MHVNREU0TFM0d05UVXRMakF6T1MwdU1EYzJlbTB0Tmk0ME16RXRMams0TTJnMkxqSXdPV0V1TXpFdU16RWdNQ0F3SURBZ0xqRXlNUzB1TURJMFl5NHdNemd0TGpBeE5pNHdOek10TGpBMExqRXdNUzB1TURkc01TNHpNUzB4TGpNMk9HTXVNREl0TGpBeU1TNHdNelF0TGpBME55NHdNemt0TGpBM05uTXVNREF4TFM0d05UZ3RMakF4TFM0d09EUmhMakUxTGpFMUlEQWdNQ0F3SUMwdU1EVTJMUzR3TmpWakxTNHdNalV0TGpBeE5pMHVNRFUwTFM0d01qUXRMakE0TXkwdU1ESTBhQzAyTGpJd09HRXVNekV1TXpFZ01DQXdJREFnTFM0eE1qRXVNREkxWXkwdU1ETTRMakF4TmkwdU1EY3lMakEwTFM0eE1ERXVNRFk1YkMweExqTXhJREV1TXpZNFl5MHVNREl1TURJeExTNHdNelF1TURRM0xTNHdNemt1TURjMmN5MHVNREF4TGpBMU9DNHdNUzR3T0RRdU1ETXhMakEwT1M0d05UWXVNRFkxTGpBMU5DNHdNalF1TURnekxqQXlOSG9pSUdacGJHdzlJblZ5YkNnallTa2lMejQ4TDNOMlp6ND0nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWNvbi5qcy5tYXAiXSwibmFtZXMiOlsiaWNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/icon.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/wallet.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/wallet.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolflareMetaMaskWallet: () => (/* binding */ SolflareMetaMaskWallet)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-standard-chains */ \"(ssr)/./node_modules/@solana/wallet-standard-chains/lib/esm/index.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/./node_modules/@wallet-standard/features/lib/esm/connect.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/./node_modules/@wallet-standard/features/lib/esm/disconnect.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/./node_modules/@wallet-standard/features/lib/esm/events.js\");\n/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icon.js */ \"(ssr)/./node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/icon.js\");\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _SolflareMetaMaskWallet_instances, _SolflareMetaMaskWallet_listeners, _SolflareMetaMaskWallet_version, _SolflareMetaMaskWallet_name, _SolflareMetaMaskWallet_icon, _SolflareMetaMaskWallet_solflareMetaMask, _SolflareMetaMaskWallet_on, _SolflareMetaMaskWallet_emit, _SolflareMetaMaskWallet_off, _SolflareMetaMaskWallet_connect, _SolflareMetaMaskWallet_disconnect, _SolflareMetaMaskWallet_signAndSendTransaction, _SolflareMetaMaskWallet_signTransaction, _SolflareMetaMaskWallet_signMessage;\n\n\n\n\n\nclass SolflareMetaMaskWallet {\n    constructor(){\n        _SolflareMetaMaskWallet_instances.add(this);\n        _SolflareMetaMaskWallet_listeners.set(this, {});\n        _SolflareMetaMaskWallet_version.set(this, \"1.0.0\");\n        _SolflareMetaMaskWallet_name.set(this, \"MetaMask\");\n        _SolflareMetaMaskWallet_icon.set(this, _icon_js__WEBPACK_IMPORTED_MODULE_0__.icon);\n        _SolflareMetaMaskWallet_solflareMetaMask.set(this, null);\n        _SolflareMetaMaskWallet_on.set(this, (event, listener)=>{\n            __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, \"f\")[event]?.push(listener) || (__classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, \"f\")[event] = [\n                listener\n            ]);\n            return ()=>__classPrivateFieldGet(this, _SolflareMetaMaskWallet_instances, \"m\", _SolflareMetaMaskWallet_off).call(this, event, listener);\n        });\n        _SolflareMetaMaskWallet_connect.set(this, async ()=>{\n            if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\")) {\n                let SolflareMetaMaskClass;\n                try {\n                    SolflareMetaMaskClass = (await __webpack_require__.e(/*! import() */ \"vendor-chunks/@solflare-wallet\").then(__webpack_require__.bind(__webpack_require__, /*! @solflare-wallet/metamask-sdk */ \"(ssr)/./node_modules/@solflare-wallet/metamask-sdk/lib/esm/index.js\"))).default;\n                } catch (error) {\n                    throw new Error(\"Unable to load Solflare MetaMask SDK\");\n                }\n                __classPrivateFieldSet(this, _SolflareMetaMaskWallet_solflareMetaMask, new SolflareMetaMaskClass(), \"f\");\n                __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\").on(\"standard_change\", (properties)=>__classPrivateFieldGet(this, _SolflareMetaMaskWallet_instances, \"m\", _SolflareMetaMaskWallet_emit).call(this, \"change\", properties));\n            }\n            if (!this.accounts.length) {\n                await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\").connect();\n            }\n            return {\n                accounts: this.accounts\n            };\n        });\n        _SolflareMetaMaskWallet_disconnect.set(this, async ()=>{\n            if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\")) return;\n            await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\").disconnect();\n        });\n        _SolflareMetaMaskWallet_signAndSendTransaction.set(this, async (...inputs)=>{\n            if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\")) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError();\n            return await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\").standardSignAndSendTransaction(...inputs);\n        });\n        _SolflareMetaMaskWallet_signTransaction.set(this, async (...inputs)=>{\n            if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\")) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError();\n            return await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\").standardSignTransaction(...inputs);\n        });\n        _SolflareMetaMaskWallet_signMessage.set(this, async (...inputs)=>{\n            if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\")) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError();\n            return await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\").standardSignMessage(...inputs);\n        });\n    }\n    get version() {\n        return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_version, \"f\");\n    }\n    get name() {\n        return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_name, \"f\");\n    }\n    get icon() {\n        return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_icon, \"f\");\n    }\n    get chains() {\n        return [\n            _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_2__.SOLANA_MAINNET_CHAIN,\n            _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_2__.SOLANA_DEVNET_CHAIN,\n            _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_2__.SOLANA_TESTNET_CHAIN\n        ];\n    }\n    get features() {\n        return {\n            [_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__.StandardConnect]: {\n                version: \"1.0.0\",\n                connect: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_connect, \"f\")\n            },\n            [_wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__.StandardDisconnect]: {\n                version: \"1.0.0\",\n                disconnect: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_disconnect, \"f\")\n            },\n            [_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__.StandardEvents]: {\n                version: \"1.0.0\",\n                on: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_on, \"f\")\n            },\n            [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction]: {\n                version: \"1.0.0\",\n                supportedTransactionVersions: [\n                    \"legacy\",\n                    0\n                ],\n                signAndSendTransaction: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_signAndSendTransaction, \"f\")\n            },\n            [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction]: {\n                version: \"1.0.0\",\n                supportedTransactionVersions: [\n                    \"legacy\",\n                    0\n                ],\n                signTransaction: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_signTransaction, \"f\")\n            },\n            [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_8__.SolanaSignMessage]: {\n                version: \"1.0.0\",\n                signMessage: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_signMessage, \"f\")\n            }\n        };\n    }\n    get accounts() {\n        return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\") ? __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, \"f\").standardAccounts : [];\n    }\n}\n_SolflareMetaMaskWallet_listeners = new WeakMap(), _SolflareMetaMaskWallet_version = new WeakMap(), _SolflareMetaMaskWallet_name = new WeakMap(), _SolflareMetaMaskWallet_icon = new WeakMap(), _SolflareMetaMaskWallet_solflareMetaMask = new WeakMap(), _SolflareMetaMaskWallet_on = new WeakMap(), _SolflareMetaMaskWallet_connect = new WeakMap(), _SolflareMetaMaskWallet_disconnect = new WeakMap(), _SolflareMetaMaskWallet_signAndSendTransaction = new WeakMap(), _SolflareMetaMaskWallet_signTransaction = new WeakMap(), _SolflareMetaMaskWallet_signMessage = new WeakMap(), _SolflareMetaMaskWallet_instances = new WeakSet(), _SolflareMetaMaskWallet_emit = function _SolflareMetaMaskWallet_emit(event, ...args) {\n    // eslint-disable-next-line prefer-spread\n    __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, \"f\")[event]?.forEach((listener)=>listener.apply(null, args));\n}, _SolflareMetaMaskWallet_off = function _SolflareMetaMaskWallet_off(event, listener) {\n    __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, \"f\")[event] = __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, \"f\")[event]?.filter((existingListener)=>listener !== existingListener);\n}; //# sourceMappingURL=wallet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1zb2xmbGFyZS9saWIvZXNtL21ldGFtYXNrL3dhbGxldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEseUJBQXlCLFNBQUssSUFBSSxTQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLENBQUM7SUFDcEcsSUFBSUQsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0gsVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNFLElBQUksQ0FBQ0YsTUFBTUksR0FBRyxDQUFDTCxXQUFXLE1BQU0sSUFBSUksVUFBVTtJQUN2RyxPQUFPRixTQUFTLE1BQU1DLElBQUlELFNBQVMsTUFBTUMsRUFBRUcsSUFBSSxDQUFDTixZQUFZRyxJQUFJQSxFQUFFSSxLQUFLLEdBQUdOLE1BQU1PLEdBQUcsQ0FBQ1I7QUFDeEY7QUFDQSxJQUFJUyx5QkFBeUIsU0FBSyxJQUFJLFNBQUksQ0FBQ0Esc0JBQXNCLElBQUssU0FBVVQsUUFBUSxFQUFFQyxLQUFLLEVBQUVNLEtBQUssRUFBRUwsSUFBSSxFQUFFQyxDQUFDO0lBQzNHLElBQUlELFNBQVMsS0FBSyxNQUFNLElBQUlFLFVBQVU7SUFDdEMsSUFBSUYsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0gsVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNFLElBQUksQ0FBQ0YsTUFBTUksR0FBRyxDQUFDTCxXQUFXLE1BQU0sSUFBSUksVUFBVTtJQUN2RyxPQUFPLFNBQVUsTUFBTUQsRUFBRUcsSUFBSSxDQUFDTixVQUFVTyxTQUFTSixJQUFJQSxFQUFFSSxLQUFLLEdBQUdBLFFBQVFOLE1BQU1TLEdBQUcsQ0FBQ1YsVUFBVU8sUUFBU0E7QUFDeEc7QUFDQSxJQUFJSSxtQ0FBbUNDLG1DQUFt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RUFBaUJBLENBQUMsRUFBRTtnQkFDakIwQixTQUFTO2dCQUNUTyxhQUFhaEUsdUJBQXVCLElBQUksRUFBRXlCLHFDQUFxQztZQUNuRjtRQUNKO0lBQ0o7SUFDQSxJQUFJd0IsV0FBVztRQUNYLE9BQU9qRCx1QkFBdUIsSUFBSSxFQUFFaUIsMENBQTBDLE9BQU9qQix1QkFBdUIsSUFBSSxFQUFFaUIsMENBQTBDLEtBQUtnRCxnQkFBZ0IsR0FBRyxFQUFFO0lBQzFMO0FBQ0o7QUFDQXBELG9DQUFvQyxJQUFJcUQsV0FBV3BELGtDQUFrQyxJQUFJb0QsV0FBV25ELCtCQUErQixJQUFJbUQsV0FBV2xELCtCQUErQixJQUFJa0QsV0FBV2pELDJDQUEyQyxJQUFJaUQsV0FBV2hELDZCQUE2QixJQUFJZ0QsV0FBVzdDLGtDQUFrQyxJQUFJNkMsV0FBVzVDLHFDQUFxQyxJQUFJNEMsV0FBVzNDLGlEQUFpRCxJQUFJMkMsV0FBVzFDLDBDQUEwQyxJQUFJMEMsV0FBV3pDLHNDQUFzQyxJQUFJeUMsV0FBV3RELG9DQUFvQyxJQUFJdUQsV0FBV2hELCtCQUErQixTQUFTQSw2QkFBNkJxQixLQUFLLEVBQUUsR0FBRzRCLElBQUk7SUFDM3JCLHlDQUF5QztJQUN6Q3BFLHVCQUF1QixJQUFJLEVBQUVhLG1DQUFtQyxJQUFJLENBQUMyQixNQUFNLEVBQUU2QixRQUFRLENBQUM1QixXQUFhQSxTQUFTNkIsS0FBSyxDQUFDLE1BQU1GO0FBQzVILEdBQUdoRCw4QkFBOEIsU0FBU0EsNEJBQTRCb0IsS0FBSyxFQUFFQyxRQUFRO0lBQ2pGekMsdUJBQXVCLElBQUksRUFBRWEsbUNBQW1DLElBQUksQ0FBQzJCLE1BQU0sR0FBR3hDLHVCQUF1QixJQUFJLEVBQUVhLG1DQUFtQyxJQUFJLENBQUMyQixNQUFNLEVBQUUrQixPQUFPLENBQUNDLG1CQUFxQi9CLGFBQWErQjtBQUN6TSxHQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItc29sZmxhcmUvbGliL2VzbS9tZXRhbWFzay93YWxsZXQuanM/YTUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfaW5zdGFuY2VzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9saXN0ZW5lcnMsIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3ZlcnNpb24sIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X25hbWUsIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X2ljb24sIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3NvbGZsYXJlTWV0YU1hc2ssIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X29uLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9lbWl0LCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9vZmYsIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X2Nvbm5lY3QsIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X2Rpc2Nvbm5lY3QsIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3NpZ25BbmRTZW5kVHJhbnNhY3Rpb24sIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3NpZ25UcmFuc2FjdGlvbiwgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc2lnbk1lc3NhZ2U7XG5pbXBvcnQgeyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZSc7XG5pbXBvcnQgeyBTT0xBTkFfREVWTkVUX0NIQUlOLCBTT0xBTkFfTUFJTk5FVF9DSEFJTiwgU09MQU5BX1RFU1RORVRfQ0hBSU4gfSBmcm9tICdAc29sYW5hL3dhbGxldC1zdGFuZGFyZC1jaGFpbnMnO1xuaW1wb3J0IHsgU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiwgU29sYW5hU2lnbk1lc3NhZ2UsIFNvbGFuYVNpZ25UcmFuc2FjdGlvbiwgfSBmcm9tICdAc29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcyc7XG5pbXBvcnQgeyBTdGFuZGFyZENvbm5lY3QsIFN0YW5kYXJkRGlzY29ubmVjdCwgU3RhbmRhcmRFdmVudHMsIH0gZnJvbSAnQHdhbGxldC1zdGFuZGFyZC9mZWF0dXJlcyc7XG5pbXBvcnQgeyBpY29uIH0gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBjbGFzcyBTb2xmbGFyZU1ldGFNYXNrV2FsbGV0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfbGlzdGVuZXJzLnNldCh0aGlzLCB7fSk7XG4gICAgICAgIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3ZlcnNpb24uc2V0KHRoaXMsICcxLjAuMCcpO1xuICAgICAgICBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9uYW1lLnNldCh0aGlzLCAnTWV0YU1hc2snKTtcbiAgICAgICAgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfaWNvbi5zZXQodGhpcywgaWNvbik7XG4gICAgICAgIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3NvbGZsYXJlTWV0YU1hc2suc2V0KHRoaXMsIG51bGwpO1xuICAgICAgICBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9vbi5zZXQodGhpcywgKGV2ZW50LCBsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF0/LnB1c2gobGlzdGVuZXIpIHx8IChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X2xpc3RlbmVycywgXCJmXCIpW2V2ZW50XSA9IFtsaXN0ZW5lcl0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfaW5zdGFuY2VzLCBcIm1cIiwgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfb2ZmKS5jYWxsKHRoaXMsIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgICAgICBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9jb25uZWN0LnNldCh0aGlzLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc29sZmxhcmVNZXRhTWFzaywgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IFNvbGZsYXJlTWV0YU1hc2tDbGFzcztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBTb2xmbGFyZU1ldGFNYXNrQ2xhc3MgPSAoYXdhaXQgaW1wb3J0KCdAc29sZmxhcmUtd2FsbGV0L21ldGFtYXNrLXNkaycpKS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gbG9hZCBTb2xmbGFyZSBNZXRhTWFzayBTREsnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9zb2xmbGFyZU1ldGFNYXNrLCBuZXcgU29sZmxhcmVNZXRhTWFza0NsYXNzKCksIFwiZlwiKTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3NvbGZsYXJlTWV0YU1hc2ssIFwiZlwiKS5vbignc3RhbmRhcmRfY2hhbmdlJywgKHByb3BlcnRpZXMpID0+IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfaW5zdGFuY2VzLCBcIm1cIiwgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfZW1pdCkuY2FsbCh0aGlzLCAnY2hhbmdlJywgcHJvcGVydGllcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc29sZmxhcmVNZXRhTWFzaywgXCJmXCIpLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGFjY291bnRzOiB0aGlzLmFjY291bnRzIH07XG4gICAgICAgIH0pO1xuICAgICAgICBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9kaXNjb25uZWN0LnNldCh0aGlzLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc29sZmxhcmVNZXRhTWFzaywgXCJmXCIpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc29sZmxhcmVNZXRhTWFzaywgXCJmXCIpLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3NpZ25BbmRTZW5kVHJhbnNhY3Rpb24uc2V0KHRoaXMsIGFzeW5jICguLi5pbnB1dHMpID0+IHtcbiAgICAgICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9zb2xmbGFyZU1ldGFNYXNrLCBcImZcIikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9zb2xmbGFyZU1ldGFNYXNrLCBcImZcIikuc3RhbmRhcmRTaWduQW5kU2VuZFRyYW5zYWN0aW9uKC4uLmlucHV0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9zaWduVHJhbnNhY3Rpb24uc2V0KHRoaXMsIGFzeW5jICguLi5pbnB1dHMpID0+IHtcbiAgICAgICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9zb2xmbGFyZU1ldGFNYXNrLCBcImZcIikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9zb2xmbGFyZU1ldGFNYXNrLCBcImZcIikuc3RhbmRhcmRTaWduVHJhbnNhY3Rpb24oLi4uaW5wdXRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3NpZ25NZXNzYWdlLnNldCh0aGlzLCBhc3luYyAoLi4uaW5wdXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc29sZmxhcmVNZXRhTWFzaywgXCJmXCIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc29sZmxhcmVNZXRhTWFzaywgXCJmXCIpLnN0YW5kYXJkU2lnbk1lc3NhZ2UoLi4uaW5wdXRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF92ZXJzaW9uLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9uYW1lLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBpY29uKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9pY29uLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBjaGFpbnMoKSB7XG4gICAgICAgIHJldHVybiBbU09MQU5BX01BSU5ORVRfQ0hBSU4sIFNPTEFOQV9ERVZORVRfQ0hBSU4sIFNPTEFOQV9URVNUTkVUX0NIQUlOXTtcbiAgICB9XG4gICAgZ2V0IGZlYXR1cmVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW1N0YW5kYXJkQ29ubmVjdF06IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Q6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfY29ubmVjdCwgXCJmXCIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtTdGFuZGFyZERpc2Nvbm5lY3RdOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X2Rpc2Nvbm5lY3QsIFwiZlwiKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbU3RhbmRhcmRFdmVudHNdOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICAgICAgICBvbjogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9vbiwgXCJmXCIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uXToge1xuICAgICAgICAgICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uczogWydsZWdhY3knLCAwXSxcbiAgICAgICAgICAgICAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3NpZ25BbmRTZW5kVHJhbnNhY3Rpb24sIFwiZlwiKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbU29sYW5hU2lnblRyYW5zYWN0aW9uXToge1xuICAgICAgICAgICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uczogWydsZWdhY3knLCAwXSxcbiAgICAgICAgICAgICAgICBzaWduVHJhbnNhY3Rpb246IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc2lnblRyYW5zYWN0aW9uLCBcImZcIiksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1NvbGFuYVNpZ25NZXNzYWdlXToge1xuICAgICAgICAgICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgICAgICAgICAgc2lnbk1lc3NhZ2U6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc2lnbk1lc3NhZ2UsIFwiZlwiKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBhY2NvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc29sZmxhcmVNZXRhTWFzaywgXCJmXCIpID8gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9zb2xmbGFyZU1ldGFNYXNrLCBcImZcIikuc3RhbmRhcmRBY2NvdW50cyA6IFtdO1xuICAgIH1cbn1cbl9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X2xpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCksIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3ZlcnNpb24gPSBuZXcgV2Vha01hcCgpLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9uYW1lID0gbmV3IFdlYWtNYXAoKSwgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfaWNvbiA9IG5ldyBXZWFrTWFwKCksIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3NvbGZsYXJlTWV0YU1hc2sgPSBuZXcgV2Vha01hcCgpLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9vbiA9IG5ldyBXZWFrTWFwKCksIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X2Nvbm5lY3QgPSBuZXcgV2Vha01hcCgpLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9kaXNjb25uZWN0ID0gbmV3IFdlYWtNYXAoKSwgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc2lnbkFuZFNlbmRUcmFuc2FjdGlvbiA9IG5ldyBXZWFrTWFwKCksIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3NpZ25UcmFuc2FjdGlvbiA9IG5ldyBXZWFrTWFwKCksIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X3NpZ25NZXNzYWdlID0gbmV3IFdlYWtNYXAoKSwgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfZW1pdCA9IGZ1bmN0aW9uIF9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X2VtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdPy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIuYXBwbHkobnVsbCwgYXJncykpO1xufSwgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfb2ZmID0gZnVuY3Rpb24gX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sZmxhcmVNZXRhTWFza1dhbGxldF9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF0/LmZpbHRlcigoZXhpc3RpbmdMaXN0ZW5lcikgPT4gbGlzdGVuZXIgIT09IGV4aXN0aW5nTGlzdGVuZXIpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhbGxldC5qcy5tYXAiXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsInJlY2VpdmVyIiwic3RhdGUiLCJraW5kIiwiZiIsIlR5cGVFcnJvciIsImhhcyIsImNhbGwiLCJ2YWx1ZSIsImdldCIsIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJzZXQiLCJfU29sZmxhcmVNZXRhTWFza1dhbGxldF9pbnN0YW5jZXMiLCJfU29sZmxhcmVNZXRhTWFza1dhbGxldF9saXN0ZW5lcnMiLCJfU29sZmxhcmVNZXRhTWFza1dhbGxldF92ZXJzaW9uIiwiX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfbmFtZSIsIl9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X2ljb24iLCJfU29sZmxhcmVNZXRhTWFza1dhbGxldF9zb2xmbGFyZU1ldGFNYXNrIiwiX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfb24iLCJfU29sZmxhcmVNZXRhTWFza1dhbGxldF9lbWl0IiwiX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfb2ZmIiwiX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfY29ubmVjdCIsIl9Tb2xmbGFyZU1ldGFNYXNrV2FsbGV0X2Rpc2Nvbm5lY3QiLCJfU29sZmxhcmVNZXRhTWFza1dhbGxldF9zaWduQW5kU2VuZFRyYW5zYWN0aW9uIiwiX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc2lnblRyYW5zYWN0aW9uIiwiX1NvbGZsYXJlTWV0YU1hc2tXYWxsZXRfc2lnbk1lc3NhZ2UiLCJXYWxsZXROb3RDb25uZWN0ZWRFcnJvciIsIlNPTEFOQV9ERVZORVRfQ0hBSU4iLCJTT0xBTkFfTUFJTk5FVF9DSEFJTiIsIlNPTEFOQV9URVNUTkVUX0NIQUlOIiwiU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiIsIlNvbGFuYVNpZ25NZXNzYWdlIiwiU29sYW5hU2lnblRyYW5zYWN0aW9uIiwiU3RhbmRhcmRDb25uZWN0IiwiU3RhbmRhcmREaXNjb25uZWN0IiwiU3RhbmRhcmRFdmVudHMiLCJpY29uIiwiU29sZmxhcmVNZXRhTWFza1dhbGxldCIsImNvbnN0cnVjdG9yIiwiYWRkIiwiZXZlbnQiLCJsaXN0ZW5lciIsInB1c2giLCJTb2xmbGFyZU1ldGFNYXNrQ2xhc3MiLCJkZWZhdWx0IiwiZXJyb3IiLCJFcnJvciIsIm9uIiwicHJvcGVydGllcyIsImFjY291bnRzIiwibGVuZ3RoIiwiY29ubmVjdCIsImRpc2Nvbm5lY3QiLCJpbnB1dHMiLCJzdGFuZGFyZFNpZ25BbmRTZW5kVHJhbnNhY3Rpb24iLCJzdGFuZGFyZFNpZ25UcmFuc2FjdGlvbiIsInN0YW5kYXJkU2lnbk1lc3NhZ2UiLCJ2ZXJzaW9uIiwibmFtZSIsImNoYWlucyIsImZlYXR1cmVzIiwic3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucyIsInNpZ25BbmRTZW5kVHJhbnNhY3Rpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduTWVzc2FnZSIsInN0YW5kYXJkQWNjb3VudHMiLCJXZWFrTWFwIiwiV2Vha1NldCIsImFyZ3MiLCJmb3JFYWNoIiwiYXBwbHkiLCJmaWx0ZXIiLCJleGlzdGluZ0xpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-adapter-solflare/lib/esm/metamask/wallet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-chains/lib/esm/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-chains/lib/esm/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SOLANA_CHAINS: () => (/* binding */ SOLANA_CHAINS),\n/* harmony export */   SOLANA_DEVNET_CHAIN: () => (/* binding */ SOLANA_DEVNET_CHAIN),\n/* harmony export */   SOLANA_LOCALNET_CHAIN: () => (/* binding */ SOLANA_LOCALNET_CHAIN),\n/* harmony export */   SOLANA_MAINNET_CHAIN: () => (/* binding */ SOLANA_MAINNET_CHAIN),\n/* harmony export */   SOLANA_TESTNET_CHAIN: () => (/* binding */ SOLANA_TESTNET_CHAIN),\n/* harmony export */   isSolanaChain: () => (/* binding */ isSolanaChain)\n/* harmony export */ });\n/** Solana Mainnet (beta) cluster, e.g. https://api.mainnet-beta.solana.com */ const SOLANA_MAINNET_CHAIN = \"solana:mainnet\";\n/** Solana Devnet cluster, e.g. https://api.devnet.solana.com */ const SOLANA_DEVNET_CHAIN = \"solana:devnet\";\n/** Solana Testnet cluster, e.g. https://api.testnet.solana.com */ const SOLANA_TESTNET_CHAIN = \"solana:testnet\";\n/** Solana Localnet cluster, e.g. http://localhost:8899 */ const SOLANA_LOCALNET_CHAIN = \"solana:localnet\";\n/** Array of all Solana clusters */ const SOLANA_CHAINS = [\n    SOLANA_MAINNET_CHAIN,\n    SOLANA_DEVNET_CHAIN,\n    SOLANA_TESTNET_CHAIN,\n    SOLANA_LOCALNET_CHAIN\n];\n/**\n * Check if a chain corresponds with one of the Solana clusters.\n */ function isSolanaChain(chain) {\n    return SOLANA_CHAINS.includes(chain);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtY2hhaW5zL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsNEVBQTRFLEdBQ3JFLE1BQU1BLHVCQUF1QixpQkFBaUI7QUFDckQsOERBQThELEdBQ3ZELE1BQU1DLHNCQUFzQixnQkFBZ0I7QUFDbkQsZ0VBQWdFLEdBQ3pELE1BQU1DLHVCQUF1QixpQkFBaUI7QUFDckQsd0RBQXdELEdBQ2pELE1BQU1DLHdCQUF3QixrQkFBa0I7QUFDdkQsaUNBQWlDLEdBQzFCLE1BQU1DLGdCQUFnQjtJQUN6Qko7SUFDQUM7SUFDQUM7SUFDQUM7Q0FDSCxDQUFDO0FBQ0Y7O0NBRUMsR0FDTSxTQUFTRSxjQUFjQyxLQUFLO0lBQy9CLE9BQU9GLGNBQWNHLFFBQVEsQ0FBQ0Q7QUFDbEMsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1jaGFpbnMvbGliL2VzbS9pbmRleC5qcz85MGZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBTb2xhbmEgTWFpbm5ldCAoYmV0YSkgY2x1c3RlciwgZS5nLiBodHRwczovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbSAqL1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9NQUlOTkVUX0NIQUlOID0gJ3NvbGFuYTptYWlubmV0Jztcbi8qKiBTb2xhbmEgRGV2bmV0IGNsdXN0ZXIsIGUuZy4gaHR0cHM6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20gKi9cbmV4cG9ydCBjb25zdCBTT0xBTkFfREVWTkVUX0NIQUlOID0gJ3NvbGFuYTpkZXZuZXQnO1xuLyoqIFNvbGFuYSBUZXN0bmV0IGNsdXN0ZXIsIGUuZy4gaHR0cHM6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tICovXG5leHBvcnQgY29uc3QgU09MQU5BX1RFU1RORVRfQ0hBSU4gPSAnc29sYW5hOnRlc3RuZXQnO1xuLyoqIFNvbGFuYSBMb2NhbG5ldCBjbHVzdGVyLCBlLmcuIGh0dHA6Ly9sb2NhbGhvc3Q6ODg5OSAqL1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9MT0NBTE5FVF9DSEFJTiA9ICdzb2xhbmE6bG9jYWxuZXQnO1xuLyoqIEFycmF5IG9mIGFsbCBTb2xhbmEgY2x1c3RlcnMgKi9cbmV4cG9ydCBjb25zdCBTT0xBTkFfQ0hBSU5TID0gW1xuICAgIFNPTEFOQV9NQUlOTkVUX0NIQUlOLFxuICAgIFNPTEFOQV9ERVZORVRfQ0hBSU4sXG4gICAgU09MQU5BX1RFU1RORVRfQ0hBSU4sXG4gICAgU09MQU5BX0xPQ0FMTkVUX0NIQUlOLFxuXTtcbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFpbiBjb3JyZXNwb25kcyB3aXRoIG9uZSBvZiB0aGUgU29sYW5hIGNsdXN0ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTb2xhbmFDaGFpbihjaGFpbikge1xuICAgIHJldHVybiBTT0xBTkFfQ0hBSU5TLmluY2x1ZGVzKGNoYWluKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJTT0xBTkFfTUFJTk5FVF9DSEFJTiIsIlNPTEFOQV9ERVZORVRfQ0hBSU4iLCJTT0xBTkFfVEVTVE5FVF9DSEFJTiIsIlNPTEFOQV9MT0NBTE5FVF9DSEFJTiIsIlNPTEFOQV9DSEFJTlMiLCJpc1NvbGFuYUNoYWluIiwiY2hhaW4iLCJpbmNsdWRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-chains/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaSignAndSendTransaction: () => (/* binding */ SolanaSignAndSendTransaction)\n/* harmony export */ });\n/** Name of the feature. */ const SolanaSignAndSendTransaction = \"solana:signAndSendTransaction\"; //# sourceMappingURL=signAndSendTransaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtZmVhdHVyZXMvbGliL2VzbS9zaWduQW5kU2VuZFRyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx5QkFBeUIsR0FDbEIsTUFBTUEsK0JBQStCLGdDQUFnQyxDQUM1RSxrREFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcy9saWIvZXNtL3NpZ25BbmRTZW5kVHJhbnNhY3Rpb24uanM/ZTEyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogTmFtZSBvZiB0aGUgZmVhdHVyZS4gKi9cbmV4cG9ydCBjb25zdCBTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uID0gJ3NvbGFuYTpzaWduQW5kU2VuZFRyYW5zYWN0aW9uJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25BbmRTZW5kVHJhbnNhY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIlNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signIn.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-features/lib/esm/signIn.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaSignIn: () => (/* binding */ SolanaSignIn)\n/* harmony export */ });\n/** Name of the feature. */ const SolanaSignIn = \"solana:signIn\"; //# sourceMappingURL=signIn.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtZmVhdHVyZXMvbGliL2VzbS9zaWduSW4uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHlCQUF5QixHQUNsQixNQUFNQSxlQUFlLGdCQUFnQixDQUM1QyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcy9saWIvZXNtL3NpZ25Jbi5qcz9jY2QxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBOYW1lIG9mIHRoZSBmZWF0dXJlLiAqL1xuZXhwb3J0IGNvbnN0IFNvbGFuYVNpZ25JbiA9ICdzb2xhbmE6c2lnbkluJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25Jbi5qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hU2lnbkluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signIn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaSignMessage: () => (/* binding */ SolanaSignMessage)\n/* harmony export */ });\n/** Name of the feature. */ const SolanaSignMessage = \"solana:signMessage\"; //# sourceMappingURL=signMessage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtZmVhdHVyZXMvbGliL2VzbS9zaWduTWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEseUJBQXlCLEdBQ2xCLE1BQU1BLG9CQUFvQixxQkFBcUIsQ0FDdEQsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtZmVhdHVyZXMvbGliL2VzbS9zaWduTWVzc2FnZS5qcz8xZGNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBOYW1lIG9mIHRoZSBmZWF0dXJlLiAqL1xuZXhwb3J0IGNvbnN0IFNvbGFuYVNpZ25NZXNzYWdlID0gJ3NvbGFuYTpzaWduTWVzc2FnZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduTWVzc2FnZS5qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hU2lnbk1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaSignTransaction: () => (/* binding */ SolanaSignTransaction)\n/* harmony export */ });\n/** Name of the feature. */ const SolanaSignTransaction = \"solana:signTransaction\"; //# sourceMappingURL=signTransaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtZmVhdHVyZXMvbGliL2VzbS9zaWduVHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHlCQUF5QixHQUNsQixNQUFNQSx3QkFBd0IseUJBQXlCLENBQzlELDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWZlYXR1cmVzL2xpYi9lc20vc2lnblRyYW5zYWN0aW9uLmpzP2ZlNTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIE5hbWUgb2YgdGhlIGZlYXR1cmUuICovXG5leHBvcnQgY29uc3QgU29sYW5hU2lnblRyYW5zYWN0aW9uID0gJ3NvbGFuYTpzaWduVHJhbnNhY3Rpb24nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnblRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFTaWduVHJhbnNhY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/commitment.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-util/lib/esm/commitment.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCommitment: () => (/* binding */ getCommitment)\n/* harmony export */ });\n/**\n * TODO: docs\n */ function getCommitment(commitment) {\n    switch(commitment){\n        case \"processed\":\n        case \"confirmed\":\n        case \"finalized\":\n        case undefined:\n            return commitment;\n        case \"recent\":\n            return \"processed\";\n        case \"single\":\n        case \"singleGossip\":\n            return \"confirmed\";\n        case \"max\":\n        case \"root\":\n            return \"finalized\";\n        default:\n            return undefined;\n    }\n} //# sourceMappingURL=commitment.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbC9saWIvZXNtL2NvbW1pdG1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztDQUVDLEdBQ00sU0FBU0EsY0FBY0MsVUFBVTtJQUNwQyxPQUFRQTtRQUNKLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUtDO1lBQ0QsT0FBT0Q7UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7UUFDTCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7UUFDTCxLQUFLO1lBQ0QsT0FBTztRQUNYO1lBQ0ksT0FBT0M7SUFDZjtBQUNKLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbC9saWIvZXNtL2NvbW1pdG1lbnQuanM/NTkwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1pdG1lbnQoY29tbWl0bWVudCkge1xuICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJldHVybiBjb21taXRtZW50O1xuICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgcmV0dXJuICdwcm9jZXNzZWQnO1xuICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgcmV0dXJuICdjb25maXJtZWQnO1xuICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgIHJldHVybiAnZmluYWxpemVkJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbWl0bWVudC5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0Q29tbWl0bWVudCIsImNvbW1pdG1lbnQiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/commitment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEVNET_ENDPOINT: () => (/* binding */ DEVNET_ENDPOINT),\n/* harmony export */   LOCALNET_ENDPOINT: () => (/* binding */ LOCALNET_ENDPOINT),\n/* harmony export */   MAINNET_ENDPOINT: () => (/* binding */ MAINNET_ENDPOINT),\n/* harmony export */   TESTNET_ENDPOINT: () => (/* binding */ TESTNET_ENDPOINT),\n/* harmony export */   getChainForEndpoint: () => (/* binding */ getChainForEndpoint),\n/* harmony export */   getEndpointForChain: () => (/* binding */ getEndpointForChain)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-standard-chains */ \"(ssr)/./node_modules/@solana/wallet-standard-chains/lib/esm/index.js\");\n\n/** TODO: docs */ const MAINNET_ENDPOINT = \"https://api.mainnet-beta.solana.com\";\n/** TODO: docs */ const DEVNET_ENDPOINT = \"https://api.devnet.solana.com\";\n/** TODO: docs */ const TESTNET_ENDPOINT = \"https://api.testnet.solana.com\";\n/** TODO: docs */ const LOCALNET_ENDPOINT = \"http://localhost:8899\";\n/**\n * TODO: docs\n */ function getChainForEndpoint(endpoint) {\n    if (endpoint.includes(MAINNET_ENDPOINT)) return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_MAINNET_CHAIN;\n    if (/\\bdevnet\\b/i.test(endpoint)) return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_DEVNET_CHAIN;\n    if (/\\btestnet\\b/i.test(endpoint)) return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_TESTNET_CHAIN;\n    if (/\\blocalhost\\b/i.test(endpoint) || /\\b127\\.0\\.0\\.1\\b/.test(endpoint)) return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_LOCALNET_CHAIN;\n    return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_MAINNET_CHAIN;\n}\n/**\n * TODO: docs\n */ function getEndpointForChain(chain, endpoint) {\n    if (endpoint) return endpoint;\n    if (chain === _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_MAINNET_CHAIN) return MAINNET_ENDPOINT;\n    if (chain === _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_DEVNET_CHAIN) return DEVNET_ENDPOINT;\n    if (chain === _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_TESTNET_CHAIN) return TESTNET_ENDPOINT;\n    if (chain === _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_LOCALNET_CHAIN) return LOCALNET_ENDPOINT;\n    return MAINNET_ENDPOINT;\n} //# sourceMappingURL=endpoint.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbC9saWIvZXNtL2VuZHBvaW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBeUk7QUFDekksZUFBZSxHQUNSLE1BQU1JLG1CQUFtQixzQ0FBc0M7QUFDdEUsZUFBZSxHQUNSLE1BQU1DLGtCQUFrQixnQ0FBZ0M7QUFDL0QsZUFBZSxHQUNSLE1BQU1DLG1CQUFtQixpQ0FBaUM7QUFDakUsZUFBZSxHQUNSLE1BQU1DLG9CQUFvQix3QkFBd0I7QUFDekQ7O0NBRUMsR0FDTSxTQUFTQyxvQkFBb0JDLFFBQVE7SUFDeEMsSUFBSUEsU0FBU0MsUUFBUSxDQUFDTixtQkFDbEIsT0FBT0YsZ0ZBQW9CQTtJQUMvQixJQUFJLGNBQWNTLElBQUksQ0FBQ0YsV0FDbkIsT0FBT1QsK0VBQW1CQTtJQUM5QixJQUFJLGVBQWVXLElBQUksQ0FBQ0YsV0FDcEIsT0FBT04sZ0ZBQW9CQTtJQUMvQixJQUFJLGlCQUFpQlEsSUFBSSxDQUFDRixhQUFhLG1CQUFtQkUsSUFBSSxDQUFDRixXQUMzRCxPQUFPUixpRkFBcUJBO0lBQ2hDLE9BQU9DLGdGQUFvQkE7QUFDL0I7QUFDQTs7Q0FFQyxHQUNNLFNBQVNVLG9CQUFvQkMsS0FBSyxFQUFFSixRQUFRO0lBQy9DLElBQUlBLFVBQ0EsT0FBT0E7SUFDWCxJQUFJSSxVQUFVWCxnRkFBb0JBLEVBQzlCLE9BQU9FO0lBQ1gsSUFBSVMsVUFBVWIsK0VBQW1CQSxFQUM3QixPQUFPSztJQUNYLElBQUlRLFVBQVVWLGdGQUFvQkEsRUFDOUIsT0FBT0c7SUFDWCxJQUFJTyxVQUFVWixpRkFBcUJBLEVBQy9CLE9BQU9NO0lBQ1gsT0FBT0g7QUFDWCxFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwvbGliL2VzbS9lbmRwb2ludC5qcz9lYzVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNPTEFOQV9ERVZORVRfQ0hBSU4sIFNPTEFOQV9MT0NBTE5FVF9DSEFJTiwgU09MQU5BX01BSU5ORVRfQ0hBSU4sIFNPTEFOQV9URVNUTkVUX0NIQUlOLCB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWNoYWlucyc7XG4vKiogVE9ETzogZG9jcyAqL1xuZXhwb3J0IGNvbnN0IE1BSU5ORVRfRU5EUE9JTlQgPSAnaHR0cHM6Ly9hcGkubWFpbm5ldC1iZXRhLnNvbGFuYS5jb20nO1xuLyoqIFRPRE86IGRvY3MgKi9cbmV4cG9ydCBjb25zdCBERVZORVRfRU5EUE9JTlQgPSAnaHR0cHM6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nO1xuLyoqIFRPRE86IGRvY3MgKi9cbmV4cG9ydCBjb25zdCBURVNUTkVUX0VORFBPSU5UID0gJ2h0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbSc7XG4vKiogVE9ETzogZG9jcyAqL1xuZXhwb3J0IGNvbnN0IExPQ0FMTkVUX0VORFBPSU5UID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODg5OSc7XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoYWluRm9yRW5kcG9pbnQoZW5kcG9pbnQpIHtcbiAgICBpZiAoZW5kcG9pbnQuaW5jbHVkZXMoTUFJTk5FVF9FTkRQT0lOVCkpXG4gICAgICAgIHJldHVybiBTT0xBTkFfTUFJTk5FVF9DSEFJTjtcbiAgICBpZiAoL1xcYmRldm5ldFxcYi9pLnRlc3QoZW5kcG9pbnQpKVxuICAgICAgICByZXR1cm4gU09MQU5BX0RFVk5FVF9DSEFJTjtcbiAgICBpZiAoL1xcYnRlc3RuZXRcXGIvaS50ZXN0KGVuZHBvaW50KSlcbiAgICAgICAgcmV0dXJuIFNPTEFOQV9URVNUTkVUX0NIQUlOO1xuICAgIGlmICgvXFxibG9jYWxob3N0XFxiL2kudGVzdChlbmRwb2ludCkgfHwgL1xcYjEyN1xcLjBcXC4wXFwuMVxcYi8udGVzdChlbmRwb2ludCkpXG4gICAgICAgIHJldHVybiBTT0xBTkFfTE9DQUxORVRfQ0hBSU47XG4gICAgcmV0dXJuIFNPTEFOQV9NQUlOTkVUX0NIQUlOO1xufVxuLyoqXG4gKiBUT0RPOiBkb2NzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbmRwb2ludEZvckNoYWluKGNoYWluLCBlbmRwb2ludCkge1xuICAgIGlmIChlbmRwb2ludClcbiAgICAgICAgcmV0dXJuIGVuZHBvaW50O1xuICAgIGlmIChjaGFpbiA9PT0gU09MQU5BX01BSU5ORVRfQ0hBSU4pXG4gICAgICAgIHJldHVybiBNQUlOTkVUX0VORFBPSU5UO1xuICAgIGlmIChjaGFpbiA9PT0gU09MQU5BX0RFVk5FVF9DSEFJTilcbiAgICAgICAgcmV0dXJuIERFVk5FVF9FTkRQT0lOVDtcbiAgICBpZiAoY2hhaW4gPT09IFNPTEFOQV9URVNUTkVUX0NIQUlOKVxuICAgICAgICByZXR1cm4gVEVTVE5FVF9FTkRQT0lOVDtcbiAgICBpZiAoY2hhaW4gPT09IFNPTEFOQV9MT0NBTE5FVF9DSEFJTilcbiAgICAgICAgcmV0dXJuIExPQ0FMTkVUX0VORFBPSU5UO1xuICAgIHJldHVybiBNQUlOTkVUX0VORFBPSU5UO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5kcG9pbnQuanMubWFwIl0sIm5hbWVzIjpbIlNPTEFOQV9ERVZORVRfQ0hBSU4iLCJTT0xBTkFfTE9DQUxORVRfQ0hBSU4iLCJTT0xBTkFfTUFJTk5FVF9DSEFJTiIsIlNPTEFOQV9URVNUTkVUX0NIQUlOIiwiTUFJTk5FVF9FTkRQT0lOVCIsIkRFVk5FVF9FTkRQT0lOVCIsIlRFU1RORVRfRU5EUE9JTlQiLCJMT0NBTE5FVF9FTkRQT0lOVCIsImdldENoYWluRm9yRW5kcG9pbnQiLCJlbmRwb2ludCIsImluY2x1ZGVzIiwidGVzdCIsImdldEVuZHBvaW50Rm9yQ2hhaW4iLCJjaGFpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/signIn.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-util/lib/esm/signIn.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSignInMessage: () => (/* binding */ createSignInMessage),\n/* harmony export */   createSignInMessageText: () => (/* binding */ createSignInMessageText),\n/* harmony export */   deriveSignInMessage: () => (/* binding */ deriveSignInMessage),\n/* harmony export */   deriveSignInMessageText: () => (/* binding */ deriveSignInMessageText),\n/* harmony export */   parseSignInMessage: () => (/* binding */ parseSignInMessage),\n/* harmony export */   parseSignInMessageText: () => (/* binding */ parseSignInMessageText),\n/* harmony export */   verifySignIn: () => (/* binding */ verifySignIn)\n/* harmony export */ });\n/* harmony import */ var _signMessage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signMessage.js */ \"(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/signMessage.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/util.js\");\n\n\n/**\n * TODO: docs\n */ function verifySignIn(input, output) {\n    const { signedMessage, signature, account: { publicKey } } = output;\n    const message = deriveSignInMessage(input, output);\n    return !!message && (0,_signMessage_js__WEBPACK_IMPORTED_MODULE_0__.verifyMessageSignature)({\n        message,\n        signedMessage,\n        signature,\n        publicKey: publicKey\n    });\n}\n/**\n * TODO: docs\n */ function deriveSignInMessage(input, output) {\n    const text = deriveSignInMessageText(input, output);\n    if (!text) return null;\n    return new TextEncoder().encode(text);\n}\n/**\n * TODO: docs\n */ function deriveSignInMessageText(input, output) {\n    const parsed = parseSignInMessage(output.signedMessage);\n    if (!parsed) return null;\n    if (input.domain && input.domain !== parsed.domain) return null;\n    if (input.address && input.address !== parsed.address) return null;\n    if (input.statement !== parsed.statement) return null;\n    if (input.uri !== parsed.uri) return null;\n    if (input.version !== parsed.version) return null;\n    if (input.chainId !== parsed.chainId) return null;\n    if (input.nonce !== parsed.nonce) return null;\n    if (input.issuedAt !== parsed.issuedAt) return null;\n    if (input.expirationTime !== parsed.expirationTime) return null;\n    if (input.notBefore !== parsed.notBefore) return null;\n    if (input.requestId !== parsed.requestId) return null;\n    if (input.resources) {\n        if (!parsed.resources) return null;\n        if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.arraysEqual)(input.resources, parsed.resources)) return null;\n    } else if (parsed.resources) return null;\n    return createSignInMessageText(parsed);\n}\n/**\n * TODO: docs\n */ function parseSignInMessage(message) {\n    const text = new TextDecoder().decode(message);\n    return parseSignInMessageText(text);\n}\n// TODO: implement https://github.com/solana-labs/solana/blob/master/docs/src/proposals/off-chain-message-signing.md\nconst DOMAIN = \"(?<domain>[^\\\\n]+?) wants you to sign in with your Solana account:\\\\n\";\nconst ADDRESS = \"(?<address>[^\\\\n]+)(?:\\\\n|$)\";\nconst STATEMENT = \"(?:\\\\n(?<statement>[\\\\S\\\\s]*?)(?:\\\\n|$))??\";\nconst URI = \"(?:\\\\nURI: (?<uri>[^\\\\n]+))?\";\nconst VERSION = \"(?:\\\\nVersion: (?<version>[^\\\\n]+))?\";\nconst CHAIN_ID = \"(?:\\\\nChain ID: (?<chainId>[^\\\\n]+))?\";\nconst NONCE = \"(?:\\\\nNonce: (?<nonce>[^\\\\n]+))?\";\nconst ISSUED_AT = \"(?:\\\\nIssued At: (?<issuedAt>[^\\\\n]+))?\";\nconst EXPIRATION_TIME = \"(?:\\\\nExpiration Time: (?<expirationTime>[^\\\\n]+))?\";\nconst NOT_BEFORE = \"(?:\\\\nNot Before: (?<notBefore>[^\\\\n]+))?\";\nconst REQUEST_ID = \"(?:\\\\nRequest ID: (?<requestId>[^\\\\n]+))?\";\nconst RESOURCES = \"(?:\\\\nResources:(?<resources>(?:\\\\n- [^\\\\n]+)*))?\";\nconst FIELDS = `${URI}${VERSION}${CHAIN_ID}${NONCE}${ISSUED_AT}${EXPIRATION_TIME}${NOT_BEFORE}${REQUEST_ID}${RESOURCES}`;\nconst MESSAGE = new RegExp(`^${DOMAIN}${ADDRESS}${STATEMENT}${FIELDS}\\\\n*$`);\n/**\n * TODO: docs\n */ function parseSignInMessageText(text) {\n    const match = MESSAGE.exec(text);\n    if (!match) return null;\n    const groups = match.groups;\n    if (!groups) return null;\n    return {\n        domain: groups.domain,\n        address: groups.address,\n        statement: groups.statement,\n        uri: groups.uri,\n        version: groups.version,\n        nonce: groups.nonce,\n        chainId: groups.chainId,\n        issuedAt: groups.issuedAt,\n        expirationTime: groups.expirationTime,\n        notBefore: groups.notBefore,\n        requestId: groups.requestId,\n        resources: groups.resources?.split(\"\\n- \").slice(1)\n    };\n}\n/**\n * TODO: docs\n */ function createSignInMessage(input) {\n    const text = createSignInMessageText(input);\n    return new TextEncoder().encode(text);\n}\n/**\n * TODO: docs\n */ function createSignInMessageText(input) {\n    // ${domain} wants you to sign in with your Solana account:\n    // ${address}\n    //\n    // ${statement}\n    //\n    // URI: ${uri}\n    // Version: ${version}\n    // Chain ID: ${chain}\n    // Nonce: ${nonce}\n    // Issued At: ${issued-at}\n    // Expiration Time: ${expiration-time}\n    // Not Before: ${not-before}\n    // Request ID: ${request-id}\n    // Resources:\n    // - ${resources[0]}\n    // - ${resources[1]}\n    // ...\n    // - ${resources[n]}\n    let message = `${input.domain} wants you to sign in with your Solana account:\\n`;\n    message += `${input.address}`;\n    if (input.statement) {\n        message += `\\n\\n${input.statement}`;\n    }\n    const fields = [];\n    if (input.uri) {\n        fields.push(`URI: ${input.uri}`);\n    }\n    if (input.version) {\n        fields.push(`Version: ${input.version}`);\n    }\n    if (input.chainId) {\n        fields.push(`Chain ID: ${input.chainId}`);\n    }\n    if (input.nonce) {\n        fields.push(`Nonce: ${input.nonce}`);\n    }\n    if (input.issuedAt) {\n        fields.push(`Issued At: ${input.issuedAt}`);\n    }\n    if (input.expirationTime) {\n        fields.push(`Expiration Time: ${input.expirationTime}`);\n    }\n    if (input.notBefore) {\n        fields.push(`Not Before: ${input.notBefore}`);\n    }\n    if (input.requestId) {\n        fields.push(`Request ID: ${input.requestId}`);\n    }\n    if (input.resources) {\n        fields.push(`Resources:`);\n        for (const resource of input.resources){\n            fields.push(`- ${resource}`);\n        }\n    }\n    if (fields.length) {\n        message += `\\n\\n${fields.join(\"\\n\")}`;\n    }\n    return message;\n} //# sourceMappingURL=signIn.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbC9saWIvZXNtL3NpZ25Jbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDbEI7QUFDeEM7O0NBRUMsR0FDTSxTQUFTRSxhQUFhQyxLQUFLLEVBQUVDLE1BQU07SUFDdEMsTUFBTSxFQUFFQyxhQUFhLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUUsRUFBRyxHQUFHSjtJQUM5RCxNQUFNSyxVQUFVQyxvQkFBb0JQLE9BQU9DO0lBQzNDLE9BQVEsQ0FBQyxDQUFDSyxXQUFXVCx1RUFBc0JBLENBQUM7UUFBRVM7UUFBU0o7UUFBZUM7UUFBV0UsV0FBV0E7SUFBVTtBQUMxRztBQUNBOztDQUVDLEdBQ00sU0FBU0Usb0JBQW9CUCxLQUFLLEVBQUVDLE1BQU07SUFDN0MsTUFBTU8sT0FBT0Msd0JBQXdCVCxPQUFPQztJQUM1QyxJQUFJLENBQUNPLE1BQ0QsT0FBTztJQUNYLE9BQU8sSUFBSUUsY0FBY0MsTUFBTSxDQUFDSDtBQUNwQztBQUNBOztDQUVDLEdBQ00sU0FBU0Msd0JBQXdCVCxLQUFLLEVBQUVDLE1BQU07SUFDakQsTUFBTVcsU0FBU0MsbUJBQW1CWixPQUFPQyxhQUFhO0lBQ3RELElBQUksQ0FBQ1UsUUFDRCxPQUFPO0lBQ1gsSUFBSVosTUFBTWMsTUFBTSxJQUFJZCxNQUFNYyxNQUFNLEtBQUtGLE9BQU9FLE1BQU0sRUFDOUMsT0FBTztJQUNYLElBQUlkLE1BQU1lLE9BQU8sSUFBSWYsTUFBTWUsT0FBTyxLQUFLSCxPQUFPRyxPQUFPLEVBQ2pELE9BQU87SUFDWCxJQUFJZixNQUFNZ0IsU0FBUyxLQUFLSixPQUFPSSxTQUFTLEVBQ3BDLE9BQU87SUFDWCxJQUFJaEIsTUFBTWlCLEdBQUcsS0FBS0wsT0FBT0ssR0FBRyxFQUN4QixPQUFPO0lBQ1gsSUFBSWpCLE1BQU1rQixPQUFPLEtBQUtOLE9BQU9NLE9BQU8sRUFDaEMsT0FBTztJ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QUFDLENBQUM7SUFDMUQ7SUFDQSxJQUFJdEIsTUFBTXVCLFNBQVMsRUFBRTtRQUNqQjRCLE9BQU9DLElBQUksQ0FBQyxDQUFDLFlBQVksRUFBRXBELE1BQU11QixTQUFTLENBQUMsQ0FBQztJQUNoRDtJQUNBLElBQUl2QixNQUFNd0IsU0FBUyxFQUFFO1FBQ2pCMkIsT0FBT0MsSUFBSSxDQUFDLENBQUMsWUFBWSxFQUFFcEQsTUFBTXdCLFNBQVMsQ0FBQyxDQUFDO0lBQ2hEO0lBQ0EsSUFBSXhCLE1BQU15QixTQUFTLEVBQUU7UUFDakIwQixPQUFPQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUM7UUFDeEIsS0FBSyxNQUFNQyxZQUFZckQsTUFBTXlCLFNBQVMsQ0FBRTtZQUNwQzBCLE9BQU9DLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRUMsU0FBUyxDQUFDO1FBQy9CO0lBQ0o7SUFDQSxJQUFJRixPQUFPRyxNQUFNLEVBQUU7UUFDZmhELFdBQVcsQ0FBQyxJQUFJLEVBQUU2QyxPQUFPSSxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3pDO0lBQ0EsT0FBT2pEO0FBQ1gsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC11dGlsL2xpYi9lc20vc2lnbkluLmpzP2ViNmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyaWZ5TWVzc2FnZVNpZ25hdHVyZSB9IGZyb20gJy4vc2lnbk1lc3NhZ2UuanMnO1xuaW1wb3J0IHsgYXJyYXlzRXF1YWwgfSBmcm9tICcuL3V0aWwuanMnO1xuLyoqXG4gKiBUT0RPOiBkb2NzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTaWduSW4oaW5wdXQsIG91dHB1dCkge1xuICAgIGNvbnN0IHsgc2lnbmVkTWVzc2FnZSwgc2lnbmF0dXJlLCBhY2NvdW50OiB7IHB1YmxpY0tleSB9LCB9ID0gb3V0cHV0O1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXJpdmVTaWduSW5NZXNzYWdlKGlucHV0LCBvdXRwdXQpO1xuICAgIHJldHVybiAoISFtZXNzYWdlICYmIHZlcmlmeU1lc3NhZ2VTaWduYXR1cmUoeyBtZXNzYWdlLCBzaWduZWRNZXNzYWdlLCBzaWduYXR1cmUsIHB1YmxpY0tleTogcHVibGljS2V5IH0pKTtcbn1cbi8qKlxuICogVE9ETzogZG9jc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlU2lnbkluTWVzc2FnZShpbnB1dCwgb3V0cHV0KSB7XG4gICAgY29uc3QgdGV4dCA9IGRlcml2ZVNpZ25Jbk1lc3NhZ2VUZXh0KGlucHV0LCBvdXRwdXQpO1xuICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXh0KTtcbn1cbi8qKlxuICogVE9ETzogZG9jc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlU2lnbkluTWVzc2FnZVRleHQoaW5wdXQsIG91dHB1dCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2lnbkluTWVzc2FnZShvdXRwdXQuc2lnbmVkTWVzc2FnZSk7XG4gICAgaWYgKCFwYXJzZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC5kb21haW4gJiYgaW5wdXQuZG9tYWluICE9PSBwYXJzZWQuZG9tYWluKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQuYWRkcmVzcyAmJiBpbnB1dC5hZGRyZXNzICE9PSBwYXJzZWQuYWRkcmVzcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlucHV0LnN0YXRlbWVudCAhPT0gcGFyc2VkLnN0YXRlbWVudClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlucHV0LnVyaSAhPT0gcGFyc2VkLnVyaSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlucHV0LnZlcnNpb24gIT09IHBhcnNlZC52ZXJzaW9uKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQuY2hhaW5JZCAhPT0gcGFyc2VkLmNoYWluSWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC5ub25jZSAhPT0gcGFyc2VkLm5vbmNlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQuaXNzdWVkQXQgIT09IHBhcnNlZC5pc3N1ZWRBdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlucHV0LmV4cGlyYXRpb25UaW1lICE9PSBwYXJzZWQuZXhwaXJhdGlvblRpbWUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC5ub3RCZWZvcmUgIT09IHBhcnNlZC5ub3RCZWZvcmUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC5yZXF1ZXN0SWQgIT09IHBhcnNlZC5yZXF1ZXN0SWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC5yZXNvdXJjZXMpIHtcbiAgICAgICAgaWYgKCFwYXJzZWQucmVzb3VyY2VzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghYXJyYXlzRXF1YWwoaW5wdXQucmVzb3VyY2VzLCBwYXJzZWQucmVzb3VyY2VzKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJzZWQucmVzb3VyY2VzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gY3JlYXRlU2lnbkluTWVzc2FnZVRleHQocGFyc2VkKTtcbn1cbi8qKlxuICogVE9ETzogZG9jc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTaWduSW5NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG1lc3NhZ2UpO1xuICAgIHJldHVybiBwYXJzZVNpZ25Jbk1lc3NhZ2VUZXh0KHRleHQpO1xufVxuLy8gVE9ETzogaW1wbGVtZW50IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi9tYXN0ZXIvZG9jcy9zcmMvcHJvcG9zYWxzL29mZi1jaGFpbi1tZXNzYWdlLXNpZ25pbmcubWRcbmNvbnN0IERPTUFJTiA9ICcoPzxkb21haW4+W15cXFxcbl0rPykgd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIFNvbGFuYSBhY2NvdW50OlxcXFxuJztcbmNvbnN0IEFERFJFU1MgPSAnKD88YWRkcmVzcz5bXlxcXFxuXSspKD86XFxcXG58JCknO1xuY29uc3QgU1RBVEVNRU5UID0gJyg/OlxcXFxuKD88c3RhdGVtZW50PltcXFxcU1xcXFxzXSo/KSg/OlxcXFxufCQpKT8/JztcbmNvbnN0IFVSSSA9ICcoPzpcXFxcblVSSTogKD88dXJpPlteXFxcXG5dKykpPyc7XG5jb25zdCBWRVJTSU9OID0gJyg/OlxcXFxuVmVyc2lvbjogKD88dmVyc2lvbj5bXlxcXFxuXSspKT8nO1xuY29uc3QgQ0hBSU5fSUQgPSAnKD86XFxcXG5DaGFpbiBJRDogKD88Y2hhaW5JZD5bXlxcXFxuXSspKT8nO1xuY29uc3QgTk9OQ0UgPSAnKD86XFxcXG5Ob25jZTogKD88bm9uY2U+W15cXFxcbl0rKSk/JztcbmNvbnN0IElTU1VFRF9BVCA9ICcoPzpcXFxcbklzc3VlZCBBdDogKD88aXNzdWVkQXQ+W15cXFxcbl0rKSk/JztcbmNvbnN0IEVYUElSQVRJT05fVElNRSA9ICcoPzpcXFxcbkV4cGlyYXRpb24gVGltZTogKD88ZXhwaXJhdGlvblRpbWU+W15cXFxcbl0rKSk/JztcbmNvbnN0IE5PVF9CRUZPUkUgPSAnKD86XFxcXG5Ob3QgQmVmb3JlOiAoPzxub3RCZWZvcmU+W15cXFxcbl0rKSk/JztcbmNvbnN0IFJFUVVFU1RfSUQgPSAnKD86XFxcXG5SZXF1ZXN0IElEOiAoPzxyZXF1ZXN0SWQ+W15cXFxcbl0rKSk/JztcbmNvbnN0IFJFU09VUkNFUyA9ICcoPzpcXFxcblJlc291cmNlczooPzxyZXNvdXJjZXM+KD86XFxcXG4tIFteXFxcXG5dKykqKSk/JztcbmNvbnN0IEZJRUxEUyA9IGAke1VSSX0ke1ZFUlNJT059JHtDSEFJTl9JRH0ke05PTkNFfSR7SVNTVUVEX0FUfSR7RVhQSVJBVElPTl9USU1FfSR7Tk9UX0JFRk9SRX0ke1JFUVVFU1RfSUR9JHtSRVNPVVJDRVN9YDtcbmNvbnN0IE1FU1NBR0UgPSBuZXcgUmVnRXhwKGBeJHtET01BSU59JHtBRERSRVNTfSR7U1RBVEVNRU5UfSR7RklFTERTfVxcXFxuKiRgKTtcbi8qKlxuICogVE9ETzogZG9jc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTaWduSW5NZXNzYWdlVGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgbWF0Y2ggPSBNRVNTQUdFLmV4ZWModGV4dCk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgZ3JvdXBzID0gbWF0Y2guZ3JvdXBzO1xuICAgIGlmICghZ3JvdXBzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBkb21haW46IGdyb3Vwcy5kb21haW4sXG4gICAgICAgIGFkZHJlc3M6IGdyb3Vwcy5hZGRyZXNzLFxuICAgICAgICBzdGF0ZW1lbnQ6IGdyb3Vwcy5zdGF0ZW1lbnQsXG4gICAgICAgIHVyaTogZ3JvdXBzLnVyaSxcbiAgICAgICAgdmVyc2lvbjogZ3JvdXBzLnZlcnNpb24sXG4gICAgICAgIG5vbmNlOiBncm91cHMubm9uY2UsXG4gICAgICAgIGNoYWluSWQ6IGdyb3Vwcy5jaGFpbklkLFxuICAgICAgICBpc3N1ZWRBdDogZ3JvdXBzLmlzc3VlZEF0LFxuICAgICAgICBleHBpcmF0aW9uVGltZTogZ3JvdXBzLmV4cGlyYXRpb25UaW1lLFxuICAgICAgICBub3RCZWZvcmU6IGdyb3Vwcy5ub3RCZWZvcmUsXG4gICAgICAgIHJlcXVlc3RJZDogZ3JvdXBzLnJlcXVlc3RJZCxcbiAgICAgICAgcmVzb3VyY2VzOiBncm91cHMucmVzb3VyY2VzPy5zcGxpdCgnXFxuLSAnKS5zbGljZSgxKSxcbiAgICB9O1xufVxuLyoqXG4gKiBUT0RPOiBkb2NzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaWduSW5NZXNzYWdlKGlucHV0KSB7XG4gICAgY29uc3QgdGV4dCA9IGNyZWF0ZVNpZ25Jbk1lc3NhZ2VUZXh0KGlucHV0KTtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRleHQpO1xufVxuLyoqXG4gKiBUT0RPOiBkb2NzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaWduSW5NZXNzYWdlVGV4dChpbnB1dCkge1xuICAgIC8vICR7ZG9tYWlufSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgU29sYW5hIGFjY291bnQ6XG4gICAgLy8gJHthZGRyZXNzfVxuICAgIC8vXG4gICAgLy8gJHtzdGF0ZW1lbnR9XG4gICAgLy9cbiAgICAvLyBVUkk6ICR7dXJpfVxuICAgIC8vIFZlcnNpb246ICR7dmVyc2lvbn1cbiAgICAvLyBDaGFpbiBJRDogJHtjaGFpbn1cbiAgICAvLyBOb25jZTogJHtub25jZX1cbiAgICAvLyBJc3N1ZWQgQXQ6ICR7aXNzdWVkLWF0fVxuICAgIC8vIEV4cGlyYXRpb24gVGltZTogJHtleHBpcmF0aW9uLXRpbWV9XG4gICAgLy8gTm90IEJlZm9yZTogJHtub3QtYmVmb3JlfVxuICAgIC8vIFJlcXVlc3QgSUQ6ICR7cmVxdWVzdC1pZH1cbiAgICAvLyBSZXNvdXJjZXM6XG4gICAgLy8gLSAke3Jlc291cmNlc1swXX1cbiAgICAvLyAtICR7cmVzb3VyY2VzWzFdfVxuICAgIC8vIC4uLlxuICAgIC8vIC0gJHtyZXNvdXJjZXNbbl19XG4gICAgbGV0IG1lc3NhZ2UgPSBgJHtpbnB1dC5kb21haW59IHdhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBTb2xhbmEgYWNjb3VudDpcXG5gO1xuICAgIG1lc3NhZ2UgKz0gYCR7aW5wdXQuYWRkcmVzc31gO1xuICAgIGlmIChpbnB1dC5zdGF0ZW1lbnQpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgXFxuXFxuJHtpbnB1dC5zdGF0ZW1lbnR9YDtcbiAgICB9XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgaWYgKGlucHV0LnVyaSkge1xuICAgICAgICBmaWVsZHMucHVzaChgVVJJOiAke2lucHV0LnVyaX1gKTtcbiAgICB9XG4gICAgaWYgKGlucHV0LnZlcnNpb24pIHtcbiAgICAgICAgZmllbGRzLnB1c2goYFZlcnNpb246ICR7aW5wdXQudmVyc2lvbn1gKTtcbiAgICB9XG4gICAgaWYgKGlucHV0LmNoYWluSWQpIHtcbiAgICAgICAgZmllbGRzLnB1c2goYENoYWluIElEOiAke2lucHV0LmNoYWluSWR9YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5ub25jZSkge1xuICAgICAgICBmaWVsZHMucHVzaChgTm9uY2U6ICR7aW5wdXQubm9uY2V9YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5pc3N1ZWRBdCkge1xuICAgICAgICBmaWVsZHMucHVzaChgSXNzdWVkIEF0OiAke2lucHV0Lmlzc3VlZEF0fWApO1xuICAgIH1cbiAgICBpZiAoaW5wdXQuZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgZmllbGRzLnB1c2goYEV4cGlyYXRpb24gVGltZTogJHtpbnB1dC5leHBpcmF0aW9uVGltZX1gKTtcbiAgICB9XG4gICAgaWYgKGlucHV0Lm5vdEJlZm9yZSkge1xuICAgICAgICBmaWVsZHMucHVzaChgTm90IEJlZm9yZTogJHtpbnB1dC5ub3RCZWZvcmV9YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5yZXF1ZXN0SWQpIHtcbiAgICAgICAgZmllbGRzLnB1c2goYFJlcXVlc3QgSUQ6ICR7aW5wdXQucmVxdWVzdElkfWApO1xuICAgIH1cbiAgICBpZiAoaW5wdXQucmVzb3VyY2VzKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGBSZXNvdXJjZXM6YCk7XG4gICAgICAgIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgaW5wdXQucmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChgLSAke3Jlc291cmNlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYFxcblxcbiR7ZmllbGRzLmpvaW4oJ1xcbicpfWA7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbkluLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJpZnlNZXNzYWdlU2lnbmF0dXJlIiwiYXJyYXlzRXF1YWwiLCJ2ZXJpZnlTaWduSW4iLCJpbnB1dCIsIm91dHB1dCIsInNpZ25lZE1lc3NhZ2UiLCJzaWduYXR1cmUiLCJhY2NvdW50IiwicHVibGljS2V5IiwibWVzc2FnZSIsImRlcml2ZVNpZ25Jbk1lc3NhZ2UiLCJ0ZXh0IiwiZGVyaXZlU2lnbkluTWVzc2FnZVRleHQiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsInBhcnNlZCIsInBhcnNlU2lnbkluTWVzc2FnZSIsImRvbWFpbiIsImFkZHJlc3MiLCJzdGF0ZW1lbnQiLCJ1cmkiLCJ2ZXJzaW9uIiwiY2hhaW5JZCIsIm5vbmNlIiwiaXNzdWVkQXQiLCJleHBpcmF0aW9uVGltZSIsIm5vdEJlZm9yZSIsInJlcXVlc3RJZCIsInJlc291cmNlcyIsImNyZWF0ZVNpZ25Jbk1lc3NhZ2VUZXh0IiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJwYXJzZVNpZ25Jbk1lc3NhZ2VUZXh0IiwiRE9NQUlOIiwiQUREUkVTUyIsIlNUQVRFTUVOVCIsIlVSSSIsIlZFUlNJT04iLCJDSEFJTl9JRCIsIk5PTkNFIiwiSVNTVUVEX0FUIiwiRVhQSVJBVElPTl9USU1FIiwiTk9UX0JFRk9SRSIsIlJFUVVFU1RfSUQiLCJSRVNPVVJDRVMiLCJGSUVMRFMiLCJNRVNTQUdFIiwiUmVnRXhwIiwibWF0Y2giLCJleGVjIiwiZ3JvdXBzIiwic3BsaXQiLCJzbGljZSIsImNyZWF0ZVNpZ25Jbk1lc3NhZ2UiLCJmaWVsZHMiLCJwdXNoIiwicmVzb3VyY2UiLCJsZW5ndGgiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/signIn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/signMessage.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-util/lib/esm/signMessage.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   verifyMessageSignature: () => (/* binding */ verifyMessageSignature),\n/* harmony export */   verifySignMessage: () => (/* binding */ verifySignMessage)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/./node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/util.js\");\n\n\n/**\n * TODO: docs\n */ function verifyMessageSignature({ message, signedMessage, signature, publicKey }) {\n    // TODO: implement https://github.com/solana-labs/solana/blob/master/docs/src/proposals/off-chain-message-signing.md\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.bytesEqual)(message, signedMessage) && _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_1__.ed25519.verify(signature, signedMessage, publicKey);\n}\n/**\n * TODO: docs\n */ function verifySignMessage(input, output) {\n    const { message, account: { publicKey } } = input;\n    const { signedMessage, signature } = output;\n    return verifyMessageSignature({\n        message,\n        signedMessage,\n        signature,\n        publicKey: publicKey\n    });\n} //# sourceMappingURL=signMessage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbC9saWIvZXNtL3NpZ25NZXNzYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0Q7QUFDVDtBQUN2Qzs7Q0FFQyxHQUNNLFNBQVNFLHVCQUF1QixFQUFFQyxPQUFPLEVBQUVDLGFBQWEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUc7SUFDcEYsb0hBQW9IO0lBQ3BILE9BQU9MLG9EQUFVQSxDQUFDRSxTQUFTQyxrQkFBa0JKLDBEQUFPQSxDQUFDTyxNQUFNLENBQUNGLFdBQVdELGVBQWVFO0FBQzFGO0FBQ0E7O0NBRUMsR0FDTSxTQUFTRSxrQkFBa0JDLEtBQUssRUFBRUMsTUFBTTtJQUMzQyxNQUFNLEVBQUVQLE9BQU8sRUFBRVEsU0FBUyxFQUFFTCxTQUFTLEVBQUUsRUFBRyxHQUFHRztJQUM3QyxNQUFNLEVBQUVMLGFBQWEsRUFBRUMsU0FBUyxFQUFFLEdBQUdLO0lBQ3JDLE9BQU9SLHVCQUF1QjtRQUFFQztRQUFTQztRQUFlQztRQUFXQyxXQUFXQTtJQUFVO0FBQzVGLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbC9saWIvZXNtL3NpZ25NZXNzYWdlLmpzPzEwOGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZWQyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG5pbXBvcnQgeyBieXRlc0VxdWFsIH0gZnJvbSAnLi91dGlsLmpzJztcbi8qKlxuICogVE9ETzogZG9jc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5TWVzc2FnZVNpZ25hdHVyZSh7IG1lc3NhZ2UsIHNpZ25lZE1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5LCB9KSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi9tYXN0ZXIvZG9jcy9zcmMvcHJvcG9zYWxzL29mZi1jaGFpbi1tZXNzYWdlLXNpZ25pbmcubWRcbiAgICByZXR1cm4gYnl0ZXNFcXVhbChtZXNzYWdlLCBzaWduZWRNZXNzYWdlKSAmJiBlZDI1NTE5LnZlcmlmeShzaWduYXR1cmUsIHNpZ25lZE1lc3NhZ2UsIHB1YmxpY0tleSk7XG59XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25NZXNzYWdlKGlucHV0LCBvdXRwdXQpIHtcbiAgICBjb25zdCB7IG1lc3NhZ2UsIGFjY291bnQ6IHsgcHVibGljS2V5IH0sIH0gPSBpbnB1dDtcbiAgICBjb25zdCB7IHNpZ25lZE1lc3NhZ2UsIHNpZ25hdHVyZSB9ID0gb3V0cHV0O1xuICAgIHJldHVybiB2ZXJpZnlNZXNzYWdlU2lnbmF0dXJlKHsgbWVzc2FnZSwgc2lnbmVkTWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXk6IHB1YmxpY0tleSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25NZXNzYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJlZDI1NTE5IiwiYnl0ZXNFcXVhbCIsInZlcmlmeU1lc3NhZ2VTaWduYXR1cmUiLCJtZXNzYWdlIiwic2lnbmVkTWVzc2FnZSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInZlcmlmeSIsInZlcmlmeVNpZ25NZXNzYWdlIiwiaW5wdXQiLCJvdXRwdXQiLCJhY2NvdW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/signMessage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/util.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-util/lib/esm/util.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arraysEqual: () => (/* binding */ arraysEqual),\n/* harmony export */   bytesEqual: () => (/* binding */ bytesEqual)\n/* harmony export */ });\n/**\n * @internal\n *\n * Efficiently compare {@link Indexed} arrays (e.g. `Array` and `Uint8Array`).\n *\n * @param a An array.\n * @param b Another array.\n *\n * @return `true` if the arrays have the same length and elements, `false` otherwise.\n *\n * @group Internal\n */ function arraysEqual(a, b) {\n    if (a === b) return true;\n    const length = a.length;\n    if (length !== b.length) return false;\n    for(let i = 0; i < length; i++){\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n/**\n * @internal\n *\n * Efficiently compare byte arrays, using {@link arraysEqual}.\n *\n * @param a A byte array.\n * @param b Another byte array.\n *\n * @return `true` if the byte arrays have the same length and bytes, `false` otherwise.\n *\n * @group Internal\n */ function bytesEqual(a, b) {\n    return arraysEqual(a, b);\n} //# sourceMappingURL=util.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbC9saWIvZXNtL3V0aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNNLFNBQVNBLFlBQVlDLENBQUMsRUFBRUMsQ0FBQztJQUM1QixJQUFJRCxNQUFNQyxHQUNOLE9BQU87SUFDWCxNQUFNQyxTQUFTRixFQUFFRSxNQUFNO0lBQ3ZCLElBQUlBLFdBQVdELEVBQUVDLE1BQU0sRUFDbkIsT0FBTztJQUNYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxRQUFRQyxJQUFLO1FBQzdCLElBQUlILENBQUMsQ0FBQ0csRUFBRSxLQUFLRixDQUFDLENBQUNFLEVBQUUsRUFDYixPQUFPO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNNLFNBQVNDLFdBQVdKLENBQUMsRUFBRUMsQ0FBQztJQUMzQixPQUFPRixZQUFZQyxHQUFHQztBQUMxQixFQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwvbGliL2VzbS91dGlsLmpzP2JhY2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBFZmZpY2llbnRseSBjb21wYXJlIHtAbGluayBJbmRleGVkfSBhcnJheXMgKGUuZy4gYEFycmF5YCBhbmQgYFVpbnQ4QXJyYXlgKS5cbiAqXG4gKiBAcGFyYW0gYSBBbiBhcnJheS5cbiAqIEBwYXJhbSBiIEFub3RoZXIgYXJyYXkuXG4gKlxuICogQHJldHVybiBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhbmQgZWxlbWVudHMsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBncm91cCBJbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlzRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBFZmZpY2llbnRseSBjb21wYXJlIGJ5dGUgYXJyYXlzLCB1c2luZyB7QGxpbmsgYXJyYXlzRXF1YWx9LlxuICpcbiAqIEBwYXJhbSBhIEEgYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSBiIEFub3RoZXIgYnl0ZSBhcnJheS5cbiAqXG4gKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGUgYnl0ZSBhcnJheXMgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYW5kIGJ5dGVzLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZ3JvdXAgSW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhcnJheXNFcXVhbChhLCBiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbImFycmF5c0VxdWFsIiwiYSIsImIiLCJsZW5ndGgiLCJpIiwiYnl0ZXNFcXVhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StandardWalletAdapter: () => (/* binding */ StandardWalletAdapter)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signIn.js\");\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js\");\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/commitment.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/./node_modules/@wallet-standard/features/lib/esm/events.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/./node_modules/@wallet-standard/features/lib/esm/disconnect.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/./node_modules/@wallet-standard/features/lib/esm/connect.js\");\n/* harmony import */ var _wallet_standard_wallet__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @wallet-standard/wallet */ \"(ssr)/./node_modules/@wallet-standard/wallet/lib/esm/util.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bs58/src/esm/index.js\");\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _StandardWalletAdapter_instances, _StandardWalletAdapter_account, _StandardWalletAdapter_publicKey, _StandardWalletAdapter_connecting, _StandardWalletAdapter_disconnecting, _StandardWalletAdapter_off, _StandardWalletAdapter_supportedTransactionVersions, _StandardWalletAdapter_wallet, _StandardWalletAdapter_readyState, _StandardWalletAdapter_connect, _StandardWalletAdapter_connected, _StandardWalletAdapter_disconnected, _StandardWalletAdapter_reset, _StandardWalletAdapter_changed, _StandardWalletAdapter_signTransaction, _StandardWalletAdapter_signAllTransactions, _StandardWalletAdapter_signMessage, _StandardWalletAdapter_signIn;\n\n\n\n\n\n\n\n/** TODO: docs */ class StandardWalletAdapter extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.BaseWalletAdapter {\n    get name() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").name;\n    }\n    get url() {\n        return \"https://github.com/solana-labs/wallet-standard\";\n    }\n    get icon() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").icon;\n    }\n    get readyState() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_readyState, \"f\");\n    }\n    get publicKey() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_publicKey, \"f\");\n    }\n    get connecting() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_connecting, \"f\");\n    }\n    get supportedTransactionVersions() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_supportedTransactionVersions, \"f\");\n    }\n    get wallet() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\");\n    }\n    get standard() {\n        return true;\n    }\n    constructor({ wallet }){\n        super();\n        _StandardWalletAdapter_instances.add(this);\n        _StandardWalletAdapter_account.set(this, void 0);\n        _StandardWalletAdapter_publicKey.set(this, void 0);\n        _StandardWalletAdapter_connecting.set(this, void 0);\n        _StandardWalletAdapter_disconnecting.set(this, void 0);\n        _StandardWalletAdapter_off.set(this, void 0);\n        _StandardWalletAdapter_supportedTransactionVersions.set(this, void 0);\n        _StandardWalletAdapter_wallet.set(this, void 0);\n        _StandardWalletAdapter_readyState.set(this,  true ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported : 0);\n        _StandardWalletAdapter_changed.set(this, (properties)=>{\n            // If accounts have changed on the wallet, reflect this on the adapter.\n            if (\"accounts\" in properties) {\n                const account = __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts[0];\n                // If the adapter isn't connected, or is disconnecting, or the first account hasn't changed, do nothing.\n                if (__classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\") && !__classPrivateFieldGet(this, _StandardWalletAdapter_disconnecting, \"f\") && account !== __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")) {\n                    // If there's a connected account, connect the adapter. Otherwise, disconnect it.\n                    if (account) {\n                        // Connect the adapter.\n                        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, account);\n                    } else {\n                        // Emit an error because the wallet spontaneously disconnected.\n                        this.emit(\"error\", new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletDisconnectedError());\n                        // Disconnect the adapter.\n                        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_disconnected).call(this);\n                    }\n                }\n            }\n            // After reflecting account changes, if features have changed on the wallet, reflect this on the adapter.\n            if (\"features\" in properties) {\n                __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n            }\n        });\n        __classPrivateFieldSet(this, _StandardWalletAdapter_wallet, wallet, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_off, __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__.StandardEvents].on(\"change\", __classPrivateFieldGet(this, _StandardWalletAdapter_changed, \"f\")), \"f\");\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n    }\n    destroy() {\n        __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n        const off = __classPrivateFieldGet(this, _StandardWalletAdapter_off, \"f\");\n        if (off) {\n            __classPrivateFieldSet(this, _StandardWalletAdapter_off, null, \"f\");\n            off();\n        }\n    }\n    async autoConnect() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connect).call(this, {\n            silent: true\n        });\n    }\n    async connect() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connect).call(this);\n    }\n    async disconnect() {\n        if (_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__.StandardDisconnect in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n            try {\n                __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, true, \"f\");\n                await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__.StandardDisconnect].disconnect();\n            } catch (error) {\n                this.emit(\"error\", new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletDisconnectionError(error?.message, error));\n            } finally{\n                __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n            }\n        }\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_disconnected).call(this);\n    }\n    async sendTransaction(transaction, connection, options = {}) {\n        try {\n            const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n            if (!account) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n            let feature;\n            if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n                if (account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction)) {\n                    feature = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction;\n                } else if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction)) {\n                    feature = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction;\n                } else {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n                }\n            } else if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n                if (!account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n                feature = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction;\n            } else {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n            }\n            const chain = (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_8__.getChainForEndpoint)(connection.rpcEndpoint);\n            if (!account.chains.includes(chain)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSendTransactionError();\n            try {\n                const { signers, ...sendOptions } = options;\n                let serializedTransaction;\n                if ((0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction)) {\n                    signers?.length && transaction.sign(signers);\n                    serializedTransaction = transaction.serialize();\n                } else {\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n                    signers?.length && transaction.partialSign(...signers);\n                    serializedTransaction = new Uint8Array(transaction.serialize({\n                        requireAllSignatures: false,\n                        verifySignatures: false\n                    }));\n                }\n                if (feature === _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction) {\n                    const [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction].signAndSendTransaction({\n                        account,\n                        chain,\n                        transaction: serializedTransaction,\n                        options: {\n                            preflightCommitment: (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_10__.getCommitment)(sendOptions.preflightCommitment || connection.commitment),\n                            skipPreflight: sendOptions.skipPreflight,\n                            maxRetries: sendOptions.maxRetries,\n                            minContextSlot: sendOptions.minContextSlot\n                        }\n                    });\n                    return bs58__WEBPACK_IMPORTED_MODULE_1__[\"default\"].encode(output.signature);\n                } else {\n                    const [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction].signTransaction({\n                        account,\n                        chain,\n                        transaction: serializedTransaction,\n                        options: {\n                            preflightCommitment: (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_10__.getCommitment)(sendOptions.preflightCommitment || connection.commitment),\n                            minContextSlot: sendOptions.minContextSlot\n                        }\n                    });\n                    return await connection.sendRawTransaction(output.signedTransaction, {\n                        ...sendOptions,\n                        preflightCommitment: (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_10__.getCommitment)(sendOptions.preflightCommitment || connection.commitment)\n                    });\n                }\n            } catch (error) {\n                if (error instanceof _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletError) throw error;\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSendTransactionError(error?.message, error);\n            }\n        } catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n}\n_StandardWalletAdapter_account = new WeakMap(), _StandardWalletAdapter_publicKey = new WeakMap(), _StandardWalletAdapter_connecting = new WeakMap(), _StandardWalletAdapter_disconnecting = new WeakMap(), _StandardWalletAdapter_off = new WeakMap(), _StandardWalletAdapter_supportedTransactionVersions = new WeakMap(), _StandardWalletAdapter_wallet = new WeakMap(), _StandardWalletAdapter_readyState = new WeakMap(), _StandardWalletAdapter_changed = new WeakMap(), _StandardWalletAdapter_instances = new WeakSet(), _StandardWalletAdapter_connect = async function _StandardWalletAdapter_connect(input) {\n    try {\n        if (this.connected || this.connecting) return;\n        if (__classPrivateFieldGet(this, _StandardWalletAdapter_readyState, \"f\") !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotReadyError();\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, true, \"f\");\n        if (!__classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts.length) {\n            try {\n                await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_wallet_standard_features__WEBPACK_IMPORTED_MODULE_11__.StandardConnect].connect(input);\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConnectionError(error?.message, error);\n            }\n        }\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts[0];\n        if (!account) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, account);\n    } catch (error) {\n        this.emit(\"error\", error);\n        throw error;\n    } finally{\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n    }\n}, _StandardWalletAdapter_connected = function _StandardWalletAdapter_connected(account) {\n    let publicKey;\n    try {\n        // Use account.address instead of account.publicKey since address could be a PDA\n        publicKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(account.address);\n    } catch (error) {\n        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletPublicKeyError(error?.message, error);\n    }\n    __classPrivateFieldSet(this, _StandardWalletAdapter_account, account, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, publicKey, \"f\");\n    __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n    this.emit(\"connect\", publicKey);\n}, _StandardWalletAdapter_disconnected = function _StandardWalletAdapter_disconnected() {\n    __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n    __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n    this.emit(\"disconnect\");\n}, _StandardWalletAdapter_reset = function _StandardWalletAdapter_reset() {\n    const supportedTransactionVersions = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features ? __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction].supportedTransactionVersions : __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction].supportedTransactionVersions;\n    __classPrivateFieldSet(this, _StandardWalletAdapter_supportedTransactionVersions, (0,_wallet_standard_wallet__WEBPACK_IMPORTED_MODULE_12__.arraysEqual)(supportedTransactionVersions, [\n        \"legacy\"\n    ]) ? null : new Set(supportedTransactionVersions), \"f\");\n    if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")?.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction)) {\n        this.signTransaction = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signTransaction);\n        this.signAllTransactions = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signAllTransactions);\n    } else {\n        delete this.signTransaction;\n        delete this.signAllTransactions;\n    }\n    if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")?.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage)) {\n        this.signMessage = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signMessage);\n    } else {\n        delete this.signMessage;\n    }\n    if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_14__.SolanaSignIn in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n        this.signIn = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signIn);\n    } else {\n        delete this.signIn;\n    }\n}, _StandardWalletAdapter_signTransaction = async function _StandardWalletAdapter_signTransaction(transaction) {\n    try {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n        if (!account) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n        if (!(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n        if (!account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n        try {\n            const signedTransactions = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction].signTransaction({\n                account,\n                transaction: (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction) ? transaction.serialize() : new Uint8Array(transaction.serialize({\n                    requireAllSignatures: false,\n                    verifySignatures: false\n                }))\n            });\n            const serializedTransaction = signedTransactions[0].signedTransaction;\n            return (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction) ? _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedTransaction.deserialize(serializedTransaction) : _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from(serializedTransaction);\n        } catch (error) {\n            if (error instanceof _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletError) throw error;\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignTransactionError(error?.message, error);\n        }\n    } catch (error) {\n        this.emit(\"error\", error);\n        throw error;\n    }\n}, _StandardWalletAdapter_signAllTransactions = async function _StandardWalletAdapter_signAllTransactions(transactions) {\n    try {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n        if (!account) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n        if (!(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n        if (!account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n        try {\n            const signedTransactions = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction].signTransaction(...transactions.map((transaction)=>({\n                    account,\n                    transaction: (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction) ? transaction.serialize() : new Uint8Array(transaction.serialize({\n                        requireAllSignatures: false,\n                        verifySignatures: false\n                    }))\n                })));\n            return transactions.map((transaction, index)=>{\n                const signedTransaction = signedTransactions[index].signedTransaction;\n                return (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction) ? _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedTransaction.deserialize(signedTransaction) : _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from(signedTransaction);\n            });\n        } catch (error) {\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignTransactionError(error?.message, error);\n        }\n    } catch (error) {\n        this.emit(\"error\", error);\n        throw error;\n    }\n}, _StandardWalletAdapter_signMessage = async function _StandardWalletAdapter_signMessage(message) {\n    try {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n        if (!account) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n        if (!(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n        if (!account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n        try {\n            const signedMessages = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage].signMessage({\n                account,\n                message\n            });\n            return signedMessages[0].signature;\n        } catch (error) {\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignMessageError(error?.message, error);\n        }\n    } catch (error) {\n        this.emit(\"error\", error);\n        throw error;\n    }\n}, _StandardWalletAdapter_signIn = async function _StandardWalletAdapter_signIn(input = {}) {\n    try {\n        if (!(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_14__.SolanaSignIn in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n        let output;\n        try {\n            [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_14__.SolanaSignIn].signIn(input);\n        } catch (error) {\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignInError(error?.message, error);\n        }\n        if (!output) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignInError();\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, output.account);\n        return output;\n    } catch (error) {\n        this.emit(\"error\", error);\n        throw error;\n    }\n}; //# sourceMappingURL=adapter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL2FkYXB0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLHlCQUF5QixTQUFLLElBQUksU0FBSSxDQUFDQSxzQkFBc0IsSUFBSyxTQUFVQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxDQUFDO0lBQ3BHLElBQUlELFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9ILFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRSxJQUFJLENBQUNGLE1BQU1JLEdBQUcsQ0FBQ0wsV0FBVyxNQUFNLElBQUlJLFVBQVU7SUFDdkcsT0FBT0YsU0FBUyxNQUFNQyxJQUFJRCxTQUFTLE1BQU1DLEVBQUVHLElBQUksQ0FBQ04sWUFBWUcsSUFBSUEsRUFBRUksS0FBSyxHQUFHTixNQUFNTyxHQUFHLENBQUNSO0FBQ3hGO0FBQ0EsSUFBSVMseUJBQXlCLFNBQUssSUFBSSxTQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVULFFBQVEsRUFBRUMsS0FBSyxFQUFFTSxLQUFLLEVBQUVMLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9ILFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRSxJQUFJLENBQUNGLE1BQU1JLEdBQUcsQ0FBQ0wsV0FBVyxNQUFNLElBQUlJLFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU1ELEVBQUVHLElBQUksQ0FBQ04sVUFBVU8sU0FBU0osSUFBSUEsRUFBRUksS0FBSyxHQUFHQSxRQUFRTixNQUFNUyxHQUFHLENBQUNWLFVBQVVPLFFBQVNBO0FBQ3hHO0FBQ0EsSUFBSUksa0NB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LENBQUM0QyxPQUFPQyxTQUFTRDtRQUNoRDtRQUNBLElBQUksQ0FBQ3NCLFFBQ0QsTUFBTSxJQUFJbEUsMEVBQWlCQTtRQUMvQjNDLHVCQUF1QixJQUFJLEVBQUVZLGtDQUFrQyxLQUFLVSxrQ0FBa0NmLElBQUksQ0FBQyxJQUFJLEVBQUVzRyxPQUFPakMsT0FBTztRQUMvSCxPQUFPaUM7SUFDWCxFQUNBLE9BQU90QixPQUFPO1FBQ1YsSUFBSSxDQUFDVCxJQUFJLENBQUMsU0FBU1M7UUFDbkIsTUFBTUE7SUFDVjtBQUNKLEdBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL2FkYXB0ZXIuanM/ZDAwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9wdWJsaWNLZXksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGluZywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0aW5nLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX29mZiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZWFkeVN0YXRlLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3QsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGVkLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Rpc2Nvbm5lY3RlZCwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZXNldCwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jaGFuZ2VkLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25UcmFuc2FjdGlvbiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduQWxsVHJhbnNhY3Rpb25zLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25NZXNzYWdlLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25JbjtcbmltcG9ydCB7IEJhc2VXYWxsZXRBZGFwdGVyLCBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uLCBXYWxsZXRBY2NvdW50RXJyb3IsIFdhbGxldENvbmZpZ0Vycm9yLCBXYWxsZXRDb25uZWN0aW9uRXJyb3IsIFdhbGxldERpc2Nvbm5lY3RlZEVycm9yLCBXYWxsZXREaXNjb25uZWN0aW9uRXJyb3IsIFdhbGxldEVycm9yLCBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciwgV2FsbGV0Tm90UmVhZHlFcnJvciwgV2FsbGV0UHVibGljS2V5RXJyb3IsIFdhbGxldFJlYWR5U3RhdGUsIFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yLCBXYWxsZXRTaWduSW5FcnJvciwgV2FsbGV0U2lnbk1lc3NhZ2VFcnJvciwgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IsIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlJztcbmltcG9ydCB7IFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24sIFNvbGFuYVNpZ25JbiwgU29sYW5hU2lnbk1lc3NhZ2UsIFNvbGFuYVNpZ25UcmFuc2FjdGlvbiwgfSBmcm9tICdAc29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcyc7XG5pbXBvcnQgeyBnZXRDaGFpbkZvckVuZHBvaW50LCBnZXRDb21taXRtZW50IH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbCc7XG5pbXBvcnQgeyBQdWJsaWNLZXksIFRyYW5zYWN0aW9uLCBWZXJzaW9uZWRUcmFuc2FjdGlvbiB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyBTdGFuZGFyZENvbm5lY3QsIFN0YW5kYXJkRGlzY29ubmVjdCwgU3RhbmRhcmRFdmVudHMsIH0gZnJvbSAnQHdhbGxldC1zdGFuZGFyZC9mZWF0dXJlcyc7XG5pbXBvcnQgeyBhcnJheXNFcXVhbCB9IGZyb20gJ0B3YWxsZXQtc3RhbmRhcmQvd2FsbGV0JztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuLyoqIFRPRE86IGRvY3MgKi9cbmV4cG9ydCBjbGFzcyBTdGFuZGFyZFdhbGxldEFkYXB0ZXIgZXh0ZW5kcyBCYXNlV2FsbGV0QWRhcHRlciB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikubmFtZTtcbiAgICB9XG4gICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuICdodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvd2FsbGV0LXN0YW5kYXJkJztcbiAgICB9XG4gICAgZ2V0IGljb24oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuaWNvbjtcbiAgICB9XG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVhZHlTdGF0ZSwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgcHVibGljS2V5KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3B1YmxpY0tleSwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBzdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3N1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IHdhbGxldCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IHN0YW5kYXJkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyB3YWxsZXQgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICAgIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9wdWJsaWNLZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGluZy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0aW5nLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX29mZi5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZWFkeVN0YXRlLnNldCh0aGlzLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IFdhbGxldFJlYWR5U3RhdGUuVW5zdXBwb3J0ZWRcbiAgICAgICAgICAgIDogV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpO1xuICAgICAgICBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2NoYW5nZWQuc2V0KHRoaXMsIChwcm9wZXJ0aWVzKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBhY2NvdW50cyBoYXZlIGNoYW5nZWQgb24gdGhlIHdhbGxldCwgcmVmbGVjdCB0aGlzIG9uIHRoZSBhZGFwdGVyLlxuICAgICAgICAgICAgaWYgKCdhY2NvdW50cycgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuYWNjb3VudHNbMF07XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFkYXB0ZXIgaXNuJ3QgY29ubmVjdGVkLCBvciBpcyBkaXNjb25uZWN0aW5nLCBvciB0aGUgZmlyc3QgYWNjb3VudCBoYXNuJ3QgY2hhbmdlZCwgZG8gbm90aGluZy5cbiAgICAgICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIFwiZlwiKSAmJiAhX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Rpc2Nvbm5lY3RpbmcsIFwiZlwiKSAmJiBhY2NvdW50ICE9PSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjb25uZWN0ZWQgYWNjb3VudCwgY29ubmVjdCB0aGUgYWRhcHRlci4gT3RoZXJ3aXNlLCBkaXNjb25uZWN0IGl0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29ubmVjdCB0aGUgYWRhcHRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RlZCkuY2FsbCh0aGlzLCBhY2NvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgYW4gZXJyb3IgYmVjYXVzZSB0aGUgd2FsbGV0IHNwb250YW5lb3VzbHkgZGlzY29ubmVjdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBXYWxsZXREaXNjb25uZWN0ZWRFcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFkYXB0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0ZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZnRlciByZWZsZWN0aW5nIGFjY291bnQgY2hhbmdlcywgaWYgZmVhdHVyZXMgaGF2ZSBjaGFuZ2VkIG9uIHRoZSB3YWxsZXQsIHJlZmxlY3QgdGhpcyBvbiB0aGUgYWRhcHRlci5cbiAgICAgICAgICAgIGlmICgnZmVhdHVyZXMnIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZXNldCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIHdhbGxldCwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgbnVsbCwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcHVibGljS2V5LCBudWxsLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nLCBmYWxzZSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGluZywgZmFsc2UsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX29mZiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1N0YW5kYXJkRXZlbnRzXS5vbignY2hhbmdlJywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2NoYW5nZWQsIFwiZlwiKSksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVzZXQpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBudWxsLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9wdWJsaWNLZXksIG51bGwsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RpbmcsIGZhbHNlLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0aW5nLCBmYWxzZSwgXCJmXCIpO1xuICAgICAgICBjb25zdCBvZmYgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfb2ZmLCBcImZcIik7XG4gICAgICAgIGlmIChvZmYpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9vZmYsIG51bGwsIFwiZlwiKTtcbiAgICAgICAgICAgIG9mZigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGF1dG9Db25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdCkuY2FsbCh0aGlzLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3QpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmIChTdGFuZGFyZERpc2Nvbm5lY3QgaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0aW5nLCB0cnVlLCBcImZcIik7XG4gICAgICAgICAgICAgICAgYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1N0YW5kYXJkRGlzY29ubmVjdF0uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBXYWxsZXREaXNjb25uZWN0aW9uRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGluZywgZmFsc2UsIFwiZlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0ZWQpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIFwiZlwiKTtcbiAgICAgICAgICAgIGlmICghYWNjb3VudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICAgICAgICAgIGxldCBmZWF0dXJlO1xuICAgICAgICAgICAgaWYgKFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjY291bnQuZmVhdHVyZXMuaW5jbHVkZXMoU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZSA9IFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFNvbGFuYVNpZ25UcmFuc2FjdGlvbiBpbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudC5mZWF0dXJlcy5pbmNsdWRlcyhTb2xhbmFTaWduVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUgPSBTb2xhbmFTaWduVHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0QWNjb3VudEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoU29sYW5hU2lnblRyYW5zYWN0aW9uIGluIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcykge1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudC5mZWF0dXJlcy5pbmNsdWRlcyhTb2xhbmFTaWduVHJhbnNhY3Rpb24pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0QWNjb3VudEVycm9yKCk7XG4gICAgICAgICAgICAgICAgZmVhdHVyZSA9IFNvbGFuYVNpZ25UcmFuc2FjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25maWdFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhaW4gPSBnZXRDaGFpbkZvckVuZHBvaW50KGNvbm5lY3Rpb24ucnBjRW5kcG9pbnQpO1xuICAgICAgICAgICAgaWYgKCFhY2NvdW50LmNoYWlucy5pbmNsdWRlcyhjaGFpbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVycywgLi4uc2VuZE9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgbGV0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVycz8ubGVuZ3RoICYmIHRyYW5zYWN0aW9uLnNpZ24oc2lnbmVycyk7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSAoYXdhaXQgdGhpcy5wcmVwYXJlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIHNlbmRPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcnM/Lmxlbmd0aCAmJiB0cmFuc2FjdGlvbi5wYXJ0aWFsU2lnbiguLi5zaWduZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gbmV3IFVpbnQ4QXJyYXkodHJhbnNhY3Rpb24uc2VyaWFsaXplKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcmlmeVNpZ25hdHVyZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlID09PSBTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvdXRwdXRdID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1NvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb25dLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiBnZXRDb21taXRtZW50KHNlbmRPcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgfHwgY29ubmVjdGlvbi5jb21taXRtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwUHJlZmxpZ2h0OiBzZW5kT3B0aW9ucy5za2lwUHJlZmxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFJldHJpZXM6IHNlbmRPcHRpb25zLm1heFJldHJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQ29udGV4dFNsb3Q6IHNlbmRPcHRpb25zLm1pbkNvbnRleHRTbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiczU4LmVuY29kZShvdXRwdXQuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvdXRwdXRdID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1NvbGFuYVNpZ25UcmFuc2FjdGlvbl0uc2lnblRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBzZXJpYWxpemVkVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogZ2V0Q29tbWl0bWVudChzZW5kT3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IGNvbm5lY3Rpb24uY29tbWl0bWVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQ29udGV4dFNsb3Q6IHNlbmRPcHRpb25zLm1pbkNvbnRleHRTbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihvdXRwdXQuc2lnbmVkVHJhbnNhY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnNlbmRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogZ2V0Q29tbWl0bWVudChzZW5kT3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IGNvbm5lY3Rpb24uY29tbWl0bWVudCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFdhbGxldEVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCA9IG5ldyBXZWFrTWFwKCksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcHVibGljS2V5ID0gbmV3IFdlYWtNYXAoKSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nID0gbmV3IFdlYWtNYXAoKSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0aW5nID0gbmV3IFdlYWtNYXAoKSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9vZmYgPSBuZXcgV2Vha01hcCgpLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3N1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMgPSBuZXcgV2Vha01hcCgpLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCA9IG5ldyBXZWFrTWFwKCksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVhZHlTdGF0ZSA9IG5ldyBXZWFrTWFwKCksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY2hhbmdlZCA9IG5ldyBXZWFrTWFwKCksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0ID0gYXN5bmMgZnVuY3Rpb24gX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0KGlucHV0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkIHx8IHRoaXMuY29ubmVjdGluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZWFkeVN0YXRlLCBcImZcIikgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RpbmcsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTdGFuZGFyZENvbm5lY3RdLmNvbm5lY3QoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuYWNjb3VudHNbMF07XG4gICAgICAgIGlmICghYWNjb3VudClcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRBY2NvdW50RXJyb3IoKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGVkKS5jYWxsKHRoaXMsIGFjY291bnQpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGluZywgZmFsc2UsIFwiZlwiKTtcbiAgICB9XG59LCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RlZCA9IGZ1bmN0aW9uIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGVkKGFjY291bnQpIHtcbiAgICBsZXQgcHVibGljS2V5O1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFVzZSBhY2NvdW50LmFkZHJlc3MgaW5zdGVhZCBvZiBhY2NvdW50LnB1YmxpY0tleSBzaW5jZSBhZGRyZXNzIGNvdWxkIGJlIGEgUERBXG4gICAgICAgIHB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkoYWNjb3VudC5hZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBXYWxsZXRQdWJsaWNLZXlFcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgIH1cbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgYWNjb3VudCwgXCJmXCIpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9wdWJsaWNLZXksIHB1YmxpY0tleSwgXCJmXCIpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3Jlc2V0KS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIHB1YmxpY0tleSk7XG59LCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Rpc2Nvbm5lY3RlZCA9IGZ1bmN0aW9uIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGVkKCkge1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBudWxsLCBcImZcIik7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3B1YmxpY0tleSwgbnVsbCwgXCJmXCIpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3Jlc2V0KS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcpO1xufSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZXNldCA9IGZ1bmN0aW9uIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVzZXQoKSB7XG4gICAgY29uc3Qgc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucyA9IFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzXG4gICAgICAgID8gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1NvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb25dLnN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnNcbiAgICAgICAgOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXNbU29sYW5hU2lnblRyYW5zYWN0aW9uXS5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zLCBhcnJheXNFcXVhbChzdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zLCBbJ2xlZ2FjeSddKVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBuZXcgU2V0KHN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMpLCBcImZcIik7XG4gICAgaWYgKFNvbGFuYVNpZ25UcmFuc2FjdGlvbiBpbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXMgJiYgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIFwiZlwiKT8uZmVhdHVyZXMuaW5jbHVkZXMoU29sYW5hU2lnblRyYW5zYWN0aW9uKSkge1xuICAgICAgICB0aGlzLnNpZ25UcmFuc2FjdGlvbiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25UcmFuc2FjdGlvbik7XG4gICAgICAgIHRoaXMuc2lnbkFsbFRyYW5zYWN0aW9ucyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25BbGxUcmFuc2FjdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2lnblRyYW5zYWN0aW9uO1xuICAgICAgICBkZWxldGUgdGhpcy5zaWduQWxsVHJhbnNhY3Rpb25zO1xuICAgIH1cbiAgICBpZiAoU29sYW5hU2lnbk1lc3NhZ2UgaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzICYmIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBcImZcIik/LmZlYXR1cmVzLmluY2x1ZGVzKFNvbGFuYVNpZ25NZXNzYWdlKSkge1xuICAgICAgICB0aGlzLnNpZ25NZXNzYWdlID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnbk1lc3NhZ2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2lnbk1lc3NhZ2U7XG4gICAgfVxuICAgIGlmIChTb2xhbmFTaWduSW4gaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzKSB7XG4gICAgICAgIHRoaXMuc2lnbkluID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnbkluKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpZ25JbjtcbiAgICB9XG59LCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25UcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBcImZcIik7XG4gICAgICAgIGlmICghYWNjb3VudClcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICBpZiAoIShTb2xhbmFTaWduVHJhbnNhY3Rpb24gaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25maWdFcnJvcigpO1xuICAgICAgICBpZiAoIWFjY291bnQuZmVhdHVyZXMuaW5jbHVkZXMoU29sYW5hU2lnblRyYW5zYWN0aW9uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRBY2NvdW50RXJyb3IoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTb2xhbmFTaWduVHJhbnNhY3Rpb25dLnNpZ25UcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZnlTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBzaWduZWRUcmFuc2FjdGlvbnNbMF0uc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gKGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgPyBWZXJzaW9uZWRUcmFuc2FjdGlvbi5kZXNlcmlhbGl6ZShzZXJpYWxpemVkVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgOiBUcmFuc2FjdGlvbi5mcm9tKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgV2FsbGV0RXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduQWxsVHJhbnNhY3Rpb25zID0gYXN5bmMgZnVuY3Rpb24gX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgXCJmXCIpO1xuICAgICAgICBpZiAoIWFjY291bnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICAgICAgaWYgKCEoU29sYW5hU2lnblRyYW5zYWN0aW9uIGluIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29uZmlnRXJyb3IoKTtcbiAgICAgICAgaWYgKCFhY2NvdW50LmZlYXR1cmVzLmluY2x1ZGVzKFNvbGFuYVNpZ25UcmFuc2FjdGlvbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0QWNjb3VudEVycm9yKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXNbU29sYW5hU2lnblRyYW5zYWN0aW9uXS5zaWduVHJhbnNhY3Rpb24oLi4udHJhbnNhY3Rpb25zLm1hcCgodHJhbnNhY3Rpb24pID0+ICh7XG4gICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZnlTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbnMubWFwKCh0cmFuc2FjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IHNpZ25lZFRyYW5zYWN0aW9uc1tpbmRleF0uc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IFZlcnNpb25lZFRyYW5zYWN0aW9uLmRlc2VyaWFsaXplKHNpZ25lZFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICA6IFRyYW5zYWN0aW9uLmZyb20oc2lnbmVkVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn0sIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnbk1lc3NhZ2UgPSBhc3luYyBmdW5jdGlvbiBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIFwiZlwiKTtcbiAgICAgICAgaWYgKCFhY2NvdW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgIGlmICghKFNvbGFuYVNpZ25NZXNzYWdlIGluIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29uZmlnRXJyb3IoKTtcbiAgICAgICAgaWYgKCFhY2NvdW50LmZlYXR1cmVzLmluY2x1ZGVzKFNvbGFuYVNpZ25NZXNzYWdlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRBY2NvdW50RXJyb3IoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2VzID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1NvbGFuYVNpZ25NZXNzYWdlXS5zaWduTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbmVkTWVzc2FnZXNbMF0uc2lnbmF0dXJlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25NZXNzYWdlRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduSW4gPSBhc3luYyBmdW5jdGlvbiBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25JbihpbnB1dCA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCEoU29sYW5hU2lnbkluIGluIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29uZmlnRXJyb3IoKTtcbiAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFtvdXRwdXRdID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1NvbGFuYVNpZ25Jbl0uc2lnbkluKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduSW5FcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3V0cHV0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25JbkVycm9yKCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RlZCkuY2FsbCh0aGlzLCBvdXRwdXQuYWNjb3VudCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRlci5qcy5tYXAiXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsInJlY2VpdmVyIiwic3RhdGUiLCJraW5kIiwiZiIsIlR5cGVFcnJvciIsImhhcyIsImNhbGwiLCJ2YWx1ZSIsImdldCIsIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJzZXQiLCJfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcyIsIl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCIsIl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcHVibGljS2V5IiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nIiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0aW5nIiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9vZmYiLCJfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3N1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMiLCJfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCIsIl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVhZHlTdGF0ZSIsIl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdCIsIl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGVkIiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0ZWQiLCJfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3Jlc2V0IiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jaGFuZ2VkIiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduVHJhbnNhY3Rpb24iLCJfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25BbGxUcmFuc2FjdGlvbnMiLCJfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25NZXNzYWdlIiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduSW4iLCJCYXNlV2FsbGV0QWRhcHRlciIsImlzVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJXYWxsZXRBY2NvdW50RXJyb3IiLCJXYWxsZXRDb25maWdFcnJvciIsIldhbGxldENvbm5lY3Rpb25FcnJvciIsIldhbGxldERpc2Nvbm5lY3RlZEVycm9yIiwiV2FsbGV0RGlzY29ubmVjdGlvbkVycm9yIiwiV2FsbGV0RXJyb3IiLCJXYWxsZXROb3RDb25uZWN0ZWRFcnJvciIsIldhbGxldE5vdFJlYWR5RXJyb3IiLCJXYWxsZXRQdWJsaWNLZXlFcnJvciIsIldhbGxldFJlYWR5U3RhdGUiLCJXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvciIsIldhbGxldFNpZ25JbkVycm9yIiwiV2FsbGV0U2lnbk1lc3NhZ2VFcnJvciIsIldhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yIiwiU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiIsIlNvbGFuYVNpZ25JbiIsIlNvbGFuYVNpZ25NZXNzYWdlIiwiU29sYW5hU2lnblRyYW5zYWN0aW9uIiwiZ2V0Q2hhaW5Gb3JFbmRwb2ludCIsImdldENvbW1pdG1lbnQiLCJQdWJsaWNLZXkiLCJUcmFuc2FjdGlvbiIsIlZlcnNpb25lZFRyYW5zYWN0aW9uIiwiU3RhbmRhcmRDb25uZWN0IiwiU3RhbmRhcmREaXNjb25uZWN0IiwiU3RhbmRhcmRFdmVudHMiLCJhcnJheXNFcXVhbCIsImJzNTgiLCJTdGFuZGFyZFdhbGxldEFkYXB0ZXIiLCJuYW1lIiwidXJsIiwiaWNvbiIsInJlYWR5U3RhdGUiLCJwdWJsaWNLZXkiLCJjb25uZWN0aW5nIiwic3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucyIsIndhbGxldCIsInN0YW5kYXJkIiwiY29uc3RydWN0b3IiLCJhZGQiLCJkb2N1bWVudCIsIlVuc3VwcG9ydGVkIiwiSW5zdGFsbGVkIiwicHJvcGVydGllcyIsImFjY291bnQiLCJhY2NvdW50cyIsImVtaXQiLCJmZWF0dXJlcyIsIm9uIiwiZGVzdHJveSIsIm9mZiIsImF1dG9Db25uZWN0Iiwic2lsZW50IiwiY29ubmVjdCIsImRpc2Nvbm5lY3QiLCJlcnJvciIsIm1lc3NhZ2UiLCJzZW5kVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbiIsImNvbm5lY3Rpb24iLCJvcHRpb25zIiwiZmVhdHVyZSIsImluY2x1ZGVzIiwiY2hhaW4iLCJycGNFbmRwb2ludCIsImNoYWlucyIsInNpZ25lcnMiLCJzZW5kT3B0aW9ucyIsInNlcmlhbGl6ZWRUcmFuc2FjdGlvbiIsImxlbmd0aCIsInNpZ24iLCJzZXJpYWxpemUiLCJwcmVwYXJlVHJhbnNhY3Rpb24iLCJwYXJ0aWFsU2lnbiIsIlVpbnQ4QXJyYXkiLCJyZXF1aXJlQWxsU2lnbmF0dXJlcyIsInZlcmlmeVNpZ25hdHVyZXMiLCJvdXRwdXQiLCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uIiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsImNvbW1pdG1lbnQiLCJza2lwUHJlZmxpZ2h0IiwibWF4UmV0cmllcyIsIm1pbkNvbnRleHRTbG90IiwiZW5jb2RlIiwic2lnbmF0dXJlIiwic2lnblRyYW5zYWN0aW9uIiwic2VuZFJhd1RyYW5zYWN0aW9uIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJXZWFrTWFwIiwiV2Vha1NldCIsImlucHV0IiwiY29ubmVjdGVkIiwiYWRkcmVzcyIsIlNldCIsInNpZ25BbGxUcmFuc2FjdGlvbnMiLCJzaWduTWVzc2FnZSIsInNpZ25JbiIsInNpZ25lZFRyYW5zYWN0aW9ucyIsImRlc2VyaWFsaXplIiwiZnJvbSIsInRyYW5zYWN0aW9ucyIsIm1hcCIsImluZGV4Iiwic2lnbmVkTWVzc2FnZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isWalletAdapterCompatibleWallet: () => (/* binding */ isWalletAdapterCompatibleWallet)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js\");\n\n/**\n * @deprecated Use `isWalletAdapterCompatibleStandardWallet` from `@solana/wallet-adapter-base` instead.\n *\n * @group Deprecated\n */ const isWalletAdapterCompatibleWallet = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__.isWalletAdapterCompatibleStandardWallet; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVGO0FBQ3ZGOzs7O0NBSUMsR0FDTSxNQUFNQyxrQ0FBa0NELGdHQUF1Q0EsQ0FBQyxDQUN2RixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC13YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vdHlwZXMuanM/ZDUwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlU3RhbmRhcmRXYWxsZXQsIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlJztcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlU3RhbmRhcmRXYWxsZXRgIGZyb20gYEBzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZWAgaW5zdGVhZC5cbiAqXG4gKiBAZ3JvdXAgRGVwcmVjYXRlZFxuICovXG5leHBvcnQgY29uc3QgaXNXYWxsZXRBZGFwdGVyQ29tcGF0aWJsZVdhbGxldCA9IGlzV2FsbGV0QWRhcHRlckNvbXBhdGlibGVTdGFuZGFyZFdhbGxldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlU3RhbmRhcmRXYWxsZXQiLCJpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlV2FsbGV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStandardWalletAdapters: () => (/* binding */ useStandardWalletAdapters)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-standard-wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js\");\n/* harmony import */ var _solana_wallet_standard_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-standard-wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _wallet_standard_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wallet-standard/app */ \"(ssr)/./node_modules/@wallet-standard/app/lib/esm/wallets.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\nfunction useStandardWalletAdapters(adapters) {\n    const warnings = useConstant(()=>new Set());\n    const { get, on } = useConstant(()=>(0,_wallet_standard_app__WEBPACK_IMPORTED_MODULE_1__.DEPRECATED_getWallets)());\n    const [standardAdapters, setStandardAdapters] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>wrapWalletsWithAdapters(get()));\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const listeners = [\n            on(\"register\", (...wallets)=>setStandardAdapters((standardAdapters)=>[\n                        ...standardAdapters,\n                        ...wrapWalletsWithAdapters(wallets)\n                    ])),\n            on(\"unregister\", (...wallets)=>setStandardAdapters((standardAdapters)=>standardAdapters.filter((standardAdapter)=>wallets.some((wallet)=>wallet === standardAdapter.wallet))))\n        ];\n        return ()=>listeners.forEach((off)=>off());\n    }, [\n        on\n    ]);\n    const prevStandardAdapters = usePrevious(standardAdapters);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!prevStandardAdapters) return;\n        const currentAdapters = new Set(standardAdapters);\n        const removedAdapters = new Set(prevStandardAdapters.filter((previousAdapter)=>!currentAdapters.has(previousAdapter)));\n        removedAdapters.forEach((adapter)=>adapter.destroy());\n    }, [\n        prevStandardAdapters,\n        standardAdapters\n    ]);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>()=>standardAdapters.forEach((adapter)=>adapter.destroy()), []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n            ...standardAdapters,\n            ...adapters.filter(({ name })=>{\n                if (standardAdapters.some((standardAdapter)=>standardAdapter.name === name)) {\n                    if (!warnings.has(name)) {\n                        warnings.add(name);\n                        console.warn(`${name} was registered as a Standard Wallet. The Wallet Adapter for ${name} can be removed from your app.`);\n                    }\n                    return false;\n                }\n                return true;\n            })\n        ], [\n        standardAdapters,\n        adapters,\n        warnings\n    ]);\n}\nfunction useConstant(fn) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    if (ref.current === undefined) {\n        ref.current = {\n            value: fn()\n        };\n    }\n    return ref.current.value;\n}\nfunction usePrevious(state) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = state;\n    });\n    return ref.current;\n}\nfunction wrapWalletsWithAdapters(wallets) {\n    return wallets.filter(_solana_wallet_standard_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.isWalletAdapterCompatibleWallet).map((wallet)=>new _solana_wallet_standard_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.StandardWalletAdapter({\n            wallet\n        }));\n} //# sourceMappingURL=useStandardWalletAdapters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS91c2VTdGFuZGFyZFdhbGxldEFkYXB0ZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXFIO0FBQ3hEO0FBQ0E7QUFDdEQsU0FBU08sMEJBQTBCQyxRQUFRO0lBQzlDLE1BQU1DLFdBQVdDLFlBQVksSUFBTSxJQUFJQztJQUN2QyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsRUFBRSxFQUFFLEdBQUdILFlBQVksSUFBTVIsMkVBQXFCQTtJQUMzRCxNQUFNLENBQUNZLGtCQUFrQkMsb0JBQW9CLEdBQUdULCtDQUFRQSxDQUFDLElBQU1VLHdCQUF3Qko7SUFDdkZULGdEQUFTQSxDQUFDO1FBQ04sTUFBTWMsWUFBWTtZQUNkSixHQUFHLFlBQVksQ0FBQyxHQUFHSyxVQUFZSCxvQkFBb0IsQ0FBQ0QsbUJBQXFCOzJCQUFJQTsyQkFBcUJFLHdCQUF3QkU7cUJBQVM7WUFDbklMLEdBQUcsY0FBYyxDQUFDLEdBQUdLLFVBQVlILG9CQUFvQixDQUFDRCxtQkFBcUJBLGlCQUFpQkssTUFBTSxDQUFDLENBQUNDLGtCQUFvQkYsUUFBUUcsSUFBSSxDQUFDLENBQUNDLFNBQVdBLFdBQVdGLGdCQUFnQkUsTUFBTTtTQUNyTDtRQUNELE9BQU8sSUFBTUwsVUFBVU0sT0FBTyxDQUFDLENBQUNDLE1BQVFBO0lBQzVDLEdBQUc7UUFBQ1g7S0FBRztJQUNQLE1BQU1ZLHVCQUF1QkMsWUFBWVo7SUFDekNYLGdEQUFTQSxDQUFDO1FBQ04sSUFBSSxDQUFDc0Isc0JBQ0Q7UUFDSixNQUFNRSxrQkFBa0IsSUFBSWhCLElBQUlHO1FBQ2hDLE1BQU1jLGtCQUFrQixJQUFJakIsSUFBSWMscUJBQXFCTixNQUFNLENBQUMsQ0FBQ1Usa0JBQW9CLENBQUNGLGdCQUFnQkcsR0FBRyxDQUFDRDtRQUN0R0QsZ0JBQWdCTCxPQUFPLENBQUMsQ0FBQ1EsVUFBWUEsUUFBUUMsT0FBTztJQUN4RCxHQUFHO1FBQUNQO1FBQXNCWDtLQUFpQjtJQUMzQyx1REFBdUQ7SUFDdkRYLGdEQUFTQSxDQUFDLElBQU0sSUFBTVcsaUJBQWlCUyxPQUFPLENBQUMsQ0FBQ1EsVUFBWUEsUUFBUUMsT0FBTyxLQUFLLEVBQUU7SUFDbEYsT0FBTzVCLDhDQUFPQSxDQUFDLElBQU07ZUFDZFU7ZUFDQU4sU0FBU1csTUFBTSxDQUFDLENBQUMsRUFBRWMsSUFBSSxFQUFFO2dCQUN4QixJQUFJbkIsaUJBQWlCTyxJQUFJLENBQUMsQ0FBQ0Qsa0JBQW9CQSxnQkFBZ0JhLElBQUksS0FBS0EsT0FBTztvQkFDM0UsSUFBSSxDQUFDeEIsU0FBU3FCLEdBQUcsQ0FBQ0csT0FBTzt3QkFDckJ4QixTQUFTeUIsR0FBRyxDQUFDRDt3QkFDYkUsUUFBUUMsSUFBSSxDQUFDLENBQUMsRUFBRUgsS0FBSyw2REFBNkQsRUFBRUEsS0FBSyw4QkFBOEIsQ0FBQztvQkFDNUg7b0JBQ0EsT0FBTztnQkFDWDtnQkFDQSxPQUFPO1lBQ1g7U0FDSCxFQUFFO1FBQUNuQjtRQUFrQk47UUFBVUM7S0FBUztBQUM3QztBQUNBLFNBQVNDLFlBQVkyQixFQUFFO0lBQ25CLE1BQU1DLE1BQU1qQyw2Q0FBTUEsQ0FBQ2tDO0lBQ25CLElBQUlELElBQUlFLE9BQU8sS0FBS0QsV0FBVztRQUMzQkQsSUFBSUUsT0FBTyxHQUFHO1lBQUVDLE9BQU9KO1FBQUs7SUFDaEM7SUFDQSxPQUFPQyxJQUFJRSxPQUFPLENBQUNDLEtBQUs7QUFDNUI7QUFDQSxTQUFTZixZQUFZZ0IsS0FBSztJQUN0QixNQUFNSixNQUFNakMsNkNBQU1BLENBQUNrQztJQUNuQnBDLGdEQUFTQSxDQUFDO1FBQ05tQyxJQUFJRSxPQUFPLEdBQUdFO0lBQ2xCO0lBQ0EsT0FBT0osSUFBSUUsT0FBTztBQUN0QjtBQUNBLFNBQVN4Qix3QkFBd0JFLE9BQU87SUFDcEMsT0FBT0EsUUFBUUMsTUFBTSxDQUFDbkIsd0dBQStCQSxFQUFFMkMsR0FBRyxDQUFDLENBQUNyQixTQUFXLElBQUlyQiw4RkFBcUJBLENBQUM7WUFBRXFCO1FBQU87QUFDOUcsRUFDQSxxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC13YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL3VzZVN0YW5kYXJkV2FsbGV0QWRhcHRlcnMuanM/ZmQwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlV2FsbGV0LCBTdGFuZGFyZFdhbGxldEFkYXB0ZXIgfSBmcm9tICdAc29sYW5hL3dhbGxldC1zdGFuZGFyZC13YWxsZXQtYWRhcHRlci1iYXNlJztcbmltcG9ydCB7IERFUFJFQ0FURURfZ2V0V2FsbGV0cyB9IGZyb20gJ0B3YWxsZXQtc3RhbmRhcmQvYXBwJztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFuZGFyZFdhbGxldEFkYXB0ZXJzKGFkYXB0ZXJzKSB7XG4gICAgY29uc3Qgd2FybmluZ3MgPSB1c2VDb25zdGFudCgoKSA9PiBuZXcgU2V0KCkpO1xuICAgIGNvbnN0IHsgZ2V0LCBvbiB9ID0gdXNlQ29uc3RhbnQoKCkgPT4gREVQUkVDQVRFRF9nZXRXYWxsZXRzKCkpO1xuICAgIGNvbnN0IFtzdGFuZGFyZEFkYXB0ZXJzLCBzZXRTdGFuZGFyZEFkYXB0ZXJzXSA9IHVzZVN0YXRlKCgpID0+IHdyYXBXYWxsZXRzV2l0aEFkYXB0ZXJzKGdldCgpKSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gW1xuICAgICAgICAgICAgb24oJ3JlZ2lzdGVyJywgKC4uLndhbGxldHMpID0+IHNldFN0YW5kYXJkQWRhcHRlcnMoKHN0YW5kYXJkQWRhcHRlcnMpID0+IFsuLi5zdGFuZGFyZEFkYXB0ZXJzLCAuLi53cmFwV2FsbGV0c1dpdGhBZGFwdGVycyh3YWxsZXRzKV0pKSxcbiAgICAgICAgICAgIG9uKCd1bnJlZ2lzdGVyJywgKC4uLndhbGxldHMpID0+IHNldFN0YW5kYXJkQWRhcHRlcnMoKHN0YW5kYXJkQWRhcHRlcnMpID0+IHN0YW5kYXJkQWRhcHRlcnMuZmlsdGVyKChzdGFuZGFyZEFkYXB0ZXIpID0+IHdhbGxldHMuc29tZSgod2FsbGV0KSA9PiB3YWxsZXQgPT09IHN0YW5kYXJkQWRhcHRlci53YWxsZXQpKSkpLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmZvckVhY2goKG9mZikgPT4gb2ZmKCkpO1xuICAgIH0sIFtvbl0pO1xuICAgIGNvbnN0IHByZXZTdGFuZGFyZEFkYXB0ZXJzID0gdXNlUHJldmlvdXMoc3RhbmRhcmRBZGFwdGVycyk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFwcmV2U3RhbmRhcmRBZGFwdGVycylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY3VycmVudEFkYXB0ZXJzID0gbmV3IFNldChzdGFuZGFyZEFkYXB0ZXJzKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZEFkYXB0ZXJzID0gbmV3IFNldChwcmV2U3RhbmRhcmRBZGFwdGVycy5maWx0ZXIoKHByZXZpb3VzQWRhcHRlcikgPT4gIWN1cnJlbnRBZGFwdGVycy5oYXMocHJldmlvdXNBZGFwdGVyKSkpO1xuICAgICAgICByZW1vdmVkQWRhcHRlcnMuZm9yRWFjaCgoYWRhcHRlcikgPT4gYWRhcHRlci5kZXN0cm95KCkpO1xuICAgIH0sIFtwcmV2U3RhbmRhcmRBZGFwdGVycywgc3RhbmRhcmRBZGFwdGVyc10pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4gc3RhbmRhcmRBZGFwdGVycy5mb3JFYWNoKChhZGFwdGVyKSA9PiBhZGFwdGVyLmRlc3Ryb3koKSksIFtdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiBbXG4gICAgICAgIC4uLnN0YW5kYXJkQWRhcHRlcnMsXG4gICAgICAgIC4uLmFkYXB0ZXJzLmZpbHRlcigoeyBuYW1lIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFuZGFyZEFkYXB0ZXJzLnNvbWUoKHN0YW5kYXJkQWRhcHRlcikgPT4gc3RhbmRhcmRBZGFwdGVyLm5hbWUgPT09IG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3YXJuaW5ncy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gd2FzIHJlZ2lzdGVyZWQgYXMgYSBTdGFuZGFyZCBXYWxsZXQuIFRoZSBXYWxsZXQgQWRhcHRlciBmb3IgJHtuYW1lfSBjYW4gYmUgcmVtb3ZlZCBmcm9tIHlvdXIgYXBwLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSksXG4gICAgXSwgW3N0YW5kYXJkQWRhcHRlcnMsIGFkYXB0ZXJzLCB3YXJuaW5nc10pO1xufVxuZnVuY3Rpb24gdXNlQ29uc3RhbnQoZm4pIHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgICBpZiAocmVmLmN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHsgdmFsdWU6IGZuKCkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50LnZhbHVlO1xufVxuZnVuY3Rpb24gdXNlUHJldmlvdXMoc3RhdGUpIHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZWYuY3VycmVudCA9IHN0YXRlO1xuICAgIH0pO1xuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cbmZ1bmN0aW9uIHdyYXBXYWxsZXRzV2l0aEFkYXB0ZXJzKHdhbGxldHMpIHtcbiAgICByZXR1cm4gd2FsbGV0cy5maWx0ZXIoaXNXYWxsZXRBZGFwdGVyQ29tcGF0aWJsZVdhbGxldCkubWFwKCh3YWxsZXQpID0+IG5ldyBTdGFuZGFyZFdhbGxldEFkYXB0ZXIoeyB3YWxsZXQgfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlU3RhbmRhcmRXYWxsZXRBZGFwdGVycy5qcy5tYXAiXSwibmFtZXMiOlsiaXNXYWxsZXRBZGFwdGVyQ29tcGF0aWJsZVdhbGxldCIsIlN0YW5kYXJkV2FsbGV0QWRhcHRlciIsIkRFUFJFQ0FURURfZ2V0V2FsbGV0cyIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZVN0YW5kYXJkV2FsbGV0QWRhcHRlcnMiLCJhZGFwdGVycyIsIndhcm5pbmdzIiwidXNlQ29uc3RhbnQiLCJTZXQiLCJnZXQiLCJvbiIsInN0YW5kYXJkQWRhcHRlcnMiLCJzZXRTdGFuZGFyZEFkYXB0ZXJzIiwid3JhcFdhbGxldHNXaXRoQWRhcHRlcnMiLCJsaXN0ZW5lcnMiLCJ3YWxsZXRzIiwiZmlsdGVyIiwic3RhbmRhcmRBZGFwdGVyIiwic29tZSIsIndhbGxldCIsImZvckVhY2giLCJvZmYiLCJwcmV2U3RhbmRhcmRBZGFwdGVycyIsInVzZVByZXZpb3VzIiwiY3VycmVudEFkYXB0ZXJzIiwicmVtb3ZlZEFkYXB0ZXJzIiwicHJldmlvdXNBZGFwdGVyIiwiaGFzIiwiYWRhcHRlciIsImRlc3Ryb3kiLCJuYW1lIiwiYWRkIiwiY29uc29sZSIsIndhcm4iLCJmbiIsInJlZiIsInVuZGVmaW5lZCIsImN1cnJlbnQiLCJ2YWx1ZSIsInN0YXRlIiwibWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n/** connects noble-curves to noble-hashes */ function getHash(hash) {\n    return {\n        hash\n    };\n}\n/** @deprecated use new `weierstrass()` and `ecdsa()` methods */ function createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_0__.weierstrass)({\n            ...curveDef,\n            hash: hash\n        });\n    return {\n        ...create(defHash),\n        create\n    };\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Q0FHQyxHQUNELG9FQUFvRSxHQUNaO0FBQ3hELDBDQUEwQyxHQUNuQyxTQUFTQyxRQUFRQyxJQUFJO0lBQ3hCLE9BQU87UUFBRUE7SUFBSztBQUNsQjtBQUNBLDhEQUE4RCxHQUN2RCxTQUFTQyxZQUFZQyxRQUFRLEVBQUVDLE9BQU87SUFDekMsTUFBTUMsU0FBUyxDQUFDSixPQUFTRixxRUFBV0EsQ0FBQztZQUFFLEdBQUdJLFFBQVE7WUFBRUYsTUFBTUE7UUFBSztJQUMvRCxPQUFPO1FBQUUsR0FBR0ksT0FBT0QsUUFBUTtRQUFFQztJQUFPO0FBQ3hDLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzPzU3YWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXRpZXMgZm9yIHNob3J0IHdlaWVyc3RyYXNzIGN1cnZlcywgY29tYmluZWQgd2l0aCBub2JsZS1oYXNoZXMuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHdlaWVyc3RyYXNzIH0gZnJvbSBcIi4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanNcIjtcbi8qKiBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIHsgaGFzaCB9O1xufVxuLyoqIEBkZXByZWNhdGVkIHVzZSBuZXcgYHdlaWVyc3RyYXNzKClgIGFuZCBgZWNkc2EoKWAgbWV0aG9kcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIGhhc2g6IGhhc2ggfSk7XG4gICAgcmV0dXJuIHsgLi4uY3JlYXRlKGRlZkhhc2gpLCBjcmVhdGUgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIndlaWVyc3RyYXNzIiwiZ2V0SGFzaCIsImhhc2giLCJjcmVhdGVDdXJ2ZSIsImN1cnZlRGVmIiwiZGVmSGFzaCIsImNyZWF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _createCurveFields: () => (/* binding */ _createCurveFields),\n/* harmony export */   mulEndoUnsafe: () => (/* binding */ mulEndoUnsafe),\n/* harmony export */   negateCt: () => (/* binding */ negateCt),\n/* harmony export */   normalizeZ: () => (/* binding */ normalizeZ),\n/* harmony export */   pippenger: () => (/* binding */ pippenger),\n/* harmony export */   precomputeMSMUnsafe: () => (/* binding */ precomputeMSMUnsafe),\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */ function normalizeZ(c, points) {\n    const invertedZs = (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch)(c.Fp, points.map((p)=>p.Z));\n    return points.map((p, i)=>c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return {\n        windows,\n        windowSize,\n        mask,\n        maxNumber,\n        shiftBy\n    };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return {\n        nextN,\n        offset,\n        isZero,\n        isNeg,\n        isNegF,\n        offsetF\n    };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points)) throw new Error(\"array expected\");\n    points.forEach((p, i)=>{\n        if (!(p instanceof c)) throw new Error(\"invalid point at index \" + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars)) throw new Error(\"array of scalars expected\");\n    scalars.forEach((s, i)=>{\n        if (!field.isValid(s)) throw new Error(\"invalid scalar at index \" + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n) throw new Error(\"invalid wNAF\");\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */ class wNAF {\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits){\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while(n > _0n){\n            if (n & _1n) p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n     * - 𝑊 is the window size\n     * - 𝑛 is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */ precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for(let window = 0; window < windows; window++){\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for(let i = 1; i < windowSize; i++){\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */ wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n)) throw new Error(\"invalid scalar\");\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for(let window = 0; window < wo.windows; window++){\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            } else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return {\n            p,\n            f\n        };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */ wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for(let window = 0; window < wo.windows; window++){\n            if (n === _0n) break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                continue;\n            } else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === \"function\") comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1) return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */ function mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while(k1 > _0n || k2 > _0n){\n        if (k1 & _1n) p1 = p1.add(acc);\n        if (k2 & _1n) p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return {\n        p1,\n        p2\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */ function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength) throw new Error(\"arrays of points and scalars must have equal length\");\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12) windowSize = wbits - 3;\n    else if (wbits > 4) windowSize = wbits - 2;\n    else if (wbits > 0) windowSize = 2;\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for(let i = lastBits; i >= 0; i -= windowSize){\n        buckets.fill(zero);\n        for(let j = 0; j < slength; j++){\n            const scalar = scalars[j];\n            const wbits = Number(scalar >> BigInt(i) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar × 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 × 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */ validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(windowSize);\n    const tables = points.map((p)=>{\n        const res = [];\n        for(let i = 0, acc = p; i < tableSize; i++){\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars)=>{\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length) throw new Error(\"array of scalars must be smaller than array of points\");\n        let res = zero;\n        for(let i = 0; i < chunks; i++){\n            // No need to double if accumulator is still zero.\n            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for(let j = 0; j < scalars.length; j++){\n                const n = scalars[j];\n                const curr = Number(n >> shiftBy & MASK);\n                if (!curr) continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\n// TODO: remove\n/** @deprecated */ function validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n}\nfunction createField(order, field) {\n    if (field) {\n        if (field.ORDER !== order) throw new Error(\"Field.ORDER must match order: Fp == p, Fn == n\");\n        (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(field);\n        return field;\n    } else {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(order);\n    }\n}\n/** Validates CURVE opts and creates fields */ function _createCurveFields(type, CURVE, curveOpts = {}) {\n    if (!CURVE || typeof CURVE !== \"object\") throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of [\n        \"p\",\n        \"n\",\n        \"h\"\n    ]){\n        const val = CURVE[p];\n        if (!(typeof val === \"bigint\" && val > _0n)) throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp);\n    const Fn = createField(CURVE.n, curveOpts.Fn);\n    const _b = type === \"weierstrass\" ? \"b\" : \"d\";\n    const params = [\n        \"Gx\",\n        \"Gy\",\n        \"a\",\n        _b\n    ];\n    for (const p of params){\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p])) throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    return {\n        Fp,\n        Fn\n    };\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNELG9FQUFvRSxHQUNOO0FBQ2M7QUFDNUUsTUFBTU8sTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ1osU0FBU0UsU0FBU0MsU0FBUyxFQUFFQyxJQUFJO0lBQ3BDLE1BQU1DLE1BQU1ELEtBQUtFLE1BQU07SUFDdkIsT0FBT0gsWUFBWUUsTUFBTUQ7QUFDN0I7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNHLFdBQVdDLENBQUMsRUFBRUMsTUFBTTtJQUNoQyxNQUFNQyxhQUFhZCwwREFBYUEsQ0FBQ1ksRUFBRUcsRUFBRSxFQUFFRixPQUFPRyxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsQ0FBQztJQUM1RCxPQUFPTCxPQUFPRyxHQUFHLENBQUMsQ0FBQ0MsR0FBR0UsSUFBTVAsRUFBRVEsVUFBVSxDQUFDSCxFQUFFSSxRQUFRLENBQUNQLFVBQVUsQ0FBQ0ssRUFBRTtBQUNyRTtBQUNBLFNBQVNHLFVBQVVDLENBQUMsRUFBRUMsSUFBSTtJQUN0QixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0gsTUFBTUEsS0FBSyxLQUFLQSxJQUFJQyxNQUMxQyxNQUFNLElBQUlHLE1BQU0sdUNBQXVDSCxPQUFPLGNBQWNEO0FBQ3BGO0FBQ0EsU0FBU0ssVUFBVUwsQ0FBQyxFQUFFTSxVQUFVO0lBQzVCUCxVQUFVQyxHQUFHTTtJQUNiLE1BQU1DLFVBQVVDLEtBQUtDLElBQUksQ0FBQ0gsYUFBYU4sS0FBSyxHQUFHLHVDQUF1QztJQUN0RixNQUFNVSxhQUFhLEtBQU1WLENBQUFBLElBQUksSUFBSSx5Q0FBeUM7SUFDMUUsTUFBTVcsWUFBWSxLQUFLWCxHQUFHLFVBQVU7SUFDcEMsTUFBTVksT0FBT3RDLGtEQUFPQSxDQUFDMEIs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QUkvRyxNQUFNLENBQUMsZUFBZSxFQUFFOEcsS0FBSyxhQUFhLENBQUM7SUFDekQsS0FBSyxNQUFNeEgsS0FBSztRQUFDO1FBQUs7UUFBSztLQUFJLENBQUU7UUFDN0IsTUFBTTJILE1BQU1GLEtBQUssQ0FBQ3pILEVBQUU7UUFDcEIsSUFBSSxDQUFFLFFBQU8ySCxRQUFRLFlBQVlBLE1BQU16SSxHQUFFLEdBQ3JDLE1BQU0sSUFBSXdCLE1BQU0sQ0FBQyxNQUFNLEVBQUVWLEVBQUUsd0JBQXdCLENBQUM7SUFDNUQ7SUFDQSxNQUFNRixLQUFLdUgsWUFBWUksTUFBTXpILENBQUMsRUFBRTBILFVBQVU1SCxFQUFFO0lBQzVDLE1BQU13RCxLQUFLK0QsWUFBWUksTUFBTXBHLENBQUMsRUFBRXFHLFVBQVVwRSxFQUFFO0lBQzVDLE1BQU1zRSxLQUFLSixTQUFTLGdCQUFnQixNQUFNO0lBQzFDLE1BQU1LLFNBQVM7UUFBQztRQUFNO1FBQU07UUFBS0Q7S0FBRztJQUNwQyxLQUFLLE1BQU01SCxLQUFLNkgsT0FBUTtRQUNwQixhQUFhO1FBQ2IsSUFBSSxDQUFDL0gsR0FBRzJDLE9BQU8sQ0FBQ2dGLEtBQUssQ0FBQ3pILEVBQUUsR0FDcEIsTUFBTSxJQUFJVSxNQUFNLENBQUMsTUFBTSxFQUFFVixFQUFFLHdDQUF3QyxDQUFDO0lBQzVFO0lBQ0EsT0FBTztRQUFFRjtRQUFJd0Q7SUFBRztBQUNwQixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanM/OTU4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1ldGhvZHMgZm9yIGVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIGJ5IHNjYWxhcnMuXG4gKiBDb250YWlucyB3TkFGLCBwaXBwZW5nZXIuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGJpdExlbiwgYml0TWFzaywgdmFsaWRhdGVPYmplY3QgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IEZpZWxkLCBGcEludmVydEJhdGNoLCBuTGVuZ3RoLCB2YWxpZGF0ZUZpZWxkIH0gZnJvbSBcIi4vbW9kdWxhci5qc1wiO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZUN0KGNvbmRpdGlvbiwgaXRlbSkge1xuICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG4vKipcbiAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVooYywgcG9pbnRzKSB7XG4gICAgY29uc3QgaW52ZXJ0ZWRacyA9IEZwSW52ZXJ0QmF0Y2goYy5GcCwgcG9pbnRzLm1hcCgocCkgPT4gcC5aKSk7XG4gICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IGMuZnJvbUFmZmluZShwLnRvQWZmaW5lKGludmVydGVkWnNbaV0pKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVcoVywgYml0cykge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoVykgfHwgVyA8PSAwIHx8IFcgPiBiaXRzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgd2luZG93IHNpemUsIGV4cGVjdGVkIFsxLi4nICsgYml0cyArICddLCBnb3QgVz0nICsgVyk7XG59XG5mdW5jdGlvbiBjYWxjV09wdHMoVywgc2NhbGFyQml0cykge1xuICAgIHZhbGlkYXRlVyhXLCBzY2FsYXJCaXRzKTtcbiAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKHNjYWxhckJpdHMgLyBXKSArIDE7IC8vIFc9OCAzMy4gTm90IDMyLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIFc9OCAxMjguIE5vdCAyNTYsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXOyAvLyBXPTggMjU2XG4gICAgY29uc3QgbWFzayA9IGJpdE1hc2soVyk7IC8vIFc9OCAyNTUgPT0gbWFzayAwYjExMTExMTExXG4gICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTsgLy8gVz04IDhcbiAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplLCBtYXNrLCBtYXhOdW1iZXIsIHNoaWZ0QnkgfTtcbn1cbmZ1bmN0aW9uIGNhbGNPZmZzZXRzKG4sIHdpbmRvdywgd09wdHMpIHtcbiAgICBjb25zdCB7IHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9ID0gd09wdHM7XG4gICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTsgLy8gZXh0cmFjdCBXIGJpdHMuXG4gICAgbGV0IG5leHROID0gbiA+PiBzaGlmdEJ5OyAvLyBzaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgIC8vIFdoYXQgYWN0dWFsbHkgaGFwcGVucyBoZXJlOlxuICAgIC8vIGNvbnN0IGhpZ2hlc3RCaXQgPSBOdW1iZXIobWFzayBeIChtYXNrID4+IDFuKSk7XG4gICAgLy8gbGV0IHdiaXRzMiA9IHdiaXRzIC0gMTsgLy8gc2tpcCB6ZXJvXG4gICAgLy8gaWYgKHdiaXRzMiAmIGhpZ2hlc3RCaXQpIHsgd2JpdHMyIF49IE51bWJlcihtYXNrKTsgLy8gKH4pO1xuICAgIC8vIHNwbGl0IGlmIGJpdHMgPiBtYXg6ICsyMjQgPT4gMjU2LTMyXG4gICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAvLyB3ZSBza2lwIHplcm8sIHdoaWNoIG1lYW5zIGluc3RlYWQgb2YgYD49IHNpemUtMWAsIHdlIGRvIGA+IHNpemVgXG4gICAgICAgIHdiaXRzIC09IG1heE51bWJlcjsgLy8gLTMyLCBjYW4gYmUgbWF4TnVtYmVyIC0gd2JpdHMsIGJ1dCB0aGVuIHdlIG5lZWQgdG8gc2V0IGlzTmVnIGhlcmUuXG4gICAgICAgIG5leHROICs9IF8xbjsgLy8gKzI1NiAoY2FycnkpXG4gICAgfVxuICAgIGNvbnN0IG9mZnNldFN0YXJ0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRTdGFydCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3QgaXNaZXJvID0gd2JpdHMgPT09IDA7IC8vIGlzIGN1cnJlbnQgd2luZG93IHNsaWNlIGEgMD9cbiAgICBjb25zdCBpc05lZyA9IHdiaXRzIDwgMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgbmVnYXRpdmU/XG4gICAgY29uc3QgaXNOZWdGID0gd2luZG93ICUgMiAhPT0gMDsgLy8gZmFrZSByYW5kb20gc3RhdGVtZW50IGZvciBub2lzZVxuICAgIGNvbnN0IG9mZnNldEYgPSBvZmZzZXRTdGFydDsgLy8gZmFrZSBvZmZzZXQgZm9yIG5vaXNlXG4gICAgcmV0dXJuIHsgbmV4dE4sIG9mZnNldCwgaXNaZXJvLCBpc05lZywgaXNOZWdGLCBvZmZzZXRGIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBleHBlY3RlZCcpO1xuICAgIHBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBjKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCBhdCBpbmRleCAnICsgaSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBleHBlY3RlZCcpO1xuICAgIHNjYWxhcnMuZm9yRWFjaCgocywgaSkgPT4ge1xuICAgICAgICBpZiAoIWZpZWxkLmlzVmFsaWQocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyIGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbi8vIFNpbmNlIHBvaW50cyBpbiBkaWZmZXJlbnQgZ3JvdXBzIGNhbm5vdCBiZSBlcXVhbCAoZGlmZmVyZW50IG9iamVjdCBjb25zdHJ1Y3RvciksXG4vLyB3ZSBjYW4gaGF2ZSBzaW5nbGUgcGxhY2UgdG8gc3RvcmUgcHJlY29tcHV0ZXMuXG4vLyBBbGxvd3MgdG8gbWFrZSBwb2ludHMgZnJvemVuIC8gaW1tdXRhYmxlLlxuY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBwb2ludFdpbmRvd1NpemVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldFcoUCkge1xuICAgIC8vIFRvIGRpc2FibGUgcHJlY29tcHV0ZXM6XG4gICAgLy8gcmV0dXJuIDE7XG4gICAgcmV0dXJuIHBvaW50V2luZG93U2l6ZXMuZ2V0KFApIHx8IDE7XG59XG5mdW5jdGlvbiBhc3NlcnQwKG4pIHtcbiAgICBpZiAobiAhPT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgd05BRicpO1xufVxuLyoqXG4gKiBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4gKiBUYWJsZSBnZW5lcmF0aW9uIHRha2VzICoqMzBNQiBvZiByYW0gYW5kIDEwbXMgb24gaGlnaC1lbmQgQ1BVKiosXG4gKiBidXQgbWF5IHRha2UgbXVjaCBsb25nZXIgb24gc2xvdyBkZXZpY2VzLiBBY3R1YWwgZ2VuZXJhdGlvbiB3aWxsIGhhcHBlbiBvblxuICogZmlyc3QgY2FsbCBvZiBgbXVsdGlwbHkoKWAuIEJ5IGRlZmF1bHQsIGBCQVNFYCBwb2ludCBpcyBwcmVjb21wdXRlZC5cbiAqXG4gKiBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbiAqIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuICogLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4gKiAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4gKiAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4gKiAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbiAqIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbiAqIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4gKlxuICogQHRvZG8gUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LlxuICogVGhpcyB3b3VsZCBhbGxvdyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyB3TkFGIHtcbiAgICAvLyBQYXJhbWV0cml6ZWQgd2l0aCBhIGdpdmVuIFBvaW50IGNsYXNzIChub3QgaW5kaXZpZHVhbCBwb2ludClcbiAgICBjb25zdHJ1Y3RvcihQb2ludCwgYml0cykge1xuICAgICAgICB0aGlzLkJBU0UgPSBQb2ludC5CQVNFO1xuICAgICAgICB0aGlzLlpFUk8gPSBQb2ludC5aRVJPO1xuICAgICAgICB0aGlzLkZuID0gUG9pbnQuRm47XG4gICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgfVxuICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgIF91bnNhZmVMYWRkZXIoZWxtLCBuLCBwID0gdGhpcy5aRVJPKSB7XG4gICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICogQHBhcmFtIHBvaW50IFBvaW50IGluc3RhbmNlXG4gICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICovXG4gICAgcHJlY29tcHV0ZVdpbmRvdyhwb2ludCwgVykge1xuICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IGNhbGNXT3B0cyhXLCB0aGlzLmJpdHMpO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgbGV0IHAgPSBwb2ludDtcbiAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgIC8vIGk9MSwgYmMgd2Ugc2tpcCAwXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgKiBNb3JlIGNvbXBhY3QgaW1wbGVtZW50YXRpb246XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1zZWNwMjU2azEvYmxvYi80N2NiMTY2OWI2ZTUwNmFkNjZiMzVmZTdkNzYxMzJhZTk3NDY1ZGEyL2luZGV4LnRzI0w1MDItTDU0MVxuICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgKi9cbiAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgIC8vIFNjYWxhciBzaG91bGQgYmUgc21hbGxlciB0aGFuIGZpZWxkIG9yZGVyXG4gICAgICAgIGlmICghdGhpcy5Gbi5pc1ZhbGlkKG4pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNjYWxhcicpO1xuICAgICAgICAvLyBBY2N1bXVsYXRvcnNcbiAgICAgICAgbGV0IHAgPSB0aGlzLlpFUk87XG4gICAgICAgIGxldCBmID0gdGhpcy5CQVNFO1xuICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICBjb25zdCB3byA9IGNhbGNXT3B0cyhXLCB0aGlzLmJpdHMpO1xuICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3by53aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgLy8gKG4gPT09IF8wbikgaXMgaGFuZGxlZCBhbmQgbm90IGVhcmx5LWV4aXRlZC4gaXNFdmVuIGFuZCBvZmZzZXRGIGFyZSB1c2VkIGZvciBub2lzZVxuICAgICAgICAgICAgY29uc3QgeyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnLCBpc05lZ0YsIG9mZnNldEYgfSA9IGNhbGNPZmZzZXRzKG4sIHdpbmRvdywgd28pO1xuICAgICAgICAgICAgbiA9IG5leHROO1xuICAgICAgICAgICAgaWYgKGlzWmVybykge1xuICAgICAgICAgICAgICAgIC8vIGJpdHMgYXJlIDA6IGFkZCBnYXJiYWdlIHRvIGZha2UgcG9pbnRcbiAgICAgICAgICAgICAgICAvLyBJbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXk6IGFkZCByYW5kb20gXCJub2lzZVwiIHBvaW50IHRvIGYuXG4gICAgICAgICAgICAgICAgZiA9IGYuYWRkKG5lZ2F0ZUN0KGlzTmVnRiwgcHJlY29tcHV0ZXNbb2Zmc2V0Rl0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGJpdHMgYXJlIDE6IGFkZCB0byByZXN1bHQgcG9pbnRcbiAgICAgICAgICAgICAgICBwID0gcC5hZGQobmVnYXRlQ3QoaXNOZWcsIHByZWNvbXB1dGVzW29mZnNldF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQwKG4pO1xuICAgICAgICAvLyBSZXR1cm4gYm90aCByZWFsIGFuZCBmYWtlIHBvaW50czogSklUIHdvbid0IGVsaW1pbmF0ZSBmLlxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBlYyB1bnNhZmUgKG5vbiBjb25zdC10aW1lKSBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAqIEBwYXJhbSBhY2MgYWNjdW11bGF0b3IgcG9pbnQgdG8gYWRkIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvblxuICAgICAqIEByZXR1cm5zIHBvaW50XG4gICAgICovXG4gICAgd05BRlVuc2FmZShXLCBwcmVjb21wdXRlcywgbiwgYWNjID0gdGhpcy5aRVJPKSB7XG4gICAgICAgIGNvbnN0IHdvID0gY2FsY1dPcHRzKFcsIHRoaXMuYml0cyk7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdvLndpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBFYXJseS1leGl0LCBza2lwIDAgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHsgbmV4dE4sIG9mZnNldCwgaXNaZXJvLCBpc05lZyB9ID0gY2FsY09mZnNldHMobiwgd2luZG93LCB3byk7XG4gICAgICAgICAgICBuID0gbmV4dE47XG4gICAgICAgICAgICBpZiAoaXNaZXJvKSB7XG4gICAgICAgICAgICAgICAgLy8gV2luZG93IGJpdHMgYXJlIDA6IHNraXAgcHJvY2Vzc2luZy5cbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHByZWNvbXB1dGVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgYWNjID0gYWNjLmFkZChpc05lZyA/IGl0ZW0ubmVnYXRlKCkgOiBpdGVtKTsgLy8gUmUtdXNpbmcgYWNjIGFsbG93cyB0byBzYXZlIGFkZHMgaW4gTVNNXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0MChuKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgZ2V0UHJlY29tcHV0ZXMoVywgcG9pbnQsIHRyYW5zZm9ybSkge1xuICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgbGV0IGNvbXAgPSBwb2ludFByZWNvbXB1dGVzLmdldChwb2ludCk7XG4gICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhwb2ludCwgVyk7XG4gICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIERvaW5nIHRyYW5zZm9ybSBvdXRzaWRlIG9mIGlmIGJyaW5ncyAxNSUgcGVyZiBoaXRcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IHRyYW5zZm9ybShjb21wKTtcbiAgICAgICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLnNldChwb2ludCwgY29tcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfVxuICAgIGNhY2hlZChwb2ludCwgc2NhbGFyLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgY29uc3QgVyA9IGdldFcocG9pbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgcG9pbnQsIHRyYW5zZm9ybSksIHNjYWxhcik7XG4gICAgfVxuICAgIHVuc2FmZShwb2ludCwgc2NhbGFyLCB0cmFuc2Zvcm0sIHByZXYpIHtcbiAgICAgICAgY29uc3QgVyA9IGdldFcocG9pbnQpO1xuICAgICAgICBpZiAoVyA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91bnNhZmVMYWRkZXIocG9pbnQsIHNjYWxhciwgcHJldik7IC8vIEZvciBXPTEgbGFkZGVyIGlzIH54MiBmYXN0ZXJcbiAgICAgICAgcmV0dXJuIHRoaXMud05BRlVuc2FmZShXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIHBvaW50LCB0cmFuc2Zvcm0pLCBzY2FsYXIsIHByZXYpO1xuICAgIH1cbiAgICAvLyBXZSBjYWxjdWxhdGUgcHJlY29tcHV0ZXMgZm9yIGVsbGlwdGljIGN1cnZlIHBvaW50IG11bHRpcGxpY2F0aW9uXG4gICAgLy8gdXNpbmcgd2luZG93ZWQgbWV0aG9kLiBUaGlzIHNwZWNpZmllcyB3aW5kb3cgc2l6ZSBhbmRcbiAgICAvLyBzdG9yZXMgcHJlY29tcHV0ZWQgdmFsdWVzLiBVc3VhbGx5IG9ubHkgYmFzZSBwb2ludCB3b3VsZCBiZSBwcmVjb21wdXRlZC5cbiAgICBjcmVhdGVDYWNoZShQLCBXKSB7XG4gICAgICAgIHZhbGlkYXRlVyhXLCB0aGlzLmJpdHMpO1xuICAgICAgICBwb2ludFdpbmRvd1NpemVzLnNldChQLCBXKTtcbiAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUoUCk7XG4gICAgfVxuICAgIGhhc0NhY2hlKGVsbSkge1xuICAgICAgICByZXR1cm4gZ2V0VyhlbG0pICE9PSAxO1xuICAgIH1cbn1cbi8qKlxuICogRW5kb21vcnBoaXNtLXNwZWNpZmljIG11bHRpcGxpY2F0aW9uIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAqIENvc3Q6IDEyOCBkYmwsIDAtMjU2IGFkZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWxFbmRvVW5zYWZlKFBvaW50LCBwb2ludCwgazEsIGsyKSB7XG4gICAgbGV0IGFjYyA9IHBvaW50O1xuICAgIGxldCBwMSA9IFBvaW50LlpFUk87XG4gICAgbGV0IHAyID0gUG9pbnQuWkVSTztcbiAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgcDEgPSBwMS5hZGQoYWNjKTtcbiAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgcDIgPSBwMi5hZGQoYWNjKTtcbiAgICAgICAgYWNjID0gYWNjLmRvdWJsZSgpO1xuICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICBrMiA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4geyBwMSwgcDIgfTtcbn1cbi8qKlxuICogUGlwcGVuZ2VyIGFsZ29yaXRobSBmb3IgbXVsdGktc2NhbGFyIG11bHRpcGxpY2F0aW9uIChNU00sIFBhICsgUWIgKyBSYyArIC4uLikuXG4gKiAzMHggZmFzdGVyIHZzIG5haXZlIGFkZGl0aW9uIG9uIEw9NDA5NiwgMTB4IGZhc3RlciB0aGFuIHByZWNvbXB1dGVzLlxuICogRm9yIE49MjU0Yml0LCBMPTEsIGl0IGRvZXM6IDEwMjQgQUREICsgMjU0IERCTC4gRm9yIEw9NTogMTUzNiBBREQgKyAyNTQgREJMLlxuICogQWxnb3JpdGhtaWNhbGx5IGNvbnN0YW50LXRpbWUgKGZvciBzYW1lIEwpLCBldmVuIHdoZW4gMSBwb2ludCArIHNjYWxhciwgb3Igd2hlbiBzY2FsYXIgPSAwLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcGFyYW0gc2NhbGFycyBhcnJheSBvZiBMIHNjYWxhcnMgKGFrYSBzZWNyZXQga2V5cyAvIGJpZ2ludHMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaXBwZW5nZXIoYywgZmllbGROLCBwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAvLyBJZiB3ZSBzcGxpdCBzY2FsYXJzIGJ5IHNvbWUgd2luZG93IChsZXQncyBzYXkgOCBiaXRzKSwgZXZlcnkgY2h1bmsgd2lsbCBvbmx5XG4gICAgLy8gdGFrZSAyNTYgYnVja2V0cyBldmVuIGlmIHRoZXJlIGFyZSA0MDk2IHNjYWxhcnMsIGFsc28gcmUtdXNlcyBkb3VibGUuXG4gICAgLy8gVE9ETzpcbiAgICAvLyAtIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMjQvNzUwLnBkZlxuICAgIC8vIC0gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzEwMjg3XG4gICAgLy8gMCBpcyBhY2NlcHRlZCBpbiBzY2FsYXJzXG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgICBjb25zdCBwbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCBzbGVuZ3RoID0gc2NhbGFycy5sZW5ndGg7XG4gICAgaWYgKHBsZW5ndGggIT09IHNsZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXlzIG9mIHBvaW50cyBhbmQgc2NhbGFycyBtdXN0IGhhdmUgZXF1YWwgbGVuZ3RoJyk7XG4gICAgLy8gaWYgKHBsZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignYXJyYXkgbXVzdCBiZSBvZiBsZW5ndGggPj0gMicpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3Qgd2JpdHMgPSBiaXRMZW4oQmlnSW50KHBsZW5ndGgpKTtcbiAgICBsZXQgd2luZG93U2l6ZSA9IDE7IC8vIGJpdHNcbiAgICBpZiAod2JpdHMgPiAxMilcbiAgICAgICAgd2luZG93U2l6ZSA9IHdiaXRzIC0gMztcbiAgICBlbHNlIGlmICh3Yml0cyA+IDQpXG4gICAgICAgIHdpbmRvd1NpemUgPSB3Yml0cyAtIDI7XG4gICAgZWxzZSBpZiAod2JpdHMgPiAwKVxuICAgICAgICB3aW5kb3dTaXplID0gMjtcbiAgICBjb25zdCBNQVNLID0gYml0TWFzayh3aW5kb3dTaXplKTtcbiAgICBjb25zdCBidWNrZXRzID0gbmV3IEFycmF5KE51bWJlcihNQVNLKSArIDEpLmZpbGwoemVybyk7IC8vICsxIGZvciB6ZXJvIGFycmF5XG4gICAgY29uc3QgbGFzdEJpdHMgPSBNYXRoLmZsb29yKChmaWVsZE4uQklUUyAtIDEpIC8gd2luZG93U2l6ZSkgKiB3aW5kb3dTaXplO1xuICAgIGxldCBzdW0gPSB6ZXJvO1xuICAgIGZvciAobGV0IGkgPSBsYXN0Qml0czsgaSA+PSAwOyBpIC09IHdpbmRvd1NpemUpIHtcbiAgICAgICAgYnVja2V0cy5maWxsKHplcm8pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGFyID0gc2NhbGFyc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IHdiaXRzID0gTnVtYmVyKChzY2FsYXIgPj4gQmlnSW50KGkpKSAmIE1BU0spO1xuICAgICAgICAgICAgYnVja2V0c1t3Yml0c10gPSBidWNrZXRzW3diaXRzXS5hZGQocG9pbnRzW2pdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzSSA9IHplcm87IC8vIG5vdCB1c2luZyB0aGlzIHdpbGwgZG8gc21hbGwgc3BlZWQtdXAsIGJ1dCB3aWxsIGxvc2UgY3RcbiAgICAgICAgLy8gU2tpcCBmaXJzdCBidWNrZXQsIGJlY2F1c2UgaXQgaXMgemVyb1xuICAgICAgICBmb3IgKGxldCBqID0gYnVja2V0cy5sZW5ndGggLSAxLCBzdW1JID0gemVybzsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgc3VtSSA9IHN1bUkuYWRkKGJ1Y2tldHNbal0pO1xuICAgICAgICAgICAgcmVzSSA9IHJlc0kuYWRkKHN1bUkpO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHN1bS5hZGQocmVzSSk7XG4gICAgICAgIGlmIChpICE9PSAwKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgc3VtID0gc3VtLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuLyoqXG4gKiBQcmVjb21wdXRlZCBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHJldHVybnMgZnVuY3Rpb24gd2hpY2ggbXVsdGlwbGllcyBwb2ludHMgd2l0aCBzY2FhcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWNvbXB1dGVNU01VbnNhZmUoYywgZmllbGROLCBwb2ludHMsIHdpbmRvd1NpemUpIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtYW5jZSBBbmFseXNpcyBvZiBXaW5kb3ctYmFzZWQgUHJlY29tcHV0YXRpb25cbiAgICAgKlxuICAgICAqIEJhc2UgQ2FzZSAoMjU2LWJpdCBzY2FsYXIsIDgtYml0IHdpbmRvdyk6XG4gICAgICogLSBTdGFuZGFyZCBwcmVjb21wdXRhdGlvbiByZXF1aXJlczpcbiAgICAgKiAgIC0gMzEgYWRkaXRpb25zIHBlciBzY2FsYXIgw5cgMjU2IHNjYWxhcnMgPSA3LDkzNiBvcHNcbiAgICAgKiAgIC0gUGx1cyAyNTUgc3VtbWFyeSBhZGRpdGlvbnMgPSA4LDE5MSB0b3RhbCBvcHNcbiAgICAgKiAgIE5vdGU6IFN1bW1hcnkgYWRkaXRpb25zIGNhbiBiZSBvcHRpbWl6ZWQgdmlhIGFjY3VtdWxhdG9yXG4gICAgICpcbiAgICAgKiBDaHVua2VkIFByZWNvbXB1dGF0aW9uIEFuYWx5c2lzOlxuICAgICAqIC0gVXNpbmcgMzIgY2h1bmtzIHJlcXVpcmVzOlxuICAgICAqICAgLSAyNTUgYWRkaXRpb25zIHBlciBjaHVua1xuICAgICAqICAgLSAyNTYgZG91YmxpbmdzXG4gICAgICogICAtIFRvdGFsOiAoMjU1IMOXIDMyKSArIDI1NiA9IDgsNDE2IG9wc1xuICAgICAqXG4gICAgICogTWVtb3J5IFVzYWdlIENvbXBhcmlzb246XG4gICAgICogV2luZG93IFNpemUgfCBTdGFuZGFyZCBQb2ludHMgfCBDaHVua2VkIFBvaW50c1xuICAgICAqIC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgICAgNC1iaXQgICB8ICAgICA1MjAgICAgICAgICB8ICAgICAgMTVcbiAgICAgKiAgICAgOC1iaXQgICB8ICAgIDQsMjI0ICAgICAgICB8ICAgICAyNTVcbiAgICAgKiAgICAxMC1iaXQgICB8ICAgMTMsODI0ICAgICAgICB8ICAgMSwwMjNcbiAgICAgKiAgICAxNi1iaXQgICB8ICA1NTcsMDU2ICAgICAgICB8ICA2NSw1MzVcbiAgICAgKlxuICAgICAqIEtleSBBZHZhbnRhZ2VzOlxuICAgICAqIDEuIEVuYWJsZXMgbGFyZ2VyIHdpbmRvdyBzaXplcyBkdWUgdG8gcmVkdWNlZCBtZW1vcnkgb3ZlcmhlYWRcbiAgICAgKiAyLiBNb3JlIGVmZmljaWVudCBmb3Igc21hbGxlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgIC0gMTYgY2h1bmtzOiAoMTYgw5cgMjU1KSArIDI1NiA9IDQsMzM2IG9wc1xuICAgICAqICAgIC0gfjJ4IGZhc3RlciB0aGFuIHN0YW5kYXJkIDgsMTkxIG9wc1xuICAgICAqXG4gICAgICogTGltaXRhdGlvbnM6XG4gICAgICogLSBOb3Qgc3VpdGFibGUgZm9yIHBsYWluIHByZWNvbXB1dGVzIChyZXF1aXJlcyAyNTYgY29uc3RhbnQgZG91YmxpbmdzKVxuICAgICAqIC0gUGVyZm9ybWFuY2UgZGVncmFkZXMgd2l0aCBsYXJnZXIgc2NhbGFyIGNvdW50czpcbiAgICAgKiAgIC0gT3B0aW1hbCBmb3IgfjI1NiBzY2FsYXJzXG4gICAgICogICAtIExlc3MgZWZmaWNpZW50IGZvciA0MDk2KyBzY2FsYXJzIChQaXBwZW5nZXIgcHJlZmVycmVkKVxuICAgICAqL1xuICAgIHZhbGlkYXRlVyh3aW5kb3dTaXplLCBmaWVsZE4uQklUUyk7XG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICBjb25zdCB6ZXJvID0gYy5aRVJPO1xuICAgIGNvbnN0IHRhYmxlU2l6ZSA9IDIgKiogd2luZG93U2l6ZSAtIDE7IC8vIHRhYmxlIHNpemUgKHdpdGhvdXQgemVybylcbiAgICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwoZmllbGROLkJJVFMgLyB3aW5kb3dTaXplKTsgLy8gY2h1bmtzIG9mIGl0ZW1cbiAgICBjb25zdCBNQVNLID0gYml0TWFzayh3aW5kb3dTaXplKTtcbiAgICBjb25zdCB0YWJsZXMgPSBwb2ludHMubWFwKChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYWNjID0gcDsgaSA8IHRhYmxlU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICByZXMucHVzaChhY2MpO1xuICAgICAgICAgICAgYWNjID0gYWNjLmFkZChwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIHJldHVybiAoc2NhbGFycykgPT4ge1xuICAgICAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgICAgICAgaWYgKHNjYWxhcnMubGVuZ3RoID4gcG9pbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBtdXN0IGJlIHNtYWxsZXIgdGhhbiBhcnJheSBvZiBwb2ludHMnKTtcbiAgICAgICAgbGV0IHJlcyA9IHplcm87XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gZG91YmxlIGlmIGFjY3VtdWxhdG9yIGlzIHN0aWxsIHplcm8uXG4gICAgICAgICAgICBpZiAocmVzICE9PSB6ZXJvKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2luZG93U2l6ZTsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuZG91YmxlKCk7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KGNodW5rcyAqIHdpbmRvd1NpemUgLSAoaSArIDEpICogd2luZG93U2l6ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNjYWxhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gc2NhbGFyc1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyID0gTnVtYmVyKChuID4+IHNoaWZ0QnkpICYgTUFTSyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB6ZXJvIHNjYWxhcnMgY2h1bmtzXG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmFkZCh0YWJsZXNbal1bY3VyciAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG4vLyBUT0RPOiByZW1vdmVcbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWVsZChvcmRlciwgZmllbGQpIHtcbiAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgaWYgKGZpZWxkLk9SREVSICE9PSBvcmRlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQuT1JERVIgbXVzdCBtYXRjaCBvcmRlcjogRnAgPT0gcCwgRm4gPT0gbicpO1xuICAgICAgICB2YWxpZGF0ZUZpZWxkKGZpZWxkKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEZpZWxkKG9yZGVyKTtcbiAgICB9XG59XG4vKiogVmFsaWRhdGVzIENVUlZFIG9wdHMgYW5kIGNyZWF0ZXMgZmllbGRzICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZUN1cnZlRmllbGRzKHR5cGUsIENVUlZFLCBjdXJ2ZU9wdHMgPSB7fSkge1xuICAgIGlmICghQ1VSVkUgfHwgdHlwZW9mIENVUlZFICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCB2YWxpZCAke3R5cGV9IENVUlZFIG9iamVjdGApO1xuICAgIGZvciAoY29uc3QgcCBvZiBbJ3AnLCAnbicsICdoJ10pIHtcbiAgICAgICAgY29uc3QgdmFsID0gQ1VSVkVbcF07XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnICYmIHZhbCA+IF8wbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENVUlZFLiR7cH0gbXVzdCBiZSBwb3NpdGl2ZSBiaWdpbnRgKTtcbiAgICB9XG4gICAgY29uc3QgRnAgPSBjcmVhdGVGaWVsZChDVVJWRS5wLCBjdXJ2ZU9wdHMuRnApO1xuICAgIGNvbnN0IEZuID0gY3JlYXRlRmllbGQoQ1VSVkUubiwgY3VydmVPcHRzLkZuKTtcbiAgICBjb25zdCBfYiA9IHR5cGUgPT09ICd3ZWllcnN0cmFzcycgPyAnYicgOiAnZCc7XG4gICAgY29uc3QgcGFyYW1zID0gWydHeCcsICdHeScsICdhJywgX2JdO1xuICAgIGZvciAoY29uc3QgcCBvZiBwYXJhbXMpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoIUZwLmlzVmFsaWQoQ1VSVkVbcF0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDVVJWRS4ke3B9IG11c3QgYmUgdmFsaWQgZmllbGQgZWxlbWVudCBvZiBDVVJWRS5GcGApO1xuICAgIH1cbiAgICByZXR1cm4geyBGcCwgRm4gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJiaXRMZW4iLCJiaXRNYXNrIiwidmFsaWRhdGVPYmplY3QiLCJGaWVsZCIsIkZwSW52ZXJ0QmF0Y2giLCJuTGVuZ3RoIiwidmFsaWRhdGVGaWVsZCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIm5lZ2F0ZUN0IiwiY29uZGl0aW9uIiwiaXRlbSIsIm5lZyIsIm5lZ2F0ZSIsIm5vcm1hbGl6ZVoiLCJjIiwicG9pbnRzIiwiaW52ZXJ0ZWRacyIsIkZwIiwibWFwIiwicCIsIloiLCJpIiwiZnJvbUFmZmluZSIsInRvQWZmaW5lIiwidmFsaWRhdGVXIiwiVyIsImJpdHMiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJjYWxjV09wdHMiLCJzY2FsYXJCaXRzIiwid2luZG93cyIsIk1hdGgiLCJjZWlsIiwid2luZG93U2l6ZSIsIm1heE51bWJlciIsIm1hc2siLCJzaGlmdEJ5IiwiY2FsY09mZnNldHMiLCJuIiwid2luZG93Iiwid09wdHMiLCJ3Yml0cyIsIm5leHROIiwib2Zmc2V0U3RhcnQiLCJvZmZzZXQiLCJhYnMiLCJpc1plcm8iLCJpc05lZyIsImlzTmVnRiIsIm9mZnNldEYiLCJ2YWxpZGF0ZU1TTVBvaW50cyIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJ2YWxpZGF0ZU1TTVNjYWxhcnMiLCJzY2FsYXJzIiwiZmllbGQiLCJzIiwiaXNWYWxpZCIsInBvaW50UHJlY29tcHV0ZXMiLCJXZWFrTWFwIiwicG9pbnRXaW5kb3dTaXplcyIsImdldFciLCJQIiwiZ2V0IiwiYXNzZXJ0MCIsIndOQUYiLCJjb25zdHJ1Y3RvciIsIlBvaW50IiwiQkFTRSIsIlpFUk8iLCJGbiIsIl91bnNhZmVMYWRkZXIiLCJlbG0iLCJkIiwiYWRkIiwiZG91YmxlIiwicHJlY29tcHV0ZVdpbmRvdyIsInBvaW50IiwiYmFzZSIsInB1c2giLCJwcmVjb21wdXRlcyIsImYiLCJ3byIsIndOQUZVbnNhZmUiLCJhY2MiLCJnZXRQcmVjb21wdXRlcyIsInRyYW5zZm9ybSIsImNvbXAiLCJzZXQiLCJjYWNoZWQiLCJzY2FsYXIiLCJ1bnNhZmUiLCJwcmV2IiwiY3JlYXRlQ2FjaGUiLCJkZWxldGUiLCJoYXNDYWNoZSIsIm11bEVuZG9VbnNhZmUiLCJrMSIsImsyIiwicDEiLCJwMiIsInBpcHBlbmdlciIsImZpZWxkTiIsInBsZW5ndGgiLCJsZW5ndGgiLCJzbGVuZ3RoIiwiemVybyIsIk1BU0siLCJidWNrZXRzIiwiZmlsbCIsImxhc3RCaXRzIiwiZmxvb3IiLCJCSVRTIiwic3VtIiwiaiIsInJlc0kiLCJzdW1JIiwicHJlY29tcHV0ZU1TTVVuc2FmZSIsInRhYmxlU2l6ZSIsImNodW5rcyIsInRhYmxlcyIsInJlcyIsImN1cnIiLCJ2YWxpZGF0ZUJhc2ljIiwiY3VydmUiLCJoIiwiR3giLCJHeSIsIm5CaXRMZW5ndGgiLCJuQnl0ZUxlbmd0aCIsIk9iamVjdCIsImZyZWV6ZSIsIk9SREVSIiwiY3JlYXRlRmllbGQiLCJvcmRlciIsIl9jcmVhdGVDdXJ2ZUZpZWxkcyIsInR5cGUiLCJDVVJWRSIsImN1cnZlT3B0cyIsInZhbCIsIl9iIiwicGFyYW1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/edwards.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/edwards.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PrimeEdwardsPoint: () => (/* binding */ PrimeEdwardsPoint),\n/* harmony export */   eddsa: () => (/* binding */ eddsa),\n/* harmony export */   edwards: () => (/* binding */ edwards),\n/* harmony export */   twistedEdwards: () => (/* binding */ twistedEdwards)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\nfunction isEdValidXY(Fp, CURVE, x, y) {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n}\nfunction edwards(CURVE, curveOpts = {}) {\n    const { Fp, Fn } = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__._createCurveFields)(\"edwards\", CURVE, curveOpts);\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._validateObject)(curveOpts, {}, {\n        uvRatio: \"function\"\n    });\n    // Important:\n    // There are some places where Fp.BYTES is used instead of nByteLength.\n    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n    // TODO: test and find curves which behave otherwise.\n    const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;\n    const modP = (n)=>Fp.create(n); // Function overrides\n    // sqrt(u/v)\n    const uvRatio = curveOpts.uvRatio || ((u, v)=>{\n        try {\n            return {\n                isValid: true,\n                value: Fp.sqrt(Fp.div(u, v))\n            };\n        } catch (e) {\n            return {\n                isValid: false,\n                value: _0n\n            };\n        }\n    });\n    // Validate whether the passed curve params are valid.\n    // equation ax² + y² = 1 + dx²y² should work for generator point.\n    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy)) throw new Error(\"bad curve params: generator point\");\n    /**\n     * Asserts coordinate is valid: 0 <= n < MASK.\n     * Coordinates >= Fp.ORDER are allowed for zip215.\n     */ function acoord(title, n, banZero = false) {\n        const min = banZero ? _1n : _0n;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange)(\"coordinate \" + title, n, min, MASK);\n        return n;\n    }\n    function aextpoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ExtendedPoint expected\");\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoized)((p, iz)=>{\n        const { X, Y, Z } = p;\n        const is0 = p.is0();\n        if (iz == null) iz = is0 ? _8n : Fp.inv(Z); // 8 was chosen arbitrarily\n        const x = modP(X * iz);\n        const y = modP(Y * iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0) return {\n            x: _0n,\n            y: _1n\n        };\n        if (zz !== _1n) throw new Error(\"invZ was invalid\");\n        return {\n            x,\n            y\n        };\n    });\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoized)((p)=>{\n        const { a, d } = CURVE;\n        if (p.is0()) throw new Error(\"bad point: ZERO\"); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        const { X, Y, Z, T } = p;\n        const X2 = modP(X * X); // X²\n        const Y2 = modP(Y * Y); // Y²\n        const Z2 = modP(Z * Z); // Z²\n        const Z4 = modP(Z2 * Z2); // Z⁴\n        const aX2 = modP(X2 * a); // aX²\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right) throw new Error(\"bad point: equation left != right (1)\");\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT) throw new Error(\"bad point: equation left != right (2)\");\n        return true;\n    });\n    // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(X, Y, Z, T){\n            this.X = acoord(\"x\", X);\n            this.Y = acoord(\"y\", Y);\n            this.Z = acoord(\"z\", Z, true);\n            this.T = acoord(\"t\", T);\n            Object.freeze(this);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        // TODO: remove\n        get ex() {\n            return this.X;\n        }\n        get ey() {\n            return this.Y;\n        }\n        get ez() {\n            return this.Z;\n        }\n        get et() {\n            return this.T;\n        }\n        static normalizeZ(points) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, points);\n        }\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.pippenger)(Point, Fn, points, scalars);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        static fromAffine(p) {\n            if (p instanceof Point) throw new Error(\"extended point not allowed\");\n            const { x, y } = p || {};\n            acoord(\"x\", x);\n            acoord(\"y\", y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy) this.multiply(_2n); // random number\n            return this;\n        }\n        // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            aextpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            aextpoint(other);\n            const { a, d } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n            const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const n = scalar;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange)(\"scalar\", n, _1n, CURVE_ORDER); // 1 <= scalar < L\n            const { p, f } = wnaf.cached(this, n, (p)=>(0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, p));\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, [\n                p,\n                f\n            ])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n        multiplyUnsafe(scalar, acc = Point.ZERO) {\n            const n = scalar;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange)(\"scalar\", n, _0n, CURVE_ORDER); // 0 <= scalar < L\n            if (n === _0n) return Point.ZERO;\n            if (this.is0() || n === _1n) return this;\n            return wnaf.unsafe(this, n, (p)=>(0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, p), acc);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafe(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        clearCofactor() {\n            if (cofactor === _1n) return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        static fromBytes(bytes, zip215 = false) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.abytes)(bytes);\n            return Point.fromHex(bytes, zip215);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"pointHex\", hex, len); // copy hex to a new array\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abool)(\"zip215\", zip215);\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(normed);\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange)(\"pointHex.y\", y, _0n, max);\n            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y² - 1\n            const v = modP(d * y2 - a); // v = d y² + 1.\n            let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n            if (!isValid) throw new Error(\"Point.fromHex: invalid y coordinate\");\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd) // if x=0 and x_0 = 1, fail\n            throw new Error(\"Point.fromHex: x=0 and x_0=1\");\n            if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({\n                x,\n                y\n            });\n        }\n        toBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE)(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        /** @deprecated use `toBytes` */ toRawBytes() {\n            return this.toBytes();\n        }\n        toHex() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes());\n        }\n        toString() {\n            return `<Point ${this.is0() ? \"ZERO\" : this.toHex()}>`;\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // fields\n    Point.Fp = Fp;\n    Point.Fn = Fn;\n    const wnaf = new _curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF(Point, Fn.BYTES * 8); // Fn.BITS?\n    return Point;\n}\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */ class PrimeEdwardsPoint {\n    constructor(ep){\n        this.ep = ep;\n    }\n    // Static methods that must be implemented by subclasses\n    static fromBytes(_bytes) {\n        throw new Error(\"fromBytes must be implemented by subclass\");\n    }\n    static fromHex(_hex) {\n        throw new Error(\"fromHex must be implemented by subclass\");\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    // Common implementations\n    clearCofactor() {\n        // no-op for prime-order groups\n        return this;\n    }\n    assertValidity() {\n        this.ep.assertValidity();\n    }\n    toAffine(invertedZ) {\n        return this.ep.toAffine(invertedZ);\n    }\n    /** @deprecated use `toBytes` */ toRawBytes() {\n        return this.toBytes();\n    }\n    toHex() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    isTorsionFree() {\n        return true;\n    }\n    isSmallOrder() {\n        return false;\n    }\n    add(other) {\n        this.assertSame(other);\n        return this.init(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        this.assertSame(other);\n        return this.init(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return this.init(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return this.init(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return this.init(this.ep.double());\n    }\n    negate() {\n        return this.init(this.ep.negate());\n    }\n    precompute(windowSize, isLazy) {\n        return this.init(this.ep.precompute(windowSize, isLazy));\n    }\n}\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */ function eddsa(Point, cHash, eddsaOpts) {\n    if (typeof cHash !== \"function\") throw new Error('\"hash\" function param is required');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._validateObject)(eddsaOpts, {}, {\n        adjustScalarBytes: \"function\",\n        randomBytes: \"function\",\n        domain: \"function\",\n        prehash: \"function\",\n        mapToCurve: \"function\"\n    });\n    const { prehash } = eddsaOpts;\n    const { BASE: G, Fp, Fn } = Point;\n    const CURVE_ORDER = Fn.ORDER;\n    const randomBytes_ = eddsaOpts.randomBytes || _utils_js__WEBPACK_IMPORTED_MODULE_2__.randomBytes;\n    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes)=>bytes); // NOOP\n    const domain = eddsaOpts.domain || ((data, ctx, phflag)=>{\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abool)(\"phflag\", phflag);\n        if (ctx.length || phflag) throw new Error(\"Contexts/pre-hash are not supported\");\n        return data;\n    }); // NOOP\n    function modN(a) {\n        return Fn.create(a);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        // Not using Fn.fromBytes: hash can be 2*Fn.BYTES\n        return modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(hash));\n    }\n    // Get the hashed private scalar per RFC8032 5.1.5\n    function getPrivateScalar(key) {\n        const len = Fp.BYTES;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"hashed private key\", cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        return {\n            head,\n            prefix,\n            scalar\n        };\n    }\n    /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */ function getExtendedPublicKey(secretKey) {\n        const { head, prefix, scalar } = getPrivateScalar(secretKey);\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toBytes();\n        return {\n            head,\n            prefix,\n            scalar,\n            point,\n            pointBytes\n        };\n    }\n    /** Calculates EdDSA pub key. RFC8032 5.1.5. */ function getPublicKey(secretKey) {\n        return getExtendedPublicKey(secretKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n        const msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(...msgs);\n        return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"context\", context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */ function sign(msg, secretKey, options = {}) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"message\", msg);\n        if (prehash) msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange)(\"signature.s\", s, _0n, CURVE_ORDER); // 0 <= s < l\n        const L = Fp.BYTES;\n        const res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(R, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE)(s, L));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"result\", res, L * 2); // 64-byte signature\n    }\n    // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n    const verifyOpts = {\n        zip215: true\n    };\n    /**\n     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n     * An extended group equation is checked.\n     */ function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"signature\", sig, 2 * len); // An extended group equation is checked.\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"message\", msg);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"publicKey\", publicKey, len);\n        if (zip215 !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abool)(\"zip215\", zip215);\n        if (prehash) msg = prehash(msg); // for ed25519ph, etc\n        const s = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(sig.slice(len, 2 * len));\n        let A, R, SB;\n        try {\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        } catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder()) return false;\n        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // Extended group equation\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().is0();\n    }\n    G.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const size = Fp.BYTES;\n    const lengths = {\n        secret: size,\n        public: size,\n        signature: 2 * size,\n        seed: size\n    };\n    function randomSecretKey(seed = randomBytes_(lengths.seed)) {\n        return seed;\n    }\n    const utils = {\n        getExtendedPublicKey,\n        /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */ randomSecretKey,\n        isValidSecretKey,\n        isValidPublicKey,\n        randomPrivateKey: randomSecretKey,\n        /**\n         * Converts ed public key to x public key. Uses formula:\n         * - ed25519:\n         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n         * - ed448:\n         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n         *\n         * There is NO `fromMontgomery`:\n         * - There are 2 valid ed25519 points for every x25519, with flipped coordinate\n         * - Sometimes there are 0 valid ed25519 points, because x25519 *additionally*\n         *   accepts inputs on the quadratic twist, which can't be moved to ed25519\n         */ toMontgomery (publicKey) {\n            const { y } = Point.fromBytes(publicKey);\n            const is25519 = size === 32;\n            if (!is25519 && size !== 57) throw new Error(\"only defined for 25519 and 448\");\n            const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n            return Fp.toBytes(u);\n        },\n        toMontgomeryPriv (privateKey) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.abytes)(privateKey, size);\n            const hashed = cHash(privateKey.subarray(0, size));\n            return adjustScalarBytes(hashed).subarray(0, size);\n        },\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        }\n    };\n    function keygen(seed) {\n        const secretKey = utils.randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: getPublicKey(secretKey)\n        };\n    }\n    function isValidSecretKey(key) {\n        try {\n            return !!Fn.fromBytes(key, false);\n        } catch (error) {\n            return false;\n        }\n    }\n    function isValidPublicKey(key, zip215) {\n        try {\n            return !!Point.fromBytes(key, zip215);\n        } catch (error) {\n            return false;\n        }\n    }\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        sign,\n        verify,\n        utils,\n        Point,\n        info: {\n            type: \"edwards\",\n            lengths\n        }\n    });\n}\n// TODO: remove\nfunction _eddsa_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        d: c.d,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy\n    };\n    const Fp = c.Fp;\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.Field)(CURVE.n, c.nBitLength, true);\n    const curveOpts = {\n        Fp,\n        Fn,\n        uvRatio: c.uvRatio\n    };\n    const eddsaOpts = {\n        randomBytes: c.randomBytes,\n        adjustScalarBytes: c.adjustScalarBytes,\n        domain: c.domain,\n        prehash: c.prehash,\n        mapToCurve: c.mapToCurve\n    };\n    return {\n        CURVE,\n        curveOpts,\n        hash: c.hash,\n        eddsaOpts\n    };\n}\n// TODO: remove\nfunction _eddsa_new_output_to_legacy(c, eddsa) {\n    const legacy = Object.assign({}, eddsa, {\n        ExtendedPoint: eddsa.Point,\n        CURVE: c\n    });\n    return legacy;\n}\n// TODO: remove. Use eddsa\nfunction twistedEdwards(c) {\n    const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);\n    const Point = edwards(CURVE, curveOpts);\n    const EDDSA = eddsa(Point, hash, eddsaOpts);\n    return _eddsa_new_output_to_legacy(c, EDDSA);\n} //# sourceMappingURL=edwards.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9lZHdhcmRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDRCxvRUFBb0UsR0FDbUc7QUFDekY7QUFDekM7QUFDckMscUVBQXFFO0FBQ3JFLGtCQUFrQjtBQUNsQixNQUFNZ0IsTUFBTUMsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLElBQUlFLE1BQU1GLE9BQU8sSUFBSUcsTUFBTUgsT0FBTztBQUN0RSxTQUFTSSxZQUFZQyxFQUFFLEVBQUVDLEtBQUssRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hDLE1BQU1DLEtBQUtKLEdBQUdLLEdBQUcsQ0FBQ0g7SUFDbEIsTUFBTUksS0FBS04sR0FBR0ssR0FBRyxDQUFDRjtJQUNsQixNQUFNSSxPQUFPUCxHQUFHUSxHQUFHLENBQUNSLEdBQUdTLEdBQUcsQ0FBQ1IsTUFBTVMsQ0FBQyxFQUFFTixLQUFLRTtJQUN6QyxNQUFNSyxRQUFRWCxHQUFHUSxHQUFHLENBQUNSLEdBQUdZLEdBQUcsRUFBRVosR0FBR1MsR0FBRyxDQUFDUixNQUFNWSxDQUFDLEVBQUViLEdBQUdTLEdBQUcsQ0FBQ0wsSUFBSUU7SUFDeEQsT0FBT04sR0FBR2MsR0FBRyxDQUFDUCxNQUFNSTtBQUN4QjtBQUNPLFNBQVNJLFFBQVFkLEtBQUssRUFBRWUsWUFBWSxDQUFDLENBQUM7SUFDekMsTUFBTSxFQUFFaEIsRUFBRSxFQUFFaUIsRUFBRSxFQUFFLEdBQUc1Qiw2REFBa0JBLENBQUMsV0FBV1ksT0FBT2U7SUFDeEQsTUFBTSxFQUFFRSxHQUFHQyxRQUFRLEVBQUVDLEdBQUdDLFdBQVcsRUFBRSxHQUFHcEI7SUFDeEN2QiwwREFBZUEsQ0FBQ3NDLFdBQVcsQ0FBQyxHQUFHO1FBQUVNLFNBQVM7SUFBVztJQUNyRCxhQUFhO0lBQ2IsdUVBQXVFO0lBQ3ZFLDZFQUE2RTtJQUM3RSxxREFB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QU87UUFDbEJDLFlBQVk0RCxFQUFFNUQsVUFBVTtJQUM1QjtJQUNBLE9BQU87UUFBRXJKO1FBQU9lO1FBQVc2SSxNQUFNcUQsRUFBRXJELElBQUk7UUFBRVg7SUFBVTtBQUN2RDtBQUNBLGVBQWU7QUFDZixTQUFTa0UsNEJBQTRCRixDQUFDLEVBQUVsRSxLQUFLO0lBQ3pDLE1BQU1xRSxTQUFTdEosT0FBT3VKLE1BQU0sQ0FBQyxDQUFDLEdBQUd0RSxPQUFPO1FBQUV1RSxlQUFldkUsTUFBTXJHLEtBQUs7UUFBRTFDLE9BQU9pTjtJQUFFO0lBQy9FLE9BQU9HO0FBQ1g7QUFDQSwwQkFBMEI7QUFDbkIsU0FBU0csZUFBZU4sQ0FBQztJQUM1QixNQUFNLEVBQUVqTixLQUFLLEVBQUVlLFNBQVMsRUFBRTZJLElBQUksRUFBRVgsU0FBUyxFQUFFLEdBQUcrRCwwQkFBMEJDO0lBQ3hFLE1BQU12SyxRQUFRNUIsUUFBUWQsT0FBT2U7SUFDN0IsTUFBTXlNLFFBQVF6RSxNQUFNckcsT0FBT2tILE1BQU1YO0lBQ2pDLE9BQU9rRSw0QkFBNEJGLEdBQUdPO0FBQzFDLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9lZHdhcmRzLmpzPzlhZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUd2lzdGVkIEVkd2FyZHMgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrIuXG4gKiBGb3IgZGVzaWduIHJhdGlvbmFsZSBvZiB0eXBlcyAvIGV4cG9ydHMsIHNlZSB3ZWllcnN0cmFzcyBtb2R1bGUgZG9jdW1lbnRhdGlvbi5cbiAqIFVudHdpc3RlZCBFZHdhcmRzIGN1cnZlcyBleGlzdCwgYnV0IHRoZXkgYXJlbid0IHVzZWQgaW4gcmVhbC13b3JsZCBwcm90b2NvbHMuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IF92YWxpZGF0ZU9iamVjdCwgYWJvb2wsIGFieXRlcywgYUluUmFuZ2UsIGJ5dGVzVG9IZXgsIGJ5dGVzVG9OdW1iZXJMRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBtZW1vaXplZCwgbnVtYmVyVG9CeXRlc0xFLCByYW5kb21CeXRlcywgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IF9jcmVhdGVDdXJ2ZUZpZWxkcywgbm9ybWFsaXplWiwgcGlwcGVuZ2VyLCB3TkFGLCB9IGZyb20gXCIuL2N1cnZlLmpzXCI7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gXCIuL21vZHVsYXIuanNcIjtcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfOG4gPSBCaWdJbnQoOCk7XG5mdW5jdGlvbiBpc0VkVmFsaWRYWShGcCwgQ1VSVkUsIHgsIHkpIHtcbiAgICBjb25zdCB4MiA9IEZwLnNxcih4KTtcbiAgICBjb25zdCB5MiA9IEZwLnNxcih5KTtcbiAgICBjb25zdCBsZWZ0ID0gRnAuYWRkKEZwLm11bChDVVJWRS5hLCB4MiksIHkyKTtcbiAgICBjb25zdCByaWdodCA9IEZwLmFkZChGcC5PTkUsIEZwLm11bChDVVJWRS5kLCBGcC5tdWwoeDIsIHkyKSkpO1xuICAgIHJldHVybiBGcC5lcWwobGVmdCwgcmlnaHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVkd2FyZHMoQ1VSVkUsIGN1cnZlT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBGcCwgRm4gfSA9IF9jcmVhdGVDdXJ2ZUZpZWxkcygnZWR3YXJkcycsIENVUlZFLCBjdXJ2ZU9wdHMpO1xuICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBfdmFsaWRhdGVPYmplY3QoY3VydmVPcHRzLCB7fSwgeyB1dlJhdGlvOiAnZnVuY3Rpb24nIH0pO1xuICAgIC8vIEltcG9ydGFudDpcbiAgICAvLyBUaGVyZSBhcmUgc29tZSBwbGFjZXMgd2hlcmUgRnAuQllURVMgaXMgdXNlZCBpbnN0ZWFkIG9mIG5CeXRlTGVuZ3RoLlxuICAgIC8vIFNvIGZhciwgZXZlcnl0aGluZyBoYXMgYmVlbiB0ZXN0ZWQgd2l0aCBjdXJ2ZXMgb2YgRnAuQllURVMgPT0gbkJ5dGVMZW5ndGguXG4gICAgLy8gVE9ETzogdGVzdCBhbmQgZmluZCBjdXJ2ZXMgd2hpY2ggYmVoYXZlIG90aGVyd2lzZS5cbiAgICBjb25zdCBNQVNLID0gXzJuIDw8IChCaWdJbnQoRm4uQllURVMgKiA4KSAtIF8xbik7XG4gICAgY29uc3QgbW9kUCA9IChuKSA9PiBGcC5jcmVhdGUobik7IC8vIEZ1bmN0aW9uIG92ZXJyaWRlc1xuICAgIC8vIHNxcnQodS92KVxuICAgIGNvbnN0IHV2UmF0aW8gPSBjdXJ2ZU9wdHMudXZSYXRpbyB8fFxuICAgICAgICAoKHUsIHYpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSwgdmFsdWU6IEZwLnNxcnQoRnAuZGl2KHUsIHYpKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgdmFsdWU6IF8wbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBlcXVhdGlvbiBheMKyICsgecKyID0gMSArIGR4wrJ5wrIgc2hvdWxkIHdvcmsgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICBpZiAoIWlzRWRWYWxpZFhZKEZwLCBDVVJWRSwgQ1VSVkUuR3gsIENVUlZFLkd5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY3VydmUgcGFyYW1zOiBnZW5lcmF0b3IgcG9pbnQnKTtcbiAgICAvKipcbiAgICAgKiBBc3NlcnRzIGNvb3JkaW5hdGUgaXMgdmFsaWQ6IDAgPD0gbiA8IE1BU0suXG4gICAgICogQ29vcmRpbmF0ZXMgPj0gRnAuT1JERVIgYXJlIGFsbG93ZWQgZm9yIHppcDIxNS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhY29vcmQodGl0bGUsIG4sIGJhblplcm8gPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBtaW4gPSBiYW5aZXJvID8gXzFuIDogXzBuO1xuICAgICAgICBhSW5SYW5nZSgnY29vcmRpbmF0ZSAnICsgdGl0bGUsIG4sIG1pbiwgTUFTSyk7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZXh0cG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuZGVkUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLy8gQ29udmVydHMgRXh0ZW5kZWQgcG9pbnQgdG8gZGVmYXVsdCAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgY29uc3QgdG9BZmZpbmVNZW1vID0gbWVtb2l6ZWQoKHAsIGl6KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgWCwgWSwgWiB9ID0gcDtcbiAgICAgICAgY29uc3QgaXMwID0gcC5pczAoKTtcbiAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICBpeiA9IGlzMCA/IF84biA6IEZwLmludihaKTsgLy8gOCB3YXMgY2hvc2VuIGFyYml0cmFyaWx5XG4gICAgICAgIGNvbnN0IHggPSBtb2RQKFggKiBpeik7XG4gICAgICAgIGNvbnN0IHkgPSBtb2RQKFkgKiBpeik7XG4gICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKFosIGl6KTtcbiAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgIHJldHVybiB7IHg6IF8wbiwgeTogXzFuIH07XG4gICAgICAgIGlmICh6eiAhPT0gXzFuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9KTtcbiAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocCkgPT4ge1xuICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuICAgICAgICBpZiAocC5pczAoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7IC8vIFRPRE86IG9wdGltaXplLCB3aXRoIHZhcnMgYmVsb3c/XG4gICAgICAgIC8vIEVxdWF0aW9uIGluIGFmZmluZSBjb29yZGluYXRlczogYXjCsiArIHnCsiA9IDEgKyBkeMKyecKyXG4gICAgICAgIC8vIEVxdWF0aW9uIGluIHByb2plY3RpdmUgY29vcmRpbmF0ZXMgKFgvWiwgWS9aLCBaKTogIChhWMKyICsgWcKyKVrCsiA9IFrigbQgKyBkWMKyWcKyXG4gICAgICAgIGNvbnN0IHsgWCwgWSwgWiwgVCB9ID0gcDtcbiAgICAgICAgY29uc3QgWDIgPSBtb2RQKFggKiBYKTsgLy8gWMKyXG4gICAgICAgIGNvbnN0IFkyID0gbW9kUChZICogWSk7IC8vIFnCslxuICAgICAgICBjb25zdCBaMiA9IG1vZFAoWiAqIFopOyAvLyBawrJcbiAgICAgICAgY29uc3QgWjQgPSBtb2RQKFoyICogWjIpOyAvLyBa4oG0XG4gICAgICAgIGNvbnN0IGFYMiA9IG1vZFAoWDIgKiBhKTsgLy8gYVjCslxuICAgICAgICBjb25zdCBsZWZ0ID0gbW9kUChaMiAqIG1vZFAoYVgyICsgWTIpKTsgLy8gKGFYwrIgKyBZwrIpWsKyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gbW9kUChaNCArIG1vZFAoZCAqIG1vZFAoWDIgKiBZMikpKTsgLy8gWuKBtCArIGRYwrJZwrJcbiAgICAgICAgaWYgKGxlZnQgIT09IHJpZ2h0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQgKDEpJyk7XG4gICAgICAgIC8vIEluIEV4dGVuZGVkIGNvb3JkaW5hdGVzIHdlIGFsc28gaGF2ZSBULCB3aGljaCBpcyB4Knk9VC9aOiBjaGVjayBYKlkgPT0gWipUXG4gICAgICAgIGNvbnN0IFhZID0gbW9kUChYICogWSk7XG4gICAgICAgIGNvbnN0IFpUID0gbW9kUChaICogVCk7XG4gICAgICAgIGlmIChYWSAhPT0gWlQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMiknKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgLy8gRXh0ZW5kZWQgUG9pbnQgd29ya3MgaW4gZXh0ZW5kZWQgY29vcmRpbmF0ZXM6IChYLCBZLCBaLCBUKSDiiIsgKHg9WC9aLCB5PVkvWiwgVD14eSkuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdpc3RlZF9FZHdhcmRzX2N1cnZlI0V4dGVuZGVkX2Nvb3JkaW5hdGVzXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihYLCBZLCBaLCBUKSB7XG4gICAgICAgICAgICB0aGlzLlggPSBhY29vcmQoJ3gnLCBYKTtcbiAgICAgICAgICAgIHRoaXMuWSA9IGFjb29yZCgneScsIFkpO1xuICAgICAgICAgICAgdGhpcy5aID0gYWNvb3JkKCd6JywgWiwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLlQgPSBhY29vcmQoJ3QnLCBUKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgICAgIGdldCBleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlg7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGV5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuWTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZXooKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5aO1xuICAgICAgICB9XG4gICAgICAgIGdldCBldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplWihQb2ludCwgcG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbXNtKHBvaW50cywgc2NhbGFycykge1xuICAgICAgICAgICAgcmV0dXJuIHBpcHBlbmdlcihQb2ludCwgRm4sIHBvaW50cywgc2NhbGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5wcmVjb21wdXRlKHdpbmRvd1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHRlbmRlZCBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgYWNvb3JkKCd4JywgeCk7XG4gICAgICAgICAgICBhY29vcmQoJ3knLCB5KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgXzFuLCBtb2RQKHggKiB5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgaXNMYXp5ID0gdHJ1ZSkge1xuICAgICAgICAgICAgd25hZi5jcmVhdGVDYWNoZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIGlmICghaXNMYXp5KVxuICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbHkoXzJuKTsgLy8gcmFuZG9tIG51bWJlclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlZnVsIGluIGZyb21BZmZpbmUoKSAtIG5vdCBmb3IgZnJvbUJ5dGVzKCksIHdoaWNoIGFsd2F5cyBjcmVhdGVkIHZhbGlkIHBvaW50cy5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBhc3NlcnRWYWxpZE1lbW8odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhZXh0cG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBYOiBYMSwgWTogWTEsIFo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBYOiBYMiwgWTogWTIsIFo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGNvbnN0IFgxWjIgPSBtb2RQKFgxICogWjIpO1xuICAgICAgICAgICAgY29uc3QgWDJaMSA9IG1vZFAoWDIgKiBaMSk7XG4gICAgICAgICAgICBjb25zdCBZMVoyID0gbW9kUChZMSAqIFoyKTtcbiAgICAgICAgICAgIGNvbnN0IFkyWjEgPSBtb2RQKFkyICogWjEpO1xuICAgICAgICAgICAgcmV0dXJuIFgxWjIgPT09IFgyWjEgJiYgWTFaMiA9PT0gWTJaMTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgLy8gRmxpcHMgcG9pbnQgc2lnbiB0byBhIG5lZ2F0aXZlIG9uZSAoLXgsIHkgaW4gYWZmaW5lIGNvb3JkcylcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQobW9kUCgtdGhpcy5YKSwgdGhpcy5ZLCB0aGlzLlosIG1vZFAoLXRoaXMuVCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhc3QgYWxnbyBmb3IgZG91YmxpbmcgRXh0ZW5kZWQgUG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQuaHRtbCNkb3VibGluZy1kYmwtMjAwOC1od2NkXG4gICAgICAgIC8vIENvc3Q6IDRNICsgNFMgKyAxKmEgKyA2YWRkICsgMSoyLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgeyBYOiBYMSwgWTogWTEsIFo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoWDEgKiBYMSk7IC8vIEEgPSBYMTJcbiAgICAgICAgICAgIGNvbnN0IEIgPSBtb2RQKFkxICogWTEpOyAvLyBCID0gWTEyXG4gICAgICAgICAgICBjb25zdCBDID0gbW9kUChfMm4gKiBtb2RQKFoxICogWjEpKTsgLy8gQyA9IDIqWjEyXG4gICAgICAgICAgICBjb25zdCBEID0gbW9kUChhICogQSk7IC8vIEQgPSBhKkFcbiAgICAgICAgICAgIGNvbnN0IHgxeTEgPSBYMSArIFkxO1xuICAgICAgICAgICAgY29uc3QgRSA9IG1vZFAobW9kUCh4MXkxICogeDF5MSkgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpMi1BLUJcbiAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQjsgLy8gRyA9IEQrQlxuICAgICAgICAgICAgY29uc3QgRiA9IEcgLSBDOyAvLyBGID0gRy1DXG4gICAgICAgICAgICBjb25zdCBIID0gRCAtIEI7IC8vIEggPSBELUJcbiAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7IC8vIFgzID0gRSpGXG4gICAgICAgICAgICBjb25zdCBZMyA9IG1vZFAoRyAqIEgpOyAvLyBZMyA9IEcqSFxuICAgICAgICAgICAgY29uc3QgVDMgPSBtb2RQKEUgKiBIKTsgLy8gVDMgPSBFKkhcbiAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7IC8vIFozID0gRipHXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMsIFQzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYXN0IGFsZ28gZm9yIGFkZGluZyAyIEV4dGVuZGVkIFBvaW50cy5cbiAgICAgICAgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2RcbiAgICAgICAgLy8gQ29zdDogOU0gKyAxKmEgKyAxKmQgKyA3YWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFleHRwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgeyBYOiBYMSwgWTogWTEsIFo6IFoxLCBUOiBUMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDIsIFk6IFkyLCBaOiBaMiwgVDogVDIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoWDEgKiBYMik7IC8vIEEgPSBYMSpYMlxuICAgICAgICAgICAgY29uc3QgQiA9IG1vZFAoWTEgKiBZMik7IC8vIEIgPSBZMSpZMlxuICAgICAgICAgICAgY29uc3QgQyA9IG1vZFAoVDEgKiBkICogVDIpOyAvLyBDID0gVDEqZCpUMlxuICAgICAgICAgICAgY29uc3QgRCA9IG1vZFAoWjEgKiBaMik7IC8vIEQgPSBaMSpaMlxuICAgICAgICAgICAgY29uc3QgRSA9IG1vZFAoKFgxICsgWTEpICogKFgyICsgWTIpIC0gQSAtIEIpOyAvLyBFID0gKFgxK1kxKSooWDIrWTIpLUEtQlxuICAgICAgICAgICAgY29uc3QgRiA9IEQgLSBDOyAvLyBGID0gRC1DXG4gICAgICAgICAgICBjb25zdCBHID0gRCArIEM7IC8vIEcgPSBEK0NcbiAgICAgICAgICAgIGNvbnN0IEggPSBtb2RQKEIgLSBhICogQSk7IC8vIEggPSBCLWEqQVxuICAgICAgICAgICAgY29uc3QgWDMgPSBtb2RQKEUgKiBGKTsgLy8gWDMgPSBFKkZcbiAgICAgICAgICAgIGNvbnN0IFkzID0gbW9kUChHICogSCk7IC8vIFkzID0gRypIXG4gICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpOyAvLyBUMyA9IEUqSFxuICAgICAgICAgICAgY29uc3QgWjMgPSBtb2RQKEYgKiBHKTsgLy8gWjMgPSBGKkdcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgY29uc3QgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGFJblJhbmdlKCdzY2FsYXInLCBuLCBfMW4sIENVUlZFX09SREVSKTsgLy8gMSA8PSBzY2FsYXIgPCBMXG4gICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHduYWYuY2FjaGVkKHRoaXMsIG4sIChwKSA9PiBub3JtYWxpemVaKFBvaW50LCBwKSk7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplWihQb2ludCwgW3AsIGZdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgIC8vIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgIC8vIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLlxuICAgICAgICAvLyBEb2VzIE5PVCBhbGxvdyBzY2FsYXJzIGhpZ2hlciB0aGFuIENVUlZFLm4uXG4gICAgICAgIC8vIEFjY2VwdHMgb3B0aW9uYWwgYWNjdW11bGF0b3IgdG8gbWVyZ2Ugd2l0aCBtdWx0aXBseSAoaW1wb3J0YW50IGZvciBzcGFyc2Ugc2NhbGFycylcbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyLCBhY2MgPSBQb2ludC5aRVJPKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2NhbGFyO1xuICAgICAgICAgICAgYUluUmFuZ2UoJ3NjYWxhcicsIG4sIF8wbiwgQ1VSVkVfT1JERVIpOyAvLyAwIDw9IHNjYWxhciA8IExcbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSB8fCBuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmUodGhpcywgbiwgKHApID0+IG5vcm1hbGl6ZVooUG9pbnQsIHApLCBhY2MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrcyBpZiBwb2ludCBpcyBvZiBzbWFsbCBvcmRlci5cbiAgICAgICAgLy8gSWYgeW91IGFkZCBzb21ldGhpbmcgdG8gc21hbGwgb3JkZXIgcG9pbnQsIHlvdSB3aWxsIGhhdmUgXCJkaXJ0eVwiXG4gICAgICAgIC8vIHBvaW50IHdpdGggdG9yc2lvbiBjb21wb25lbnQuXG4gICAgICAgIC8vIE11bHRpcGxpZXMgcG9pbnQgYnkgY29mYWN0b3IgYW5kIGNoZWNrcyBpZiB0aGUgcmVzdWx0IGlzIDAuXG4gICAgICAgIGlzU21hbGxPcmRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGN1cnZlIG9yZGVyIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgICAgICAvLyBSZXR1cm5zIGBmYWxzZWAgaXMgdGhlIHBvaW50IGlzIGRpcnR5LlxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlKHRoaXMsIENVUlZFX09SREVSKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBFeHRlbmRlZCBwb2ludCB0byBkZWZhdWx0ICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIHRvQWZmaW5lKGludmVydGVkWikge1xuICAgICAgICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpbnZlcnRlZFopO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzLCB6aXAyMTUgPSBmYWxzZSkge1xuICAgICAgICAgICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5mcm9tSGV4KGJ5dGVzLCB6aXAyMTUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgIC8vIFVzZXMgYWxnbyBmcm9tIFJGQzgwMzIgNS4xLjMuXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCwgemlwMjE1ID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZCwgYSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBGcC5CWVRFUztcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCwgbGVuKTsgLy8gY29weSBoZXggdG8gYSBuZXcgYXJyYXlcbiAgICAgICAgICAgIGFib29sKCd6aXAyMTUnLCB6aXAyMTUpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWVkID0gaGV4LnNsaWNlKCk7IC8vIGNvcHkgYWdhaW4sIHdlJ2xsIG1hbmlwdWxhdGUgaXRcbiAgICAgICAgICAgIGNvbnN0IGxhc3RCeXRlID0gaGV4W2xlbiAtIDFdOyAvLyBzZWxlY3QgbGFzdCBieXRlXG4gICAgICAgICAgICBub3JtZWRbbGVuIC0gMV0gPSBsYXN0Qnl0ZSAmIH4weDgwOyAvLyBjbGVhciBsYXN0IGJpdFxuICAgICAgICAgICAgY29uc3QgeSA9IGJ5dGVzVG9OdW1iZXJMRShub3JtZWQpO1xuICAgICAgICAgICAgLy8gemlwMjE1PXRydWUgaXMgZ29vZCBmb3IgY29uc2Vuc3VzLWNyaXRpY2FsIGFwcHMuID1mYWxzZSBmb2xsb3dzIFJGQzgwMzIgLyBOSVNUMTg2LTUuXG4gICAgICAgICAgICAvLyBSRkM4MDMyIHByb2hpYml0cyA+PSBwLCBidXQgWklQMjE1IGRvZXNuJ3RcbiAgICAgICAgICAgIC8vIHppcDIxNT10cnVlOiAgMCA8PSB5IDwgTUFTSyAoMl4yNTYgZm9yIGVkMjU1MTkpXG4gICAgICAgICAgICAvLyB6aXAyMTU9ZmFsc2U6IDAgPD0geSA8IFAgKDJeMjU1LTE5IGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgY29uc3QgbWF4ID0gemlwMjE1ID8gTUFTSyA6IEZwLk9SREVSO1xuICAgICAgICAgICAgYUluUmFuZ2UoJ3BvaW50SGV4LnknLCB5LCBfMG4sIG1heCk7XG4gICAgICAgICAgICAvLyBFZDI1NTE5OiB4wrIgPSAoecKyLTEpLyhkecKyKzEpIG1vZCBwLiBFZDQ0ODogeMKyID0gKHnCsi0xKS8oZHnCsi0xKSBtb2QgcC4gR2VuZXJpYyBjYXNlOlxuICAgICAgICAgICAgLy8gYXjCsit5wrI9MStkeMKyecKyID0+IHnCsi0xPWR4wrJ5wrItYXjCsiA9PiB5wrItMT14wrIoZHnCsi1hKSA9PiB4wrI9KHnCsi0xKS8oZHnCsi1hKVxuICAgICAgICAgICAgY29uc3QgeTIgPSBtb2RQKHkgKiB5KTsgLy8gZGVub21pbmF0b3IgaXMgYWx3YXlzIG5vbi0wIG1vZCBwLlxuICAgICAgICAgICAgY29uc3QgdSA9IG1vZFAoeTIgLSBfMW4pOyAvLyB1ID0gecKyIC0gMVxuICAgICAgICAgICAgY29uc3QgdiA9IG1vZFAoZCAqIHkyIC0gYSk7IC8vIHYgPSBkIHnCsiArIDEuXG4gICAgICAgICAgICBsZXQgeyBpc1ZhbGlkLCB2YWx1ZTogeCB9ID0gdXZSYXRpbyh1LCB2KTsgLy8g4oiaKHUvdilcbiAgICAgICAgICAgIGlmICghaXNWYWxpZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50LmZyb21IZXg6IGludmFsaWQgeSBjb29yZGluYXRlJyk7XG4gICAgICAgICAgICBjb25zdCBpc1hPZGQgPSAoeCAmIF8xbikgPT09IF8xbjsgLy8gVGhlcmUgYXJlIDIgc3F1YXJlIHJvb3RzLiBVc2UgeF8wIGJpdCB0byBzZWxlY3QgcHJvcGVyXG4gICAgICAgICAgICBjb25zdCBpc0xhc3RCeXRlT2RkID0gKGxhc3RCeXRlICYgMHg4MCkgIT09IDA7IC8vIHhfMCwgbGFzdCBiaXRcbiAgICAgICAgICAgIGlmICghemlwMjE1ICYmIHggPT09IF8wbiAmJiBpc0xhc3RCeXRlT2RkKVxuICAgICAgICAgICAgICAgIC8vIGlmIHg9MCBhbmQgeF8wID0gMSwgZmFpbFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQuZnJvbUhleDogeD0wIGFuZCB4XzA9MScpO1xuICAgICAgICAgICAgaWYgKGlzTGFzdEJ5dGVPZGQgIT09IGlzWE9kZClcbiAgICAgICAgICAgICAgICB4ID0gbW9kUCgteCk7IC8vIGlmIHhfMCAhPSB4IG1vZCAyLCBzZXQgeCA9IHAteFxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LmZyb21BZmZpbmUoeyB4LCB5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbnVtYmVyVG9CeXRlc0xFKHksIEZwLkJZVEVTKTsgLy8gZWFjaCB5IGhhcyAyIHggdmFsdWVzICh4LCAteSlcbiAgICAgICAgICAgIGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdIHw9IHggJiBfMW4gPyAweDgwIDogMDsgLy8gd2hlbiBjb21wcmVzc2luZywgaXQncyBlbm91Z2ggdG8gc3RvcmUgeVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzOyAvLyBhbmQgdXNlIHRoZSBsYXN0IGJ5dGUgdG8gZW5jb2RlIHNpZ24gb2YgeFxuICAgICAgICB9XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHRvQnl0ZXNgICovXG4gICAgICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvQnl0ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gYDxQb2ludCAke3RoaXMuaXMwKCkgPyAnWkVSTycgOiB0aGlzLnRvSGV4KCl9PmA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYmFzZSAvIGdlbmVyYXRvciBwb2ludFxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBfMW4sIG1vZFAoQ1VSVkUuR3ggKiBDVVJWRS5HeSkpO1xuICAgIC8vIHplcm8gLyBpbmZpbml0eSAvIGlkZW50aXR5IHBvaW50XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChfMG4sIF8xbiwgXzFuLCBfMG4pOyAvLyAwLCAxLCAxLCAwXG4gICAgLy8gZmllbGRzXG4gICAgUG9pbnQuRnAgPSBGcDtcbiAgICBQb2ludC5GbiA9IEZuO1xuICAgIGNvbnN0IHduYWYgPSBuZXcgd05BRihQb2ludCwgRm4uQllURVMgKiA4KTsgLy8gRm4uQklUUz9cbiAgICByZXR1cm4gUG9pbnQ7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHByaW1lLW9yZGVyIHBvaW50cyBsaWtlIFJpc3RyZXR0bzI1NSBhbmQgRGVjYWY0NDguXG4gKiBUaGVzZSBwb2ludHMgZWxpbWluYXRlIGNvZmFjdG9yIGlzc3VlcyBieSByZXByZXNlbnRpbmcgZXF1aXZhbGVuY2UgY2xhc3Nlc1xuICogb2YgRWR3YXJkcyBjdXJ2ZSBwb2ludHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQcmltZUVkd2FyZHNQb2ludCB7XG4gICAgY29uc3RydWN0b3IoZXApIHtcbiAgICAgICAgdGhpcy5lcCA9IGVwO1xuICAgIH1cbiAgICAvLyBTdGF0aWMgbWV0aG9kcyB0aGF0IG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Nlc1xuICAgIHN0YXRpYyBmcm9tQnl0ZXMoX2J5dGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnJvbUJ5dGVzIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3MnKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoX2hleCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zyb21IZXggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzcycpO1xuICAgIH1cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgIH1cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgIH1cbiAgICAvLyBDb21tb24gaW1wbGVtZW50YXRpb25zXG4gICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgLy8gbm8tb3AgZm9yIHByaW1lLW9yZGVyIGdyb3Vwc1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgIHRoaXMuZXAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICB9XG4gICAgdG9BZmZpbmUoaW52ZXJ0ZWRaKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVwLnRvQWZmaW5lKGludmVydGVkWik7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHRvQnl0ZXNgICovXG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcygpO1xuICAgIH1cbiAgICB0b0hleCgpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcy50b0J5dGVzKCkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXgoKTtcbiAgICB9XG4gICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzU21hbGxPcmRlcigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTYW1lKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCh0aGlzLmVwLmFkZChvdGhlci5lcCkpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICB0aGlzLmFzc2VydFNhbWUob3RoZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAuc3VidHJhY3Qob3RoZXIuZXApKTtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQodGhpcy5lcC5tdWx0aXBseShzY2FsYXIpKTtcbiAgICB9XG4gICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQodGhpcy5lcC5tdWx0aXBseVVuc2FmZShzY2FsYXIpKTtcbiAgICB9XG4gICAgZG91YmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAuZG91YmxlKCkpO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQodGhpcy5lcC5uZWdhdGUoKSk7XG4gICAgfVxuICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSwgaXNMYXp5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQodGhpcy5lcC5wcmVjb21wdXRlKHdpbmRvd1NpemUsIGlzTGF6eSkpO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgRWREU0Egc2lnbmF0dXJlcyBvdmVyIGdpdmVuIEVkd2FyZHMgY3VydmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZGRzYShQb2ludCwgY0hhc2gsIGVkZHNhT3B0cykge1xuICAgIGlmICh0eXBlb2YgY0hhc2ggIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJoYXNoXCIgZnVuY3Rpb24gcGFyYW0gaXMgcmVxdWlyZWQnKTtcbiAgICBfdmFsaWRhdGVPYmplY3QoZWRkc2FPcHRzLCB7fSwge1xuICAgICAgICBhZGp1c3RTY2FsYXJCeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIGRvbWFpbjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcHJlaGFzaDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbWFwVG9DdXJ2ZTogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHByZWhhc2ggfSA9IGVkZHNhT3B0cztcbiAgICBjb25zdCB7IEJBU0U6IEcsIEZwLCBGbiB9ID0gUG9pbnQ7XG4gICAgY29uc3QgQ1VSVkVfT1JERVIgPSBGbi5PUkRFUjtcbiAgICBjb25zdCByYW5kb21CeXRlc18gPSBlZGRzYU9wdHMucmFuZG9tQnl0ZXMgfHwgcmFuZG9tQnl0ZXM7XG4gICAgY29uc3QgYWRqdXN0U2NhbGFyQnl0ZXMgPSBlZGRzYU9wdHMuYWRqdXN0U2NhbGFyQnl0ZXMgfHwgKChieXRlcykgPT4gYnl0ZXMpOyAvLyBOT09QXG4gICAgY29uc3QgZG9tYWluID0gZWRkc2FPcHRzLmRvbWFpbiB8fFxuICAgICAgICAoKGRhdGEsIGN0eCwgcGhmbGFnKSA9PiB7XG4gICAgICAgICAgICBhYm9vbCgncGhmbGFnJywgcGhmbGFnKTtcbiAgICAgICAgICAgIGlmIChjdHgubGVuZ3RoIHx8IHBoZmxhZylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHRzL3ByZS1oYXNoIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7IC8vIE5PT1BcbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIEZuLmNyZWF0ZShhKTtcbiAgICB9XG4gICAgLy8gTGl0dGxlLWVuZGlhbiBTSEE1MTIgd2l0aCBtb2R1bG8gblxuICAgIGZ1bmN0aW9uIG1vZE5fTEUoaGFzaCkge1xuICAgICAgICAvLyBOb3QgdXNpbmcgRm4uZnJvbUJ5dGVzOiBoYXNoIGNhbiBiZSAyKkZuLkJZVEVTXG4gICAgICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJMRShoYXNoKSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgaGFzaGVkIHByaXZhdGUgc2NhbGFyIHBlciBSRkM4MDMyIDUuMS41XG4gICAgZnVuY3Rpb24gZ2V0UHJpdmF0ZVNjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gRnAuQllURVM7XG4gICAgICAgIGtleSA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbGVuKTtcbiAgICAgICAgLy8gSGFzaCBwcml2YXRlIGtleSB3aXRoIGN1cnZlJ3MgaGFzaCBmdW5jdGlvbiB0byBwcm9kdWNlIHVuaWZvcm1pbmdseSByYW5kb20gaW5wdXRcbiAgICAgICAgLy8gQ2hlY2sgYnl0ZSBsZW5ndGhzOiBlbnN1cmUoNjQsIGgoZW5zdXJlKDMyLCBrZXkpKSlcbiAgICAgICAgY29uc3QgaGFzaGVkID0gZW5zdXJlQnl0ZXMoJ2hhc2hlZCBwcml2YXRlIGtleScsIGNIYXNoKGtleSksIDIgKiBsZW4pO1xuICAgICAgICBjb25zdCBoZWFkID0gYWRqdXN0U2NhbGFyQnl0ZXMoaGFzaGVkLnNsaWNlKDAsIGxlbikpOyAvLyBjbGVhciBmaXJzdCBoYWxmIGJpdHMsIHByb2R1Y2UgRkVcbiAgICAgICAgY29uc3QgcHJlZml4ID0gaGFzaGVkLnNsaWNlKGxlbiwgMiAqIGxlbik7IC8vIHNlY29uZCBoYWxmIGlzIGNhbGxlZCBrZXkgcHJlZml4ICg1LjEuNilcbiAgICAgICAgY29uc3Qgc2NhbGFyID0gbW9kTl9MRShoZWFkKTsgLy8gVGhlIGFjdHVhbCBwcml2YXRlIHNjYWxhclxuICAgICAgICByZXR1cm4geyBoZWFkLCBwcmVmaXgsIHNjYWxhciB9O1xuICAgIH1cbiAgICAvKiogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgY3JlYXRlcyBwdWJsaWMga2V5IGZyb20gc2NhbGFyLiBSRkM4MDMyIDUuMS41ICovXG4gICAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoc2VjcmV0S2V5KSB7XG4gICAgICAgIGNvbnN0IHsgaGVhZCwgcHJlZml4LCBzY2FsYXIgfSA9IGdldFByaXZhdGVTY2FsYXIoc2VjcmV0S2V5KTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBHLm11bHRpcGx5KHNjYWxhcik7IC8vIFBvaW50IG9uIEVkd2FyZHMgY3VydmUgYWthIHB1YmxpYyBrZXlcbiAgICAgICAgY29uc3QgcG9pbnRCeXRlcyA9IHBvaW50LnRvQnl0ZXMoKTtcbiAgICAgICAgcmV0dXJuIHsgaGVhZCwgcHJlZml4LCBzY2FsYXIsIHBvaW50LCBwb2ludEJ5dGVzIH07XG4gICAgfVxuICAgIC8qKiBDYWxjdWxhdGVzIEVkRFNBIHB1YiBrZXkuIFJGQzgwMzIgNS4xLjUuICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHNlY3JldEtleSkge1xuICAgICAgICByZXR1cm4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoc2VjcmV0S2V5KS5wb2ludEJ5dGVzO1xuICAgIH1cbiAgICAvLyBpbnQoJ0xFJywgU0hBNTEyKGRvbTIoRiwgQykgfHwgbXNncykpIG1vZCBOXG4gICAgZnVuY3Rpb24gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQgPSBVaW50OEFycmF5Lm9mKCksIC4uLm1zZ3MpIHtcbiAgICAgICAgY29uc3QgbXNnID0gY29uY2F0Qnl0ZXMoLi4ubXNncyk7XG4gICAgICAgIHJldHVybiBtb2ROX0xFKGNIYXNoKGRvbWFpbihtc2csIGVuc3VyZUJ5dGVzKCdjb250ZXh0JywgY29udGV4dCksICEhcHJlaGFzaCkpKTtcbiAgICB9XG4gICAgLyoqIFNpZ25zIG1lc3NhZ2Ugd2l0aCBwcml2YXRlS2V5LiBSRkM4MDMyIDUuMS42ICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2csIHNlY3JldEtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIG1zZyA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2cgPSBwcmVoYXNoKG1zZyk7IC8vIGZvciBlZDI1NTE5cGggZXRjLlxuICAgICAgICBjb25zdCB7IHByZWZpeCwgc2NhbGFyLCBwb2ludEJ5dGVzIH0gPSBnZXRFeHRlbmRlZFB1YmxpY0tleShzZWNyZXRLZXkpO1xuICAgICAgICBjb25zdCByID0gaGFzaERvbWFpblRvU2NhbGFyKG9wdGlvbnMuY29udGV4dCwgcHJlZml4LCBtc2cpOyAvLyByID0gZG9tMihGLCBDKSB8fCBwcmVmaXggfHwgUEgoTSlcbiAgICAgICAgY29uc3QgUiA9IEcubXVsdGlwbHkocikudG9CeXRlcygpOyAvLyBSID0gckdcbiAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihvcHRpb25zLmNvbnRleHQsIFIsIHBvaW50Qnl0ZXMsIG1zZyk7IC8vIFIgfHwgQSB8fCBQSChNKVxuICAgICAgICBjb25zdCBzID0gbW9kTihyICsgayAqIHNjYWxhcik7IC8vIFMgPSAociArIGsgKiBzKSBtb2QgTFxuICAgICAgICBhSW5SYW5nZSgnc2lnbmF0dXJlLnMnLCBzLCBfMG4sIENVUlZFX09SREVSKTsgLy8gMCA8PSBzIDwgbFxuICAgICAgICBjb25zdCBMID0gRnAuQllURVM7XG4gICAgICAgIGNvbnN0IHJlcyA9IGNvbmNhdEJ5dGVzKFIsIG51bWJlclRvQnl0ZXNMRShzLCBMKSk7XG4gICAgICAgIHJldHVybiBlbnN1cmVCeXRlcygncmVzdWx0JywgcmVzLCBMICogMik7IC8vIDY0LWJ5dGUgc2lnbmF0dXJlXG4gICAgfVxuICAgIC8vIHZlcmlmaWNhdGlvbiBydWxlIGlzIGVpdGhlciB6aXAyMTUgb3IgcmZjODAzMiAvIG5pc3QxODYtNS4gQ29uc3VsdCBmcm9tSGV4OlxuICAgIGNvbnN0IHZlcmlmeU9wdHMgPSB7IHppcDIxNTogdHJ1ZSB9O1xuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIEVkRFNBIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuIFJGQzgwMzIgNS4xLjcuXG4gICAgICogQW4gZXh0ZW5kZWQgZ3JvdXAgZXF1YXRpb24gaXMgY2hlY2tlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnLCBtc2csIHB1YmxpY0tleSwgb3B0aW9ucyA9IHZlcmlmeU9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0LCB6aXAyMTUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGxlbiA9IEZwLkJZVEVTOyAvLyBWZXJpZmllcyBFZERTQSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGFuZCBwdWJsaWMga2V5LiBSRkM4MDMyIDUuMS43LlxuICAgICAgICBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnLCAyICogbGVuKTsgLy8gQW4gZXh0ZW5kZWQgZ3JvdXAgZXF1YXRpb24gaXMgY2hlY2tlZC5cbiAgICAgICAgbXNnID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCBsZW4pO1xuICAgICAgICBpZiAoemlwMjE1ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhYm9vbCgnemlwMjE1JywgemlwMjE1KTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2cgPSBwcmVoYXNoKG1zZyk7IC8vIGZvciBlZDI1NTE5cGgsIGV0Y1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckxFKHNpZy5zbGljZShsZW4sIDIgKiBsZW4pKTtcbiAgICAgICAgbGV0IEEsIFIsIFNCO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gemlwMjE1PXRydWUgaXMgZ29vZCBmb3IgY29uc2Vuc3VzLWNyaXRpY2FsIGFwcHMuID1mYWxzZSBmb2xsb3dzIFJGQzgwMzIgLyBOSVNUMTg2LTUuXG4gICAgICAgICAgICAvLyB6aXAyMTU9dHJ1ZTogIDAgPD0geSA8IE1BU0sgKDJeMjU2IGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgLy8gemlwMjE1PWZhbHNlOiAwIDw9IHkgPCBQICgyXjI1NS0xOSBmb3IgZWQyNTUxOSlcbiAgICAgICAgICAgIEEgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSwgemlwMjE1KTtcbiAgICAgICAgICAgIFIgPSBQb2ludC5mcm9tSGV4KHNpZy5zbGljZSgwLCBsZW4pLCB6aXAyMTUpO1xuICAgICAgICAgICAgU0IgPSBHLm11bHRpcGx5VW5zYWZlKHMpOyAvLyAwIDw9IHMgPCBsIGlzIGRvbmUgaW5zaWRlXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6aXAyMTUgJiYgQS5pc1NtYWxsT3JkZXIoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihjb250ZXh0LCBSLnRvQnl0ZXMoKSwgQS50b0J5dGVzKCksIG1zZyk7XG4gICAgICAgIGNvbnN0IFJrQSA9IFIuYWRkKEEubXVsdGlwbHlVbnNhZmUoaykpO1xuICAgICAgICAvLyBFeHRlbmRlZCBncm91cCBlcXVhdGlvblxuICAgICAgICAvLyBbOF1bU11CID0gWzhdUiArIFs4XVtrXUEnXG4gICAgICAgIHJldHVybiBSa0Euc3VidHJhY3QoU0IpLmNsZWFyQ29mYWN0b3IoKS5pczAoKTtcbiAgICB9XG4gICAgRy5wcmVjb21wdXRlKDgpOyAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgY29uc3Qgc2l6ZSA9IEZwLkJZVEVTO1xuICAgIGNvbnN0IGxlbmd0aHMgPSB7XG4gICAgICAgIHNlY3JldDogc2l6ZSxcbiAgICAgICAgcHVibGljOiBzaXplLFxuICAgICAgICBzaWduYXR1cmU6IDIgKiBzaXplLFxuICAgICAgICBzZWVkOiBzaXplLFxuICAgIH07XG4gICAgZnVuY3Rpb24gcmFuZG9tU2VjcmV0S2V5KHNlZWQgPSByYW5kb21CeXRlc18obGVuZ3Rocy5zZWVkKSkge1xuICAgICAgICByZXR1cm4gc2VlZDtcbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGdldEV4dGVuZGVkUHVibGljS2V5LFxuICAgICAgICAvKiogZWQyNTUxOSBwcml2IGtleXMgYXJlIHVuaWZvcm0gMzJiLiBObyBuZWVkIHRvIGNoZWNrIGZvciBtb2R1bG8gYmlhcywgbGlrZSBpbiBzZWNwMjU2azEuICovXG4gICAgICAgIHJhbmRvbVNlY3JldEtleSxcbiAgICAgICAgaXNWYWxpZFNlY3JldEtleSxcbiAgICAgICAgaXNWYWxpZFB1YmxpY0tleSxcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogcmFuZG9tU2VjcmV0S2V5LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgZWQgcHVibGljIGtleSB0byB4IHB1YmxpYyBrZXkuIFVzZXMgZm9ybXVsYTpcbiAgICAgICAgICogLSBlZDI1NTE5OlxuICAgICAgICAgKiAgIC0gYCh1LCB2KSA9ICgoMSt5KS8oMS15KSwgc3FydCgtNDg2NjY0KSp1L3gpYFxuICAgICAgICAgKiAgIC0gYCh4LCB5KSA9IChzcXJ0KC00ODY2NjQpKnUvdiwgKHUtMSkvKHUrMSkpYFxuICAgICAgICAgKiAtIGVkNDQ4OlxuICAgICAgICAgKiAgIC0gYCh1LCB2KSA9ICgoeS0xKS8oeSsxKSwgc3FydCgxNTYzMjQpKnUveClgXG4gICAgICAgICAqICAgLSBgKHgsIHkpID0gKHNxcnQoMTU2MzI0KSp1L3YsICgxK3UpLygxLXUpKWBcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlcmUgaXMgTk8gYGZyb21Nb250Z29tZXJ5YDpcbiAgICAgICAgICogLSBUaGVyZSBhcmUgMiB2YWxpZCBlZDI1NTE5IHBvaW50cyBmb3IgZXZlcnkgeDI1NTE5LCB3aXRoIGZsaXBwZWQgY29vcmRpbmF0ZVxuICAgICAgICAgKiAtIFNvbWV0aW1lcyB0aGVyZSBhcmUgMCB2YWxpZCBlZDI1NTE5IHBvaW50cywgYmVjYXVzZSB4MjU1MTkgKmFkZGl0aW9uYWxseSpcbiAgICAgICAgICogICBhY2NlcHRzIGlucHV0cyBvbiB0aGUgcXVhZHJhdGljIHR3aXN0LCB3aGljaCBjYW4ndCBiZSBtb3ZlZCB0byBlZDI1NTE5XG4gICAgICAgICAqL1xuICAgICAgICB0b01vbnRnb21lcnkocHVibGljS2V5KSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IFBvaW50LmZyb21CeXRlcyhwdWJsaWNLZXkpO1xuICAgICAgICAgICAgY29uc3QgaXMyNTUxOSA9IHNpemUgPT09IDMyO1xuICAgICAgICAgICAgaWYgKCFpczI1NTE5ICYmIHNpemUgIT09IDU3KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb25seSBkZWZpbmVkIGZvciAyNTUxOSBhbmQgNDQ4Jyk7XG4gICAgICAgICAgICBjb25zdCB1ID0gaXMyNTUxOSA/IEZwLmRpdihfMW4gKyB5LCBfMW4gLSB5KSA6IEZwLmRpdih5IC0gXzFuLCB5ICsgXzFuKTtcbiAgICAgICAgICAgIHJldHVybiBGcC50b0J5dGVzKHUpO1xuICAgICAgICB9LFxuICAgICAgICB0b01vbnRnb21lcnlQcml2KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIGFieXRlcyhwcml2YXRlS2V5LCBzaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2hlZCA9IGNIYXNoKHByaXZhdGVLZXkuc3ViYXJyYXkoMCwgc2l6ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkanVzdFNjYWxhckJ5dGVzKGhhc2hlZCkuc3ViYXJyYXkoMCwgc2l6ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSdyZSBkb2luZyBzY2FsYXIgbXVsdGlwbGljYXRpb24gKHVzZWQgaW4gZ2V0UHVibGljS2V5IGV0Yykgd2l0aCBwcmVjb21wdXRlZCBCQVNFX1BPSU5UXG4gICAgICAgICAqIHZhbHVlcy4gVGhpcyBzbG93cyBkb3duIGZpcnN0IGdldFB1YmxpY0tleSgpIGJ5IG1pbGxpc2Vjb25kcyAoc2VlIFNwZWVkIHNlY3Rpb24pLFxuICAgICAgICAgKiBidXQgYWxsb3dzIHRvIHNwZWVkLXVwIHN1YnNlcXVlbnQgZ2V0UHVibGljS2V5KCkgY2FsbHMgdXAgdG8gMjB4LlxuICAgICAgICAgKiBAcGFyYW0gd2luZG93U2l6ZSAyLCA0LCA4LCAxNlxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQucHJlY29tcHV0ZSh3aW5kb3dTaXplLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBmdW5jdGlvbiBrZXlnZW4oc2VlZCkge1xuICAgICAgICBjb25zdCBzZWNyZXRLZXkgPSB1dGlscy5yYW5kb21TZWNyZXRLZXkoc2VlZCk7XG4gICAgICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBnZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkU2VjcmV0S2V5KGtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICEhRm4uZnJvbUJ5dGVzKGtleSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRQdWJsaWNLZXkoa2V5LCB6aXAyMTUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhIVBvaW50LmZyb21CeXRlcyhrZXksIHppcDIxNSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICBrZXlnZW4sXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICB1dGlscyxcbiAgICAgICAgUG9pbnQsXG4gICAgICAgIGluZm86IHsgdHlwZTogJ2Vkd2FyZHMnLCBsZW5ndGhzIH0sXG4gICAgfSk7XG59XG4vLyBUT0RPOiByZW1vdmVcbmZ1bmN0aW9uIF9lZGRzYV9sZWdhY3lfb3B0c190b19uZXcoYykge1xuICAgIGNvbnN0IENVUlZFID0ge1xuICAgICAgICBhOiBjLmEsXG4gICAgICAgIGQ6IGMuZCxcbiAgICAgICAgcDogYy5GcC5PUkRFUixcbiAgICAgICAgbjogYy5uLFxuICAgICAgICBoOiBjLmgsXG4gICAgICAgIEd4OiBjLkd4LFxuICAgICAgICBHeTogYy5HeSxcbiAgICB9O1xuICAgIGNvbnN0IEZwID0gYy5GcDtcbiAgICBjb25zdCBGbiA9IEZpZWxkKENVUlZFLm4sIGMubkJpdExlbmd0aCwgdHJ1ZSk7XG4gICAgY29uc3QgY3VydmVPcHRzID0geyBGcCwgRm4sIHV2UmF0aW86IGMudXZSYXRpbyB9O1xuICAgIGNvbnN0IGVkZHNhT3B0cyA9IHtcbiAgICAgICAgcmFuZG9tQnl0ZXM6IGMucmFuZG9tQnl0ZXMsXG4gICAgICAgIGFkanVzdFNjYWxhckJ5dGVzOiBjLmFkanVzdFNjYWxhckJ5dGVzLFxuICAgICAgICBkb21haW46IGMuZG9tYWluLFxuICAgICAgICBwcmVoYXNoOiBjLnByZWhhc2gsXG4gICAgICAgIG1hcFRvQ3VydmU6IGMubWFwVG9DdXJ2ZSxcbiAgICB9O1xuICAgIHJldHVybiB7IENVUlZFLCBjdXJ2ZU9wdHMsIGhhc2g6IGMuaGFzaCwgZWRkc2FPcHRzIH07XG59XG4vLyBUT0RPOiByZW1vdmVcbmZ1bmN0aW9uIF9lZGRzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBlZGRzYSkge1xuICAgIGNvbnN0IGxlZ2FjeSA9IE9iamVjdC5hc3NpZ24oe30sIGVkZHNhLCB7IEV4dGVuZGVkUG9pbnQ6IGVkZHNhLlBvaW50LCBDVVJWRTogYyB9KTtcbiAgICByZXR1cm4gbGVnYWN5O1xufVxuLy8gVE9ETzogcmVtb3ZlLiBVc2UgZWRkc2FcbmV4cG9ydCBmdW5jdGlvbiB0d2lzdGVkRWR3YXJkcyhjKSB7XG4gICAgY29uc3QgeyBDVVJWRSwgY3VydmVPcHRzLCBoYXNoLCBlZGRzYU9wdHMgfSA9IF9lZGRzYV9sZWdhY3lfb3B0c190b19uZXcoYyk7XG4gICAgY29uc3QgUG9pbnQgPSBlZHdhcmRzKENVUlZFLCBjdXJ2ZU9wdHMpO1xuICAgIGNvbnN0IEVERFNBID0gZWRkc2EoUG9pbnQsIGhhc2gsIGVkZHNhT3B0cyk7XG4gICAgcmV0dXJuIF9lZGRzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBFRERTQSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZHdhcmRzLmpzLm1hcCJdLCJuYW1lcyI6WyJfdmFsaWRhdGVPYmplY3QiLCJhYm9vbCIsImFieXRlcyIsImFJblJhbmdlIiwiYnl0ZXNUb0hleCIsImJ5dGVzVG9OdW1iZXJMRSIsImNvbmNhdEJ5dGVzIiwiZW5zdXJlQnl0ZXMiLCJtZW1vaXplZCIsIm51bWJlclRvQnl0ZXNMRSIsInJhbmRvbUJ5dGVzIiwiX2NyZWF0ZUN1cnZlRmllbGRzIiwibm9ybWFsaXplWiIsInBpcHBlbmdlciIsIndOQUYiLCJGaWVsZCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl84biIsImlzRWRWYWxpZFhZIiwiRnAiLCJDVVJWRSIsIngiLCJ5IiwieDIiLCJzcXIiLCJ5MiIsImxlZnQiLCJhZGQiLCJtdWwiLCJhIiwicmlnaHQiLCJPTkUiLCJkIiwiZXFsIiwiZWR3YXJkcyIsImN1cnZlT3B0cyIsIkZuIiwiaCIsImNvZmFjdG9yIiwibiIsIkNVUlZFX09SREVSIiwidXZSYXRpbyIsIk1BU0siLCJCWVRFUyIsIm1vZFAiLCJjcmVhdGUiLCJ1IiwidiIsImlzVmFsaWQiLCJ2YWx1ZSIsInNxcnQiLCJkaXYiLCJlIiwiR3giLCJHeSIsIkVycm9yIiwiYWNvb3JkIiwidGl0bGUiLCJiYW5aZXJvIiwibWluIiwiYWV4dHBvaW50Iiwib3RoZXIiLCJQb2ludCIsInRvQWZmaW5lTWVtbyIsInAiLCJpeiIsIlgiLCJZIiwiWiIsImlzMCIsImludiIsInp6IiwiYXNzZXJ0VmFsaWRNZW1vIiwiVCIsIlgyIiwiWTIiLCJaMiIsIlo0IiwiYVgyIiwiWFkiLCJaVCIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiZnJlZXplIiwidG9BZmZpbmUiLCJleCIsImV5IiwiZXoiLCJldCIsInBvaW50cyIsIm1zbSIsInNjYWxhcnMiLCJfc2V0V2luZG93U2l6ZSIsIndpbmRvd1NpemUiLCJwcmVjb21wdXRlIiwiZnJvbUFmZmluZSIsImlzTGF6eSIsInduYWYiLCJjcmVhdGVDYWNoZSIsIm11bHRpcGx5IiwiYXNzZXJ0VmFsaWRpdHkiLCJlcXVhbHMiLCJYMSIsIlkxIiwiWjEiLCJYMVoyIiwiWDJaMSIsIlkxWjIiLCJZMloxIiwiWkVSTyIsIm5lZ2F0ZSIsImRvdWJsZSIsIkEiLCJCIiwiQyIsIkQiLCJ4MXkxIiwiRSIsIkciLCJGIiwiSCIsIlgzIiwiWTMiLCJUMyIsIlozIiwiVDEiLCJUMiIsInN1YnRyYWN0Iiwic2NhbGFyIiwiZiIsImNhY2hlZCIsIm11bHRpcGx5VW5zYWZlIiwiYWNjIiwidW5zYWZlIiwiaXNTbWFsbE9yZGVyIiwiaXNUb3JzaW9uRnJlZSIsImludmVydGVkWiIsImNsZWFyQ29mYWN0b3IiLCJmcm9tQnl0ZXMiLCJieXRlcyIsInppcDIxNSIsImZyb21IZXgiLCJoZXgiLCJsZW4iLCJub3JtZWQiLCJzbGljZSIsImxhc3RCeXRlIiwibWF4IiwiT1JERVIiLCJpc1hPZGQiLCJpc0xhc3RCeXRlT2RkIiwidG9CeXRlcyIsImxlbmd0aCIsInRvUmF3Qnl0ZXMiLCJ0b0hleCIsInRvU3RyaW5nIiwiQkFTRSIsIlByaW1lRWR3YXJkc1BvaW50IiwiZXAiLCJfYnl0ZXMiLCJfaGV4IiwiYXNzZXJ0U2FtZSIsImluaXQiLCJlZGRzYSIsImNIYXNoIiwiZWRkc2FPcHRzIiwiYWRqdXN0U2NhbGFyQnl0ZXMiLCJkb21haW4iLCJwcmVoYXNoIiwibWFwVG9DdXJ2ZSIsInJhbmRvbUJ5dGVzXyIsImRhdGEiLCJjdHgiLCJwaGZsYWciLCJtb2ROIiwibW9kTl9MRSIsImhhc2giLCJnZXRQcml2YXRlU2NhbGFyIiwia2V5IiwiaGFzaGVkIiwiaGVhZCIsInByZWZpeCIsImdldEV4dGVuZGVkUHVibGljS2V5Iiwic2VjcmV0S2V5IiwicG9pbnQiLCJwb2ludEJ5dGVzIiwiZ2V0UHVibGljS2V5IiwiaGFzaERvbWFpblRvU2NhbGFyIiwiY29udGV4dCIsIlVpbnQ4QXJyYXkiLCJvZiIsIm1zZ3MiLCJtc2ciLCJzaWduIiwib3B0aW9ucyIsInIiLCJSIiwiayIsInMiLCJMIiwicmVzIiwidmVyaWZ5T3B0cyIsInZlcmlmeSIsInNpZyIsInB1YmxpY0tleSIsInVuZGVmaW5lZCIsIlNCIiwiZXJyb3IiLCJSa0EiLCJzaXplIiwibGVuZ3RocyIsInNlY3JldCIsInB1YmxpYyIsInNpZ25hdHVyZSIsInNlZWQiLCJyYW5kb21TZWNyZXRLZXkiLCJ1dGlscyIsImlzVmFsaWRTZWNyZXRLZXkiLCJpc1ZhbGlkUHVibGljS2V5IiwicmFuZG9tUHJpdmF0ZUtleSIsInRvTW9udGdvbWVyeSIsImlzMjU1MTkiLCJ0b01vbnRnb21lcnlQcml2IiwicHJpdmF0ZUtleSIsInN1YmFycmF5Iiwia2V5Z2VuIiwiaW5mbyIsInR5cGUiLCJfZWRkc2FfbGVnYWN5X29wdHNfdG9fbmV3IiwiYyIsIm5CaXRMZW5ndGgiLCJfZWRkc2FfbmV3X291dHB1dF90b19sZWdhY3kiLCJsZWdhY3kiLCJhc3NpZ24iLCJFeHRlbmRlZFBvaW50IiwidHdpc3RlZEVkd2FyZHMiLCJFRERTQSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/edwards.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _DST_scalar: () => (/* binding */ _DST_scalar),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << 8 * length) throw new Error(\"invalid I2OSP input: \" + value);\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\nfunction normDST(DST) {\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes)(DST) && typeof DST !== \"string\") throw new Error(\"DST must be Uint8Array or string\");\n    return typeof DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(DST) : DST;\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */ function expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(msg);\n    anum(lenInBytes);\n    DST = normDST(DST);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255) throw new Error(\"expand_message_xmd: invalid lenInBytes\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */ function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(msg);\n    anum(lenInBytes);\n    DST = normDST(DST);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(options, {\n        p: \"bigint\",\n        m: \"number\",\n        k: \"number\",\n        hash: \"function\"\n    });\n    const { p, k, m, hash, expand, DST } = options;\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isHash)(options.hash)) throw new Error(\"expected valid hash\");\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(msg);\n    anum(count);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xn, xd, yn, yd] = coeff.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.FpInvertBatch)(field, [\n            xd,\n            yd\n        ], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nconst _DST_scalar = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"HashToScalar-\");\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */ function createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        hashToCurve (msg, options) {\n            const opts = Object.assign({}, defaults, options);\n            const u = hash_to_field(msg, 2, opts);\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        encodeToCurve (msg, options) {\n            const optsDst = defaults.encodeDST ? {\n                DST: defaults.encodeDST\n            } : {};\n            const opts = Object.assign({}, defaults, optsDst, options);\n            const u = hash_to_field(msg, 1, opts);\n            const u0 = map(u[0]);\n            return clear(u0);\n        },\n        /** See {@link H2CHasher} */ mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(\"expected array of bigints\");\n            return clear(map(scalars));\n        },\n        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393\n        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08\n        hashToScalar (msg, options) {\n            // @ts-ignore\n            const N = Point.Fn.ORDER;\n            const opts = Object.assign({}, defaults, {\n                p: N,\n                m: 1,\n                DST: _DST_scalar\n            }, options);\n            return hash_to_field(msg, 1, opts)[0][0];\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFtSDtBQUNqRTtBQUNsRCw2RkFBNkY7QUFDN0YsTUFBTVMsUUFBUVAsc0RBQWVBO0FBQzdCLDRDQUE0QztBQUM1QyxTQUFTUSxNQUFNQyxLQUFLLEVBQUVDLE1BQU07SUFDeEJDLEtBQUtGO0lBQ0xFLEtBQUtEO0lBQ0wsSUFBSUQsUUFBUSxLQUFLQSxTQUFTLEtBQU0sSUFBSUMsUUFDaEMsTUFBTSxJQUFJRSxNQUFNLDBCQUEwQkg7SUFDOUMsTUFBTUksTUFBTUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVMO0lBQU8sR0FBR00sSUFBSSxDQUFDO0lBQ3hDLElBQUssSUFBSUMsSUFBSVAsU0FBUyxHQUFHTyxLQUFLLEdBQUdBLElBQUs7UUFDbENKLEdBQUcsQ0FBQ0ksRUFBRSxHQUFHUixRQUFRO1FBQ2pCQSxXQUFXO0lBQ2Y7SUFDQSxPQUFPLElBQUlTLFdBQVdMO0FBQzFCO0FBQ0EsU0FBU00sT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLE1BQU1DLE1BQU0sSUFBSUosV0FBV0UsRUFBRVYsTUFBTTtJQUNuQyxJQUFLLElBQUlPLElBQUksR0FBR0EsSUFBSUcsRUFBRVYsTUFBTSxFQUFFTyxJQUFLO1FBQy9CSyxHQUFHLENBQUNMLEVBQUUsR0FBR0csQ0FBQyxDQUFDSCxFQUFFLEdBQUdJLENBQUMsQ0FBQ0osRUFBRTtJQUN4QjtJQUNBLE9BQU9LO0FBQ1g7QUFDQSxTQUFTWCxLQUFLWSxJQUFJO0lBQ2QsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE9BQ3RCLE1BQU0sSUFBSVgsTUFBTTtBQUN4QjtBQUNBLFNBQVNjLFFBQVFDLEdBQUc7SUFDaEIsSUFBSSxDQUFDekIsa0RBQU9BLENBQUN5QixRQUFRLE9BQU9BLFFBQVEsVUFDaEMsTUFB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LEVBQUUsQ0FBQ0MsS0FBSztZQUN4QixNQUFNYixPQUFPQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHYixVQUFVO2dCQUFFckMsR0FBRzJEO2dCQUFHMUQsR0FBRztnQkFBRzdCLEtBQUs2RDtZQUFZLEdBQUdsQztZQUMzRSxPQUFPRixjQUFjdkIsS0FBSyxHQUFHMEUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQzVDO0lBQ0o7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz9hNjg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF92YWxpZGF0ZU9iamVjdCwgYWJ5dGVzLCBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBpc0J5dGVzLCBpc0hhc2gsIHV0ZjhUb0J5dGVzLCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgRnBJbnZlcnRCYXRjaCwgbW9kIH0gZnJvbSBcIi4vbW9kdWxhci5qc1wiO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBhbnVtKHZhbHVlKTtcbiAgICBhbnVtKGxlbmd0aCk7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEkyT1NQIGlucHV0OiAnICsgdmFsdWUpO1xuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gYW51bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIG5vcm1EU1QoRFNUKSB7XG4gICAgaWYgKCFpc0J5dGVzKERTVCkgJiYgdHlwZW9mIERTVCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRFNUIG11c3QgYmUgVWludDhBcnJheSBvciBzdHJpbmcnKTtcbiAgICByZXR1cm4gdHlwZW9mIERTVCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhEU1QpIDogRFNUO1xufVxuLyoqXG4gKiBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzLlxuICogW1JGQyA5MzgwIDUuMy4xXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgRFNUID0gbm9ybURTVChEU1QpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSChjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG1kOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSBjb25jYXRCeXRlcyhEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoY29uY2F0Qnl0ZXMoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoY29uY2F0Qnl0ZXMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoY29uY2F0Qnl0ZXMoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gY29uY2F0Qnl0ZXMoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG4vKipcbiAqIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuICogMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4gKiAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuICogICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4gKiBbUkZDIDkzODAgNS4zLjJdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjIpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICBEU1QgPSBub3JtRFNUKERTVCk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIC8vIERTVCA9IEgoJ0gyQy1PVkVSU0laRS1EU1QtJyB8fCBhX3ZlcnlfbG9uZ19EU1QsIE1hdGguY2VpbCgobGVuSW5CeXRlcyAqIGspIC8gOCkpO1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgIGNvbnN0IGRrTGVuID0gTWF0aC5jZWlsKCgyICogaykgLyA4KTtcbiAgICAgICAgRFNUID0gSC5jcmVhdGUoeyBka0xlbiB9KS51cGRhdGUodXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICByZXR1cm4gKEguY3JlYXRlKHsgZGtMZW46IGxlbkluQnl0ZXMgfSlcbiAgICAgICAgLnVwZGF0ZShtc2cpXG4gICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXG4gICAgICAgIC8vIDIuIERTVF9wcmltZSA9IERTVCB8fCBJMk9TUChsZW4oRFNUKSwgMSlcbiAgICAgICAgLnVwZGF0ZShEU1QpXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG4gICAgICAgIC5kaWdlc3QoKSk7XG59XG4vKipcbiAqIEhhc2hlcyBhcmJpdHJhcnktbGVuZ3RoIGJ5dGUgc3RyaW5ncyB0byBhIGxpc3Qgb2Ygb25lIG9yIG1vcmUgZWxlbWVudHMgb2YgYSBmaW5pdGUgZmllbGQgRi5cbiAqIFtSRkMgOTM4MCA1LjJdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4yKS5cbiAqIEBwYXJhbSBtc2cgYSBieXRlIHN0cmluZyBjb250YWluaW5nIHRoZSBtZXNzYWdlIHRvIGhhc2hcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIEYgdG8gb3V0cHV0XG4gKiBAcGFyYW0gb3B0aW9ucyBge0RTVDogc3RyaW5nLCBwOiBiaWdpbnQsIG06IG51bWJlciwgazogbnVtYmVyLCBleHBhbmQ6ICd4bWQnIHwgJ3hvZicsIGhhc2g6IEh9YCwgc2VlIGFib3ZlXG4gKiBAcmV0dXJucyBbdV8wLCAuLi4sIHVfKGNvdW50IC0gMSldLCBhIGxpc3Qgb2YgZmllbGQgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoX3RvX2ZpZWxkKG1zZywgY291bnQsIG9wdGlvbnMpIHtcbiAgICBfdmFsaWRhdGVPYmplY3Qob3B0aW9ucywge1xuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ251bWJlcicsXG4gICAgICAgIGs6ICdudW1iZXInLFxuICAgICAgICBoYXNoOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgcCwgaywgbSwgaGFzaCwgZXhwYW5kLCBEU1QgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFpc0hhc2gob3B0aW9ucy5oYXNoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YWxpZCBoYXNoJyk7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYW51bShjb3VudCk7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgY29lZmYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4biwgeGQsIHluLCB5ZF0gPSBjb2VmZi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIC8vIDYuNi4zXG4gICAgICAgIC8vIEV4Y2VwdGlvbmFsIGNhc2VzIG9mIGlzb19tYXAgYXJlIGlucHV0cyB0aGF0IGNhdXNlIHRoZSBkZW5vbWluYXRvciBvZlxuICAgICAgICAvLyBlaXRoZXIgcmF0aW9uYWwgZnVuY3Rpb24gdG8gZXZhbHVhdGUgdG8gemVybzsgc3VjaCBjYXNlcyBNVVNUIHJldHVyblxuICAgICAgICAvLyB0aGUgaWRlbnRpdHkgcG9pbnQgb24gRS5cbiAgICAgICAgY29uc3QgW3hkX2ludiwgeWRfaW52XSA9IEZwSW52ZXJ0QmF0Y2goZmllbGQsIFt4ZCwgeWRdLCB0cnVlKTtcbiAgICAgICAgeCA9IGZpZWxkLm11bCh4biwgeGRfaW52KTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5tdWwoeW4sIHlkX2ludikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBfRFNUX3NjYWxhciA9IHV0ZjhUb0J5dGVzKCdIYXNoVG9TY2FsYXItJyk7XG4vKiogQ3JlYXRlcyBoYXNoLXRvLWN1cnZlIG1ldGhvZHMgZnJvbSBFQyBQb2ludCBhbmQgbWFwVG9DdXJ2ZSBmdW5jdGlvbi4gU2VlIHtAbGluayBIMkNIYXNoZXJ9LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmYXVsdHMpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIGZ1bmN0aW9uIG1hcChudW0pIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZShudW0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXIoaW5pdGlhbCkge1xuICAgICAgICBjb25zdCBQID0gaW5pdGlhbC5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgIGlmIChQLmVxdWFscyhQb2ludC5aRVJPKSlcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPOyAvLyB6ZXJvIHdpbGwgdGhyb3cgaW4gYXNzZXJ0XG4gICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIFA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlZmF1bHRzLFxuICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIG9wdHMpO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBtYXAodVswXSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IG1hcCh1WzFdKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcih1MC5hZGQodTEpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5jb2RlVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHNEc3QgPSBkZWZhdWx0cy5lbmNvZGVEU1QgPyB7IERTVDogZGVmYXVsdHMuZW5jb2RlRFNUIH0gOiB7fTtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0c0RzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIG9wdHMpO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBtYXAodVswXSk7XG4gICAgICAgICAgICByZXR1cm4gY2xlYXIodTApO1xuICAgICAgICB9LFxuICAgICAgICAvKiogU2VlIHtAbGluayBIMkNIYXNoZXJ9ICovXG4gICAgICAgIG1hcFRvQ3VydmUoc2NhbGFycykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjYWxhcnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cycpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIG9mIHNjYWxhcnMpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzJyk7XG4gICAgICAgICAgICByZXR1cm4gY2xlYXIobWFwKHNjYWxhcnMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaGFzaF90b19zY2FsYXIgY2FuIHByb2R1Y2UgMDogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvZXJyYXRhL2VpZDgzOTNcbiAgICAgICAgLy8gUkZDIDkzODAsIGRyYWZ0LWlydGYtY2ZyZy1iYnMtc2lnbmF0dXJlcy0wOFxuICAgICAgICBoYXNoVG9TY2FsYXIobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBOID0gUG9pbnQuRm4uT1JERVI7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHsgcDogTiwgbTogMSwgRFNUOiBfRFNUX3NjYWxhciB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgb3B0cylbMF1bMF07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbIl92YWxpZGF0ZU9iamVjdCIsImFieXRlcyIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwiaXNCeXRlcyIsImlzSGFzaCIsInV0ZjhUb0J5dGVzIiwiRnBJbnZlcnRCYXRjaCIsIm1vZCIsIm9zMmlwIiwiaTJvc3AiLCJ2YWx1ZSIsImxlbmd0aCIsImFudW0iLCJFcnJvciIsInJlcyIsIkFycmF5IiwiZnJvbSIsImZpbGwiLCJpIiwiVWludDhBcnJheSIsInN0cnhvciIsImEiLCJiIiwiYXJyIiwiaXRlbSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJub3JtRFNUIiwiRFNUIiwiZXhwYW5kX21lc3NhZ2VfeG1kIiwibXNnIiwibGVuSW5CeXRlcyIsIkgiLCJvdXRwdXRMZW4iLCJiX2luX2J5dGVzIiwiYmxvY2tMZW4iLCJyX2luX2J5dGVzIiwiZWxsIiwiTWF0aCIsImNlaWwiLCJEU1RfcHJpbWUiLCJaX3BhZCIsImxfaV9iX3N0ciIsImJfMCIsImFyZ3MiLCJwc2V1ZG9fcmFuZG9tX2J5dGVzIiwic2xpY2UiLCJleHBhbmRfbWVzc2FnZV94b2YiLCJrIiwiZGtMZW4iLCJjcmVhdGUiLCJ1cGRhdGUiLCJkaWdlc3QiLCJoYXNoX3RvX2ZpZWxkIiwiY291bnQiLCJvcHRpb25zIiwicCIsIm0iLCJoYXNoIiwiZXhwYW5kIiwibG9nMnAiLCJ0b1N0cmluZyIsIkwiLCJsZW5faW5fYnl0ZXMiLCJwcmIiLCJ1IiwiZSIsImoiLCJlbG1fb2Zmc2V0IiwidHYiLCJzdWJhcnJheSIsImlzb2dlbnlNYXAiLCJmaWVsZCIsIm1hcCIsImNvZWZmIiwicmV2ZXJzZSIsIngiLCJ5IiwieG4iLCJ4ZCIsInluIiwieWQiLCJ2YWwiLCJyZWR1Y2UiLCJhY2MiLCJhZGQiLCJtdWwiLCJ4ZF9pbnYiLCJ5ZF9pbnYiLCJfRFNUX3NjYWxhciIsImNyZWF0ZUhhc2hlciIsIlBvaW50IiwibWFwVG9DdXJ2ZSIsImRlZmF1bHRzIiwibnVtIiwiZnJvbUFmZmluZSIsImNsZWFyIiwiaW5pdGlhbCIsIlAiLCJjbGVhckNvZmFjdG9yIiwiZXF1YWxzIiwiWkVSTyIsImFzc2VydFZhbGlkaXR5IiwiaGFzaFRvQ3VydmUiLCJvcHRzIiwiT2JqZWN0IiwiYXNzaWduIiwidTAiLCJ1MSIsImVuY29kZVRvQ3VydmUiLCJvcHRzRHN0IiwiZW5jb2RlRFNUIiwic2NhbGFycyIsImlzQXJyYXkiLCJoYXNoVG9TY2FsYXIiLCJOIiwiRm4iLCJPUkRFUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpLegendre: () => (/* binding */ FpLegendre),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */ function pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */ function invert(number, modulo) {\n    if (number === _0n) throw new Error(\"invert: expected non-zero number\");\n    if (modulo <= _0n) throw new Error(\"invert: expected positive modulus, got \" + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n)=>{\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n) throw new Error(\"sqrt is not defined for small field\");\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while(Q % _2n === _0n){\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while(FpLegendre(_Fp, Z) === 1){\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000) throw new Error(\"Cannot find square root: probably non-prime P\");\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1) return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n)) return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1) throw new Error(\"Cannot find square root\");\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while(!Fp.eql(t, Fp.ONE)){\n            if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i) ≡ 1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while(!Fp.eql(t_tmp, Fp.ONE)){\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M) throw new Error(\"Cannot find square root\");\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */ function FpSqrt(P) {\n    // P ≡ 3 (mod 4) => √n = n^((P+1)/4)\n    if (P % _4n === _3n) return sqrt3mod4;\n    // P ≡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n) return sqrt5mod8;\n    // P ≡ 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n) return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"number\",\n        BITS: \"number\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(Fp, num, power) {\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (power === _0n) return Fp.ONE;\n    if (power === _1n) return num;\n    let p = Fp.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */ function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */ function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no) throw new Error(\"invalid Legendre symbol result\");\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {\n    if (ORDER <= _0n) throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    let _nbitLength = undefined;\n    let _sqrt = undefined;\n    let modOnDecode = false;\n    let allowedLengths = undefined;\n    if (typeof bitLenOrOpts === \"object\" && bitLenOrOpts != null) {\n        if (opts.sqrt || isLE) throw new Error(\"cannot specify opts in two arguments\");\n        const _opts = bitLenOrOpts;\n        if (_opts.BITS) _nbitLength = _opts.BITS;\n        if (_opts.sqrt) _sqrt = _opts.sqrt;\n        if (typeof _opts.isLE === \"boolean\") isLE = _opts.isLE;\n        if (typeof _opts.modOnDecode === \"boolean\") modOnDecode = _opts.modOnDecode;\n        allowedLengths = _opts.allowedLengths;\n    } else {\n        if (typeof bitLenOrOpts === \"number\") _nbitLength = bitLenOrOpts;\n        if (opts.sqrt) _sqrt = opts.sqrt;\n    }\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n    if (BYTES > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        allowedLengths: allowedLengths,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        // is valid and invertible\n        isValidNot0: (num)=>!f.is0(num) && f.isValid(num),\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: _sqrt || ((n)=>{\n            if (!sqrtP) sqrtP = FpSqrt(ORDER);\n            return sqrtP(f, n);\n        }),\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes, skipValidation = true)=>{\n            if (allowedLengths) {\n                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                    throw new Error(\"Field.fromBytes: expected \" + allowedLengths + \" bytes, got \" + bytes.length);\n                }\n                const padded = new Uint8Array(BYTES);\n                // isLE add 0 to right, !isLE to the left.\n                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n                bytes = padded;\n            }\n            if (bytes.length !== BYTES) throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n            let scalar = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n            if (modOnDecode) scalar = mod(scalar, ORDER);\n            if (!skipValidation) {\n                if (!f.isValid(scalar)) throw new Error(\"invalid field element: outside of range 0..ORDER\");\n            }\n            // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n            // protocol may allow non-reduced scalar that reduced later or changed some other way.\n            return scalar;\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c)=>c ? b : a\n    });\n    return Object.freeze(f);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(\"hashToPrivateScalar: expected \" + minLen + \"-1024 bytes of input, got \" + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDRCxvRUFBb0UsR0FDOEU7QUFDbEosa0JBQWtCO0FBQ2xCLE1BQU1RLE1BQU1DLE9BQU8sSUFBSUMsTUFBTUQsT0FBTyxJQUFJRSxNQUFNLGFBQWEsR0FBR0YsT0FBTyxJQUFJRyxNQUFNLGFBQWEsR0FBR0gsT0FBTztBQUN0RyxrQkFBa0I7QUFDbEIsTUFBTUksTUFBTSxhQUFhLEdBQUdKLE9BQU8sSUFBSUssTUFBTSxhQUFhLEdBQUdMLE9BQU8sSUFBSU0sTUFBTSxhQUFhLEdBQUdOLE9BQU87QUFDckcsa0JBQWtCO0FBQ2xCLE1BQU1PLE1BQU0sYUFBYSxHQUFHUCxPQUFPLElBQUlRLE1BQU0sYUFBYSxHQUFHUixPQUFPLElBQUlTLE9BQU8sYUFBYSxHQUFHVCxPQUFPO0FBQ3RHLHdCQUF3QjtBQUNqQixTQUFTVSxJQUFJQyxDQUFDLEVBQUVDLENBQUM7SUFDcEIsTUFBTUMsU0FBU0YsSUFBSUM7SUFDbkIsT0FBT0MsVUFBVWQsTUFBTWMsU0FBU0QsSUFBSUM7QUFDeEM7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNDLElBQUlDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxNQUFNO0lBQ2xDLE9BQU9DLE1BQU1DLE1BQU1GLFNBQVNGLEtBQUtDO0FBQ3JDO0FBQ0EsMERBQTBELEdBQ25ELFNBQVNJLEtBQUtDLENBQUMsRUFBRUwsS0FBSyxFQUFFQyxNQUFNO0lBQ2pDLElBQUlLLE1BQU1EO0lBQ1YsTUFBT0wsVUFBVWpCLElBQUs7UUFDbEJ1QixPQUFPQTtRQUNQQSxPQUFPTDtJQUNYO0lBQ0EsT0FBT0s7QUFDWDtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNDLE9BQU9DLE1BQU0sRUFBRVAsTUFBTTtJQUNqQyxJQUFJ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O0lBQ3hELE1BQU04QyxNQUFNRCxJQUFJdkUsTUFBTTtJQUN0QixNQUFNeUUsV0FBV1Asb0JBQW9CQztJQUNyQyxNQUFNRixTQUFTSSxpQkFBaUJGO0lBQ2hDLGlHQUFpRztJQUNqRyxJQUFJSyxNQUFNLE1BQU1BLE1BQU1QLFVBQVVPLE1BQU0sTUFDbEMsTUFBTSxJQUFJdkosTUFBTSxjQUFjZ0osU0FBUywrQkFBK0JPO0lBQzFFLE1BQU1qSyxNQUFNbUgsT0FBT3ZJLDBEQUFlQSxDQUFDb0wsT0FBT3JMLDBEQUFlQSxDQUFDcUw7SUFDMUQsK0VBQStFO0lBQy9FLE1BQU1HLFVBQVV4SyxJQUFJSyxLQUFLNEosYUFBYTFLLE9BQU9BO0lBQzdDLE9BQU9pSSxPQUFPcEksMERBQWVBLENBQUNvTCxTQUFTRCxZQUFZcEwsMERBQWVBLENBQUNxTCxTQUFTRDtBQUNoRixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcz9mZDQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbHMgZm9yIG1vZHVsYXIgZGl2aXNpb24gYW5kIGZpZWxkcy5cbiAqIEZpZWxkIG92ZXIgMTEgaXMgYSBmaW5pdGUgKEdhbG9pcykgZmllbGQgaXMgaW50ZWdlciBudW1iZXIgb3BlcmF0aW9ucyBgbW9kIDExYC5cbiAqIFRoZXJlIGlzIG5vIGRpdmlzaW9uOiBpdCBpcyByZXBsYWNlZCBieSBtb2R1bGFyIG11bHRpcGxpY2F0aXZlIGludmVyc2UuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IF92YWxpZGF0ZU9iamVjdCwgYW51bWJlciwgYml0TWFzaywgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiksIF8zbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNCksIF81biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNSksIF83biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF84biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoOCksIF85biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoOSksIF8xNm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICByZXR1cm4gRnBQb3coRmllbGQobW9kdWxvKSwgbnVtLCBwb3dlcik7XG59XG4vKiogRG9lcyBgeF4oMl5wb3dlcilgIG1vZCBwLiBgcG93MigzMCwgNClgID09IGAzMF4oMl40KWAgKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG8uXG4gKiBJbXBsZW1lbnRlZCB1c2luZyBbRXVjbGlkZWFuIEdDRF0oaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS8pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgbm9uLXplcm8gbnVtYmVyJyk7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBtb2R1bHVzLCBnb3QgJyArIG1vZHVsbyk7XG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1NxdWFyZShGcCwgcm9vdCwgbikge1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbn1cbi8vIE5vdCBhbGwgcm9vdHMgYXJlIHBvc3NpYmxlISBFeGFtcGxlIHdoaWNoIHdpbGwgdGhyb3c6XG4vLyBjb25zdCBOVU0gPVxuLy8gbiA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbi8vIEZwID0gRmllbGQoQmlnSW50KCcweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYicpKTtcbmZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgIGNvbnN0IHAxZGl2NCA9IChGcC5PUkRFUiArIF8xbikgLyBfNG47XG4gICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgIGFzc2VydElzU3F1YXJlKEZwLCByb290LCBuKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgIGNvbnN0IHA1ZGl2OCA9IChGcC5PUkRFUiAtIF81bikgLyBfOG47XG4gICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICBjb25zdCB2ID0gRnAucG93KG4yLCBwNWRpdjgpO1xuICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgYXNzZXJ0SXNTcXVhcmUoRnAsIHJvb3QsIG4pO1xuICAgIHJldHVybiByb290O1xufVxuLy8gQmFzZWQgb24gUkZDOTM4MCwgS29uZyBhbGdvcml0aG1cbi8vIHByZXR0aWVyLWlnbm9yZVxuZnVuY3Rpb24gc3FydDltb2QxNihQKSB7XG4gICAgY29uc3QgRnBfID0gRmllbGQoUCk7XG4gICAgY29uc3QgdG4gPSB0b25lbGxpU2hhbmtzKFApO1xuICAgIGNvbnN0IGMxID0gdG4oRnBfLCBGcF8ubmVnKEZwXy5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICBjb25zdCBjMiA9IHRuKEZwXywgYzEpOyAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgIGNvbnN0IGMzID0gdG4oRnBfLCBGcF8ubmVnKGMxKSk7IC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47IC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKEZwLCBuKSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBGcC5wb3cobiwgYzQpOyAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICBsZXQgdHYyID0gRnAubXVsKHR2MSwgYzEpOyAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKHR2MSwgYzIpOyAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgY29uc3QgdHY0ID0gRnAubXVsKHR2MSwgYzMpOyAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgY29uc3QgZTEgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIGNvbnN0IGUyID0gRnAuZXFsKEZwLnNxcih0djMpLCBuKTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIGNvbnN0IGUzID0gRnAuZXFsKEZwLnNxcih0djIpLCBuKTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICBjb25zdCByb290ID0gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICAjIFNlbGVjdCBzcXJ0IGZyb20gdHYxICYgdHYyXG4gICAgICAgIGFzc2VydElzU3F1YXJlKEZwLCByb290LCBuKTtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIEluaXRpYWxpemF0aW9uIChwcmVjb21wdXRhdGlvbikuXG4gICAgLy8gQ2FjaGluZyBpbml0aWFsaXphdGlvbiBjb3VsZCBib29zdCBwZXJmIGJ5IDclLlxuICAgIGlmIChQIDwgXzNuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxcnQgaXMgbm90IGRlZmluZWQgZm9yIHNtYWxsIGZpZWxkJyk7XG4gICAgLy8gRmFjdG9yIFAgLSAxID0gUSAqIDJeUywgd2hlcmUgUSBpcyBvZGRcbiAgICBsZXQgUSA9IFAgLSBfMW47XG4gICAgbGV0IFMgPSAwO1xuICAgIHdoaWxlIChRICUgXzJuID09PSBfMG4pIHtcbiAgICAgICAgUSAvPSBfMm47XG4gICAgICAgIFMrKztcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgcXVhZHJhdGljIG5vbi1yZXNpZHVlIFogPj0gMlxuICAgIGxldCBaID0gXzJuO1xuICAgIGNvbnN0IF9GcCA9IEZpZWxkKFApO1xuICAgIHdoaWxlIChGcExlZ2VuZHJlKF9GcCwgWikgPT09IDEpIHtcbiAgICAgICAgLy8gQmFzaWMgcHJpbWFsaXR5IHRlc3QgZm9yIFAuIEFmdGVyIHggaXRlcmF0aW9ucywgY2hhbmNlIG9mXG4gICAgICAgIC8vIG5vdCBmaW5kaW5nIHF1YWRyYXRpYyBub24tcmVzaWR1ZSBpcyAyXngsIHNvIDJeMTAwMC5cbiAgICAgICAgaWYgKForKyA+IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290OiBwcm9iYWJseSBub24tcHJpbWUgUCcpO1xuICAgIH1cbiAgICAvLyBGYXN0LXBhdGg7IHVzdWFsbHkgZG9uZSBiZWZvcmUgWiwgYnV0IHdlIGRvIFwicHJpbWFsaXR5IHRlc3RcIi5cbiAgICBpZiAoUyA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHNxcnQzbW9kNDtcbiAgICAvLyBTbG93LXBhdGhcbiAgICAvLyBUT0RPOiB0ZXN0IG9uIEZwMiBhbmQgb3RoZXJzXG4gICAgbGV0IGNjID0gX0ZwLnBvdyhaLCBRKTsgLy8gYyA9IHpeUVxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgaWYgKEZwLmlzMChuKSlcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAvLyBDaGVjayBpZiBuIGlzIGEgcXVhZHJhdGljIHJlc2lkdWUgdXNpbmcgTGVnZW5kcmUgc3ltYm9sXG4gICAgICAgIGlmIChGcExlZ2VuZHJlKEZwLCBuKSAhPT0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXMgZm9yIHRoZSBtYWluIGxvb3BcbiAgICAgICAgbGV0IE0gPSBTO1xuICAgICAgICBsZXQgYyA9IEZwLm11bChGcC5PTkUsIGNjKTsgLy8gYyA9IHpeUSwgbW92ZSBjYyBmcm9tIGZpZWxkIF9GcCBpbnRvIGZpZWxkIEZwXG4gICAgICAgIGxldCB0ID0gRnAucG93KG4sIFEpOyAvLyB0ID0gbl5RLCBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIGxldCBSID0gRnAucG93KG4sIFExZGl2Mik7IC8vIFIgPSBuXigoUSsxKS8yKSwgZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIC8vIE1haW4gbG9vcFxuICAgICAgICAvLyB3aGlsZSB0ICE9IDFcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwodCwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmlzMCh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaWYgdD0wIHJldHVybiBSPTBcbiAgICAgICAgICAgIGxldCBpID0gMTtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHNtYWxsZXN0IGkgPj0gMSBzdWNoIHRoYXQgdF4oMl5pKSDiiaEgMSAobW9kIFApXG4gICAgICAgICAgICBsZXQgdF90bXAgPSBGcC5zcXIodCk7IC8vIHReKDJeMSlcbiAgICAgICAgICAgIHdoaWxlICghRnAuZXFsKHRfdG1wLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHRfdG1wID0gRnAuc3FyKHRfdG1wKTsgLy8gdF4oMl4yKS4uLlxuICAgICAgICAgICAgICAgIGlmIChpID09PSBNKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGV4cG9uZW50IGZvciBiOiAyXihNIC0gaSAtIDEpXG4gICAgICAgICAgICBjb25zdCBleHBvbmVudCA9IF8xbiA8PCBCaWdJbnQoTSAtIGkgLSAxKTsgLy8gYmlnaW50IGlzIGltcG9ydGFudFxuICAgICAgICAgICAgY29uc3QgYiA9IEZwLnBvdyhjLCBleHBvbmVudCk7IC8vIGIgPSAyXihNIC0gaSAtIDEpXG4gICAgICAgICAgICAvLyBVcGRhdGUgdmFyaWFibGVzXG4gICAgICAgICAgICBNID0gaTtcbiAgICAgICAgICAgIGMgPSBGcC5zcXIoYik7IC8vIGMgPSBiXjJcbiAgICAgICAgICAgIHQgPSBGcC5tdWwodCwgYyk7IC8vIHQgPSAodCAqIGJeMilcbiAgICAgICAgICAgIFIgPSBGcC5tdWwoUiwgYik7IC8vIFIgPSBSKmJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUjtcbiAgICB9O1xufVxuLyoqXG4gKiBTcXVhcmUgcm9vdCBmb3IgYSBmaW5pdGUgZmllbGQuIFdpbGwgdHJ5IG9wdGltaXplZCB2ZXJzaW9ucyBmaXJzdDpcbiAqXG4gKiAxLiBQIOKJoSAzIChtb2QgNClcbiAqIDIuIFAg4omhIDUgKG1vZCA4KVxuICogMy4gUCDiiaEgOSAobW9kIDE2KVxuICogNC4gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gKlxuICogRGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICogRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIFAg4omhIDMgKG1vZCA0KSA9PiDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKVxuICAgICAgICByZXR1cm4gc3FydDNtb2Q0O1xuICAgIC8vIFAg4omhIDUgKG1vZCA4KSA9PiBBdGtpbiBhbGdvcml0aG0sIHBhZ2UgMTAgb2YgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bilcbiAgICAgICAgcmV0dXJuIHNxcnQ1bW9kODtcbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpID0+IEtvbmcgYWxnb3JpdGhtLCBwYWdlIDExIG9mIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAoYWxnb3JpdGhtIDQpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pXG4gICAgICAgIHJldHVybiBzcXJ0OW1vZDE2KFApO1xuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnbnVtYmVyJyxcbiAgICAgICAgQklUUzogJ251bWJlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIF92YWxpZGF0ZU9iamVjdChmaWVsZCwgb3B0cyk7XG4gICAgLy8gY29uc3QgbWF4ID0gMTYzODQ7XG4gICAgLy8gaWYgKGZpZWxkLkJZVEVTIDwgMSB8fCBmaWVsZC5CWVRFUyA+IG1heCkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkJyk7XG4gICAgLy8gaWYgKGZpZWxkLkJJVFMgPCAxIHx8IGZpZWxkLkJJVFMgPiA4ICogbWF4KSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQnKTtcbiAgICByZXR1cm4gZmllbGQ7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBQb3coRnAsIG51bSwgcG93ZXIpIHtcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBleHBvbmVudCwgbmVnYXRpdmVzIHVuc3VwcG9ydGVkJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBGcC5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBGcC5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBGcC5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBGcC5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBFeGNlcHRpb24tZnJlZS4gV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIDAgZWxlbWVudHMuXG4gKiBAcGFyYW0gcGFzc1plcm8gbWFwIDAgdG8gMCAoaW5zdGVhZCBvZiB1bmRlZmluZWQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKEZwLCBudW1zLCBwYXNzWmVybyA9IGZhbHNlKSB7XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpLmZpbGwocGFzc1plcm8gPyBGcC5aRVJPIDogdW5kZWZpbmVkKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbXVsdGlwbGllZEFjYyA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoRnAuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICBpbnZlcnRlZFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIEZwLm11bChhY2MsIG51bSk7XG4gICAgfSwgRnAuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWRBY2MgPSBGcC5pbnYobXVsdGlwbGllZEFjYyk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChGcC5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIGludmVydGVkW2ldID0gRnAubXVsKGFjYywgaW52ZXJ0ZWRbaV0pO1xuICAgICAgICByZXR1cm4gRnAubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZEFjYyk7XG4gICAgcmV0dXJuIGludmVydGVkO1xufVxuLy8gVE9ETzogcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gRnBEaXYoRnAsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIEZwLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgRnAuT1JERVIpIDogRnAuaW52KHJocykpO1xufVxuLyoqXG4gKiBMZWdlbmRyZSBzeW1ib2wuXG4gKiBMZWdlbmRyZSBjb25zdGFudCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKVxuICogd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAqXG4gKiAqIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApLCBxdWFkcmF0aWMgcmVzaWR1ZVxuICogKiAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyBub24gcmVzaWR1ZVxuICogKiAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBMZWdlbmRyZShGcCwgbikge1xuICAgIC8vIFdlIGNhbiB1c2UgM3JkIGFyZ3VtZW50IGFzIG9wdGlvbmFsIGNhY2hlIG9mIHRoaXMgdmFsdWVcbiAgICAvLyBidXQgc2VlbXMgdW5uZWVkZWQgZm9yIG5vdy4gVGhlIG9wZXJhdGlvbiBpcyB2ZXJ5IGZhc3QuXG4gICAgY29uc3QgcDFtb2QyID0gKEZwLk9SREVSIC0gXzFuKSAvIF8ybjtcbiAgICBjb25zdCBwb3dlcmVkID0gRnAucG93KG4sIHAxbW9kMik7XG4gICAgY29uc3QgeWVzID0gRnAuZXFsKHBvd2VyZWQsIEZwLk9ORSk7XG4gICAgY29uc3QgemVybyA9IEZwLmVxbChwb3dlcmVkLCBGcC5aRVJPKTtcbiAgICBjb25zdCBubyA9IEZwLmVxbChwb3dlcmVkLCBGcC5uZWcoRnAuT05FKSk7XG4gICAgaWYgKCF5ZXMgJiYgIXplcm8gJiYgIW5vKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgTGVnZW5kcmUgc3ltYm9sIHJlc3VsdCcpO1xuICAgIHJldHVybiB5ZXMgPyAxIDogemVybyA/IDAgOiAtMTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoRnAsIG4pIHtcbiAgICBjb25zdCBsID0gRnBMZWdlbmRyZShGcCwgbik7XG4gICAgcmV0dXJuIGwgPT09IDE7XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBpZiAobkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhbnVtYmVyKG5CaXRMZW5ndGgpO1xuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBmaW5pdGUgZmllbGQuIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIDEuIERlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bC5cbiAqICogMi4gSWRlbnRpY2FsIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzLlxuICogKiAzLiBgT2JqZWN0LmZyZWV6ZWAuXG4gKiBGcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogU2VjdXJpdHkgbm90ZTogb3BlcmF0aW9ucyBkb24ndCBjaGVjayAnaXNWYWxpZCcgZm9yIGFsbCBlbGVtZW50cyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyxcbiAqIGl0IGlzIGNhbGxlciByZXNwb25zaWJpbGl0eSB0byBjaGVjayB0aGlzLlxuICogVGhpcyBpcyBsb3ctbGV2ZWwgY29kZSwgcGxlYXNlIG1ha2Ugc3VyZSB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAqXG4gKiBOb3RlIGFib3V0IGZpZWxkIHByb3BlcnRpZXM6XG4gKiAqIENIQVJBQ1RFUklTVElDIHAgPSBwcmltZSBudW1iZXIsIG51bWJlciBvZiBlbGVtZW50cyBpbiBtYWluIHN1Ymdyb3VwLlxuICogKiBPUkRFUiBxID0gc2ltaWxhciB0byBjb2ZhY3RvciBpbiBjdXJ2ZXMsIG1heSBiZSBjb21wb3NpdGUgYHEgPSBwXm1gLlxuICpcbiAqIEBwYXJhbSBPUkRFUiBmaWVsZCBvcmRlciwgcHJvYmFibHkgcHJpbWUsIG9yIGNvdWxkIGJlIGNvbXBvc2l0ZVxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZmF1bHQ6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbk9yT3B0cywgLy8gVE9ETzogdXNlIG9wdHMgb25seSBpbiB2Mj9cbmlzTEUgPSBmYWxzZSwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkOiBleHBlY3RlZCBPUkRFUiA+IDAsIGdvdCAnICsgT1JERVIpO1xuICAgIGxldCBfbmJpdExlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgX3NxcnQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IG1vZE9uRGVjb2RlID0gZmFsc2U7XG4gICAgbGV0IGFsbG93ZWRMZW5ndGhzID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgYml0TGVuT3JPcHRzID09PSAnb2JqZWN0JyAmJiBiaXRMZW5Pck9wdHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0cy5zcXJ0IHx8IGlzTEUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzcGVjaWZ5IG9wdHMgaW4gdHdvIGFyZ3VtZW50cycpO1xuICAgICAgICBjb25zdCBfb3B0cyA9IGJpdExlbk9yT3B0cztcbiAgICAgICAgaWYgKF9vcHRzLkJJVFMpXG4gICAgICAgICAgICBfbmJpdExlbmd0aCA9IF9vcHRzLkJJVFM7XG4gICAgICAgIGlmIChfb3B0cy5zcXJ0KVxuICAgICAgICAgICAgX3NxcnQgPSBfb3B0cy5zcXJ0O1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzLmlzTEUgPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIGlzTEUgPSBfb3B0cy5pc0xFO1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzLm1vZE9uRGVjb2RlID09PSAnYm9vbGVhbicpXG4gICAgICAgICAgICBtb2RPbkRlY29kZSA9IF9vcHRzLm1vZE9uRGVjb2RlO1xuICAgICAgICBhbGxvd2VkTGVuZ3RocyA9IF9vcHRzLmFsbG93ZWRMZW5ndGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiaXRMZW5Pck9wdHMgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgX25iaXRMZW5ndGggPSBiaXRMZW5Pck9wdHM7XG4gICAgICAgIGlmIChvcHRzLnNxcnQpXG4gICAgICAgICAgICBfc3FydCA9IG9wdHMuc3FydDtcbiAgICB9XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIF9uYml0TGVuZ3RoKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSIG9mIDw9IDIwNDggYnl0ZXMnKTtcbiAgICBsZXQgc3FydFA7IC8vIGNhY2hlZCBzcXJ0UFxuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIGlzTEUsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBhbGxvd2VkTGVuZ3RoczogYWxsb3dlZExlbmd0aHMsXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICcgKyB0eXBlb2YgbnVtKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIC8vIGlzIHZhbGlkIGFuZCBpbnZlcnRpYmxlXG4gICAgICAgIGlzVmFsaWROb3QwOiAobnVtKSA9PiAhZi5pczAobnVtKSAmJiBmLmlzVmFsaWQobnVtKSxcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiBfc3FydCB8fFxuICAgICAgICAgICAgKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcXJ0UClcbiAgICAgICAgICAgICAgICAgICAgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcXJ0UChmLCBuKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzLCBza2lwVmFsaWRhdGlvbiA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIGlmIChhbGxvd2VkTGVuZ3Rocykge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dlZExlbmd0aHMuaW5jbHVkZXMoYnl0ZXMubGVuZ3RoKSB8fCBieXRlcy5sZW5ndGggPiBCWVRFUykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkLmZyb21CeXRlczogZXhwZWN0ZWQgJyArIGFsbG93ZWRMZW5ndGhzICsgJyBieXRlcywgZ290ICcgKyBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheShCWVRFUyk7XG4gICAgICAgICAgICAgICAgLy8gaXNMRSBhZGQgMCB0byByaWdodCwgIWlzTEUgdG8gdGhlIGxlZnQuXG4gICAgICAgICAgICAgICAgcGFkZGVkLnNldChieXRlcywgaXNMRSA/IDAgOiBwYWRkZWQubGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBieXRlcyA9IHBhZGRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQuZnJvbUJ5dGVzOiBleHBlY3RlZCAnICsgQllURVMgKyAnIGJ5dGVzLCBnb3QgJyArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgc2NhbGFyID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICAgICAgaWYgKG1vZE9uRGVjb2RlKVxuICAgICAgICAgICAgICAgIHNjYWxhciA9IG1vZChzY2FsYXIsIE9SREVSKTtcbiAgICAgICAgICAgIGlmICghc2tpcFZhbGlkYXRpb24pXG4gICAgICAgICAgICAgICAgaWYgKCFmLmlzVmFsaWQoc2NhbGFyKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IG91dHNpZGUgb2YgcmFuZ2UgMC4uT1JERVInKTtcbiAgICAgICAgICAgIC8vIE5PVEU6IHdlIGRvbid0IHZhbGlkYXRlIHNjYWxhciBoZXJlLCBwbGVhc2UgdXNlIGlzVmFsaWQuIFRoaXMgZG9uZSBzdWNoIHdheSBiZWNhdXNlIHNvbWVcbiAgICAgICAgICAgIC8vIHByb3RvY29sIG1heSBhbGxvdyBub24tcmVkdWNlZCBzY2FsYXIgdGhhdCByZWR1Y2VkIGxhdGVyIG9yIGNoYW5nZWQgc29tZSBvdGhlciB3YXkuXG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUT0RPOiB3ZSBkb24ndCBuZWVkIGl0IGhlcmUsIG1vdmUgb3V0IHRvIHNlcGFyYXRlIGZuXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFdlIGNhbid0IG1vdmUgdGhpcyBvdXQgYmVjYXVzZSBGcDYsIEZwMTIgaW1wbGVtZW50IGl0XG4gICAgICAgIC8vIGFuZCBpdCdzIHVuY2xlYXIgd2hhdCB0byByZXR1cm4gaW4gdGhlcmUuXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbi8vIEdlbmVyaWMgcmFuZG9tIHNjYWxhciwgd2UgY2FuIGRvIHNhbWUgZm9yIG90aGVyIGZpZWxkcyBpZiB2aWEgRnAyLm11bChGcDIuT05FLCBGcDIucmFuZG9tKT9cbi8vIFRoaXMgYWxsb3dzIHVuc2FmZSBtZXRob2RzIGxpa2UgaWdub3JlIGJpYXMgb3IgemVyby4gVGhlc2UgdW5zYWZlLCBidXQgb2Z0ZW4gdXNlZCBpbiBkaWZmZXJlbnQgcHJvdG9jb2xzIChpZiBkZXRlcm1pbmlzdGljIFJORykuXG4vLyB3aGljaCBtZWFuIHdlIGNhbm5vdCBmb3JjZSB0aGlzIHZpYSBvcHRzLlxuLy8gTm90IHN1cmUgd2hhdCB0byBkbyB3aXRoIHJhbmRvbUJ5dGVzLCB3ZSBjYW4gYWNjZXB0IGl0IGluc2lkZSBvcHRzIGlmIHdhbnRlZC5cbi8vIFByb2JhYmx5IG5lZWQgdG8gZXhwb3J0IGdldE1pbkhhc2hMZW5ndGggc29tZXdoZXJlP1xuLy8gcmFuZG9tKGJ5dGVzPzogVWludDhBcnJheSwgdW5zYWZlQWxsb3daZXJvID0gZmFsc2UsIHVuc2FmZUFsbG93QmlhcyA9IGZhbHNlKSB7XG4vLyAgIGNvbnN0IExFTiA9ICF1bnNhZmVBbGxvd0JpYXMgPyBnZXRNaW5IYXNoTGVuZ3RoKE9SREVSKSA6IEJZVEVTO1xuLy8gICBpZiAoYnl0ZXMgPT09IHVuZGVmaW5lZCkgYnl0ZXMgPSByYW5kb21CeXRlcyhMRU4pOyAvLyBfb3B0cy5yYW5kb21CeXRlcz9cbi8vICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuLy8gICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4vLyAgIGNvbnN0IHJlZHVjZWQgPSB1bnNhZmVBbGxvd1plcm8gPyBtb2QobnVtLCBPUkRFUikgOiBtb2QobnVtLCBPUkRFUiAtIF8xbikgKyBfMW47XG4vLyAgIHJldHVybiByZWR1Y2VkO1xuLy8gfSxcbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkXCIpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBgbWFwS2V5VG9GaWVsZGAgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgaGFzaExlbik7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgbGVuKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGtleSkgOiBieXRlc1RvTnVtYmVyQkUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6WyJfdmFsaWRhdGVPYmplY3QiLCJhbnVtYmVyIiwiYml0TWFzayIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwibnVtYmVyVG9CeXRlc0JFIiwibnVtYmVyVG9CeXRlc0xFIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzNuIiwiXzRuIiwiXzVuIiwiXzduIiwiXzhuIiwiXzluIiwiXzE2biIsIm1vZCIsImEiLCJiIiwicmVzdWx0IiwicG93IiwibnVtIiwicG93ZXIiLCJtb2R1bG8iLCJGcFBvdyIsIkZpZWxkIiwicG93MiIsIngiLCJyZXMiLCJpbnZlcnQiLCJudW1iZXIiLCJFcnJvciIsInkiLCJ1IiwidiIsInEiLCJyIiwibSIsIm4iLCJnY2QiLCJhc3NlcnRJc1NxdWFyZSIsIkZwIiwicm9vdCIsImVxbCIsInNxciIsInNxcnQzbW9kNCIsInAxZGl2NCIsIk9SREVSIiwic3FydDVtb2Q4IiwicDVkaXY4IiwibjIiLCJtdWwiLCJudiIsImkiLCJzdWIiLCJPTkUiLCJzcXJ0OW1vZDE2IiwiUCIsIkZwXyIsInRuIiwidG9uZWxsaVNoYW5rcyIsImMxIiwibmVnIiwiYzIiLCJjMyIsImM0IiwidHYxIiwidHYyIiwidHYzIiwidHY0IiwiZTEiLCJlMiIsImNtb3YiLCJlMyIsIlEiLCJTIiwiWiIsIl9GcCIsIkZwTGVnZW5kcmUiLCJjYyIsIlExZGl2MiIsInRvbmVsbGlTbG93IiwiaXMwIiwiTSIsImMiLCJ0IiwiUiIsIlpFUk8iLCJ0X3RtcCIsImV4cG9uZW50IiwiRnBTcXJ0IiwiaXNOZWdhdGl2ZUxFIiwiRklFTERfRklFTERTIiwidmFsaWRhdGVGaWVsZCIsImZpZWxkIiwiaW5pdGlhbCIsIk1BU0siLCJCWVRFUyIsIkJJVFMiLCJvcHRzIiwicmVkdWNlIiwibWFwIiwidmFsIiwicCIsImQiLCJGcEludmVydEJhdGNoIiwibnVtcyIsInBhc3NaZXJvIiwiaW52ZXJ0ZWQiLCJBcnJheSIsImxlbmd0aCIsImZpbGwiLCJ1bmRlZmluZWQiLCJtdWx0aXBsaWVkQWNjIiwiYWNjIiwiaW52ZXJ0ZWRBY2MiLCJpbnYiLCJyZWR1Y2VSaWdodCIsIkZwRGl2IiwibGhzIiwicmhzIiwicDFtb2QyIiwicG93ZXJlZCIsInllcyIsInplcm8iLCJubyIsIkZwSXNTcXVhcmUiLCJsIiwibkxlbmd0aCIsIm5CaXRMZW5ndGgiLCJfbkJpdExlbmd0aCIsInRvU3RyaW5nIiwibkJ5dGVMZW5ndGgiLCJNYXRoIiwiY2VpbCIsImJpdExlbk9yT3B0cyIsImlzTEUiLCJfbmJpdExlbmd0aCIsIl9zcXJ0IiwibW9kT25EZWNvZGUiLCJhbGxvd2VkTGVuZ3RocyIsInNxcnQiLCJfb3B0cyIsInNxcnRQIiwiZiIsIk9iamVjdCIsImZyZWV6ZSIsImNyZWF0ZSIsImlzVmFsaWQiLCJpc1ZhbGlkTm90MCIsImlzT2RkIiwiYWRkIiwiZGl2Iiwic3FyTiIsImFkZE4iLCJzdWJOIiwibXVsTiIsInRvQnl0ZXMiLCJmcm9tQnl0ZXMiLCJieXRlcyIsInNraXBWYWxpZGF0aW9uIiwiaW5jbHVkZXMiLCJwYWRkZWQiLCJVaW50OEFycmF5Iiwic2V0Iiwic2NhbGFyIiwiaW52ZXJ0QmF0Y2giLCJsc3QiLCJGcFNxcnRPZGQiLCJlbG0iLCJGcFNxcnRFdmVuIiwiaGFzaFRvUHJpdmF0ZVNjYWxhciIsImhhc2giLCJncm91cE9yZGVyIiwiaGFzaExlbiIsIm1pbkxlbiIsImdldEZpZWxkQnl0ZXNMZW5ndGgiLCJmaWVsZE9yZGVyIiwiYml0TGVuZ3RoIiwiZ2V0TWluSGFzaExlbmd0aCIsIm1hcEhhc2hUb0ZpZWxkIiwia2V5IiwibGVuIiwiZmllbGRMZW4iLCJyZWR1Y2VkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/montgomery.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/montgomery.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   montgomery: () => (/* binding */ montgomery)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction validateOpts(curve) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(curve, {\n        adjustScalarBytes: \"function\",\n        powPminus2: \"function\"\n    });\n    return Object.freeze({\n        ...curve\n    });\n}\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n    const is25519 = type === \"x25519\";\n    if (!is25519 && type !== \"x448\") throw new Error(\"invalid type\");\n    const randomBytes_ = rand || _utils_js__WEBPACK_IMPORTED_MODULE_1__.randomBytes;\n    const montgomeryBits = is25519 ? 255 : 448;\n    const fieldLen = is25519 ? 32 : 56;\n    const Gu = is25519 ? BigInt(9) : BigInt(5);\n    // RFC 7748 #5:\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n    // (156326 - 2) / 4 = 39081 for curve448/X448\n    // const a = is25519 ? 156326n : 486662n;\n    const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n    // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n    // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n    // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n    const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;\n    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n    const modP = (n)=>(0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(n, P);\n    const GuBytes = encodeU(Gu);\n    function encodeU(u) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(modP(u), fieldLen);\n    }\n    function decodeU(u) {\n        const _u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"u coordinate\", u, fieldLen);\n        // RFC: When receiving such an array, implementations of X25519\n        // (but not X448) MUST mask the most significant bit in the final byte.\n        if (is25519) _u[31] &= 127; // 0b0111_1111\n        // RFC: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.  The non-canonical\n        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n        // - 1 through 2^448 - 1 for X448.\n        return modP((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(_u));\n    }\n    function decodeScalar(scalar) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(adjustScalarBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"scalar\", scalar, fieldLen)));\n    }\n    function scalarMult(scalar, u) {\n        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n        // Some public keys are useless, of low-order. Curve author doesn't think\n        // it needs to be validated, but we do it nonetheless.\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n) throw new Error(\"invalid private or public key received\");\n        return encodeU(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    // cswap from RFC7748 \"example code\"\n    function cswap(swap, x_2, x_3) {\n        // dummy = mask(swap) AND (x_2 XOR x_3)\n        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n        // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n        return {\n            x_2,\n            x_3\n        };\n    }\n    /**\n     * Montgomery x-only multiplication ladder.\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */ function montgomeryLadder(u, scalar) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"u\", u, _0n, P);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"scalar\", scalar, minScalar, maxScalar);\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        for(let t = BigInt(montgomeryBits - 1); t >= _0n; t--){\n            const k_t = k >> t & _1n;\n            swap ^= k_t;\n            ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n    }\n    const randomSecretKey = (seed = randomBytes_(fieldLen))=>seed;\n    const utils = {\n        randomSecretKey,\n        randomPrivateKey: randomSecretKey\n    };\n    function keygen(seed) {\n        const secretKey = utils.randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: scalarMultBase(secretKey)\n        };\n    }\n    const lengths = {\n        secret: fieldLen,\n        public: fieldLen,\n        seed: fieldLen\n    };\n    return {\n        keygen,\n        getSharedSecret: (secretKey, publicKey)=>scalarMult(secretKey, publicKey),\n        getPublicKey: (secretKey)=>scalarMultBase(secretKey),\n        scalarMult,\n        scalarMultBase,\n        utils,\n        GuBytes: GuBytes.slice(),\n        info: {\n            type: \"montgomery\",\n            lengths\n        }\n    };\n} //# sourceMappingURL=montgomery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb250Z29tZXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNELG9FQUFvRSxHQUNpRDtBQUNsRjtBQUNuQyxNQUFNTyxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixTQUFTRyxhQUFhQyxLQUFLO0lBQ3ZCWiwwREFBZUEsQ0FBQ1ksT0FBTztRQUNuQkMsbUJBQW1CO1FBQ25CQyxZQUFZO0lBQ2hCO0lBQ0EsT0FBT0MsT0FBT0MsTUFBTSxDQUFDO1FBQUUsR0FBR0osS0FBSztJQUFDO0FBQ3BDO0FBQ08sU0FBU0ssV0FBV0MsUUFBUTtJQUMvQixNQUFNQyxRQUFRUixhQUFhTztJQUMzQixNQUFNLEVBQUVFLENBQUMsRUFBRUMsSUFBSSxFQUFFUixpQkFBaUIsRUFBRUMsVUFBVSxFQUFFVCxhQUFhaUIsSUFBSSxFQUFFLEdBQUdIO0lBQ3RFLE1BQU1JLFVBQVVGLFNBQVM7SUFDekIsSUFBSSxDQUFDRSxXQUFXRixTQUFTLFFBQ3JCLE1BQU0sSUFBSUcsTUFBTTtJQUNwQixNQUFNQyxlQUFlSCxRQUFRakIsa0RBQVdBO0lBQ3hDLE1BQU1xQixpQkFBaUJILFVBQVUsTUFBTTtJQUN2QyxNQUFNSSxXQUFXSixVQUFVLEtBQUs7SUFDaEMsTUFBTUssS0FBS0wsVUFBVWYsT0FBTyxLQUFLQSxPQUFPO0lBQ3hDLGVBQWU7SUFDZiwwRUFBMEU7SUFDMUUsNkNBQTZDO0lBQzdDLHlDQUF5QztJQUN6QyxNQUFNcUIsTUFBTU4sVUFBVWYsT0FBTyxVQUFVQSxPQUFPO0lBQzlDLCtEQUErRDtJQUMvRCwyREFBMkQ7SUFDM0QsNEVBQTRFO0lBQzVFLE1BQU1zQixZQUFZUCxVQUFVYixPQUFPRixPQUFPLE9BQU9FLE9BQU9GLE9BQU87SUFDL0QsTUFB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UTtJQUN4QztBQUNKLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb250Z29tZXJ5LmpzPzQ2YTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb250Z29tZXJ5IGN1cnZlIG1ldGhvZHMuIEl0J3Mgbm90IHJlYWxseSB3aG9sZSBtb250Z29tZXJ5IGN1cnZlLFxuICoganVzdCBidW5jaCBvZiB2ZXJ5IHNwZWNpZmljIG1ldGhvZHMgZm9yIFgyNTUxOSAvIFg0NDggZnJvbVxuICogW1JGQyA3NzQ4XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzc0OClcbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgX3ZhbGlkYXRlT2JqZWN0LCBhSW5SYW5nZSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0xFLCByYW5kb21CeXRlcywgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IG1vZCB9IGZyb20gXCIuL21vZHVsYXIuanNcIjtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIF92YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBhZGp1c3RTY2FsYXJCeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcG93UG1pbnVzMjogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmN1cnZlIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRnb21lcnkoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBQLCB0eXBlLCBhZGp1c3RTY2FsYXJCeXRlcywgcG93UG1pbnVzMiwgcmFuZG9tQnl0ZXM6IHJhbmQgfSA9IENVUlZFO1xuICAgIGNvbnN0IGlzMjU1MTkgPSB0eXBlID09PSAneDI1NTE5JztcbiAgICBpZiAoIWlzMjU1MTkgJiYgdHlwZSAhPT0gJ3g0NDgnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xuICAgIGNvbnN0IHJhbmRvbUJ5dGVzXyA9IHJhbmQgfHwgcmFuZG9tQnl0ZXM7XG4gICAgY29uc3QgbW9udGdvbWVyeUJpdHMgPSBpczI1NTE5ID8gMjU1IDogNDQ4O1xuICAgIGNvbnN0IGZpZWxkTGVuID0gaXMyNTUxOSA/IDMyIDogNTY7XG4gICAgY29uc3QgR3UgPSBpczI1NTE5ID8gQmlnSW50KDkpIDogQmlnSW50KDUpO1xuICAgIC8vIFJGQyA3NzQ4ICM1OlxuICAgIC8vIFRoZSBjb25zdGFudCBhMjQgaXMgKDQ4NjY2MiAtIDIpIC8gNCA9IDEyMTY2NSBmb3IgY3VydmUyNTUxOS9YMjU1MTkgYW5kXG4gICAgLy8gKDE1NjMyNiAtIDIpIC8gNCA9IDM5MDgxIGZvciBjdXJ2ZTQ0OC9YNDQ4XG4gICAgLy8gY29uc3QgYSA9IGlzMjU1MTkgPyAxNTYzMjZuIDogNDg2NjYybjtcbiAgICBjb25zdCBhMjQgPSBpczI1NTE5ID8gQmlnSW50KDEyMTY2NSkgOiBCaWdJbnQoMzkwODEpO1xuICAgIC8vIFJGQzogeDI1NTE5IFwidGhlIHJlc3VsdGluZyBpbnRlZ2VyIGlzIG9mIHRoZSBmb3JtIDJeMjU0IHBsdXNcbiAgICAvLyBlaWdodCB0aW1lcyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMl4yNTEgLSAxIChpbmNsdXNpdmUpXCJcbiAgICAvLyB4NDQ4OiBcIjJeNDQ3IHBsdXMgZm91ciB0aW1lcyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMl40NDUgLSAxIChpbmNsdXNpdmUpXCJcbiAgICBjb25zdCBtaW5TY2FsYXIgPSBpczI1NTE5ID8gXzJuICoqIEJpZ0ludCgyNTQpIDogXzJuICoqIEJpZ0ludCg0NDcpO1xuICAgIGNvbnN0IG1heEFkZGVkID0gaXMyNTUxOVxuICAgICAgICA/IEJpZ0ludCg4KSAqIF8ybiAqKiBCaWdJbnQoMjUxKSAtIF8xblxuICAgICAgICA6IEJpZ0ludCg0KSAqIF8ybiAqKiBCaWdJbnQoNDQ1KSAtIF8xbjtcbiAgICBjb25zdCBtYXhTY2FsYXIgPSBtaW5TY2FsYXIgKyBtYXhBZGRlZCArIF8xbjsgLy8gKGluY2x1c2l2ZSlcbiAgICBjb25zdCBtb2RQID0gKG4pID0+IG1vZChuLCBQKTtcbiAgICBjb25zdCBHdUJ5dGVzID0gZW5jb2RlVShHdSk7XG4gICAgZnVuY3Rpb24gZW5jb2RlVSh1KSB7XG4gICAgICAgIHJldHVybiBudW1iZXJUb0J5dGVzTEUobW9kUCh1KSwgZmllbGRMZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVVKHUpIHtcbiAgICAgICAgY29uc3QgX3UgPSBlbnN1cmVCeXRlcygndSBjb29yZGluYXRlJywgdSwgZmllbGRMZW4pO1xuICAgICAgICAvLyBSRkM6IFdoZW4gcmVjZWl2aW5nIHN1Y2ggYW4gYXJyYXksIGltcGxlbWVudGF0aW9ucyBvZiBYMjU1MTlcbiAgICAgICAgLy8gKGJ1dCBub3QgWDQ0OCkgTVVTVCBtYXNrIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBpbiB0aGUgZmluYWwgYnl0ZS5cbiAgICAgICAgaWYgKGlzMjU1MTkpXG4gICAgICAgICAgICBfdVszMV0gJj0gMTI3OyAvLyAwYjAxMTFfMTExMVxuICAgICAgICAvLyBSRkM6IEltcGxlbWVudGF0aW9ucyBNVVNUIGFjY2VwdCBub24tY2Fub25pY2FsIHZhbHVlcyBhbmQgcHJvY2VzcyB0aGVtIGFzXG4gICAgICAgIC8vIGlmIHRoZXkgaGFkIGJlZW4gcmVkdWNlZCBtb2R1bG8gdGhlIGZpZWxkIHByaW1lLiAgVGhlIG5vbi1jYW5vbmljYWxcbiAgICAgICAgLy8gdmFsdWVzIGFyZSAyXjI1NSAtIDE5IHRocm91Z2ggMl4yNTUgLSAxIGZvciBYMjU1MTkgYW5kIDJeNDQ4IC0gMl4yMjRcbiAgICAgICAgLy8gLSAxIHRocm91Z2ggMl40NDggLSAxIGZvciBYNDQ4LlxuICAgICAgICByZXR1cm4gbW9kUChieXRlc1RvTnVtYmVyTEUoX3UpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlU2NhbGFyKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb051bWJlckxFKGFkanVzdFNjYWxhckJ5dGVzKGVuc3VyZUJ5dGVzKCdzY2FsYXInLCBzY2FsYXIsIGZpZWxkTGVuKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsYXJNdWx0KHNjYWxhciwgdSkge1xuICAgICAgICBjb25zdCBwdSA9IG1vbnRnb21lcnlMYWRkZXIoZGVjb2RlVSh1KSwgZGVjb2RlU2NhbGFyKHNjYWxhcikpO1xuICAgICAgICAvLyBTb21lIHB1YmxpYyBrZXlzIGFyZSB1c2VsZXNzLCBvZiBsb3ctb3JkZXIuIEN1cnZlIGF1dGhvciBkb2Vzbid0IHRoaW5rXG4gICAgICAgIC8vIGl0IG5lZWRzIHRvIGJlIHZhbGlkYXRlZCwgYnV0IHdlIGRvIGl0IG5vbmV0aGVsZXNzLlxuICAgICAgICAvLyBodHRwczovL2NyLnlwLnRvL2VjZGguaHRtbCN2YWxpZGF0ZVxuICAgICAgICBpZiAocHUgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcml2YXRlIG9yIHB1YmxpYyBrZXkgcmVjZWl2ZWQnKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZVUocHUpO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZS4gQnkgZG9pbmcgc2NhbGFyIG11bHRpcGxpY2F0aW9uIG9mIGJhc2UgcG9pbnQuXG4gICAgZnVuY3Rpb24gc2NhbGFyTXVsdEJhc2Uoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBzY2FsYXJNdWx0KHNjYWxhciwgR3VCeXRlcyk7XG4gICAgfVxuICAgIC8vIGNzd2FwIGZyb20gUkZDNzc0OCBcImV4YW1wbGUgY29kZVwiXG4gICAgZnVuY3Rpb24gY3N3YXAoc3dhcCwgeF8yLCB4XzMpIHtcbiAgICAgICAgLy8gZHVtbXkgPSBtYXNrKHN3YXApIEFORCAoeF8yIFhPUiB4XzMpXG4gICAgICAgIC8vIFdoZXJlIG1hc2soc3dhcCkgaXMgdGhlIGFsbC0xIG9yIGFsbC0wIHdvcmQgb2YgdGhlIHNhbWUgbGVuZ3RoIGFzIHhfMlxuICAgICAgICAvLyBhbmQgeF8zLCBjb21wdXRlZCwgZS5nLiwgYXMgbWFzayhzd2FwKSA9IDAgLSBzd2FwLlxuICAgICAgICBjb25zdCBkdW1teSA9IG1vZFAoc3dhcCAqICh4XzIgLSB4XzMpKTtcbiAgICAgICAgeF8yID0gbW9kUCh4XzIgLSBkdW1teSk7IC8vIHhfMiA9IHhfMiBYT1IgZHVtbXlcbiAgICAgICAgeF8zID0gbW9kUCh4XzMgKyBkdW1teSk7IC8vIHhfMyA9IHhfMyBYT1IgZHVtbXlcbiAgICAgICAgcmV0dXJuIHsgeF8yLCB4XzMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9udGdvbWVyeSB4LW9ubHkgbXVsdGlwbGljYXRpb24gbGFkZGVyLlxuICAgICAqIEBwYXJhbSBwb2ludFUgdSBjb29yZGluYXRlICh4KSBvbiBNb250Z29tZXJ5IEN1cnZlIDI1NTE5XG4gICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAqIEByZXR1cm5zIG5ldyBQb2ludCBvbiBNb250Z29tZXJ5IGN1cnZlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9udGdvbWVyeUxhZGRlcih1LCBzY2FsYXIpIHtcbiAgICAgICAgYUluUmFuZ2UoJ3UnLCB1LCBfMG4sIFApO1xuICAgICAgICBhSW5SYW5nZSgnc2NhbGFyJywgc2NhbGFyLCBtaW5TY2FsYXIsIG1heFNjYWxhcik7XG4gICAgICAgIGNvbnN0IGsgPSBzY2FsYXI7XG4gICAgICAgIGNvbnN0IHhfMSA9IHU7XG4gICAgICAgIGxldCB4XzIgPSBfMW47XG4gICAgICAgIGxldCB6XzIgPSBfMG47XG4gICAgICAgIGxldCB4XzMgPSB1O1xuICAgICAgICBsZXQgel8zID0gXzFuO1xuICAgICAgICBsZXQgc3dhcCA9IF8wbjtcbiAgICAgICAgZm9yIChsZXQgdCA9IEJpZ0ludChtb250Z29tZXJ5Qml0cyAtIDEpOyB0ID49IF8wbjsgdC0tKSB7XG4gICAgICAgICAgICBjb25zdCBrX3QgPSAoayA+PiB0KSAmIF8xbjtcbiAgICAgICAgICAgIHN3YXAgXj0ga190O1xuICAgICAgICAgICAgKHsgeF8yLCB4XzMgfSA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKSk7XG4gICAgICAgICAgICAoeyB4XzI6IHpfMiwgeF8zOiB6XzMgfSA9IGNzd2FwKHN3YXAsIHpfMiwgel8zKSk7XG4gICAgICAgICAgICBzd2FwID0ga190O1xuICAgICAgICAgICAgY29uc3QgQSA9IHhfMiArIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEFBID0gbW9kUChBICogQSk7XG4gICAgICAgICAgICBjb25zdCBCID0geF8yIC0gel8yO1xuICAgICAgICAgICAgY29uc3QgQkIgPSBtb2RQKEIgKiBCKTtcbiAgICAgICAgICAgIGNvbnN0IEUgPSBBQSAtIEJCO1xuICAgICAgICAgICAgY29uc3QgQyA9IHhfMyArIHpfMztcbiAgICAgICAgICAgIGNvbnN0IEQgPSB4XzMgLSB6XzM7XG4gICAgICAgICAgICBjb25zdCBEQSA9IG1vZFAoRCAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQ0IgPSBtb2RQKEMgKiBCKTtcbiAgICAgICAgICAgIGNvbnN0IGRhY2IgPSBEQSArIENCO1xuICAgICAgICAgICAgY29uc3QgZGFfY2IgPSBEQSAtIENCO1xuICAgICAgICAgICAgeF8zID0gbW9kUChkYWNiICogZGFjYik7XG4gICAgICAgICAgICB6XzMgPSBtb2RQKHhfMSAqIG1vZFAoZGFfY2IgKiBkYV9jYikpO1xuICAgICAgICAgICAgeF8yID0gbW9kUChBQSAqIEJCKTtcbiAgICAgICAgICAgIHpfMiA9IG1vZFAoRSAqIChBQSArIG1vZFAoYTI0ICogRSkpKTtcbiAgICAgICAgfVxuICAgICAgICAoeyB4XzIsIHhfMyB9ID0gY3N3YXAoc3dhcCwgeF8yLCB4XzMpKTtcbiAgICAgICAgKHsgeF8yOiB6XzIsIHhfMzogel8zIH0gPSBjc3dhcChzd2FwLCB6XzIsIHpfMykpO1xuICAgICAgICBjb25zdCB6MiA9IHBvd1BtaW51czIoel8yKTsgLy8gYEZwLnBvdyh4LCBQIC0gXzJuKWAgaXMgbXVjaCBzbG93ZXIgZXF1aXZhbGVudFxuICAgICAgICByZXR1cm4gbW9kUCh4XzIgKiB6Mik7IC8vIFJldHVybiB4XzIgKiAoel8yXihwIC0gMikpXG4gICAgfVxuICAgIGNvbnN0IHJhbmRvbVNlY3JldEtleSA9IChzZWVkID0gcmFuZG9tQnl0ZXNfKGZpZWxkTGVuKSkgPT4gc2VlZDtcbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgcmFuZG9tU2VjcmV0S2V5LFxuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiByYW5kb21TZWNyZXRLZXksXG4gICAgfTtcbiAgICBmdW5jdGlvbiBrZXlnZW4oc2VlZCkge1xuICAgICAgICBjb25zdCBzZWNyZXRLZXkgPSB1dGlscy5yYW5kb21TZWNyZXRLZXkoc2VlZCk7XG4gICAgICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBzY2FsYXJNdWx0QmFzZShzZWNyZXRLZXkpIH07XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aHMgPSB7XG4gICAgICAgIHNlY3JldDogZmllbGRMZW4sXG4gICAgICAgIHB1YmxpYzogZmllbGRMZW4sXG4gICAgICAgIHNlZWQ6IGZpZWxkTGVuLFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5Z2VuLFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQ6IChzZWNyZXRLZXksIHB1YmxpY0tleSkgPT4gc2NhbGFyTXVsdChzZWNyZXRLZXksIHB1YmxpY0tleSksXG4gICAgICAgIGdldFB1YmxpY0tleTogKHNlY3JldEtleSkgPT4gc2NhbGFyTXVsdEJhc2Uoc2VjcmV0S2V5KSxcbiAgICAgICAgc2NhbGFyTXVsdCxcbiAgICAgICAgc2NhbGFyTXVsdEJhc2UsXG4gICAgICAgIHV0aWxzLFxuICAgICAgICBHdUJ5dGVzOiBHdUJ5dGVzLnNsaWNlKCksXG4gICAgICAgIGluZm86IHsgdHlwZTogJ21vbnRnb21lcnknLCBsZW5ndGhzIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vbnRnb21lcnkuanMubWFwIl0sIm5hbWVzIjpbIl92YWxpZGF0ZU9iamVjdCIsImFJblJhbmdlIiwiYnl0ZXNUb051bWJlckxFIiwiZW5zdXJlQnl0ZXMiLCJudW1iZXJUb0J5dGVzTEUiLCJyYW5kb21CeXRlcyIsIm1vZCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsInZhbGlkYXRlT3B0cyIsImN1cnZlIiwiYWRqdXN0U2NhbGFyQnl0ZXMiLCJwb3dQbWludXMyIiwiT2JqZWN0IiwiZnJlZXplIiwibW9udGdvbWVyeSIsImN1cnZlRGVmIiwiQ1VSVkUiLCJQIiwidHlwZSIsInJhbmQiLCJpczI1NTE5IiwiRXJyb3IiLCJyYW5kb21CeXRlc18iLCJtb250Z29tZXJ5Qml0cyIsImZpZWxkTGVuIiwiR3UiLCJhMjQiLCJtaW5TY2FsYXIiLCJtYXhBZGRlZCIsIm1heFNjYWxhciIsIm1vZFAiLCJuIiwiR3VCeXRlcyIsImVuY29kZVUiLCJ1IiwiZGVjb2RlVSIsIl91IiwiZGVjb2RlU2NhbGFyIiwic2NhbGFyIiwic2NhbGFyTXVsdCIsInB1IiwibW9udGdvbWVyeUxhZGRlciIsInNjYWxhck11bHRCYXNlIiwiY3N3YXAiLCJzd2FwIiwieF8yIiwieF8zIiwiZHVtbXkiLCJrIiwieF8xIiwiel8yIiwiel8zIiwidCIsImtfdCIsIkEiLCJBQSIsIkIiLCJCQiIsIkUiLCJDIiwiRCIsIkRBIiwiQ0IiLCJkYWNiIiwiZGFfY2IiLCJ6MiIsInJhbmRvbVNlY3JldEtleSIsInNlZWQiLCJ1dGlscyIsInJhbmRvbVByaXZhdGVLZXkiLCJrZXlnZW4iLCJzZWNyZXRLZXkiLCJwdWJsaWNLZXkiLCJsZW5ndGhzIiwic2VjcmV0IiwicHVibGljIiwiZ2V0U2hhcmVkU2VjcmV0IiwiZ2V0UHVibGljS2V5Iiwic2xpY2UiLCJpbmZvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/montgomery.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   DERErr: () => (/* binding */ DERErr),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   _legacyHelperEquat: () => (/* binding */ _legacyHelperEquat),\n/* harmony export */   _normFnElement: () => (/* binding */ _normFnElement),\n/* harmony export */   _splitEndoScalar: () => (/* binding */ _splitEndoScalar),\n/* harmony export */   ecdsa: () => (/* binding */ ecdsa),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassN: () => (/* binding */ weierstrassN),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/hmac.js */ \"(ssr)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num, den)=>(num + (num >= 0 ? den : -den) / _2n) / den;\n/**\n * Splits scalar for GLV endomorphism.\n */ function _splitEndoScalar(k, basis, n) {\n    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n    // Since part can be negative, we need to do this on point.\n    // TODO: verifyScalar function which consumes lambda\n    const [[a1, b1], [a2, b2]] = basis;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    // |k1|/|k2| is < sqrt(N), but can be negative.\n    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n    let k1 = k - c1 * a1 - c2 * a2;\n    let k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < _0n;\n    const k2neg = k2 < _0n;\n    if (k1neg) k1 = -k1;\n    if (k2neg) k2 = -k2;\n    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n    const MAX_NUM = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(Math.ceil((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(n) / 2)) + _1n; // Half bits of N\n    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n        throw new Error(\"splitScalar (endomorphism): failed, k=\" + k);\n    }\n    return {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n    };\n}\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"lowS\", opts.lowS);\n    if (opts.prehash !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"prehash\", opts.prehash);\n}\nclass DERErr extends Error {\n    constructor(m = \"\"){\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */ const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data)=>{\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length & 1) throw new E(\"tlv.encode: unpadded data\");\n            const dataLen = data.length / 2;\n            const len = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(dataLen);\n            if (len.length / 2 & 128) throw new E(\"tlv.encode: long form length too big\");\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(len.length / 2 | 128) : \"\";\n            const t = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode (tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length < 2 || data[pos++] !== tag) throw new E(\"tlv.decode: wrong tlv\");\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong) length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen) throw new E(\"tlv.decode(long): indefinite length not supported\");\n                if (lenLen > 4) throw new E(\"tlv.decode(long): byte length is too big\"); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen) throw new E(\"tlv.decode: length bytes not complete\");\n                if (lengthBytes[0] === 0) throw new E(\"tlv.decode(long): zero leftmost byte\");\n                for (const b of lengthBytes)length = length << 8 | b;\n                pos += lenLen;\n                if (length < 128) throw new E(\"tlv.decode(long): not minimal encoding\");\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length) throw new E(\"tlv.decode: wrong value length\");\n            return {\n                v,\n                l: data.subarray(pos + length)\n            };\n        }\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode (num) {\n            const { Err: E } = DER;\n            if (num < _0n) throw new E(\"integer: negative integers are not allowed\");\n            let hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 8) hex = \"00\" + hex;\n            if (hex.length & 1) throw new E(\"unexpected DER parsing assertion: unpadded hex\");\n            return hex;\n        },\n        decode (data) {\n            const { Err: E } = DER;\n            if (data[0] & 128) throw new E(\"invalid signature integer: negative\");\n            if (data[0] === 0x00 && !(data[1] & 128)) throw new E(\"invalid signature integer: unnecessary leading zero\");\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(data);\n        }\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"signature\", hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        return {\n            r: int.decode(rBytes),\n            s: int.decode(sBytes)\n        };\n    },\n    hexFromSig (sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n// TODO: remove\nfunction _legacyHelperEquat(Fp, a, b) {\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula. Takes x, returns y².\n     * @returns y²\n     */ function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x² * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x³ + a * x + b\n    }\n    return weierstrassEquation;\n}\nfunction _normFnElement(Fn, key) {\n    const { BYTES: expected } = Fn;\n    let num;\n    if (typeof key === \"bigint\") {\n        num = key;\n    } else {\n        let bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"private key\", key);\n        try {\n            num = Fn.fromBytes(bytes);\n        } catch (error) {\n            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n        }\n    }\n    if (!Fn.isValidNot0(num)) throw new Error(\"invalid private key: out of range [1..N-1]\");\n    return num;\n}\nfunction weierstrassN(CURVE, curveOpts = {}) {\n    const { Fp, Fn } = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__._createCurveFields)(\"weierstrass\", CURVE, curveOpts);\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(curveOpts, {}, {\n        allowInfinityPoint: \"boolean\",\n        clearCofactor: \"function\",\n        isTorsionFree: \"function\",\n        fromBytes: \"function\",\n        toBytes: \"function\",\n        endo: \"object\",\n        wrapPrivateKey: \"boolean\"\n    });\n    const { endo } = curveOpts;\n    if (endo) {\n        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n        if (!Fp.is0(CURVE.a) || typeof endo.beta !== \"bigint\" || !Array.isArray(endo.basises)) {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n        }\n    }\n    function assertCompressionIsSupported() {\n        if (!Fp.isOdd) throw new Error(\"compression is not supported: Field does not have .isOdd()\");\n    }\n    // Implements IEEE P1363 point encoding\n    function pointToBytes(_c, point, isCompressed) {\n        const { x, y } = point.toAffine();\n        const bx = Fp.toBytes(x);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n        if (isCompressed) {\n            assertCompressionIsSupported();\n            const hasEvenY = !Fp.isOdd(y);\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(pprefix(hasEvenY), bx);\n        } else {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n        }\n    }\n    function pointFromBytes(bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.abytes)(bytes);\n        const L = Fp.BYTES;\n        const LC = L + 1; // length compressed, e.g. 33 for 32-byte field\n        const LU = 2 * L + 1; // length uncompressed, e.g. 65 for 32-byte field\n        const length = bytes.length;\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // No actual validation is done here: use .assertValidity()\n        if (length === LC && (head === 0x02 || head === 0x03)) {\n            const x = Fp.fromBytes(tail);\n            if (!Fp.isValid(x)) throw new Error(\"bad point: is not on curve, wrong x\");\n            const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n            let y;\n            try {\n                y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n            } catch (sqrtError) {\n                const err = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                throw new Error(\"bad point: is not on curve, sqrt error\" + err);\n            }\n            assertCompressionIsSupported();\n            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;\n            const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n            if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n            return {\n                x,\n                y\n            };\n        } else if (length === LU && head === 0x04) {\n            // TODO: more checks\n            const x = Fp.fromBytes(tail.subarray(L * 0, L * 1));\n            const y = Fp.fromBytes(tail.subarray(L * 1, L * 2));\n            if (!isValidXY(x, y)) throw new Error(\"bad point: is not on curve\");\n            return {\n                x,\n                y\n            };\n        } else {\n            throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);\n        }\n    }\n    const toBytes = curveOpts.toBytes || pointToBytes;\n    const fromBytes = curveOpts.fromBytes || pointFromBytes;\n    const weierstrassEquation = _legacyHelperEquat(Fp, CURVE.a, CURVE.b);\n    // TODO: move top-level\n    /** Checks whether equation holds for given x, y: y² == x³ + ax + b */ function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y²\n        const right = weierstrassEquation(x); // x³ + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y² = x³ + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error(\"bad curve params: generator point\");\n    // Test 2: discriminant Δ part should be non-zero: 4a³ + 27b² != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error(\"bad curve params: a or b\");\n    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */ function acoord(title, n, banZero = false) {\n        if (!Fp.isValid(n) || banZero && Fp.is0(n)) throw new Error(`bad point coordinate ${title}`);\n        return n;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    function splitEndoScalarN(k) {\n        if (!endo || !endo.basises) throw new Error(\"no endo\");\n        return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z) ∋ (x=X/Z, y=Y/Z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz)=>{\n        const { X, Y, Z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(Z, Fp.ONE)) return {\n            x: X,\n            y: Y\n        };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(Z);\n        const x = Fp.mul(X, iz);\n        const y = Fp.mul(Y, iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0) return {\n            x: Fp.ZERO,\n            y: Fp.ZERO\n        };\n        if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n        return {\n            x,\n            y\n        };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p)=>{\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (curveOpts.allowInfinityPoint && !Fp.is0(p.Y)) return;\n            throw new Error(\"bad point: ZERO\");\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not field elements\");\n        if (!isValidXY(x, y)) throw new Error(\"bad point: equation left != right\");\n        if (!p.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        return true;\n    });\n    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n        k1p = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.negateCt)(k1neg, k1p);\n        k2p = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.negateCt)(k2neg, k2p);\n        return k1p.add(k2p);\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ∋ (x=X/Z, y=Y/Z).\n     * Default Point works in 2d / affine coordinates: (x, y).\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ constructor(X, Y, Z){\n            this.X = acoord(\"x\", X);\n            this.Y = acoord(\"y\", Y, true);\n            this.Z = acoord(\"z\", Z);\n            Object.freeze(this);\n        }\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n            if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        // TODO: remove\n        get px() {\n            return this.X;\n        }\n        get py() {\n            return this.X;\n        }\n        get pz() {\n            return this.Z;\n        }\n        static normalizeZ(points) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.normalizeZ)(Point, points);\n        }\n        static fromBytes(bytes) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.abytes)(bytes);\n            return Point.fromHex(bytes);\n        }\n        /** Converts hash string or Uint8Array to Point. */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        /** Multiplies generator point by privateKey. */ static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(_normFnElement(Fn, privateKey));\n        }\n        // TODO: remove\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        /**\n         *\n         * @param windowSize\n         * @param isLazy true will defer table computation until the first multiplication\n         * @returns\n         */ precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy) this.multiply(_3n); // random number\n            return this;\n        }\n        // TODO: return `this`\n        /** A point on curve is valid if it conforms to equation. */ assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (!Fp.isOdd) throw new Error(\"Field doesn't support isOdd\");\n            return !Fp.isOdd(y);\n        }\n        /** Compare one point to another. */ equals(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */ negate() {\n            return new Point(this.X, Fp.neg(this.Y), this.Z);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            const { endo } = curveOpts;\n            if (!Fn.isValidNot0(scalar)) throw new Error(\"invalid scalar: out of range\"); // 0 is invalid\n            let point, fake; // Fake point is used to const-time mult\n            const mul = (n)=>wnaf.cached(this, n, (p)=>(0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.normalizeZ)(Point, p));\n            /** See docs for {@link EndomorphismOpts} */ if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n                const { p: k1p, f: k1f } = mul(k1);\n                const { p: k2p, f: k2f } = mul(k2);\n                fake = k1f.add(k2f);\n                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n            } else {\n                const { p, f } = mul(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.normalizeZ)(Point, [\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed secret key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(sc) {\n            const { endo } = curveOpts;\n            const p = this;\n            if (!Fn.isValid(sc)) throw new Error(\"invalid scalar: out of range\"); // 0 is valid\n            if (sc === _0n || p.is0()) return Point.ZERO;\n            if (sc === _1n) return p; // fast-path\n            if (wnaf.hasCache(this)) return this.multiply(sc);\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n                const { p1, p2 } = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.mulEndoUnsafe)(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n            } else {\n                return wnaf.unsafe(p, sc);\n            }\n        }\n        multiplyAndAddUnsafe(Q, a, b) {\n            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n            return sum.is0() ? undefined : sum;\n        }\n        /**\n         * Converts Projective point to affine (x, y) coordinates.\n         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n         */ toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        /**\n         * Checks whether Point is free of torsion elements (is in prime subgroup).\n         * Always torsion-free for cofactor=1 curves.\n         */ isTorsionFree() {\n            const { isTorsionFree } = curveOpts;\n            if (cofactor === _1n) return true;\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            return wnaf.unsafe(this, CURVE_ORDER).is0();\n        }\n        clearCofactor() {\n            const { clearCofactor } = curveOpts;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(cofactor);\n        }\n        isSmallOrder() {\n            // can we use this.clearCofactor()?\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        toBytes(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        /** @deprecated use `toBytes` */ toRawBytes(isCompressed = true) {\n            return this.toBytes(isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes(isCompressed));\n        }\n        toString() {\n            return `<Point ${this.is0() ? \"ZERO\" : this.toHex()}>`;\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // fields\n    Point.Fp = Fp;\n    Point.Fn = Fn;\n    const bits = Fn.BITS;\n    const wnaf = new _curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF(Point, curveOpts.endo ? Math.ceil(bits / 2) : bits);\n    return Point;\n}\n// _legacyWeierstrass\n// TODO: remove\n/** @deprecated use `weierstrass` in newer releases */ function weierstrassPoints(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    return _weierstrass_new_output_to_legacy(c, Point);\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.validateField)(Fp);\n    const { A, B, Z } = opts;\n    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n    if (!Fp.isOdd) throw new Error(\"Field does not have .isOdd()\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.FpInvertBatch)(Fp, [\n            tv4\n        ], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n}\n/**\n * Creates ECDSA for given elliptic curve Point and hash function.\n */ function ecdsa(Point, hash, ecdsaOpts = {}) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.ahash)(hash);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(ecdsaOpts, {}, {\n        hmac: \"function\",\n        lowS: \"boolean\",\n        randomBytes: \"function\",\n        bits2int: \"function\",\n        bits2int_modN: \"function\"\n    });\n    const randomBytes_ = ecdsaOpts.randomBytes || _utils_js__WEBPACK_IMPORTED_MODULE_2__.randomBytes;\n    const hmac_ = ecdsaOpts.hmac || ((key, ...msgs)=>(0,_noble_hashes_hmac_js__WEBPACK_IMPORTED_MODULE_4__.hmac)(hash, key, (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(...msgs)));\n    const { Fp, Fn } = Point;\n    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n    const seedLen = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.getMinHashLength)(CURVE_ORDER);\n    const lengths = {\n        secret: Fn.BYTES,\n        public: 1 + Fp.BYTES,\n        publicUncompressed: 1 + 2 * Fp.BYTES,\n        signature: 2 * Fn.BYTES,\n        seed: seedLen\n    };\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;\n    }\n    function aValidRS(title, num) {\n        if (!Fn.isValidNot0(num)) throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);\n    }\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            aValidRS(\"r\", r); // r in [1..N-1]\n            aValidRS(\"s\", s); // s in [1..N-1]\n            this.r = r;\n            this.s = s;\n            if (recovery != null) this.recovery = recovery;\n            Object.freeze(this);\n        }\n        static fromBytes(bytes, format = \"compact\") {\n            if (format === \"compact\") {\n                const L = Fn.BYTES;\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.abytes)(bytes, L * 2);\n                const r = bytes.subarray(0, L);\n                const s = bytes.subarray(L, L * 2);\n                return new Signature(Fn.fromBytes(r), Fn.fromBytes(s));\n            }\n            if (format === \"der\") {\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.abytes)(bytes);\n                const { r, s } = DER.toSig(bytes);\n                return new Signature(r, s);\n            }\n            throw new Error(\"invalid format\");\n        }\n        static fromHex(hex, format) {\n            return this.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.hexToBytes)(hex), format);\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        // ProjPointType<bigint>\n        recoverPublicKey(msgHash) {\n            const FIELD_ORDER = Fp.ORDER;\n            const { r, s, recovery: rec } = this;\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            // ECDSA recovery is hard for cofactor > 1 curves.\n            // In sign, `r = q.x mod n`, and here we recover q.x from r.\n            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n            // However, for cofactor>1, r+n may not get q.x:\n            // r+n*i would need to be done instead where i is unknown.\n            // To easily get i, we either need to:\n            // a. increase amount of valid recid values (4, 5...); OR\n            // b. prohibit non-prime-order signatures (recid > 1).\n            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n            if (hasCofactor && rec > 1) throw new Error(\"recovery id is ambiguous for h>1 curve\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n            if (!Fp.isValid(radj)) throw new Error(\"recovery id 2 or 3 invalid\");\n            const x = Fp.toBytes(radj);\n            const R = Point.fromHex((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(pprefix((rec & 1) === 0), x));\n            const ir = Fn.inv(radj); // r^-1\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            const u1 = Fn.create(-h * ir); // -hr^-1\n            const u2 = Fn.create(s * ir); // sr^-1\n            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n            if (Q.is0()) throw new Error(\"point at infinify\");\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n        }\n        toBytes(format = \"compact\") {\n            if (format === \"compact\") return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(Fn.toBytes(this.r), Fn.toBytes(this.s));\n            if (format === \"der\") return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.hexToBytes)(DER.hexFromSig(this));\n            throw new Error(\"invalid format\");\n        }\n        toHex(format) {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes(format));\n        }\n        // TODO: remove\n        assertValidity() {}\n        static fromCompact(hex) {\n            return Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", hex), \"compact\");\n        }\n        static fromDER(hex) {\n            return Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", hex), \"der\");\n        }\n        toDERRawBytes() {\n            return this.toBytes(\"der\");\n        }\n        toDERHex() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes(\"der\"));\n        }\n        toCompactRawBytes() {\n            return this.toBytes(\"compact\");\n        }\n        toCompactHex() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes(\"compact\"));\n        }\n    }\n    function isValidSecretKey(privateKey) {\n        try {\n            return !!_normFnElement(Fn, privateKey);\n        } catch (error) {\n            return false;\n        }\n    }\n    function isValidPublicKey(publicKey, isCompressed) {\n        try {\n            const l = publicKey.length;\n            if (isCompressed === true && l !== lengths.public) return false;\n            if (isCompressed === false && l !== lengths.publicUncompressed) return false;\n            return !!Point.fromBytes(publicKey);\n        } catch (error) {\n            return false;\n        }\n    }\n    /**\n     * Produces cryptographically secure secret key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */ function randomSecretKey(seed = randomBytes_(seedLen)) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.mapHashToField)(seed, CURVE_ORDER);\n    }\n    const utils = {\n        isValidSecretKey,\n        isValidPublicKey,\n        randomSecretKey,\n        // TODO: remove\n        isValidPrivateKey: isValidSecretKey,\n        randomPrivateKey: randomSecretKey,\n        normPrivateKeyToScalar: (key)=>_normFnElement(Fn, key),\n        precompute (windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        }\n    };\n    /**\n     * Computes public key for a secret key. Checks for validity of the secret key.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(secretKey, isCompressed = true) {\n        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        // TODO: remove\n        if (typeof item === \"bigint\") return false;\n        // TODO: remove\n        if (item instanceof Point) return true;\n        if (Fn.allowedLengths || lengths.secret === lengths.public) return undefined;\n        const l = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"key\", item).length;\n        return l === lengths.public || l === lengths.publicUncompressed;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from secret key A and public key B.\n     * Checks: 1) secret key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {\n        if (isProbPub(secretKeyA) === true) throw new Error(\"first arg must be private key\");\n        if (isProbPub(publicKeyB) === false) throw new Error(\"second arg must be public key\");\n        const s = _normFnElement(Fn, secretKeyA);\n        const b = Point.fromHex(publicKeyB); // checks for being on-curve\n        return b.multiply(s).toBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = ecdsaOpts.bits2int || function(bytes) {\n        // Our custom check \"just in case\", for protection against DoS\n        if (bytes.length > 8192) throw new Error(\"input is too large\");\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes) {\n        return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(fnBits);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"num < 2^\" + fnBits, num, _0n, ORDER_MASK);\n        return Fn.toBytes(num);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash);\n        validateSigVerOpts(opts);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes_(lengths.secret) : ent; // gen random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        // To transform k => Signature:\n        // q = k⋅G\n        // r = q.x mod n\n        // s = k^-1(m + rd) mod n\n        // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            // Important: all mod() calls here must be done over N\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1\n            const ik = Fn.inv(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = k⋅G\n            const r = Fn.create(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: ecdsaOpts.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: ecdsaOpts.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a secret key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     */ function sign(msgHash, secretKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, secretKey, opts); // Steps A, D of RFC6979 3.2.\n        const drbg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg)(hash.outputLen, Fn.BYTES, hmac_);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE.precompute(8);\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"publicKey\", publicKey);\n        // Verify opts\n        validateSigVerOpts(opts);\n        const { lowS, prehash, format } = opts;\n        // TODO: remove\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        let _sig = undefined;\n        let P;\n        if (format === undefined) {\n            // Try to deduce format\n            const isHex = typeof sg === \"string\" || (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isBytes)(sg);\n            const isObj = !isHex && sg !== null && typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\";\n            if (!isHex && !isObj) throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n            if (isObj) {\n                _sig = new Signature(sg.r, sg.s);\n            } else if (isHex) {\n                // TODO: remove this malleable check\n                // Signature can be represented in 2 ways: compact (2*Fn.BYTES) & DER (variable-length).\n                // Since DER can also be 2*Fn.BYTES bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                }\n                if (!_sig) {\n                    try {\n                        _sig = Signature.fromCompact(sg);\n                    } catch (error) {\n                        return false;\n                    }\n                }\n            }\n        } else {\n            if (format === \"compact\" || format === \"der\") {\n                if (typeof sg !== \"string\" && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isBytes)(sg)) throw new Error('\"der\" / \"compact\" format expects Uint8Array signature');\n                _sig = Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", sg), format);\n            } else if (format === \"js\") {\n                if (!(sg instanceof Signature)) throw new Error('\"js\" format expects Signature instance');\n                _sig = sg;\n            } else {\n                throw new Error('format must be \"compact\", \"der\" or \"js\"');\n            }\n        }\n        if (!_sig) return false;\n        try {\n            P = Point.fromHex(publicKey);\n            if (lowS && _sig.hasHighS()) return false;\n            // todo: optional.hash => hash\n            if (prehash) msgHash = hash(msgHash);\n            const { r, s } = _sig;\n            const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n            const is = Fn.inv(s); // s^-1\n            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));\n            if (R.is0()) return false;\n            const v = Fn.create(R.x); // v = r.x mod n\n            return v === r;\n        } catch (e) {\n            return false;\n        }\n    }\n    function keygen(seed) {\n        const secretKey = utils.randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: getPublicKey(secretKey)\n        };\n    }\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        sign,\n        verify,\n        getSharedSecret,\n        utils,\n        Point,\n        Signature,\n        info: {\n            type: \"weierstrass\",\n            lengths,\n            publicKeyHasPrefix: true\n        }\n    });\n}\n// TODO: remove\nfunction _weierstrass_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        b: c.b,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy\n    };\n    const Fp = c.Fp;\n    let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l)=>Math.ceil(l / 2)))) : undefined;\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.Field)(CURVE.n, {\n        BITS: c.nBitLength,\n        allowedLengths: allowedLengths,\n        modOnDecode: c.wrapPrivateKey\n    });\n    const curveOpts = {\n        Fp,\n        Fn,\n        allowInfinityPoint: c.allowInfinityPoint,\n        endo: c.endo,\n        isTorsionFree: c.isTorsionFree,\n        clearCofactor: c.clearCofactor,\n        fromBytes: c.fromBytes,\n        toBytes: c.toBytes\n    };\n    return {\n        CURVE,\n        curveOpts\n    };\n}\nfunction _ecdsa_legacy_opts_to_new(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const ecdsaOpts = {\n        hmac: c.hmac,\n        randomBytes: c.randomBytes,\n        lowS: c.lowS,\n        bits2int: c.bits2int,\n        bits2int_modN: c.bits2int_modN\n    };\n    return {\n        CURVE,\n        curveOpts,\n        hash: c.hash,\n        ecdsaOpts\n    };\n}\n// TODO: remove\nfunction _weierstrass_new_output_to_legacy(c, Point) {\n    const { Fp, Fn } = Point;\n    // TODO: remove\n    function isWithinCurveOrder(num) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(num, _1n, Fn.ORDER);\n    }\n    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n    return Object.assign({}, {\n        CURVE: c,\n        Point: Point,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar: (key)=>_normFnElement(Fn, key),\n        weierstrassEquation,\n        isWithinCurveOrder\n    });\n}\n// TODO: remove\nfunction _ecdsa_new_output_to_legacy(c, ecdsa) {\n    return Object.assign({}, ecdsa, {\n        ProjectivePoint: ecdsa.Point,\n        CURVE: c\n    });\n}\n// _ecdsa_legacy\nfunction weierstrass(c) {\n    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    const signs = ecdsa(Point, hash, ecdsaOpts);\n    return _ecdsa_new_output_to_legacy(c, signs);\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDRCxvRUFBb0UsR0FDdkI7QUFDRDtBQUM4TDtBQUNuSTtBQUNEO0FBQ3RHLCtIQUErSDtBQUMvSCxNQUFNOEIsYUFBYSxDQUFDQyxLQUFLQyxNQUFRLENBQUNELE1BQU0sQ0FBQ0EsT0FBTyxJQUFJQyxNQUFNLENBQUNBLEdBQUUsSUFBS0MsR0FBRSxJQUFLRDtBQUN6RTs7Q0FFQyxHQUNNLFNBQVNFLGlCQUFpQkMsQ0FBQyxFQUFFQyxLQUFLLEVBQUVDLENBQUM7SUFDeEMsNEVBQTRFO0lBQzVFLDJEQUEyRDtJQUMzRCxvREFBb0Q7SUFDcEQsTUFBTSxDQUFDLENBQUNDLElBQUlDLEdBQUcsRUFBRSxDQUFDQyxJQUFJQyxHQUFHLENBQUMsR0FBR0w7SUFDN0IsTUFBTU0sS0FBS1osV0FBV1csS0FBS04sR0FBR0U7SUFDOUIsTUFBTU0sS0FBS2IsV0FBVyxDQUFDUyxLQUFLSixHQUFHRTtJQUMvQiwrQ0FBK0M7SUFDL0MsK0ZBQStGO0lBQy9GLElBQUlPLEtBQUtULElBQUlPLEtBQUtKLEtBQUtLLEtBQUtIO0lBQzVCLElBQUlLLEtBQUssQ0FBQ0gsS0FBS0gsS0FBS0ksS0FBS0Y7SUFDekIsTUFBTUssUUFBUUYsS0FBS0c7SUFDbkIsTUFBTUMsUUFBUUgsS0FBS0U7SUFDbkIsSUFBSUQsT0FDQUYsS0FBSyxDQUFDQTtJQUNWLElBQUlJLE9BQ0FILEtBQUssQ0FBQ0E7SUFDVix5RkFBeUY7SUFDekYsbUdBQW1HO0lBQ25HLE1BQU1JLFVBQVUxQyxrREFBT0EsQ0FBQzJDLEtBQUtDLElBQUksQ0FBQzdDLGlEQUFNQSxDQUFDK0IsS0FBSyxNQUFNZSxLQUFLLGlCQUFpQjtJQUMx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O0FBQ0o7QUFDQSxlQUFlO0FBQ2YsU0FBU0csNEJBQTRCdEksQ0FBQyxFQUFFZ0MsS0FBSztJQUN6QyxPQUFPcEcsT0FBT3dNLE1BQU0sQ0FBQyxDQUFDLEdBQUdwRyxPQUFPO1FBQzVCcUcsaUJBQWlCckcsTUFBTXRILEtBQUs7UUFDNUIxRCxPQUFPZ0o7SUFDWDtBQUNKO0FBQ0EsZ0JBQWdCO0FBQ1QsU0FBU3VJLFlBQVl2SSxDQUFDO0lBQ3pCLE1BQU0sRUFBRWhKLEtBQUssRUFBRUMsU0FBUyxFQUFFZ0wsSUFBSSxFQUFFQyxTQUFTLEVBQUUsR0FBR2dHLDBCQUEwQmxJO0lBQ3hFLE1BQU10RixRQUFRM0QsYUFBYUMsT0FBT0M7SUFDbEMsTUFBTXVSLFFBQVF4RyxNQUFNdEgsT0FBT3VILE1BQU1DO0lBQ2pDLE9BQU9vRyw0QkFBNEJ0SSxHQUFHd0k7QUFDMUMsRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzP2Y3Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZSBtZXRob2RzLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiLlxuICpcbiAqICMjIyBEZXNpZ24gcmF0aW9uYWxlIGZvciB0eXBlc1xuICpcbiAqICogSW50ZXJhY3Rpb24gYmV0d2VlbiBjbGFzc2VzIGZyb20gZGlmZmVyZW50IGN1cnZlcyBzaG91bGQgZmFpbDpcbiAqICAgYGsyNTYuUG9pbnQuQkFTRS5hZGQocDI1Ni5Qb2ludC5CQVNFKWBcbiAqICogRm9yIHRoaXMgcHVycG9zZSB3ZSB3YW50IHRvIHVzZSBgaW5zdGFuY2VvZmAgb3BlcmF0b3IsIHdoaWNoIGlzIGZhc3QgYW5kIHdvcmtzIGR1cmluZyBydW50aW1lXG4gKiAqIERpZmZlcmVudCBjYWxscyBvZiBgY3VydmUoKWAgd291bGQgcmV0dXJuIGRpZmZlcmVudCBjbGFzc2VzIC1cbiAqICAgYGN1cnZlKHBhcmFtcykgIT09IGN1cnZlKHBhcmFtcylgOiBpZiBzb21lYm9keSBkZWNpZGVkIHRvIG1vbmtleS1wYXRjaCB0aGVpciBjdXJ2ZSxcbiAqICAgaXQgd29uJ3QgYWZmZWN0IG90aGVyc1xuICpcbiAqIFR5cGVTY3JpcHQgY2FuJ3QgaW5mZXIgdHlwZXMgZm9yIGNsYXNzZXMgY3JlYXRlZCBpbnNpZGUgYSBmdW5jdGlvbi4gQ2xhc3NlcyBpcyBvbmUgaW5zdGFuY2VcbiAqIG9mIG5vbWluYXRpdmUgdHlwZXMgaW4gVHlwZVNjcmlwdCBhbmQgaW50ZXJmYWNlcyBvbmx5IGNoZWNrIGZvciBzaGFwZSwgc28gaXQncyBoYXJkIHRvIGNyZWF0ZVxuICogdW5pcXVlIHR5cGUgZm9yIGV2ZXJ5IGZ1bmN0aW9uIGNhbGwuXG4gKlxuICogV2UgY2FuIHVzZSBnZW5lcmljIHR5cGVzIHZpYSBzb21lIHBhcmFtLCBsaWtlIGN1cnZlIG9wdHMsIGJ1dCB0aGF0IHdvdWxkOlxuICogICAgIDEuIEVuYWJsZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIGBjdXJ2ZShwYXJhbXMpYCBhbmQgYGN1cnZlKHBhcmFtcylgIChjdXJ2ZXMgb2Ygc2FtZSBwYXJhbXMpXG4gKiAgICAgd2hpY2ggaXMgaGFyZCB0byBkZWJ1Zy5cbiAqICAgICAyLiBQYXJhbXMgY2FuIGJlIGdlbmVyaWMgYW5kIHdlIGNhbid0IGVuZm9yY2UgdGhlbSB0byBiZSBjb25zdGFudCB2YWx1ZTpcbiAqICAgICBpZiBzb21lYm9keSBjcmVhdGVzIGN1cnZlIGZyb20gbm9uLWNvbnN0YW50IHBhcmFtcyxcbiAqICAgICBpdCB3b3VsZCBiZSBhbGxvd2VkIHRvIGludGVyYWN0IHdpdGggb3RoZXIgY3VydmVzIHdpdGggbm9uLWNvbnN0YW50IHBhcmFtc1xuICpcbiAqIEB0b2RvIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC0yLTcuaHRtbCN1bmlxdWUtc3ltYm9sXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMuanMnO1xuaW1wb3J0IHsgYWhhc2ggfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IF92YWxpZGF0ZU9iamVjdCwgYWJvb2wsIGFieXRlcywgYUluUmFuZ2UsIGJpdExlbiwgYml0TWFzaywgYnl0ZXNUb0hleCwgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgY3JlYXRlSG1hY0RyYmcsIGVuc3VyZUJ5dGVzLCBoZXhUb0J5dGVzLCBpblJhbmdlLCBpc0J5dGVzLCBtZW1vaXplZCwgbnVtYmVyVG9IZXhVbnBhZGRlZCwgcmFuZG9tQnl0ZXMsIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBfY3JlYXRlQ3VydmVGaWVsZHMsIG11bEVuZG9VbnNhZmUsIG5lZ2F0ZUN0LCBub3JtYWxpemVaLCBwaXBwZW5nZXIsIHdOQUYsIH0gZnJvbSBcIi4vY3VydmUuanNcIjtcbmltcG9ydCB7IEZpZWxkLCBGcEludmVydEJhdGNoLCBnZXRNaW5IYXNoTGVuZ3RoLCBtYXBIYXNoVG9GaWVsZCwgdmFsaWRhdGVGaWVsZCwgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG4vLyBXZSBjb25zdHJ1Y3QgYmFzaXMgaW4gc3VjaCB3YXkgdGhhdCBkZW4gaXMgYWx3YXlzIHBvc2l0aXZlIGFuZCBlcXVhbHMgbiwgYnV0IG51bSBzaWduIGRlcGVuZHMgb24gYmFzaXMgKG5vdCBvbiBzZWNyZXQgdmFsdWUpXG5jb25zdCBkaXZOZWFyZXN0ID0gKG51bSwgZGVuKSA9PiAobnVtICsgKG51bSA+PSAwID8gZGVuIDogLWRlbikgLyBfMm4pIC8gZGVuO1xuLyoqXG4gKiBTcGxpdHMgc2NhbGFyIGZvciBHTFYgZW5kb21vcnBoaXNtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NwbGl0RW5kb1NjYWxhcihrLCBiYXNpcywgbikge1xuICAgIC8vIFNwbGl0IHNjYWxhciBpbnRvIHR3byBzdWNoIHRoYXQgcGFydCBpcyB+aGFsZiBiaXRzOiBgYWJzKHBhcnQpIDwgc3FydChOKWBcbiAgICAvLyBTaW5jZSBwYXJ0IGNhbiBiZSBuZWdhdGl2ZSwgd2UgbmVlZCB0byBkbyB0aGlzIG9uIHBvaW50LlxuICAgIC8vIFRPRE86IHZlcmlmeVNjYWxhciBmdW5jdGlvbiB3aGljaCBjb25zdW1lcyBsYW1iZGFcbiAgICBjb25zdCBbW2ExLCBiMV0sIFthMiwgYjJdXSA9IGJhc2lzO1xuICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgIGNvbnN0IGMyID0gZGl2TmVhcmVzdCgtYjEgKiBrLCBuKTtcbiAgICAvLyB8azF8L3xrMnwgaXMgPCBzcXJ0KE4pLCBidXQgY2FuIGJlIG5lZ2F0aXZlLlxuICAgIC8vIElmIHdlIGRvIGBrMSBtb2QgTmAsIHdlJ2xsIGdldCBiaWcgc2NhbGFyIChgPiBzcXJ0KE4pYCk6IHNvLCB3ZSBkbyBjaGVhcGVyIG5lZ2F0aW9uIGluc3RlYWQuXG4gICAgbGV0IGsxID0gayAtIGMxICogYTEgLSBjMiAqIGEyO1xuICAgIGxldCBrMiA9IC1jMSAqIGIxIC0gYzIgKiBiMjtcbiAgICBjb25zdCBrMW5lZyA9IGsxIDwgXzBuO1xuICAgIGNvbnN0IGsybmVnID0gazIgPCBfMG47XG4gICAgaWYgKGsxbmVnKVxuICAgICAgICBrMSA9IC1rMTtcbiAgICBpZiAoazJuZWcpXG4gICAgICAgIGsyID0gLWsyO1xuICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IHJlc3VsdGluZyBzY2FsYXIgbGVzcyB0aGFuIGhhbGYgYml0cyBvZiBOOiBvdGhlcndpc2Ugd05BRiB3aWxsIGZhaWwuXG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gb24gd3JvbmcgYmFzaXNlcy4gQWxzbywgbWF0aCBpbnNpZGUgaXMgdG9vIGNvbXBsZXggYW5kIEkgZG9uJ3QgdHJ1c3QgaXQuXG4gICAgY29uc3QgTUFYX05VTSA9IGJpdE1hc2soTWF0aC5jZWlsKGJpdExlbihuKSAvIDIpKSArIF8xbjsgLy8gSGFsZiBiaXRzIG9mIE5cbiAgICBpZiAoazEgPCBfMG4gfHwgazEgPj0gTUFYX05VTSB8fCBrMiA8IF8wbiB8fCBrMiA+PSBNQVhfTlVNKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXIgKGVuZG9tb3JwaGlzbSk6IGZhaWxlZCwgaz0nICsgayk7XG4gICAgfVxuICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cykge1xuICAgIGlmIChvcHRzLmxvd1MgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYWJvb2woJ2xvd1MnLCBvcHRzLmxvd1MpO1xuICAgIGlmIChvcHRzLnByZWhhc2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgYWJvb2woJ3ByZWhhc2gnLCBvcHRzLnByZWhhc2gpO1xufVxuZXhwb3J0IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgc3VwZXIobSk7XG4gICAgfVxufVxuLyoqXG4gKiBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzLiBBU04gaXMgdmVyeSBjb21wbGV4ICYgZnJhZ2lsZS4gRm9ybWF0OlxuICpcbiAqICAgICBbMHgzMCAoU0VRVUVOQ0UpLCBieXRlbGVuZ3RoLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBSLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBTXVxuICpcbiAqIERvY3M6IGh0dHBzOi8vbGV0c2VuY3J5cHQub3JnL2RvY3MvYS13YXJtLXdlbGNvbWUtdG8tYXNuMS1hbmQtZGVyLywgaHR0cHM6Ly9sdWNhLm50b3Aub3JnL1RlYWNoaW5nL0FwcHVudGkvYXNuMS5odG1sXG4gKi9cbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBERVJFcnIsXG4gICAgLy8gQmFzaWMgYnVpbGRpbmcgYmxvY2sgaXMgVExWIChUYWctTGVuZ3RoLVZhbHVlKVxuICAgIF90bHY6IHtcbiAgICAgICAgZW5jb2RlOiAodGFnLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHVucGFkZGVkIGRhdGEnKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFMZW4gPSBkYXRhLmxlbmd0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBudW1iZXJUb0hleFVucGFkZGVkKGRhdGFMZW4pO1xuICAgICAgICAgICAgaWYgKChsZW4ubGVuZ3RoIC8gMikgJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IGxvbmcgZm9ybSBsZW5ndGggdG9vIGJpZycpO1xuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGxlbmd0aCB3aXRoIGxvbmcgZm9ybSBmbGFnXG4gICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBkYXRhTGVuID4gMTI3ID8gbnVtYmVyVG9IZXhVbnBhZGRlZCgobGVuLmxlbmd0aCAvIDIpIHwgMTI4KSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgdCA9IG51bWJlclRvSGV4VW5wYWRkZWQodGFnKTtcbiAgICAgICAgICAgIHJldHVybiB0ICsgbGVuTGVuICsgbGVuICsgZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdiAtIHZhbHVlLCBsIC0gbGVmdCBieXRlcyAodW5wYXJzZWQpXG4gICAgICAgIGRlY29kZSh0YWcsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGlmICh0YWcgPCAwIHx8IHRhZyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbcG9zKytdICE9PSB0YWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHRsdicpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IGlzTG9uZyA9ICEhKGZpcnN0ICYgMTI4KTsgLy8gRmlyc3QgYml0IG9mIGZpcnN0IGxlbmd0aCBieXRlIGlzIGZsYWcgZm9yIHNob3J0L2xvbmcgZm9ybVxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoIWlzTG9uZylcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBmaXJzdDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExvbmcgZm9ybTogW2xvbmdGbGFnKDFiaXQpLCBsZW5ndGhMZW5ndGgoN2JpdCksIGxlbmd0aCAoQkUpXVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGZpcnN0ICYgMTI3O1xuICAgICAgICAgICAgICAgIGlmICghbGVuTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogaW5kZWZpbml0ZSBsZW5ndGggbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIGlmIChsZW5MZW4gPiA0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogYnl0ZSBsZW5ndGggaXMgdG9vIGJpZycpOyAvLyB0aGlzIHdpbGwgb3ZlcmZsb3cgdTMyIGluIGpzXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoQnl0ZXMgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuTGVuKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXMubGVuZ3RoICE9PSBsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiBsZW5ndGggYnl0ZXMgbm90IGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEJ5dGVzWzBdID09PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlJyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIGxlbmd0aEJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIDw8IDgpIHwgYjtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuTGVuO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAxMjgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBub3QgbWluaW1hbCBlbmNvZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdiA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHYubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHZhbHVlIGxlbmd0aCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdiwgbDogZGF0YS5zdWJhcnJheShwb3MgKyBsZW5ndGgpIH07XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgX2ludDoge1xuICAgICAgICBlbmNvZGUobnVtKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKG51bSA8IF8wbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW50ZWdlcjogbmVnYXRpdmUgaW50ZWdlcnMgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBsZXQgaGV4ID0gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pO1xuICAgICAgICAgICAgLy8gUGFkIHdpdGggemVybyBieXRlIGlmIG5lZ2F0aXZlIGZsYWcgaXMgcHJlc2VudFxuICAgICAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChoZXhbMF0sIDE2KSAmIDBiMTAwMClcbiAgICAgICAgICAgICAgICBoZXggPSAnMDAnICsgaGV4O1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd1bmV4cGVjdGVkIERFUiBwYXJzaW5nIGFzc2VydGlvbjogdW5wYWRkZWQgaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gaGV4O1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGlmIChkYXRhWzBdICYgMTI4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gPT09IDB4MDAgJiYgIShkYXRhWzFdICYgMTI4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNUb051bWJlckJFKGRhdGEpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUsIF9pbnQ6IGludCwgX3RsdjogdGx2IH0gPSBERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgaGV4KTtcbiAgICAgICAgY29uc3QgeyB2OiBzZXFCeXRlcywgbDogc2VxTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MzAsIGRhdGEpO1xuICAgICAgICBpZiAoc2VxTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIGNvbnN0IHsgdjogckJ5dGVzLCBsOiByTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHNlcUJ5dGVzKTtcbiAgICAgICAgY29uc3QgeyB2OiBzQnl0ZXMsIGw6IHNMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgwMiwgckxlZnRCeXRlcyk7XG4gICAgICAgIGlmIChzTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHI6IGludC5kZWNvZGUockJ5dGVzKSwgczogaW50LmRlY29kZShzQnl0ZXMpIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICBjb25zdCB7IF90bHY6IHRsdiwgX2ludDogaW50IH0gPSBERVI7XG4gICAgICAgIGNvbnN0IHJzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHNlcSA9IHJzICsgc3M7XG4gICAgICAgIHJldHVybiB0bHYuZW5jb2RlKDB4MzAsIHNlcSk7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG4vLyBUT0RPOiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBfbGVnYWN5SGVscGVyRXF1YXQoRnAsIGEsIGIpIHtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGEuIFRha2VzIHgsIHJldHVybnMgecKyLlxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4wrIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geMKzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIHJldHVybiB3ZWllcnN0cmFzc0VxdWF0aW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9ub3JtRm5FbGVtZW50KEZuLCBrZXkpIHtcbiAgICBjb25zdCB7IEJZVEVTOiBleHBlY3RlZCB9ID0gRm47XG4gICAgbGV0IG51bTtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgbnVtID0ga2V5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9IEZuLmZyb21CeXRlcyhieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcHJpdmF0ZSBrZXk6IGV4cGVjdGVkIHVpOGEgb2Ygc2l6ZSAke2V4cGVjdGVkfSwgZ290ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIUZuLmlzVmFsaWROb3QwKG51bSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcml2YXRlIGtleTogb3V0IG9mIHJhbmdlIFsxLi5OLTFdJyk7XG4gICAgcmV0dXJuIG51bTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzc04oQ1VSVkUsIGN1cnZlT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBGcCwgRm4gfSA9IF9jcmVhdGVDdXJ2ZUZpZWxkcygnd2VpZXJzdHJhc3MnLCBDVVJWRSwgY3VydmVPcHRzKTtcbiAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gICAgX3ZhbGlkYXRlT2JqZWN0KGN1cnZlT3B0cywge30sIHtcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZW5kbzogJ29iamVjdCcsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvIH0gPSBjdXJ2ZU9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgLy8gdmFsaWRhdGVPYmplY3QoZW5kbywgeyBiZXRhOiAnYmlnaW50Jywgc3BsaXRTY2FsYXI6ICdmdW5jdGlvbicgfSk7XG4gICAgICAgIGlmICghRnAuaXMwKENVUlZFLmEpIHx8IHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8ICFBcnJheS5pc0FycmF5KGVuZG8uYmFzaXNlcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBlbmRvOiBleHBlY3RlZCBcImJldGFcIjogYmlnaW50IGFuZCBcImJhc2lzZXNcIjogYXJyYXknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRDb21wcmVzc2lvbklzU3VwcG9ydGVkKCkge1xuICAgICAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb21wcmVzc2lvbiBpcyBub3Qgc3VwcG9ydGVkOiBGaWVsZCBkb2VzIG5vdCBoYXZlIC5pc09kZCgpJyk7XG4gICAgfVxuICAgIC8vIEltcGxlbWVudHMgSUVFRSBQMTM2MyBwb2ludCBlbmNvZGluZ1xuICAgIGZ1bmN0aW9uIHBvaW50VG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgIGNvbnN0IGJ4ID0gRnAudG9CeXRlcyh4KTtcbiAgICAgICAgYWJvb2woJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGFzc2VydENvbXByZXNzaW9uSXNTdXBwb3J0ZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc0V2ZW5ZID0gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKHBwcmVmaXgoaGFzRXZlblkpLCBieCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoVWludDhBcnJheS5vZigweDA0KSwgYngsIEZwLnRvQnl0ZXMoeSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50RnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIGFieXRlcyhieXRlcyk7XG4gICAgICAgIGNvbnN0IEwgPSBGcC5CWVRFUztcbiAgICAgICAgY29uc3QgTEMgPSBMICsgMTsgLy8gbGVuZ3RoIGNvbXByZXNzZWQsIGUuZy4gMzMgZm9yIDMyLWJ5dGUgZmllbGRcbiAgICAgICAgY29uc3QgTFUgPSAyICogTCArIDE7IC8vIGxlbmd0aCB1bmNvbXByZXNzZWQsIGUuZy4gNjUgZm9yIDMyLWJ5dGUgZmllbGRcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgLy8gTm8gYWN0dWFsIHZhbGlkYXRpb24gaXMgZG9uZSBoZXJlOiB1c2UgLmFzc2VydFZhbGlkaXR5KClcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gTEMgJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbCk7XG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGlzIG5vdCBvbiBjdXJ2ZSwgd3JvbmcgeCcpO1xuICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGxldCB5O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoc3FydEVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogaXMgbm90IG9uIGN1cnZlLCBzcXJ0IGVycm9yJyArIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRDb21wcmVzc2lvbklzU3VwcG9ydGVkKCk7XG4gICAgICAgICAgICBjb25zdCBpc1lPZGQgPSBGcC5pc09kZCh5KTsgLy8gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxOyAvLyBFQ0RTQS1zcGVjaWZpY1xuICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID09PSBMVSAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtb3JlIGNoZWNrc1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEwgKiAwLCBMICogMSkpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEwgKiAxLCBMICogMikpO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkWFkoeCwgeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgcG9pbnQ6IGdvdCBsZW5ndGggJHtsZW5ndGh9LCBleHBlY3RlZCBjb21wcmVzc2VkPSR7TEN9IG9yIHVuY29tcHJlc3NlZD0ke0xVfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRvQnl0ZXMgPSBjdXJ2ZU9wdHMudG9CeXRlcyB8fCBwb2ludFRvQnl0ZXM7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gY3VydmVPcHRzLmZyb21CeXRlcyB8fCBwb2ludEZyb21CeXRlcztcbiAgICBjb25zdCB3ZWllcnN0cmFzc0VxdWF0aW9uID0gX2xlZ2FjeUhlbHBlckVxdWF0KEZwLCBDVVJWRS5hLCBDVVJWRS5iKTtcbiAgICAvLyBUT0RPOiBtb3ZlIHRvcC1sZXZlbFxuICAgIC8qKiBDaGVja3Mgd2hldGhlciBlcXVhdGlvbiBob2xkcyBmb3IgZ2l2ZW4geCwgeTogecKyID09IHjCsyArIGF4ICsgYiAqL1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRYWSh4LCB5KSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICByZXR1cm4gRnAuZXFsKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gVGVzdCAxOiBlcXVhdGlvbiB5wrIgPSB4wrMgKyBheCArIGIgc2hvdWxkIHdvcmsgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICBpZiAoIWlzVmFsaWRYWShDVVJWRS5HeCwgQ1VSVkUuR3kpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjdXJ2ZSBwYXJhbXM6IGdlbmVyYXRvciBwb2ludCcpO1xuICAgIC8vIFRlc3QgMjogZGlzY3JpbWluYW50IM6UIHBhcnQgc2hvdWxkIGJlIG5vbi16ZXJvOiA0YcKzICsgMjdiwrIgIT0gMC5cbiAgICAvLyBHdWFyYW50ZWVzIGN1cnZlIGlzIGdlbnVzLTEsIHNtb290aCAobm9uLXNpbmd1bGFyKS5cbiAgICBjb25zdCBfNGEzID0gRnAubXVsKEZwLnBvdyhDVVJWRS5hLCBfM24pLCBfNG4pO1xuICAgIGNvbnN0IF8yN2IyID0gRnAubXVsKEZwLnNxcihDVVJWRS5iKSwgQmlnSW50KDI3KSk7XG4gICAgaWYgKEZwLmlzMChGcC5hZGQoXzRhMywgXzI3YjIpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY3VydmUgcGFyYW1zOiBhIG9yIGInKTtcbiAgICAvKiogQXNzZXJ0cyBjb29yZGluYXRlIGlzIHZhbGlkOiAwIDw9IG4gPCBGcC5PUkRFUi4gKi9cbiAgICBmdW5jdGlvbiBhY29vcmQodGl0bGUsIG4sIGJhblplcm8gPSBmYWxzZSkge1xuICAgICAgICBpZiAoIUZwLmlzVmFsaWQobikgfHwgKGJhblplcm8gJiYgRnAuaXMwKG4pKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIHBvaW50IGNvb3JkaW5hdGUgJHt0aXRsZX1gKTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcmpwb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwbGl0RW5kb1NjYWxhck4oaykge1xuICAgICAgICBpZiAoIWVuZG8gfHwgIWVuZG8uYmFzaXNlcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gZW5kbycpO1xuICAgICAgICByZXR1cm4gX3NwbGl0RW5kb1NjYWxhcihrLCBlbmRvLmJhc2lzZXMsIEZuLk9SREVSKTtcbiAgICB9XG4gICAgLy8gTWVtb2l6ZWQgdG9BZmZpbmUgLyB2YWxpZGl0eSBjaGVjay4gVGhleSBhcmUgaGVhdnkuIFBvaW50cyBhcmUgaW1tdXRhYmxlLlxuICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAvLyAoWCwgWSwgWikg4oiLICh4PVgvWiwgeT1ZL1opXG4gICAgY29uc3QgdG9BZmZpbmVNZW1vID0gbWVtb2l6ZWQoKHAsIGl6KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgWCwgWSwgWiB9ID0gcDtcbiAgICAgICAgLy8gRmFzdC1wYXRoIGZvciBub3JtYWxpemVkIHBvaW50c1xuICAgICAgICBpZiAoRnAuZXFsKFosIEZwLk9ORSkpXG4gICAgICAgICAgICByZXR1cm4geyB4OiBYLCB5OiBZIH07XG4gICAgICAgIGNvbnN0IGlzMCA9IHAuaXMwKCk7XG4gICAgICAgIC8vIElmIGludlogd2FzIDAsIHdlIHJldHVybiB6ZXJvIHBvaW50LiBIb3dldmVyIHdlIHN0aWxsIHdhbnQgdG8gZXhlY3V0ZVxuICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgIGl6ID0gaXMwID8gRnAuT05FIDogRnAuaW52KFopO1xuICAgICAgICBjb25zdCB4ID0gRnAubXVsKFgsIGl6KTtcbiAgICAgICAgY29uc3QgeSA9IEZwLm11bChZLCBpeik7XG4gICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKFosIGl6KTtcbiAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH0pO1xuICAgIC8vIE5PVEU6IG9uIGV4Y2VwdGlvbiB0aGlzIHdpbGwgY3Jhc2ggJ2NhY2hlZCcgYW5kIG5vIHZhbHVlIHdpbGwgYmUgc2V0LlxuICAgIC8vIE90aGVyd2lzZSB0cnVlIHdpbGwgYmUgcmV0dXJuXG4gICAgY29uc3QgYXNzZXJ0VmFsaWRNZW1vID0gbWVtb2l6ZWQoKHApID0+IHtcbiAgICAgICAgaWYgKHAuaXMwKCkpIHtcbiAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxuICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIGludmFsaWQgcmVwcmVzZW50YXRpb24gb2YgWkVSTy5cbiAgICAgICAgICAgIGlmIChjdXJ2ZU9wdHMuYWxsb3dJbmZpbml0eVBvaW50ICYmICFGcC5pczAocC5ZKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwLnRvQWZmaW5lKCk7XG4gICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4IG9yIHkgbm90IGZpZWxkIGVsZW1lbnRzJyk7XG4gICAgICAgIGlmICghaXNWYWxpZFhZKHgsIHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAgICAgaWYgKCFwLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZmluaXNoRW5kbyhlbmRvQmV0YSwgazFwLCBrMnAsIGsxbmVnLCBrMm5lZykge1xuICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5YLCBlbmRvQmV0YSksIGsycC5ZLCBrMnAuWik7XG4gICAgICAgIGsxcCA9IG5lZ2F0ZUN0KGsxbmVnLCBrMXApO1xuICAgICAgICBrMnAgPSBuZWdhdGVDdChrMm5lZywgazJwKTtcbiAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczooWCwgWSwgWikg4oiLICh4PVgvWiwgeT1ZL1opLlxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KS5cbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICAvKiogRG9lcyBOT1QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIHZhbGlkLiBVc2UgYC5hc3NlcnRWYWxpZGl0eSgpYC4gKi9cbiAgICAgICAgY29uc3RydWN0b3IoWCwgWSwgWikge1xuICAgICAgICAgICAgdGhpcy5YID0gYWNvb3JkKCd4JywgWCk7XG4gICAgICAgICAgICB0aGlzLlkgPSBhY29vcmQoJ3knLCBZLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuWiA9IGFjb29yZCgneicsIFopO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogRG9lcyBOT1QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIHZhbGlkLiBVc2UgYC5hc3NlcnRWYWxpZGl0eSgpYC4gKi9cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICAvLyAoMCwgMCkgd291bGQndmUgcHJvZHVjZWQgKDAsIDAsIDEpIC0gaW5zdGVhZCwgd2UgbmVlZCAoMCwgMSwgMClcbiAgICAgICAgICAgIGlmIChGcC5pczAoeCkgJiYgRnAuaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZVxuICAgICAgICBnZXQgcHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5YO1xuICAgICAgICB9XG4gICAgICAgIGdldCBweSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlg7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHB6KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuWjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVaKFBvaW50LCBwb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGFieXRlcyhieXRlcyk7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUhleChieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LiAqL1xuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkoX25vcm1GbkVsZW1lbnQoRm4sIHByaXZhdGVLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwaXBwZW5nZXIoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMucHJlY29tcHV0ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHdpbmRvd1NpemVcbiAgICAgICAgICogQHBhcmFtIGlzTGF6eSB0cnVlIHdpbGwgZGVmZXIgdGFibGUgY29tcHV0YXRpb24gdW50aWwgdGhlIGZpcnN0IG11bHRpcGxpY2F0aW9uXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBpc0xhenkgPSB0cnVlKSB7XG4gICAgICAgICAgICB3bmFmLmNyZWF0ZUNhY2hlKHRoaXMsIHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgaWYgKCFpc0xhenkpXG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBseShfM24pOyAvLyByYW5kb20gbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZXR1cm4gYHRoaXNgXG4gICAgICAgIC8qKiBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLiAqL1xuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLiAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFwcmpwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiwgWjogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLiAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuWCwgRnAubmVnKHRoaXMuWSksIHRoaXMuWik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxLCBaOiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFwcmpwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiwgWjogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBjdXJ2ZU9wdHM7XG4gICAgICAgICAgICBpZiAoIUZuLmlzVmFsaWROb3QwKHNjYWxhcikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNjYWxhcjogb3V0IG9mIHJhbmdlJyk7IC8vIDAgaXMgaW52YWxpZFxuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBjb25zdCBtdWwgPSAobikgPT4gd25hZi5jYWNoZWQodGhpcywgbiwgKHApID0+IG5vcm1hbGl6ZVooUG9pbnQsIHApKTtcbiAgICAgICAgICAgIC8qKiBTZWUgZG9jcyBmb3Ige0BsaW5rIEVuZG9tb3JwaGlzbU9wdHN9ICovXG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IHNwbGl0RW5kb1NjYWxhck4oc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHA6IGsxcCwgZjogazFmIH0gPSBtdWwoazEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcDogazJwLCBmOiBrMmYgfSA9IG11bChrMik7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGsxZi5hZGQoazJmKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGZpbmlzaEVuZG8oZW5kby5iZXRhLCBrMXAsIGsycCwgazFuZWcsIGsybmVnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gbXVsKHNjYWxhcik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVooUG9pbnQsIFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgICAqIGFuIGV4cG9zZWQgc2VjcmV0IGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKHNjKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IGN1cnZlT3B0cztcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFGbi5pc1ZhbGlkKHNjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyOiBvdXQgb2YgcmFuZ2UnKTsgLy8gMCBpcyB2YWxpZFxuICAgICAgICAgICAgaWYgKHNjID09PSBfMG4gfHwgcC5pczAoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChzYyA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiBwOyAvLyBmYXN0LXBhdGhcbiAgICAgICAgICAgIGlmICh3bmFmLmhhc0NhY2hlKHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KHNjKTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gc3BsaXRFbmRvU2NhbGFyTihzYyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwMSwgcDIgfSA9IG11bEVuZG9VbnNhZmUoUG9pbnQsIHAsIGsxLCBrMik7IC8vIDMwJSBmYXN0ZXIgdnMgd25hZi51bnNhZmVcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoRW5kbyhlbmRvLmJldGEsIHAxLCBwMiwgazFuZWcsIGsybmVnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZShwLCBzYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gdGhpcy5tdWx0aXBseVVuc2FmZShhKS5hZGQoUS5tdWx0aXBseVVuc2FmZShiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqIEBwYXJhbSBpbnZlcnRlZFogWl4tMSAoaW52ZXJ0ZWQgemVybykgLSBvcHRpb25hbCwgcHJlY29tcHV0YXRpb24gaXMgdXNlZnVsIGZvciBpbnZlcnRCYXRjaFxuICAgICAgICAgKi9cbiAgICAgICAgdG9BZmZpbmUoaW52ZXJ0ZWRaKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9BZmZpbmVNZW1vKHRoaXMsIGludmVydGVkWik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIFBvaW50IGlzIGZyZWUgb2YgdG9yc2lvbiBlbGVtZW50cyAoaXMgaW4gcHJpbWUgc3ViZ3JvdXApLlxuICAgICAgICAgKiBBbHdheXMgdG9yc2lvbi1mcmVlIGZvciBjb2ZhY3Rvcj0xIGN1cnZlcy5cbiAgICAgICAgICovXG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlzVG9yc2lvbkZyZWUgfSA9IGN1cnZlT3B0cztcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlKHRoaXMsIENVUlZFX09SREVSKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBjbGVhckNvZmFjdG9yIH0gPSBjdXJ2ZU9wdHM7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShjb2ZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgaXNTbWFsbE9yZGVyKCkge1xuICAgICAgICAgICAgLy8gY2FuIHdlIHVzZSB0aGlzLmNsZWFyQ29mYWN0b3IoKT9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICB0b0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgdG9CeXRlc2AgKi9cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcy50b0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIGA8UG9pbnQgJHt0aGlzLmlzMCgpID8gJ1pFUk8nIDogdGhpcy50b0hleCgpfT5gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJhc2UgLyBnZW5lcmF0b3IgcG9pbnRcbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICAvLyB6ZXJvIC8gaW5maW5pdHkgLyBpZGVudGl0eSBwb2ludFxuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTsgLy8gMCwgMSwgMFxuICAgIC8vIGZpZWxkc1xuICAgIFBvaW50LkZwID0gRnA7XG4gICAgUG9pbnQuRm4gPSBGbjtcbiAgICBjb25zdCBiaXRzID0gRm4uQklUUztcbiAgICBjb25zdCB3bmFmID0gbmV3IHdOQUYoUG9pbnQsIGN1cnZlT3B0cy5lbmRvID8gTWF0aC5jZWlsKGJpdHMgLyAyKSA6IGJpdHMpO1xuICAgIHJldHVybiBQb2ludDtcbn1cbi8vIF9sZWdhY3lXZWllcnN0cmFzc1xuLy8gVE9ETzogcmVtb3ZlXG4vKiogQGRlcHJlY2F0ZWQgdXNlIGB3ZWllcnN0cmFzc2AgaW4gbmV3ZXIgcmVsZWFzZXMgKi9cbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzc1BvaW50cyhjKSB7XG4gICAgY29uc3QgeyBDVVJWRSwgY3VydmVPcHRzIH0gPSBfd2VpZXJzdHJhc3NfbGVnYWN5X29wdHNfdG9fbmV3KGMpO1xuICAgIGNvbnN0IFBvaW50ID0gd2VpZXJzdHJhc3NOKENVUlZFLCBjdXJ2ZU9wdHMpO1xuICAgIHJldHVybiBfd2VpZXJzdHJhc3NfbmV3X291dHB1dF90b19sZWdhY3koYywgUG9pbnQpO1xufVxuLy8gUG9pbnRzIHN0YXJ0IHdpdGggYnl0ZSAweDAyIHdoZW4geSBpcyBldmVuOyBvdGhlcndpc2UgMHgwM1xuZnVuY3Rpb24gcHByZWZpeChoYXNFdmVuWSkge1xuICAgIHJldHVybiBVaW50OEFycmF5Lm9mKGhhc0V2ZW5ZID8gMHgwMiA6IDB4MDMpO1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBjb25zdCB7IEEsIEIsIFogfSA9IG9wdHM7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKEEpIHx8ICFGcC5pc1ZhbGlkKEIpIHx8ICFGcC5pc1ZhbGlkKFopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBaKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIGRvZXMgbm90IGhhdmUgLmlzT2RkKCknKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIFopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuICAgICAgICB0djIgPSBGcC5zcXIodHYxKTsgLy8gMy4gIHR2MiA9IHR2MV4yXG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcbiAgICAgICAgdHYzID0gRnAubXVsKHR2MywgQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3YoWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBBKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vIDkuICB0djIgPSB0djNeMlxuICAgICAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIEEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBCKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIGNvbnN0IHR2NF9pbnYgPSBGcEludmVydEJhdGNoKEZwLCBbdHY0XSwgdHJ1ZSlbMF07XG4gICAgICAgIHggPSBGcC5tdWwoeCwgdHY0X2ludik7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIEVDRFNBIGZvciBnaXZlbiBlbGxpcHRpYyBjdXJ2ZSBQb2ludCBhbmQgaGFzaCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVjZHNhKFBvaW50LCBoYXNoLCBlY2RzYU9wdHMgPSB7fSkge1xuICAgIGFoYXNoKGhhc2gpO1xuICAgIF92YWxpZGF0ZU9iamVjdChlY2RzYU9wdHMsIHt9LCB7XG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHJhbmRvbUJ5dGVzXyA9IGVjZHNhT3B0cy5yYW5kb21CeXRlcyB8fCByYW5kb21CeXRlcztcbiAgICBjb25zdCBobWFjXyA9IGVjZHNhT3B0cy5obWFjIHx8XG4gICAgICAgICgoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpKTtcbiAgICBjb25zdCB7IEZwLCBGbiB9ID0gUG9pbnQ7XG4gICAgY29uc3QgeyBPUkRFUjogQ1VSVkVfT1JERVIsIEJJVFM6IGZuQml0cyB9ID0gRm47XG4gICAgY29uc3Qgc2VlZExlbiA9IGdldE1pbkhhc2hMZW5ndGgoQ1VSVkVfT1JERVIpO1xuICAgIGNvbnN0IGxlbmd0aHMgPSB7XG4gICAgICAgIHNlY3JldDogRm4uQllURVMsXG4gICAgICAgIHB1YmxpYzogMSArIEZwLkJZVEVTLFxuICAgICAgICBwdWJsaWNVbmNvbXByZXNzZWQ6IDEgKyAyICogRnAuQllURVMsXG4gICAgICAgIHNpZ25hdHVyZTogMiAqIEZuLkJZVEVTLFxuICAgICAgICBzZWVkOiBzZWVkTGVuLFxuICAgIH07XG4gICAgZnVuY3Rpb24gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKG51bWJlcikge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBGbi5uZWcocykgOiBzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhVmFsaWRSUyh0aXRsZSwgbnVtKSB7XG4gICAgICAgIGlmICghRm4uaXNWYWxpZE5vdDAobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzaWduYXR1cmUgJHt0aXRsZX06IG91dCBvZiByYW5nZSAxLi5DVVJWRS5uYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIGFWYWxpZFJTKCdyJywgcik7IC8vIHIgaW4gWzEuLk4tMV1cbiAgICAgICAgICAgIGFWYWxpZFJTKCdzJywgcyk7IC8vIHMgaW4gWzEuLk4tMV1cbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgaWYgKHJlY292ZXJ5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzLCBmb3JtYXQgPSAnY29tcGFjdCcpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdjb21wYWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IEwgPSBGbi5CWVRFUztcbiAgICAgICAgICAgICAgICBhYnl0ZXMoYnl0ZXMsIEwgKiAyKTtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gYnl0ZXMuc3ViYXJyYXkoMCwgTCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGJ5dGVzLnN1YmFycmF5KEwsIEwgKiAyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShGbi5mcm9tQnl0ZXMociksIEZuLmZyb21CeXRlcyhzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGVyJykge1xuICAgICAgICAgICAgICAgIGFieXRlcyhieXRlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoYnl0ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCwgZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnl0ZXMoaGV4VG9CeXRlcyhoZXgpLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb2pQb2ludFR5cGU8YmlnaW50PlxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IEZJRUxEX09SREVSID0gRnAuT1JERVI7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgLy8gRUNEU0EgcmVjb3ZlcnkgaXMgaGFyZCBmb3IgY29mYWN0b3IgPiAxIGN1cnZlcy5cbiAgICAgICAgICAgIC8vIEluIHNpZ24sIGByID0gcS54IG1vZCBuYCwgYW5kIGhlcmUgd2UgcmVjb3ZlciBxLnggZnJvbSByLlxuICAgICAgICAgICAgLy8gV2hpbGUgcmVjb3ZlcmluZyBxLnggPj0gbiwgd2UgbmVlZCB0byBhZGQgcituIGZvciBjb2ZhY3Rvcj0xIGN1cnZlcy5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGZvciBjb2ZhY3Rvcj4xLCByK24gbWF5IG5vdCBnZXQgcS54OlxuICAgICAgICAgICAgLy8gcituKmkgd291bGQgbmVlZCB0byBiZSBkb25lIGluc3RlYWQgd2hlcmUgaSBpcyB1bmtub3duLlxuICAgICAgICAgICAgLy8gVG8gZWFzaWx5IGdldCBpLCB3ZSBlaXRoZXIgbmVlZCB0bzpcbiAgICAgICAgICAgIC8vIGEuIGluY3JlYXNlIGFtb3VudCBvZiB2YWxpZCByZWNpZCB2YWx1ZXMgKDQsIDUuLi4pOyBPUlxuICAgICAgICAgICAgLy8gYi4gcHJvaGliaXQgbm9uLXByaW1lLW9yZGVyIHNpZ25hdHVyZXMgKHJlY2lkID4gMSkuXG4gICAgICAgICAgICBjb25zdCBoYXNDb2ZhY3RvciA9IENVUlZFX09SREVSICogXzJuIDwgRklFTERfT1JERVI7XG4gICAgICAgICAgICBpZiAoaGFzQ29mYWN0b3IgJiYgcmVjID4gMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGlzIGFtYmlndW91cyBmb3IgaD4xIGN1cnZlJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRV9PUkRFUiA6IHI7XG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQocmFkaikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMocmFkaik7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChjb25jYXRCeXRlcyhwcHJlZml4KChyZWMgJiAxKSA9PT0gMCksIHgpKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gRm4uaW52KHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgY29uc3QgdTEgPSBGbi5jcmVhdGUoLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBGbi5jcmVhdGUocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKS4gdW5zYWZlIGlzIGZpbmU6IHRoZXJlIGlzIG5vIHByaXZhdGUgZGF0YS5cbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5VW5zYWZlKHUxKS5hZGQoUi5tdWx0aXBseVVuc2FmZSh1MikpO1xuICAgICAgICAgICAgaWYgKFEuaXMwKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpO1xuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBGbi5uZWcodGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRvQnl0ZXMoZm9ybWF0ID0gJ2NvbXBhY3QnKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnY29tcGFjdCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKEZuLnRvQnl0ZXModGhpcy5yKSwgRm4udG9CeXRlcyh0aGlzLnMpKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZXInKVxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKERFUi5oZXhGcm9tU2lnKHRoaXMpKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmb3JtYXQnKTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChmb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcyhmb3JtYXQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7IH1cbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3NpZycsIGhleCksICdjb21wYWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21CeXRlcyhlbnN1cmVCeXRlcygnc2lnJywgaGV4KSwgJ2RlcicpO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCdkZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcygnZGVyJykpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcygnY29tcGFjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcygnY29tcGFjdCcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkU2VjcmV0S2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhIV9ub3JtRm5FbGVtZW50KEZuLCBwcml2YXRlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkUHVibGljS2V5KHB1YmxpY0tleSwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsID0gcHVibGljS2V5Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQgPT09IHRydWUgJiYgbCAhPT0gbGVuZ3Rocy5wdWJsaWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCA9PT0gZmFsc2UgJiYgbCAhPT0gbGVuZ3Rocy5wdWJsaWNVbmNvbXByZXNzZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuICEhUG9pbnQuZnJvbUJ5dGVzKHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHNlY3JldCBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbVNlY3JldEtleShzZWVkID0gcmFuZG9tQnl0ZXNfKHNlZWRMZW4pKSB7XG4gICAgICAgIHJldHVybiBtYXBIYXNoVG9GaWVsZChzZWVkLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkU2VjcmV0S2V5LFxuICAgICAgICBpc1ZhbGlkUHVibGljS2V5LFxuICAgICAgICByYW5kb21TZWNyZXRLZXksXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZVxuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleTogaXNWYWxpZFNlY3JldEtleSxcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogcmFuZG9tU2VjcmV0S2V5LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiAoa2V5KSA9PiBfbm9ybUZuRWxlbWVudChGbiwga2V5KSxcbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQucHJlY29tcHV0ZSh3aW5kb3dTaXplLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHNlY3JldCBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHNlY3JldCBrZXkuXG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHNlY3JldEtleSwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShfbm9ybUZuRWxlbWVudChGbiwgc2VjcmV0S2V5KSkudG9CeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWljayBhbmQgZGlydHkgY2hlY2sgZm9yIGl0ZW0gYmVpbmcgcHVibGljIGtleS4gRG9lcyBub3QgdmFsaWRhdGUgaGV4LCBvciBiZWluZyBvbi1jdXJ2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKEZuLmFsbG93ZWRMZW5ndGhzIHx8IGxlbmd0aHMuc2VjcmV0ID09PSBsZW5ndGhzLnB1YmxpYylcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGwgPSBlbnN1cmVCeXRlcygna2V5JywgaXRlbSkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbCA9PT0gbGVuZ3Rocy5wdWJsaWMgfHwgbCA9PT0gbGVuZ3Rocy5wdWJsaWNVbmNvbXByZXNzZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHNlY3JldCBrZXkgQSBhbmQgcHVibGljIGtleSBCLlxuICAgICAqIENoZWNrczogMSkgc2VjcmV0IGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxuICAgICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHNlY3JldEtleUEsIHB1YmxpY0tleUIsIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKGlzUHJvYlB1YihzZWNyZXRLZXlBKSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKGlzUHJvYlB1YihwdWJsaWNLZXlCKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IHMgPSBfbm9ybUZuRWxlbWVudChGbiwgc2VjcmV0S2V5QSk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleUIpOyAvLyBjaGVja3MgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgICAgIHJldHVybiBiLm11bHRpcGx5KHMpLnRvQnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IGVjZHNhT3B0cy5iaXRzMmludCB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIE91ciBjdXN0b20gY2hlY2sgXCJqdXN0IGluIGNhc2VcIiwgZm9yIHByb3RlY3Rpb24gYWdhaW5zdCBEb1NcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiA4MTkyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgaXMgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gZm5CaXRzOyAvLyB0cnVuY2F0ZSB0byBuQml0TGVuZ3RoIGxlZnRtb3N0IGJpdHNcbiAgICAgICAgICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbiAgICAgICAgfTtcbiAgICBjb25zdCBiaXRzMmludF9tb2ROID0gZWNkc2FPcHRzLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gRm4uY3JlYXRlKGJpdHMyaW50KGJ5dGVzKSk7IC8vIGNhbid0IHVzZSBieXRlc1RvTnVtYmVyQkUgaGVyZVxuICAgICAgICB9O1xuICAgIC8vIE5PVEU6IHBhZHMgb3V0cHV0IHdpdGggemVybyBhcyBwZXIgc3BlY1xuICAgIGNvbnN0IE9SREVSX01BU0sgPSBiaXRNYXNrKGZuQml0cyk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICAvLyBJTVBPUlRBTlQ6IHRoZSBjaGVjayBlbnN1cmVzIHdvcmtpbmcgZm9yIGNhc2UgYEZuLkJZVEVTICE9IEZuLkJJVFMgKiA4YFxuICAgICAgICBhSW5SYW5nZSgnbnVtIDwgMl4nICsgZm5CaXRzLCBudW0sIF8wbiwgT1JERVJfTUFTSyk7XG4gICAgICAgIHJldHVybiBGbi50b0J5dGVzKG51bSk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlcixcbiAgICAvLyB0aGlzIHdpbGwgYmUgaW52YWxpZCBhdCBsZWFzdCBmb3IgUDUyMS4gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XG4gICAgZnVuY3Rpb24gcHJlcFNpZyhtc2dIYXNoLCBwcml2YXRlS2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgaWYgKFsncmVjb3ZlcmVkJywgJ2Nhbm9uaWNhbCddLnNvbWUoKGspID0+IGsgaW4gb3B0cykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBmbkJpdHMgJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IGQgPSBfbm9ybUZuRWxlbWVudChGbiwgcHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHNlY3JldCBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXNfKGxlbmd0aHMuc2VjcmV0KSA6IGVudDsgLy8gZ2VuIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSBjb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICAvLyBUbyB0cmFuc2Zvcm0gayA9PiBTaWduYXR1cmU6XG4gICAgICAgIC8vIHEgPSBr4ouFR1xuICAgICAgICAvLyByID0gcS54IG1vZCBuXG4gICAgICAgIC8vIHMgPSBrXi0xKG0gKyByZCkgbW9kIG5cbiAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFGbi5pc1ZhbGlkTm90MChrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFZhbGlkIHNjYWxhcnMgKGluY2x1ZGluZyBrKSBtdXN0IGJlIGluIDEuLk4tMVxuICAgICAgICAgICAgY29uc3QgaWsgPSBGbi5pbnYoayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBr4ouFR1xuICAgICAgICAgICAgY29uc3QgciA9IEZuLmNyZWF0ZShxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBGbi5jcmVhdGUoaWsgKiBGbi5jcmVhdGUobSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlLCBzZWUgY29tbWVudCBhYm92ZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IGVjZHNhT3B0cy5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBlY2RzYU9wdHMubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHNlY3JldCBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHNlY3JldEtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgc2VjcmV0S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEcmJnKGhhc2gub3V0cHV0TGVuLCBGbi5CWVRFUywgaG1hY18pO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UucHJlY29tcHV0ZSg4KTtcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgLy8gVmVyaWZ5IG9wdHNcbiAgICAgICAgdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2gsIGZvcm1hdCB9ID0gb3B0cztcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZGVkdWNlIGZvcm1hdFxuICAgICAgICAgICAgY29uc3QgaXNIZXggPSB0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IGlzQnl0ZXMoc2cpO1xuICAgICAgICAgICAgY29uc3QgaXNPYmogPSAhaXNIZXggJiZcbiAgICAgICAgICAgICAgICBzZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCc7XG4gICAgICAgICAgICBpZiAoIWlzSGV4ICYmICFpc09iailcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmF0dXJlLCBleHBlY3RlZCBVaW50OEFycmF5LCBoZXggc3RyaW5nIG9yIFNpZ25hdHVyZSBpbnN0YW5jZScpO1xuICAgICAgICAgICAgaWYgKGlzT2JqKSB7XG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUoc2cuciwgc2cucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0hleCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIG1hbGxlYWJsZSBjaGVja1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKkZuLkJZVEVTKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipGbi5CWVRFUyBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghX3NpZykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnY29tcGFjdCcgfHwgZm9ybWF0ID09PSAnZGVyJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2cgIT09ICdzdHJpbmcnICYmICFpc0J5dGVzKHNnKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImRlclwiIC8gXCJjb21wYWN0XCIgZm9ybWF0IGV4cGVjdHMgVWludDhBcnJheSBzaWduYXR1cmUnKTtcbiAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21CeXRlcyhlbnN1cmVCeXRlcygnc2lnJywgc2cpLCBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSAnanMnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoc2cgaW5zdGFuY2VvZiBTaWduYXR1cmUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wianNcIiBmb3JtYXQgZXhwZWN0cyBTaWduYXR1cmUgaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICBfc2lnID0gc2c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBtdXN0IGJlIFwiY29tcGFjdFwiLCBcImRlclwiIG9yIFwianNcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghX3NpZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFAgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gdG9kbzogb3B0aW9uYWwuaGFzaCA9PiBoYXNoXG4gICAgICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgICAgICBtc2dIYXNoID0gaGFzaChtc2dIYXNoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCBpcyA9IEZuLmludihzKTsgLy8gc14tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBGbi5jcmVhdGUoaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgdTIgPSBGbi5jcmVhdGUociAqIGlzKTsgLy8gdTIgPSByc14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlVbnNhZmUodTEpLmFkZChQLm11bHRpcGx5VW5zYWZlKHUyKSk7XG4gICAgICAgICAgICBpZiAoUi5pczAoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCB2ID0gRm4uY3JlYXRlKFIueCk7IC8vIHYgPSByLnggbW9kIG5cbiAgICAgICAgICAgIHJldHVybiB2ID09PSByO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24ga2V5Z2VuKHNlZWQpIHtcbiAgICAgICAgY29uc3Qgc2VjcmV0S2V5ID0gdXRpbHMucmFuZG9tU2VjcmV0S2V5KHNlZWQpO1xuICAgICAgICByZXR1cm4geyBzZWNyZXRLZXksIHB1YmxpY0tleTogZ2V0UHVibGljS2V5KHNlY3JldEtleSkgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICBrZXlnZW4sXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHV0aWxzLFxuICAgICAgICBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICBpbmZvOiB7IHR5cGU6ICd3ZWllcnN0cmFzcycsIGxlbmd0aHMsIHB1YmxpY0tleUhhc1ByZWZpeDogdHJ1ZSB9LFxuICAgIH0pO1xufVxuLy8gVE9ETzogcmVtb3ZlXG5mdW5jdGlvbiBfd2VpZXJzdHJhc3NfbGVnYWN5X29wdHNfdG9fbmV3KGMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHtcbiAgICAgICAgYTogYy5hLFxuICAgICAgICBiOiBjLmIsXG4gICAgICAgIHA6IGMuRnAuT1JERVIsXG4gICAgICAgIG46IGMubixcbiAgICAgICAgaDogYy5oLFxuICAgICAgICBHeDogYy5HeCxcbiAgICAgICAgR3k6IGMuR3ksXG4gICAgfTtcbiAgICBjb25zdCBGcCA9IGMuRnA7XG4gICAgbGV0IGFsbG93ZWRMZW5ndGhzID0gYy5hbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHNcbiAgICAgICAgPyBBcnJheS5mcm9tKG5ldyBTZXQoYy5hbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMubWFwKChsKSA9PiBNYXRoLmNlaWwobCAvIDIpKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IEZuID0gRmllbGQoQ1VSVkUubiwge1xuICAgICAgICBCSVRTOiBjLm5CaXRMZW5ndGgsXG4gICAgICAgIGFsbG93ZWRMZW5ndGhzOiBhbGxvd2VkTGVuZ3RocyxcbiAgICAgICAgbW9kT25EZWNvZGU6IGMud3JhcFByaXZhdGVLZXksXG4gICAgfSk7XG4gICAgY29uc3QgY3VydmVPcHRzID0ge1xuICAgICAgICBGcCxcbiAgICAgICAgRm4sXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogYy5hbGxvd0luZmluaXR5UG9pbnQsXG4gICAgICAgIGVuZG86IGMuZW5kbyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogYy5pc1RvcnNpb25GcmVlLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiBjLmNsZWFyQ29mYWN0b3IsXG4gICAgICAgIGZyb21CeXRlczogYy5mcm9tQnl0ZXMsXG4gICAgICAgIHRvQnl0ZXM6IGMudG9CeXRlcyxcbiAgICB9O1xuICAgIHJldHVybiB7IENVUlZFLCBjdXJ2ZU9wdHMgfTtcbn1cbmZ1bmN0aW9uIF9lY2RzYV9sZWdhY3lfb3B0c190b19uZXcoYykge1xuICAgIGNvbnN0IHsgQ1VSVkUsIGN1cnZlT3B0cyB9ID0gX3dlaWVyc3RyYXNzX2xlZ2FjeV9vcHRzX3RvX25ldyhjKTtcbiAgICBjb25zdCBlY2RzYU9wdHMgPSB7XG4gICAgICAgIGhtYWM6IGMuaG1hYyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6IGMucmFuZG9tQnl0ZXMsXG4gICAgICAgIGxvd1M6IGMubG93UyxcbiAgICAgICAgYml0czJpbnQ6IGMuYml0czJpbnQsXG4gICAgICAgIGJpdHMyaW50X21vZE46IGMuYml0czJpbnRfbW9kTixcbiAgICB9O1xuICAgIHJldHVybiB7IENVUlZFLCBjdXJ2ZU9wdHMsIGhhc2g6IGMuaGFzaCwgZWNkc2FPcHRzIH07XG59XG4vLyBUT0RPOiByZW1vdmVcbmZ1bmN0aW9uIF93ZWllcnN0cmFzc19uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBQb2ludCkge1xuICAgIGNvbnN0IHsgRnAsIEZuIH0gPSBQb2ludDtcbiAgICAvLyBUT0RPOiByZW1vdmVcbiAgICBmdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgICAgIHJldHVybiBpblJhbmdlKG51bSwgXzFuLCBGbi5PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHdlaWVyc3RyYXNzRXF1YXRpb24gPSBfbGVnYWN5SGVscGVyRXF1YXQoRnAsIGMuYSwgYy5iKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICBDVVJWRTogYyxcbiAgICAgICAgUG9pbnQ6IFBvaW50LFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiAoa2V5KSA9PiBfbm9ybUZuRWxlbWVudChGbiwga2V5KSxcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH0pO1xufVxuLy8gVE9ETzogcmVtb3ZlXG5mdW5jdGlvbiBfZWNkc2FfbmV3X291dHB1dF90b19sZWdhY3koYywgZWNkc2EpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZWNkc2EsIHtcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBlY2RzYS5Qb2ludCxcbiAgICAgICAgQ1VSVkU6IGMsXG4gICAgfSk7XG59XG4vLyBfZWNkc2FfbGVnYWN5XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoYykge1xuICAgIGNvbnN0IHsgQ1VSVkUsIGN1cnZlT3B0cywgaGFzaCwgZWNkc2FPcHRzIH0gPSBfZWNkc2FfbGVnYWN5X29wdHNfdG9fbmV3KGMpO1xuICAgIGNvbnN0IFBvaW50ID0gd2VpZXJzdHJhc3NOKENVUlZFLCBjdXJ2ZU9wdHMpO1xuICAgIGNvbnN0IHNpZ25zID0gZWNkc2EoUG9pbnQsIGhhc2gsIGVjZHNhT3B0cyk7XG4gICAgcmV0dXJuIF9lY2RzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBzaWducyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOlsiaG1hYyIsImFoYXNoIiwiX3ZhbGlkYXRlT2JqZWN0IiwiYWJvb2wiLCJhYnl0ZXMiLCJhSW5SYW5nZSIsImJpdExlbiIsImJpdE1hc2siLCJieXRlc1RvSGV4IiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJjcmVhdGVIbWFjRHJiZyIsImVuc3VyZUJ5dGVzIiwiaGV4VG9CeXRlcyIsImluUmFuZ2UiLCJpc0J5dGVzIiwibWVtb2l6ZWQiLCJudW1iZXJUb0hleFVucGFkZGVkIiwicmFuZG9tQnl0ZXMiLCJfY3JlYXRlQ3VydmVGaWVsZHMiLCJtdWxFbmRvVW5zYWZlIiwibmVnYXRlQ3QiLCJub3JtYWxpemVaIiwicGlwcGVuZ2VyIiwid05BRiIsIkZpZWxkIiwiRnBJbnZlcnRCYXRjaCIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsInZhbGlkYXRlRmllbGQiLCJkaXZOZWFyZXN0IiwibnVtIiwiZGVuIiwiXzJuIiwiX3NwbGl0RW5kb1NjYWxhciIsImsiLCJiYXNpcyIsIm4iLCJhMSIsImIxIiwiYTIiLCJiMiIsImMxIiwiYzIiLCJrMSIsImsyIiwiazFuZWciLCJfMG4iLCJrMm5lZyIsIk1BWF9OVU0iLCJNYXRoIiwiY2VpbCIsIl8xbiIsIkVycm9yIiwidmFsaWRhdGVTaWdWZXJPcHRzIiwib3B0cyIsImxvd1MiLCJ1bmRlZmluZWQiLCJwcmVoYXNoIiwiREVSRXJyIiwiY29uc3RydWN0b3IiLCJtIiwiREVSIiwiRXJyIiwiX3RsdiIsImVuY29kZSIsInRhZyIsImRhdGEiLCJFIiwibGVuZ3RoIiwiZGF0YUxlbiIsImxlbiIsImxlbkxlbiIsInQiLCJkZWNvZGUiLCJwb3MiLCJmaXJzdCIsImlzTG9uZyIsImxlbmd0aEJ5dGVzIiwic3ViYXJyYXkiLCJiIiwidiIsImwiLCJfaW50IiwiaGV4IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJ0b1NpZyIsImludCIsInRsdiIsInNlcUJ5dGVzIiwic2VxTGVmdEJ5dGVzIiwickJ5dGVzIiwickxlZnRCeXRlcyIsInNCeXRlcyIsInNMZWZ0Qnl0ZXMiLCJyIiwicyIsImhleEZyb21TaWciLCJzaWciLCJycyIsInNzIiwic2VxIiwiQmlnSW50IiwiXzNuIiwiXzRuIiwiX2xlZ2FjeUhlbHBlckVxdWF0IiwiRnAiLCJhIiwid2VpZXJzdHJhc3NFcXVhdGlvbiIsIngiLCJ4MiIsInNxciIsIngzIiwibXVsIiwiYWRkIiwiX25vcm1GbkVsZW1lbnQiLCJGbiIsImtleSIsIkJZVEVTIiwiZXhwZWN0ZWQiLCJieXRlcyIsImZyb21CeXRlcyIsImVycm9yIiwiaXNWYWxpZE5vdDAiLCJ3ZWllcnN0cmFzc04iLCJDVVJWRSIsImN1cnZlT3B0cyIsImgiLCJjb2ZhY3RvciIsIkNVUlZFX09SREVSIiwiYWxsb3dJbmZpbml0eVBvaW50IiwiY2xlYXJDb2ZhY3RvciIsImlzVG9yc2lvbkZyZWUiLCJ0b0J5dGVzIiwiZW5kbyIsIndyYXBQcml2YXRlS2V5IiwiaXMwIiwiYmV0YSIsIkFycmF5IiwiaXNBcnJheSIsImJhc2lzZXMiLCJhc3NlcnRDb21wcmVzc2lvbklzU3VwcG9ydGVkIiwiaXNPZGQiLCJwb2ludFRvQnl0ZXMiLCJfYyIsInBvaW50IiwiaXNDb21wcmVzc2VkIiwieSIsInRvQWZmaW5lIiwiYngiLCJoYXNFdmVuWSIsInBwcmVmaXgiLCJVaW50OEFycmF5Iiwib2YiLCJwb2ludEZyb21CeXRlcyIsIkwiLCJMQyIsIkxVIiwiaGVhZCIsInRhaWwiLCJpc1ZhbGlkIiwieTIiLCJzcXJ0Iiwic3FydEVycm9yIiwiZXJyIiwibWVzc2FnZSIsImlzWU9kZCIsImlzSGVhZE9kZCIsIm5lZyIsImlzVmFsaWRYWSIsImxlZnQiLCJyaWdodCIsImVxbCIsIkd4IiwiR3kiLCJfNGEzIiwicG93IiwiXzI3YjIiLCJhY29vcmQiLCJ0aXRsZSIsImJhblplcm8iLCJhcHJqcG9pbnQiLCJvdGhlciIsIlBvaW50Iiwic3BsaXRFbmRvU2NhbGFyTiIsIk9SREVSIiwidG9BZmZpbmVNZW1vIiwicCIsIml6IiwiWCIsIlkiLCJaIiwiT05FIiwiaW52IiwienoiLCJaRVJPIiwiYXNzZXJ0VmFsaWRNZW1vIiwiZmluaXNoRW5kbyIsImVuZG9CZXRhIiwiazFwIiwiazJwIiwiT2JqZWN0IiwiZnJlZXplIiwiZnJvbUFmZmluZSIsInB4IiwicHkiLCJweiIsInBvaW50cyIsImZyb21IZXgiLCJQIiwiYXNzZXJ0VmFsaWRpdHkiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJCQVNFIiwibXVsdGlwbHkiLCJtc20iLCJzY2FsYXJzIiwiX3NldFdpbmRvd1NpemUiLCJ3aW5kb3dTaXplIiwicHJlY29tcHV0ZSIsImlzTGF6eSIsInduYWYiLCJjcmVhdGVDYWNoZSIsImVxdWFscyIsIlgxIiwiWTEiLCJaMSIsIlgyIiwiWTIiLCJaMiIsIlUxIiwiVTIiLCJuZWdhdGUiLCJkb3VibGUiLCJiMyIsIlgzIiwiWTMiLCJaMyIsInQwIiwidDEiLCJ0MiIsInQzIiwic3ViIiwidDQiLCJ0NSIsInN1YnRyYWN0Iiwic2NhbGFyIiwiZmFrZSIsImNhY2hlZCIsImYiLCJrMWYiLCJrMmYiLCJtdWx0aXBseVVuc2FmZSIsInNjIiwiaGFzQ2FjaGUiLCJwMSIsInAyIiwidW5zYWZlIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJRIiwic3VtIiwiaW52ZXJ0ZWRaIiwiaXNTbWFsbE9yZGVyIiwidG9SYXdCeXRlcyIsInRvSGV4IiwidG9TdHJpbmciLCJiaXRzIiwiQklUUyIsIndlaWVyc3RyYXNzUG9pbnRzIiwiYyIsIl93ZWllcnN0cmFzc19sZWdhY3lfb3B0c190b19uZXciLCJfd2VpZXJzdHJhc3NfbmV3X291dHB1dF90b19sZWdhY3kiLCJTV1VGcFNxcnRSYXRpbyIsInEiLCJvIiwiXzJuX3Bvd19jMV8xIiwiXzJuX3Bvd19jMSIsImMzIiwiYzQiLCJjNSIsImM2IiwiYzciLCJzcXJ0UmF0aW8iLCJ1IiwidHYxIiwidHYyIiwidHYzIiwidHY1IiwidHY0IiwiaXNRUiIsImNtb3YiLCJpIiwidHZ2NSIsImUxIiwidmFsdWUiLCJ5MSIsIm1hcFRvQ3VydmVTaW1wbGVTV1UiLCJBIiwiQiIsInR2NiIsInR2NF9pbnYiLCJlY2RzYSIsImhhc2giLCJlY2RzYU9wdHMiLCJiaXRzMmludCIsImJpdHMyaW50X21vZE4iLCJyYW5kb21CeXRlc18iLCJobWFjXyIsIm1zZ3MiLCJmbkJpdHMiLCJzZWVkTGVuIiwibGVuZ3RocyIsInNlY3JldCIsInB1YmxpYyIsInB1YmxpY1VuY29tcHJlc3NlZCIsInNpZ25hdHVyZSIsInNlZWQiLCJpc0JpZ2dlclRoYW5IYWxmT3JkZXIiLCJudW1iZXIiLCJIQUxGIiwibm9ybWFsaXplUyIsImFWYWxpZFJTIiwiU2lnbmF0dXJlIiwicmVjb3ZlcnkiLCJmb3JtYXQiLCJhZGRSZWNvdmVyeUJpdCIsInJlY292ZXJQdWJsaWNLZXkiLCJtc2dIYXNoIiwiRklFTERfT1JERVIiLCJyZWMiLCJpbmNsdWRlcyIsImhhc0NvZmFjdG9yIiwicmFkaiIsIlIiLCJpciIsInUxIiwiY3JlYXRlIiwidTIiLCJoYXNIaWdoUyIsImZyb21Db21wYWN0IiwiZnJvbURFUiIsInRvREVSUmF3Qnl0ZXMiLCJ0b0RFUkhleCIsInRvQ29tcGFjdFJhd0J5dGVzIiwidG9Db21wYWN0SGV4IiwiaXNWYWxpZFNlY3JldEtleSIsImlzVmFsaWRQdWJsaWNLZXkiLCJwdWJsaWNLZXkiLCJyYW5kb21TZWNyZXRLZXkiLCJ1dGlscyIsImlzVmFsaWRQcml2YXRlS2V5IiwicmFuZG9tUHJpdmF0ZUtleSIsIm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIiLCJnZXRQdWJsaWNLZXkiLCJzZWNyZXRLZXkiLCJpc1Byb2JQdWIiLCJpdGVtIiwiYWxsb3dlZExlbmd0aHMiLCJnZXRTaGFyZWRTZWNyZXQiLCJzZWNyZXRLZXlBIiwicHVibGljS2V5QiIsImRlbHRhIiwiT1JERVJfTUFTSyIsImludDJvY3RldHMiLCJwcmVwU2lnIiwiZGVmYXVsdFNpZ09wdHMiLCJzb21lIiwiZXh0cmFFbnRyb3B5IiwiZW50IiwiaDFpbnQiLCJkIiwic2VlZEFyZ3MiLCJlIiwicHVzaCIsImsyc2lnIiwia0J5dGVzIiwiaWsiLCJub3JtUyIsImRlZmF1bHRWZXJPcHRzIiwic2lnbiIsImRyYmciLCJvdXRwdXRMZW4iLCJ2ZXJpZnkiLCJzZyIsIl9zaWciLCJpc0hleCIsImlzT2JqIiwiZGVyRXJyb3IiLCJpcyIsImtleWdlbiIsImluZm8iLCJ0eXBlIiwicHVibGljS2V5SGFzUHJlZml4IiwiYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIiwiZnJvbSIsIlNldCIsIm1hcCIsIm5CaXRMZW5ndGgiLCJtb2RPbkRlY29kZSIsIl9lY2RzYV9sZWdhY3lfb3B0c190b19uZXciLCJpc1dpdGhpbkN1cnZlT3JkZXIiLCJhc3NpZ24iLCJQcm9qZWN0aXZlUG9pbnQiLCJfZWNkc2FfbmV3X291dHB1dF90b19sZWdhY3kiLCJ3ZWllcnN0cmFzcyIsInNpZ25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/ed25519.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/ed25519.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_TORSION_SUBGROUP: () => (/* binding */ ED25519_TORSION_SUBGROUP),\n/* harmony export */   RistrettoPoint: () => (/* binding */ RistrettoPoint),\n/* harmony export */   ed25519: () => (/* binding */ ed25519),\n/* harmony export */   ed25519_hasher: () => (/* binding */ ed25519_hasher),\n/* harmony export */   ed25519ctx: () => (/* binding */ ed25519ctx),\n/* harmony export */   ed25519ph: () => (/* binding */ ed25519ph),\n/* harmony export */   edwardsToMontgomery: () => (/* binding */ edwardsToMontgomery),\n/* harmony export */   edwardsToMontgomeryPriv: () => (/* binding */ edwardsToMontgomeryPriv),\n/* harmony export */   edwardsToMontgomeryPub: () => (/* binding */ edwardsToMontgomeryPub),\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   hashToRistretto255: () => (/* binding */ hashToRistretto255),\n/* harmony export */   hash_to_ristretto255: () => (/* binding */ hash_to_ristretto255),\n/* harmony export */   ristretto255: () => (/* binding */ ristretto255),\n/* harmony export */   ristretto255_hasher: () => (/* binding */ ristretto255_hasher),\n/* harmony export */   x25519: () => (/* binding */ x25519)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha2.js */ \"(ssr)/./node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_curve_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./abstract/curve.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/edwards.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/edwards.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/montgomery.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/montgomery.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n// P = 2n**255n - 19n\n// N = 2n**252n + 27742317777372353535851937790883648493n\n// a = Fp.create(BigInt(-1))\n// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\nconst ed25519_CURVE = {\n    p: BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\"),\n    n: BigInt(\"0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\"),\n    h: _8n,\n    a: BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec\"),\n    d: BigInt(\"0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3\"),\n    Gx: BigInt(\"0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\"),\n    Gy: BigInt(\"0x6666666666666666666666666666666666666666666666666666666666666658\")\n};\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ed25519_CURVE.p;\n    const x2 = x * x % P;\n    const b2 = x2 * x % P; // x^3, 11\n    const b4 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b2, _2n, P) * b2 % P; // x^15, 1111\n    const b5 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b4, _1n, P) * x % P; // x^31\n    const b10 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b5, _5n, P) * b5 % P;\n    const b20 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b10, _10n, P) * b10 % P;\n    const b40 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b20, _20n, P) * b20 % P;\n    const b80 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b40, _40n, P) * b40 % P;\n    const b160 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b80, _80n, P) * b80 % P;\n    const b240 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b160, _80n, P) * b80 % P;\n    const b250 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b240, _10n, P) * b10 % P;\n    const pow_p_5_8 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b250, _2n, P) * x % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return {\n        pow_p_5_8,\n        b2\n    };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// √(-1) aka √(a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ed25519_CURVE.p;\n    const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * v * v, P); // v³\n    const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v3 * v3 * v, P); // v⁷\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * x * x, P); // vx²\n    const root1 = x; // First root candidate\n    const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P)) x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-x, P);\n    return {\n        isValid: useRoot1 || useRoot2,\n        value: x\n    };\n}\nconst Fp = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ed25519_CURVE.p, {\n        isLE: true\n    }))();\nconst Fn = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ed25519_CURVE.n, {\n        isLE: true\n    }))();\nconst ed25519Defaults = /* @__PURE__ */ (()=>({\n        ...ed25519_CURVE,\n        Fp,\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512,\n        adjustScalarBytes,\n        // dom2\n        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n        // Constant-time, u/√v\n        uvRatio\n    }))();\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const { secretKey, publicKey } = ed25519.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */ const ed25519 = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)(ed25519Defaults))();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255) throw new Error(\"Context is too big\");\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.utf8ToBytes)(\"SigEd25519 no Ed25519 collisions\"), new Uint8Array([\n        phflag ? 1 : 0,\n        ctx.length\n    ]), ctx, data);\n}\n/** Context of ed25519. Uses context for domain separation. */ const ed25519ctx = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)({\n        ...ed25519Defaults,\n        domain: ed25519_domain\n    }))();\n/** Prehashed version of ed25519. Accepts already-hashed messages in sign() and verify(). */ const ed25519ph = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)(Object.assign({}, ed25519Defaults, {\n        domain: ed25519_domain,\n        prehash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512\n    })))();\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomSecretKey());\n */ const x25519 = /* @__PURE__ */ (()=>{\n    const P = ed25519_CURVE.p;\n    return (0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__.montgomery)({\n        P,\n        type: \"x25519\",\n        powPminus2: (x)=>{\n            // x^(p-2) aka x^(2^255-21)\n            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n            return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(pow_p_5_8, _3n, P) * b2, P);\n        },\n        adjustScalarBytes\n    });\n})();\n/** @deprecated use `ed25519.utils.toMontgomery` */ function edwardsToMontgomeryPub(edwardsPub) {\n    return ed25519.utils.toMontgomery((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"pub\", edwardsPub));\n}\n/** @deprecated use `ed25519.utils.toMontgomery` */ const edwardsToMontgomery = edwardsToMontgomeryPub;\n/** @deprecated use `ed25519.utils.toMontgomeryPriv` */ function edwardsToMontgomeryPriv(edwardsPriv) {\n    return ed25519.utils.toMontgomeryPriv((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"pub\", edwardsPriv));\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (()=>(Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (()=>Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (()=>Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return {\n        xMn: xn,\n        xMd: xd,\n        yMn: y,\n        yMd: _1n\n    }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const [xd_inv, yd_inv] = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch)(Fp, [\n        xd,\n        yd\n    ], true); // batch division\n    return {\n        x: Fp.mul(xn, xd_inv),\n        y: Fp.mul(yn, yd_inv)\n    }; //  13. return (xn, xd, yn, yd)\n}\n/** Hashing to ed25519 points / field. RFC 9380 methods. */ const ed25519_hasher = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.createHasher)(ed25519.Point, (scalars)=>map_to_curve_elligator2_edwards25519(scalars[0]), {\n        DST: \"edwards25519_XMD:SHA-512_ELL2_RO_\",\n        encodeDST: \"edwards25519_XMD:SHA-512_ELL2_NU_\",\n        p: Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512\n    }))();\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\"25063068953384623474111414158702152701244531502492656460079210482610430750235\");\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\"54469307008909316920995813868745141605393597292927456921205312896311721017578\");\n// 1-d²\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\"1159843021668779879193775521855586647937357759715417654439879720876111806838\");\n// (d-1)²\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\"40440834346308536858101042469323190826248399146238708352240133220865137265952\");\n// Calculates 1/√(number)\nconst invertSqrt = (number)=>uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst bytes255ToNumberLE = (bytes)=>ed25519.CURVE.Fp.create((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.bytesToNumberLE)(bytes) & MAX_255B);\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */ function calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s_, P)) s_ = mod(-s_);\n    if (!Ns_D_is_sq) s = s_; // 7\n    if (!Ns_D_is_sq) c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\nfunction ristretto255_map(bytes) {\n    (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.abytes)(bytes, 64);\n    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new _RistrettoPoint(R1.add(R2));\n}\n/**\n * Wrapper over Edwards Point for ristretto255.\n *\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */ class _RistrettoPoint extends _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.PrimeEdwardsPoint {\n    constructor(ep){\n        super(ep);\n    }\n    static fromAffine(ap) {\n        return new _RistrettoPoint(ed25519.Point.fromAffine(ap));\n    }\n    assertSame(other) {\n        if (!(other instanceof _RistrettoPoint)) throw new Error(\"RistrettoPoint expected\");\n    }\n    init(ep) {\n        return new _RistrettoPoint(ep);\n    }\n    /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ static hashToCurve(hex) {\n        return ristretto255_map((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"ristrettoHash\", hex, 64));\n    }\n    static fromBytes(bytes) {\n        (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.abytes)(bytes, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = Fp.ORDER;\n        const mod = Fp.create;\n        const s = bytes255ToNumberLE(bytes);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.equalBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.numberToBytesLE)(s, 32), bytes) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P)) throw new Error(\"invalid ristretto255 encoding 1\");\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P)) x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t, P) || y === _0n) throw new Error(\"invalid ristretto255 encoding 2\");\n        return new _RistrettoPoint(new ed25519.Point(x, y, _1n, t));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */ static fromHex(hex) {\n        return _RistrettoPoint.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"ristrettoHex\", hex, 32));\n    }\n    static msm(points, scalars) {\n        return (0,_abstract_curve_js__WEBPACK_IMPORTED_MODULE_7__.pippenger)(_RistrettoPoint, ed25519.Point.Fn, points, scalars);\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n     */ toBytes() {\n        let { X, Y, Z, T } = this.ep;\n        const P = Fp.ORDER;\n        const mod = Fp.create;\n        const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1\n        const u2 = mod(X * Y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * T); // 6\n        let D; // 7\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(T * zInv, P)) {\n            let _x = mod(Y * SQRT_M1);\n            let _y = mod(X * SQRT_M1);\n            X = _x;\n            Y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        } else {\n            D = D2; // 8\n        }\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(X * zInv, P)) Y = mod(-Y); // 9\n        let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P)) s = mod(-s);\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.numberToBytesLE)(s, 32); // 11\n    }\n    /**\n     * Compares two Ristretto points.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n     */ equals(other) {\n        this.assertSame(other);\n        const { X: X1, Y: Y1 } = this.ep;\n        const { X: X2, Y: Y2 } = other.ep;\n        const mod = Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    is0() {\n        return this.equals(_RistrettoPoint.ZERO);\n    }\n}\n// Do NOT change syntax: the following gymnastics is done,\n// because typescript strips comments, which makes bundlers disable tree-shaking.\n// prettier-ignore\n_RistrettoPoint.BASE = /* @__PURE__ */ (()=>new _RistrettoPoint(ed25519.Point.BASE))();\n// prettier-ignore\n_RistrettoPoint.ZERO = /* @__PURE__ */ (()=>new _RistrettoPoint(ed25519.Point.ZERO))();\n// prettier-ignore\n_RistrettoPoint.Fp = /* @__PURE__ */ Fp;\n// prettier-ignore\n_RistrettoPoint.Fn = /* @__PURE__ */ Fn;\n/** @deprecated use `ristretto255.Point` */ const RistrettoPoint = _RistrettoPoint;\nconst ristretto255 = {\n    Point: _RistrettoPoint\n};\n/** Hashing to ristretto255 points / field. RFC 9380 methods. */ const ristretto255_hasher = {\n    hashToCurve (msg, options) {\n        const DST = options?.DST || \"ristretto255_XMD:SHA-512_R255MAP_RO_\";\n        return ristretto255_map((0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512));\n    },\n    hashToScalar (msg, options = {\n        DST: _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__._DST_scalar\n    }) {\n        return Fn.create((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.bytesToNumberLE)((0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.expand_message_xmd)(msg, options.DST, 64, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512)));\n    }\n};\n// export const ristretto255_oprf: OPRF = createORPF({\n//   name: 'ristretto255-SHA512',\n//   Point: RistrettoPoint,\n//   hash: sha512,\n//   hashToGroup: ristretto255_hasher.hashToCurve,\n//   hashToScalar: ristretto255_hasher.hashToScalar,\n// });\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */ const hashToCurve = /* @__PURE__ */ (()=>ed25519_hasher.hashToCurve)();\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */ const encodeToCurve = /* @__PURE__ */ (()=>ed25519_hasher.encodeToCurve)();\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ const hashToRistretto255 = /* @__PURE__ */ (()=>ristretto255_hasher.hashToCurve)();\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ const hash_to_ristretto255 = /* @__PURE__ */ (()=>ristretto255_hasher.hashToCurve)();\n/**\n * Weird / bogus points, useful for debugging.\n * All 8 ed25519 points of 8-torsion subgroup can be generated from the point\n * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.\n * ⟨T⟩ = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }\n */ const ED25519_TORSION_SUBGROUP = [\n    \"0100000000000000000000000000000000000000000000000000000000000000\",\n    \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a\",\n    \"0000000000000000000000000000000000000000000000000000000000000080\",\n    \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05\",\n    \"ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f\",\n    \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85\",\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa\"\n]; //# sourceMappingURL=ed25519.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9lZDI1NTE5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNELG9FQUFvRSxHQUNyQjtBQUMyQjtBQUMxQjtBQUMyQjtBQUNrQjtBQUNNO0FBQzdDO0FBQ2lDO0FBQ3ZGLGtCQUFrQjtBQUNsQixNQUFNcUIsTUFBTUMsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLElBQUlFLE1BQU1GLE9BQU8sSUFBSUcsTUFBTUgsT0FBTztBQUN0RSxrQkFBa0I7QUFDbEIsTUFBTUksTUFBTUosT0FBTyxJQUFJSyxNQUFNTCxPQUFPO0FBQ3BDLHFCQUFxQjtBQUNyQix5REFBeUQ7QUFDekQsNEJBQTRCO0FBQzVCLDREQUE0RDtBQUM1RCxNQUFNTSxnQkFBZ0I7SUFDbEJDLEdBQUdQLE9BQU87SUFDVlEsR0FBR1IsT0FBTztJQUNWUyxHQUFHSjtJQUNISyxHQUFHVixPQUFPO0lBQ1ZXLEdBQUdYLE9BQU87SUFDVlksSUFBSVosT0FBTztJQUNYYSxJQUFJYixPQUFPO0FBQ2Y7QUFDQSxTQUFTYyxvQkFBb0JDLENBQUM7SUFDMUIsa0JBQWtCO0lBQ2xCLE1BQU1DLE9BQU9oQixPQUFPLEtBQUtpQixPQUFPakIsT0FBTyxLQUFLa0IsT0FBT2xCLE9BQU8sS0FBS21CLE9BQU9uQixPQUFPO0lBQzdFLE1BQU1vQixJQUFJZCxjQUFjQyxDQUFDO0lBQ3pCLE1BQU1jLEtBQUssSUFBS04sSUFBS0s7SUFDckIsTUFBTUUsS0FBSyxLQUFNUCxJQUFLSyxHQUFHLFVBQVU7SUFDbkMsTUFBTUcsS0FBSywyREFBTUQsSUFBSXBCLEtBQUtrQixLQUFLRSxLQUFNRixHQUFHLGFBQWE7SUFDckQsTUFBTUksS0FBSywyREFBTUQsSUFBSXRCLEtBQUttQixLQUFLTCxJQUFLSyxHQUFHLE9BQU87SUFDOUMsTUFBTUssTUFBTSwy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akMsMkJBQTJCO0FBQzNCLGtCQUFrQjtBQUNsQixrREFBa0Q7QUFDbEQsb0RBQW9EO0FBQ3BELE1BQU07QUFDTixpRkFBaUYsR0FDMUUsTUFBTXdNLGNBQThCLGFBQUgsR0FBSSxLQUFNaEQsZUFBZWdELFdBQVcsSUFBSTtBQUNoRixpRkFBaUYsR0FDMUUsTUFBTXlDLGdCQUFnQyxhQUFILEdBQUksS0FBTXpGLGVBQWV5RixhQUFhLElBQUk7QUFDcEYsc0ZBQXNGLEdBQy9FLE1BQU1DLHFCQUFxQyxhQUFILEdBQUksS0FBTUwsb0JBQW9CckMsV0FBVyxJQUFJO0FBQzVGLHNGQUFzRixHQUMvRSxNQUFNMkMsdUJBQXVDLGFBQUgsR0FBSSxLQUFNTixvQkFBb0JyQyxXQUFXLElBQUk7QUFDOUY7Ozs7O0NBS0MsR0FDTSxNQUFNNEMsMkJBQTJCO0lBQ3BDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSCxDQUFDLENBQ0YsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9lZDI1NTE5LmpzPzM4MjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBlZDI1NTE5IFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZSB3aXRoIGZvbGxvd2luZyBhZGRvbnM6XG4gKiAtIFgyNTUxOSBFQ0RIXG4gKiAtIFJpc3RyZXR0byBjb2ZhY3RvciBlbGltaW5hdGlvblxuICogLSBFbGxpZ2F0b3IgaGFzaC10by1ncm91cCAvIHBvaW50IGluZGlzdGluZ3Vpc2hhYmlsaXR5XG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMi5qcyc7XG5pbXBvcnQgeyBhYnl0ZXMsIGNvbmNhdEJ5dGVzLCB1dGY4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuaW1wb3J0IHsgcGlwcGVuZ2VyIH0gZnJvbSBcIi4vYWJzdHJhY3QvY3VydmUuanNcIjtcbmltcG9ydCB7IFByaW1lRWR3YXJkc1BvaW50LCB0d2lzdGVkRWR3YXJkcywgfSBmcm9tIFwiLi9hYnN0cmFjdC9lZHdhcmRzLmpzXCI7XG5pbXBvcnQgeyBfRFNUX3NjYWxhciwgY3JlYXRlSGFzaGVyLCBleHBhbmRfbWVzc2FnZV94bWQsIH0gZnJvbSBcIi4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qc1wiO1xuaW1wb3J0IHsgRmllbGQsIEZwSW52ZXJ0QmF0Y2gsIEZwU3FydEV2ZW4sIGlzTmVnYXRpdmVMRSwgbW9kLCBwb3cyLCB9IGZyb20gXCIuL2Fic3RyYWN0L21vZHVsYXIuanNcIjtcbmltcG9ydCB7IG1vbnRnb21lcnkgfSBmcm9tIFwiLi9hYnN0cmFjdC9tb250Z29tZXJ5LmpzXCI7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBlcXVhbEJ5dGVzLCBudW1iZXJUb0J5dGVzTEUgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gUCA9IDJuKioyNTVuIC0gMTluXG4vLyBOID0gMm4qKjI1Mm4gKyAyNzc0MjMxNzc3NzM3MjM1MzUzNTg1MTkzNzc5MDg4MzY0ODQ5M25cbi8vIGEgPSBGcC5jcmVhdGUoQmlnSW50KC0xKSlcbi8vIGQgPSAtMTIxNjY1LzEyMTY2NiBhLmsuYS4gRnAubmVnKDEyMTY2NSAqIEZwLmludigxMjE2NjYpKVxuY29uc3QgZWQyNTUxOV9DVVJWRSA9IHtcbiAgICBwOiBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZCcpLFxuICAgIG46IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE0ZGVmOWRlYTJmNzljZDY1ODEyNjMxYTVjZjVkM2VkJyksXG4gICAgaDogXzhuLFxuICAgIGE6IEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVjJyksXG4gICAgZDogQmlnSW50KCcweDUyMDM2Y2VlMmI2ZmZlNzM4Y2M3NDA3OTc3NzllODk4MDA3MDBhNGQ0MTQxZDhhYjc1ZWI0ZGNhMTM1OTc4YTMnKSxcbiAgICBHeDogQmlnSW50KCcweDIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnKSxcbiAgICBHeTogQmlnSW50KCcweDY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnKSxcbn07XG5mdW5jdGlvbiBlZDI1NTE5X3Bvd18yXzI1Ml8zKHgpIHtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMTBuID0gQmlnSW50KDEwKSwgXzIwbiA9IEJpZ0ludCgyMCksIF80MG4gPSBCaWdJbnQoNDApLCBfODBuID0gQmlnSW50KDgwKTtcbiAgICBjb25zdCBQID0gZWQyNTUxOV9DVVJWRS5wO1xuICAgIGNvbnN0IHgyID0gKHggKiB4KSAlIFA7XG4gICAgY29uc3QgYjIgPSAoeDIgKiB4KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiNCA9IChwb3cyKGIyLCBfMm4sIFApICogYjIpICUgUDsgLy8geF4xNSwgMTExMVxuICAgIGNvbnN0IGI1ID0gKHBvdzIoYjQsIF8xbiwgUCkgKiB4KSAlIFA7IC8vIHheMzFcbiAgICBjb25zdCBiMTAgPSAocG93MihiNSwgXzVuLCBQKSAqIGI1KSAlIFA7XG4gICAgY29uc3QgYjIwID0gKHBvdzIoYjEwLCBfMTBuLCBQKSAqIGIxMCkgJSBQO1xuICAgIGNvbnN0IGI0MCA9IChwb3cyKGIyMCwgXzIwbiwgUCkgKiBiMjApICUgUDtcbiAgICBjb25zdCBiODAgPSAocG93MihiNDAsIF80MG4sIFApICogYjQwKSAlIFA7XG4gICAgY29uc3QgYjE2MCA9IChwb3cyKGI4MCwgXzgwbiwgUCkgKiBiODApICUgUDtcbiAgICBjb25zdCBiMjQwID0gKHBvdzIoYjE2MCwgXzgwbiwgUCkgKiBiODApICUgUDtcbiAgICBjb25zdCBiMjUwID0gKHBvdzIoYjI0MCwgXzEwbiwgUCkgKiBiMTApICUgUDtcbiAgICBjb25zdCBwb3dfcF81XzggPSAocG93MihiMjUwLCBfMm4sIFApICogeCkgJSBQO1xuICAgIC8vIF4gVG8gcG93IHRvIChwKzMpLzgsIG11bHRpcGx5IGl0IGJ5IHguXG4gICAgcmV0dXJuIHsgcG93X3BfNV84LCBiMiB9O1xufVxuZnVuY3Rpb24gYWRqdXN0U2NhbGFyQnl0ZXMoYnl0ZXMpIHtcbiAgICAvLyBTZWN0aW9uIDU6IEZvciBYMjU1MTksIGluIG9yZGVyIHRvIGRlY29kZSAzMiByYW5kb20gYnl0ZXMgYXMgYW4gaW50ZWdlciBzY2FsYXIsXG4gICAgLy8gc2V0IHRoZSB0aHJlZSBsZWFzdCBzaWduaWZpY2FudCBiaXRzIG9mIHRoZSBmaXJzdCBieXRlXG4gICAgYnl0ZXNbMF0gJj0gMjQ4OyAvLyAwYjExMTFfMTAwMFxuICAgIC8vIGFuZCB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGxhc3QgdG8gemVybyxcbiAgICBieXRlc1szMV0gJj0gMTI3OyAvLyAwYjAxMTFfMTExMVxuICAgIC8vIHNldCB0aGUgc2Vjb25kIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBsYXN0IGJ5dGUgdG8gMVxuICAgIGJ5dGVzWzMxXSB8PSA2NDsgLy8gMGIwMTAwXzAwMDBcbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vLyDiiJooLTEpIGFrYSDiiJooYSkgYWthIDJeKChwLTEpLzQpXG4vLyBGcC5zcXJ0KEZwLm5lZygxKSlcbmNvbnN0IEVEMjU1MTlfU1FSVF9NMSA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzE5NjgxMTYxMzc2NzA3NTA1OTU2ODA3MDc5MzA0OTg4NTQyMDE1NDQ2MDY2NTE1OTIzODkwMTYyNzQ0MDIxMDczMTIzODI5Nzg0NzUyJyk7XG4vLyBzcXJ0KHUvdilcbmZ1bmN0aW9uIHV2UmF0aW8odSwgdikge1xuICAgIGNvbnN0IFAgPSBlZDI1NTE5X0NVUlZFLnA7XG4gICAgY29uc3QgdjMgPSBtb2QodiAqIHYgKiB2LCBQKTsgLy8gdsKzXG4gICAgY29uc3QgdjcgPSBtb2QodjMgKiB2MyAqIHYsIFApOyAvLyB24oG3XG4gICAgLy8gKHArMykvOCBhbmQgKHAtNSkvOFxuICAgIGNvbnN0IHBvdyA9IGVkMjU1MTlfcG93XzJfMjUyXzModSAqIHY3KS5wb3dfcF81Xzg7XG4gICAgbGV0IHggPSBtb2QodSAqIHYzICogcG93LCBQKTsgLy8gKHV2wrMpKHV24oG3KV4ocC01KS84XG4gICAgY29uc3QgdngyID0gbW9kKHYgKiB4ICogeCwgUCk7IC8vIHZ4wrJcbiAgICBjb25zdCByb290MSA9IHg7IC8vIEZpcnN0IHJvb3QgY2FuZGlkYXRlXG4gICAgY29uc3Qgcm9vdDIgPSBtb2QoeCAqIEVEMjU1MTlfU1FSVF9NMSwgUCk7IC8vIFNlY29uZCByb290IGNhbmRpZGF0ZVxuICAgIGNvbnN0IHVzZVJvb3QxID0gdngyID09PSB1OyAvLyBJZiB2eMKyID0gdSAobW9kIHApLCB4IGlzIGEgc3F1YXJlIHJvb3RcbiAgICBjb25zdCB1c2VSb290MiA9IHZ4MiA9PT0gbW9kKC11LCBQKTsgLy8gSWYgdnjCsiA9IC11LCBzZXQgeCA8LS0geCAqIDJeKChwLTEpLzQpXG4gICAgY29uc3Qgbm9Sb290ID0gdngyID09PSBtb2QoLXUgKiBFRDI1NTE5X1NRUlRfTTEsIFApOyAvLyBUaGVyZSBpcyBubyB2YWxpZCByb290LCB2eMKyID0gLXXiiJooLTEpXG4gICAgaWYgKHVzZVJvb3QxKVxuICAgICAgICB4ID0gcm9vdDE7XG4gICAgaWYgKHVzZVJvb3QyIHx8IG5vUm9vdClcbiAgICAgICAgeCA9IHJvb3QyOyAvLyBXZSByZXR1cm4gcm9vdDIgYW55d2F5LCBmb3IgY29uc3QtdGltZVxuICAgIGlmIChpc05lZ2F0aXZlTEUoeCwgUCkpXG4gICAgICAgIHggPSBtb2QoLXgsIFApO1xuICAgIHJldHVybiB7IGlzVmFsaWQ6IHVzZVJvb3QxIHx8IHVzZVJvb3QyLCB2YWx1ZTogeCB9O1xufVxuY29uc3QgRnAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZpZWxkKGVkMjU1MTlfQ1VSVkUucCwgeyBpc0xFOiB0cnVlIH0pKSgpO1xuY29uc3QgRm4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZpZWxkKGVkMjU1MTlfQ1VSVkUubiwgeyBpc0xFOiB0cnVlIH0pKSgpO1xuY29uc3QgZWQyNTUxOURlZmF1bHRzID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoe1xuICAgIC4uLmVkMjU1MTlfQ1VSVkUsXG4gICAgRnAsXG4gICAgaGFzaDogc2hhNTEyLFxuICAgIGFkanVzdFNjYWxhckJ5dGVzLFxuICAgIC8vIGRvbTJcbiAgICAvLyBSYXRpbyBvZiB1IHRvIHYuIEFsbG93cyB1cyB0byBjb21iaW5lIGludmVyc2lvbiBhbmQgc3F1YXJlIHJvb3QuIFVzZXMgYWxnbyBmcm9tIFJGQzgwMzIgNS4xLjMuXG4gICAgLy8gQ29uc3RhbnQtdGltZSwgdS/iiJp2XG4gICAgdXZSYXRpbyxcbn0pKSgpO1xuLyoqXG4gKiBlZDI1NTE5IGN1cnZlIHdpdGggRWREU0Egc2lnbmF0dXJlcy5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBlZDI1NTE5IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5JztcbiAqIGNvbnN0IHsgc2VjcmV0S2V5LCBwdWJsaWNLZXkgfSA9IGVkMjU1MTkua2V5Z2VuKCk7XG4gKiBjb25zdCBtc2cgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ2hlbGxvJyk7XG4gKiBjb25zdCBzaWcgPSBlZDI1NTE5LnNpZ24obXNnLCBwcml2KTtcbiAqIGVkMjU1MTkudmVyaWZ5KHNpZywgbXNnLCBwdWIpOyAvLyBEZWZhdWx0IG1vZGU6IGZvbGxvd3MgWklQMjE1XG4gKiBlZDI1NTE5LnZlcmlmeShzaWcsIG1zZywgcHViLCB7IHppcDIxNTogZmFsc2UgfSk7IC8vIFJGQzgwMzIgLyBGSVBTIDE4Ni01XG4gKi9cbmV4cG9ydCBjb25zdCBlZDI1NTE5ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0d2lzdGVkRWR3YXJkcyhlZDI1NTE5RGVmYXVsdHMpKSgpO1xuZnVuY3Rpb24gZWQyNTUxOV9kb21haW4oZGF0YSwgY3R4LCBwaGZsYWcpIHtcbiAgICBpZiAoY3R4Lmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0IGlzIHRvbyBiaWcnKTtcbiAgICByZXR1cm4gY29uY2F0Qnl0ZXModXRmOFRvQnl0ZXMoJ1NpZ0VkMjU1MTkgbm8gRWQyNTUxOSBjb2xsaXNpb25zJyksIG5ldyBVaW50OEFycmF5KFtwaGZsYWcgPyAxIDogMCwgY3R4Lmxlbmd0aF0pLCBjdHgsIGRhdGEpO1xufVxuLyoqIENvbnRleHQgb2YgZWQyNTUxOS4gVXNlcyBjb250ZXh0IGZvciBkb21haW4gc2VwYXJhdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBlZDI1NTE5Y3R4ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0d2lzdGVkRWR3YXJkcyh7XG4gICAgLi4uZWQyNTUxOURlZmF1bHRzLFxuICAgIGRvbWFpbjogZWQyNTUxOV9kb21haW4sXG59KSkoKTtcbi8qKiBQcmVoYXNoZWQgdmVyc2lvbiBvZiBlZDI1NTE5LiBBY2NlcHRzIGFscmVhZHktaGFzaGVkIG1lc3NhZ2VzIGluIHNpZ24oKSBhbmQgdmVyaWZ5KCkuICovXG5leHBvcnQgY29uc3QgZWQyNTUxOXBoID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0d2lzdGVkRWR3YXJkcyhPYmplY3QuYXNzaWduKHt9LCBlZDI1NTE5RGVmYXVsdHMsIHtcbiAgICBkb21haW46IGVkMjU1MTlfZG9tYWluLFxuICAgIHByZWhhc2g6IHNoYTUxMixcbn0pKSkoKTtcbi8qKlxuICogRUNESCB1c2luZyBjdXJ2ZTI1NTE5IGFrYSB4MjU1MTkuXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgeDI1NTE5IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5JztcbiAqIGNvbnN0IHByaXYgPSAnYTU0NmUzNmJmMDUyN2M5ZDNiMTYxNTRiODI0NjVlZGQ2MjE0NGMwYWMxZmM1YTE4NTA2YTIyNDRiYTQ0OWFjNCc7XG4gKiBjb25zdCBwdWIgPSAnZTZkYjY4Njc1ODMwMzBkYjM1OTRjMWE0MjRiMTVmN2M3MjY2MjRlYzI2YjMzNTNiMTBhOTAzYTZkMGFiMWM0Yyc7XG4gKiB4MjU1MTkuZ2V0U2hhcmVkU2VjcmV0KHByaXYsIHB1YikgPT09IHgyNTUxOS5zY2FsYXJNdWx0KHByaXYsIHB1Yik7IC8vIGFsaWFzZXNcbiAqIHgyNTUxOS5nZXRQdWJsaWNLZXkocHJpdikgPT09IHgyNTUxOS5zY2FsYXJNdWx0QmFzZShwcml2KTtcbiAqIHgyNTUxOS5nZXRQdWJsaWNLZXkoeDI1NTE5LnV0aWxzLnJhbmRvbVNlY3JldEtleSgpKTtcbiAqL1xuZXhwb3J0IGNvbnN0IHgyNTUxOSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGNvbnN0IFAgPSBlZDI1NTE5X0NVUlZFLnA7XG4gICAgcmV0dXJuIG1vbnRnb21lcnkoe1xuICAgICAgICBQLFxuICAgICAgICB0eXBlOiAneDI1NTE5JyxcbiAgICAgICAgcG93UG1pbnVzMjogKHgpID0+IHtcbiAgICAgICAgICAgIC8vIHheKHAtMikgYWthIHheKDJeMjU1LTIxKVxuICAgICAgICAgICAgY29uc3QgeyBwb3dfcF81XzgsIGIyIH0gPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHgpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZChwb3cyKHBvd19wXzVfOCwgXzNuLCBQKSAqIGIyLCBQKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgfSk7XG59KSgpO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgZWQyNTUxOS51dGlscy50b01vbnRnb21lcnlgICovXG5leHBvcnQgZnVuY3Rpb24gZWR3YXJkc1RvTW9udGdvbWVyeVB1YihlZHdhcmRzUHViKSB7XG4gICAgcmV0dXJuIGVkMjU1MTkudXRpbHMudG9Nb250Z29tZXJ5KGVuc3VyZUJ5dGVzKCdwdWInLCBlZHdhcmRzUHViKSk7XG59XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeWAgKi9cbmV4cG9ydCBjb25zdCBlZHdhcmRzVG9Nb250Z29tZXJ5ID0gZWR3YXJkc1RvTW9udGdvbWVyeVB1Yjtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGVkMjU1MTkudXRpbHMudG9Nb250Z29tZXJ5UHJpdmAgKi9cbmV4cG9ydCBmdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdihlZHdhcmRzUHJpdikge1xuICAgIHJldHVybiBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeVByaXYoZW5zdXJlQnl0ZXMoJ3B1YicsIGVkd2FyZHNQcml2KSk7XG59XG4vLyBIYXNoIFRvIEN1cnZlIEVsbGlnYXRvcjIgTWFwIChOT1RFOiBkaWZmZXJlbnQgZnJvbSByaXN0cmV0dG8yNTUgZWxsaWdhdG9yKVxuLy8gTk9URTogdmVyeSBpbXBvcnRhbnQgcGFydCBpcyB1c2FnZSBvZiBGcFNxcnRFdmVuIGZvciBFTEwyX0MxX0VEV0FSRFMsIHNpbmNlXG4vLyBTYWdlTWF0aCByZXR1cm5zIGRpZmZlcmVudCByb290IGZpcnN0IGFuZCBldmVyeXRoaW5nIGZhbGxzIGFwYXJ0XG5jb25zdCBFTEwyX0MxID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoRnAuT1JERVIgKyBfM24pIC8gXzhuKSgpOyAvLyAxLiBjMSA9IChxICsgMykgLyA4ICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG5jb25zdCBFTEwyX0MyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGcC5wb3coXzJuLCBFTEwyX0MxKSkoKTsgLy8gMi4gYzIgPSAyXmMxXG5jb25zdCBFTEwyX0MzID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGcC5zcXJ0KEZwLm5lZyhGcC5PTkUpKSkoKTsgLy8gMy4gYzMgPSBzcXJ0KC0xKVxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpIHtcbiAgICBjb25zdCBFTEwyX0M0ID0gKEZwLk9SREVSIC0gXzVuKSAvIF84bjsgLy8gNC4gYzQgPSAocSAtIDUpIC8gOCAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IEVMTDJfSiA9IEJpZ0ludCg0ODY2NjIpO1xuICAgIGxldCB0djEgPSBGcC5zcXIodSk7IC8vICAxLiAgdHYxID0gdV4yXG4gICAgdHYxID0gRnAubXVsKHR2MSwgXzJuKTsgLy8gIDIuICB0djEgPSAyICogdHYxXG4gICAgbGV0IHhkID0gRnAuYWRkKHR2MSwgRnAuT05FKTsgLy8gIDMuICAgeGQgPSB0djEgKyAxICAgICAgICAgIyBOb256ZXJvOiAtMSBpcyBzcXVhcmUgKG1vZCBwKSwgdHYxIGlzIG5vdFxuICAgIGxldCB4MW4gPSBGcC5uZWcoRUxMMl9KKTsgLy8gIDQuICB4MW4gPSAtSiAgICAgICAgICAgICAgIyB4MSA9IHgxbiAvIHhkID0gLUogLyAoMSArIDIgKiB1XjIpXG4gICAgbGV0IHR2MiA9IEZwLnNxcih4ZCk7IC8vICA1LiAgdHYyID0geGReMlxuICAgIGxldCBneGQgPSBGcC5tdWwodHYyLCB4ZCk7IC8vICA2LiAgZ3hkID0gdHYyICogeGQgICAgICAgICMgZ3hkID0geGReM1xuICAgIGxldCBneDEgPSBGcC5tdWwodHYxLCBFTEwyX0opOyAvLyAgNy4gIGd4MSA9IEogKiB0djEgICAgICAgICAjIHgxbiArIEogKiB4ZFxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICA4LiAgZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjIgKyBKICogeDFuICogeGRcbiAgICBneDEgPSBGcC5hZGQoZ3gxLCB0djIpOyAvLyAgOS4gIGd4MSA9IGd4MSArIHR2MiAgICAgICAjIHgxbl4yICsgSiAqIHgxbiAqIHhkICsgeGReMlxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICAxMC4gZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjMgKyBKICogeDFuXjIgKiB4ZCArIHgxbiAqIHhkXjJcbiAgICBsZXQgdHYzID0gRnAuc3FyKGd4ZCk7IC8vICAxMS4gdHYzID0gZ3hkXjJcbiAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gIDEyLiB0djIgPSB0djNeMiAgICAgICAgICAgIyBneGReNFxuICAgIHR2MyA9IEZwLm11bCh0djMsIGd4ZCk7IC8vICAxMy4gdHYzID0gdHYzICogZ3hkICAgICAgICMgZ3hkXjNcbiAgICB0djMgPSBGcC5tdWwodHYzLCBneDEpOyAvLyAgMTQuIHR2MyA9IHR2MyAqIGd4MSAgICAgICAjIGd4MSAqIGd4ZF4zXG4gICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gIDE1LiB0djIgPSB0djIgKiB0djMgICAgICAgIyBneDEgKiBneGReN1xuICAgIGxldCB5MTEgPSBGcC5wb3codHYyLCBFTEwyX0M0KTsgLy8gIDE2LiB5MTEgPSB0djJeYzQgICAgICAgICMgKGd4MSAqIGd4ZF43KV4oKHAgLSA1KSAvIDgpXG4gICAgeTExID0gRnAubXVsKHkxMSwgdHYzKTsgLy8gIDE3LiB5MTEgPSB5MTEgKiB0djMgICAgICAgIyBneDEqZ3hkXjMqKGd4MSpneGReNyleKChwLTUpLzgpXG4gICAgbGV0IHkxMiA9IEZwLm11bCh5MTEsIEVMTDJfQzMpOyAvLyAgMTguIHkxMiA9IHkxMSAqIGMzXG4gICAgdHYyID0gRnAuc3FyKHkxMSk7IC8vICAxOS4gdHYyID0geTExXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMjAuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMSA9IEZwLmVxbCh0djIsIGd4MSk7IC8vICAyMS4gIGUxID0gdHYyID09IGd4MVxuICAgIGxldCB5MSA9IEZwLmNtb3YoeTEyLCB5MTEsIGUxKTsgLy8gIDIyLiAgeTEgPSBDTU9WKHkxMiwgeTExLCBlMSkgICMgSWYgZyh4MSkgaXMgc3F1YXJlLCB0aGlzIGlzIGl0cyBzcXJ0XG4gICAgbGV0IHgybiA9IEZwLm11bCh4MW4sIHR2MSk7IC8vICAyMy4geDJuID0geDFuICogdHYxICAgICAgICMgeDIgPSB4Mm4gLyB4ZCA9IDIgKiB1XjIgKiB4MW4gLyB4ZFxuICAgIGxldCB5MjEgPSBGcC5tdWwoeTExLCB1KTsgLy8gIDI0LiB5MjEgPSB5MTEgKiB1XG4gICAgeTIxID0gRnAubXVsKHkyMSwgRUxMMl9DMik7IC8vICAyNS4geTIxID0geTIxICogYzJcbiAgICBsZXQgeTIyID0gRnAubXVsKHkyMSwgRUxMMl9DMyk7IC8vICAyNi4geTIyID0geTIxICogYzNcbiAgICBsZXQgZ3gyID0gRnAubXVsKGd4MSwgdHYxKTsgLy8gIDI3LiBneDIgPSBneDEgKiB0djEgICAgICAgIyBnKHgyKSA9IGd4MiAvIGd4ZCA9IDIgKiB1XjIgKiBnKHgxKVxuICAgIHR2MiA9IEZwLnNxcih5MjEpOyAvLyAgMjguIHR2MiA9IHkyMV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDI5LiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTIgPSBGcC5lcWwodHYyLCBneDIpOyAvLyAgMzAuICBlMiA9IHR2MiA9PSBneDJcbiAgICBsZXQgeTIgPSBGcC5jbW92KHkyMiwgeTIxLCBlMik7IC8vICAzMS4gIHkyID0gQ01PVih5MjIsIHkyMSwgZTIpICAjIElmIGcoeDIpIGlzIHNxdWFyZSwgdGhpcyBpcyBpdHMgc3FydFxuICAgIHR2MiA9IEZwLnNxcih5MSk7IC8vICAzMi4gdHYyID0geTFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAzMy4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUzID0gRnAuZXFsKHR2MiwgZ3gxKTsgLy8gIDM0LiAgZTMgPSB0djIgPT0gZ3gxXG4gICAgbGV0IHhuID0gRnAuY21vdih4Mm4sIHgxbiwgZTMpOyAvLyAgMzUuICB4biA9IENNT1YoeDJuLCB4MW4sIGUzKSAgIyBJZiBlMywgeCA9IHgxLCBlbHNlIHggPSB4MlxuICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGUzKTsgLy8gIDM2LiAgIHkgPSBDTU9WKHkyLCB5MSwgZTMpICAgICMgSWYgZTMsIHkgPSB5MSwgZWxzZSB5ID0geTJcbiAgICBsZXQgZTQgPSBGcC5pc09kZCh5KTsgLy8gIDM3LiAgZTQgPSBzZ24wKHkpID09IDEgICAgICAgICMgRml4IHNpZ24gb2YgeVxuICAgIHkgPSBGcC5jbW92KHksIEZwLm5lZyh5KSwgZTMgIT09IGU0KTsgLy8gIDM4LiAgIHkgPSBDTU9WKHksIC15LCBlMyBYT1IgZTQpXG4gICAgcmV0dXJuIHsgeE1uOiB4biwgeE1kOiB4ZCwgeU1uOiB5LCB5TWQ6IF8xbiB9OyAvLyAgMzkuIHJldHVybiAoeG4sIHhkLCB5LCAxKVxufVxuY29uc3QgRUxMMl9DMV9FRFdBUkRTID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGcFNxcnRFdmVuKEZwLCBGcC5uZWcoQmlnSW50KDQ4NjY2NCkpKSkoKTsgLy8gc2duMChjMSkgTVVTVCBlcXVhbCAwXG5mdW5jdGlvbiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkodSkge1xuICAgIGNvbnN0IHsgeE1uLCB4TWQsIHlNbiwgeU1kIH0gPSBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpOyAvLyAgMS4gICh4TW4sIHhNZCwgeU1uLCB5TWQpID1cbiAgICAvLyBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpXG4gICAgbGV0IHhuID0gRnAubXVsKHhNbiwgeU1kKTsgLy8gIDIuICB4biA9IHhNbiAqIHlNZFxuICAgIHhuID0gRnAubXVsKHhuLCBFTEwyX0MxX0VEV0FSRFMpOyAvLyAgMy4gIHhuID0geG4gKiBjMVxuICAgIGxldCB4ZCA9IEZwLm11bCh4TWQsIHlNbik7IC8vICA0LiAgeGQgPSB4TWQgKiB5TW4gICAgIyB4biAvIHhkID0gYzEgKiB4TSAvIHlNXG4gICAgbGV0IHluID0gRnAuc3ViKHhNbiwgeE1kKTsgLy8gIDUuICB5biA9IHhNbiAtIHhNZFxuICAgIGxldCB5ZCA9IEZwLmFkZCh4TW4sIHhNZCk7IC8vICA2LiAgeWQgPSB4TW4gKyB4TWQgICAgIyAobiAvIGQgLSAxKSAvIChuIC8gZCArIDEpID0gKG4gLSBkKSAvIChuICsgZClcbiAgICBsZXQgdHYxID0gRnAubXVsKHhkLCB5ZCk7IC8vICA3LiB0djEgPSB4ZCAqIHlkXG4gICAgbGV0IGUgPSBGcC5lcWwodHYxLCBGcC5aRVJPKTsgLy8gIDguICAgZSA9IHR2MSA9PSAwXG4gICAgeG4gPSBGcC5jbW92KHhuLCBGcC5aRVJPLCBlKTsgLy8gIDkuICB4biA9IENNT1YoeG4sIDAsIGUpXG4gICAgeGQgPSBGcC5jbW92KHhkLCBGcC5PTkUsIGUpOyAvLyAgMTAuIHhkID0gQ01PVih4ZCwgMSwgZSlcbiAgICB5biA9IEZwLmNtb3YoeW4sIEZwLk9ORSwgZSk7IC8vICAxMS4geW4gPSBDTU9WKHluLCAxLCBlKVxuICAgIHlkID0gRnAuY21vdih5ZCwgRnAuT05FLCBlKTsgLy8gIDEyLiB5ZCA9IENNT1YoeWQsIDEsIGUpXG4gICAgY29uc3QgW3hkX2ludiwgeWRfaW52XSA9IEZwSW52ZXJ0QmF0Y2goRnAsIFt4ZCwgeWRdLCB0cnVlKTsgLy8gYmF0Y2ggZGl2aXNpb25cbiAgICByZXR1cm4geyB4OiBGcC5tdWwoeG4sIHhkX2ludiksIHk6IEZwLm11bCh5biwgeWRfaW52KSB9OyAvLyAgMTMuIHJldHVybiAoeG4sIHhkLCB5biwgeWQpXG59XG4vKiogSGFzaGluZyB0byBlZDI1NTE5IHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0IGNvbnN0IGVkMjU1MTlfaGFzaGVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoZWQyNTUxOS5Qb2ludCwgKHNjYWxhcnMpID0+IG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOShzY2FsYXJzWzBdKSwge1xuICAgIERTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnZWR3YXJkczI1NTE5X1hNRDpTSEEtNTEyX0VMTDJfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTUxMixcbn0pKSgpO1xuLy8g4oiaKC0xKSBha2Eg4oiaKGEpIGFrYSAyXigocC0xKS80KVxuY29uc3QgU1FSVF9NMSA9IEVEMjU1MTlfU1FSVF9NMTtcbi8vIOKImihhZCAtIDEpXG5jb25zdCBTUVJUX0FEX01JTlVTX09ORSA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzI1MDYzMDY4OTUzMzg0NjIzNDc0MTExNDE0MTU4NzAyMTUyNzAxMjQ0NTMxNTAyNDkyNjU2NDYwMDc5MjEwNDgyNjEwNDMwNzUwMjM1Jyk7XG4vLyAxIC8g4oiaKGEtZClcbmNvbnN0IElOVlNRUlRfQV9NSU5VU19EID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnNTQ0NjkzMDcwMDg5MDkzMTY5MjA5OTU4MTM4Njg3NDUxNDE2MDUzOTM1OTcyOTI5Mjc0NTY5MjEyMDUzMTI4OTYzMTE3MjEwMTc1NzgnKTtcbi8vIDEtZMKyXG5jb25zdCBPTkVfTUlOVVNfRF9TUSA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzExNTk4NDMwMjE2Njg3Nzk4NzkxOTM3NzU1MjE4NTU1ODY2NDc5MzczNTc3NTk3MTU0MTc2NTQ0Mzk4Nzk3MjA4NzYxMTE4MDY4MzgnKTtcbi8vIChkLTEpwrJcbmNvbnN0IERfTUlOVVNfT05FX1NRID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnNDA0NDA4MzQzNDYzMDg1MzY4NTgxMDEwNDI0NjkzMjMxOTA4MjYyNDgzOTkxNDYyMzg3MDgzNTIyNDAxMzMyMjA4NjUxMzcyNjU5NTInKTtcbi8vIENhbGN1bGF0ZXMgMS/iiJoobnVtYmVyKVxuY29uc3QgaW52ZXJ0U3FydCA9IChudW1iZXIpID0+IHV2UmF0aW8oXzFuLCBudW1iZXIpO1xuY29uc3QgTUFYXzI1NUIgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnKTtcbmNvbnN0IGJ5dGVzMjU1VG9OdW1iZXJMRSA9IChieXRlcykgPT4gZWQyNTUxOS5DVVJWRS5GcC5jcmVhdGUoYnl0ZXNUb051bWJlckxFKGJ5dGVzKSAmIE1BWF8yNTVCKTtcbi8qKlxuICogQ29tcHV0ZXMgRWxsaWdhdG9yIG1hcCBmb3IgUmlzdHJldHRvMjU1LlxuICogRGVzY3JpYmVkIGluIFtSRkM5MzgwXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNhcHBlbmRpeC1CKSBhbmQgb25cbiAqIHRoZSBbd2Vic2l0ZV0oaHR0cHM6Ly9yaXN0cmV0dG8uZ3JvdXAvZm9ybXVsYXMvZWxsaWdhdG9yLmh0bWwpLlxuICovXG5mdW5jdGlvbiBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIwKSB7XG4gICAgY29uc3QgeyBkIH0gPSBlZDI1NTE5LkNVUlZFO1xuICAgIGNvbnN0IFAgPSBlZDI1NTE5LkNVUlZFLkZwLk9SREVSO1xuICAgIGNvbnN0IG1vZCA9IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgIGNvbnN0IHIgPSBtb2QoU1FSVF9NMSAqIHIwICogcjApOyAvLyAxXG4gICAgY29uc3QgTnMgPSBtb2QoKHIgKyBfMW4pICogT05FX01JTlVTX0RfU1EpOyAvLyAyXG4gICAgbGV0IGMgPSBCaWdJbnQoLTEpOyAvLyAzXG4gICAgY29uc3QgRCA9IG1vZCgoYyAtIGQgKiByKSAqIG1vZChyICsgZCkpOyAvLyA0XG4gICAgbGV0IHsgaXNWYWxpZDogTnNfRF9pc19zcSwgdmFsdWU6IHMgfSA9IHV2UmF0aW8oTnMsIEQpOyAvLyA1XG4gICAgbGV0IHNfID0gbW9kKHMgKiByMCk7IC8vIDZcbiAgICBpZiAoIWlzTmVnYXRpdmVMRShzXywgUCkpXG4gICAgICAgIHNfID0gbW9kKC1zXyk7XG4gICAgaWYgKCFOc19EX2lzX3NxKVxuICAgICAgICBzID0gc187IC8vIDdcbiAgICBpZiAoIU5zX0RfaXNfc3EpXG4gICAgICAgIGMgPSByOyAvLyA4XG4gICAgY29uc3QgTnQgPSBtb2QoYyAqIChyIC0gXzFuKSAqIERfTUlOVVNfT05FX1NRIC0gRCk7IC8vIDlcbiAgICBjb25zdCBzMiA9IHMgKiBzO1xuICAgIGNvbnN0IFcwID0gbW9kKChzICsgcykgKiBEKTsgLy8gMTBcbiAgICBjb25zdCBXMSA9IG1vZChOdCAqIFNRUlRfQURfTUlOVVNfT05FKTsgLy8gMTFcbiAgICBjb25zdCBXMiA9IG1vZChfMW4gLSBzMik7IC8vIDEyXG4gICAgY29uc3QgVzMgPSBtb2QoXzFuICsgczIpOyAvLyAxM1xuICAgIHJldHVybiBuZXcgZWQyNTUxOS5Qb2ludChtb2QoVzAgKiBXMyksIG1vZChXMiAqIFcxKSwgbW9kKFcxICogVzMpLCBtb2QoVzAgKiBXMikpO1xufVxuZnVuY3Rpb24gcmlzdHJldHRvMjU1X21hcChieXRlcykge1xuICAgIGFieXRlcyhieXRlcywgNjQpO1xuICAgIGNvbnN0IHIxID0gYnl0ZXMyNTVUb051bWJlckxFKGJ5dGVzLnN1YmFycmF5KDAsIDMyKSk7XG4gICAgY29uc3QgUjEgPSBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIxKTtcbiAgICBjb25zdCByMiA9IGJ5dGVzMjU1VG9OdW1iZXJMRShieXRlcy5zdWJhcnJheSgzMiwgNjQpKTtcbiAgICBjb25zdCBSMiA9IGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjIpO1xuICAgIHJldHVybiBuZXcgX1Jpc3RyZXR0b1BvaW50KFIxLmFkZChSMikpO1xufVxuLyoqXG4gKiBXcmFwcGVyIG92ZXIgRWR3YXJkcyBQb2ludCBmb3IgcmlzdHJldHRvMjU1LlxuICpcbiAqIEVhY2ggZWQyNTUxOS9FeHRlbmRlZFBvaW50IGhhcyA4IGRpZmZlcmVudCBlcXVpdmFsZW50IHBvaW50cy4gVGhpcyBjYW4gYmVcbiAqIGEgc291cmNlIG9mIGJ1Z3MgZm9yIHByb3RvY29scyBsaWtlIHJpbmcgc2lnbmF0dXJlcy4gUmlzdHJldHRvIHdhcyBjcmVhdGVkIHRvIHNvbHZlIHRoaXMuXG4gKiBSaXN0cmV0dG8gcG9pbnQgb3BlcmF0ZXMgaW4gWDpZOlo6VCBleHRlbmRlZCBjb29yZGluYXRlcyBsaWtlIEV4dGVuZGVkUG9pbnQsXG4gKiBidXQgaXQgc2hvdWxkIHdvcmsgaW4gaXRzIG93biBuYW1lc3BhY2U6IGRvIG5vdCBjb21iaW5lIHRob3NlIHR3by5cbiAqIFNlZSBbUkZDOTQ5Nl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk0OTYpLlxuICovXG5jbGFzcyBfUmlzdHJldHRvUG9pbnQgZXh0ZW5kcyBQcmltZUVkd2FyZHNQb2ludCB7XG4gICAgY29uc3RydWN0b3IoZXApIHtcbiAgICAgICAgc3VwZXIoZXApO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFmZmluZShhcCkge1xuICAgICAgICByZXR1cm4gbmV3IF9SaXN0cmV0dG9Qb2ludChlZDI1NTE5LlBvaW50LmZyb21BZmZpbmUoYXApKTtcbiAgICB9XG4gICAgYXNzZXJ0U2FtZShvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIF9SaXN0cmV0dG9Qb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jpc3RyZXR0b1BvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGluaXQoZXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfUmlzdHJldHRvUG9pbnQoZXApO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyByaXN0cmV0dG8yNTVfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5LmpzJztgICovXG4gICAgc3RhdGljIGhhc2hUb0N1cnZlKGhleCkge1xuICAgICAgICByZXR1cm4gcmlzdHJldHRvMjU1X21hcChlbnN1cmVCeXRlcygncmlzdHJldHRvSGFzaCcsIGhleCwgNjQpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICBhYnl0ZXMoYnl0ZXMsIDMyKTtcbiAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBlZDI1NTE5LkNVUlZFO1xuICAgICAgICBjb25zdCBQID0gRnAuT1JERVI7XG4gICAgICAgIGNvbnN0IG1vZCA9IEZwLmNyZWF0ZTtcbiAgICAgICAgY29uc3QgcyA9IGJ5dGVzMjU1VG9OdW1iZXJMRShieXRlcyk7XG4gICAgICAgIC8vIDEuIENoZWNrIHRoYXQgc19ieXRlcyBpcyB0aGUgY2Fub25pY2FsIGVuY29kaW5nIG9mIGEgZmllbGQgZWxlbWVudCwgb3IgZWxzZSBhYm9ydC5cbiAgICAgICAgLy8gMy4gQ2hlY2sgdGhhdCBzIGlzIG5vbi1uZWdhdGl2ZSwgb3IgZWxzZSBhYm9ydFxuICAgICAgICBpZiAoIWVxdWFsQnl0ZXMobnVtYmVyVG9CeXRlc0xFKHMsIDMyKSwgYnl0ZXMpIHx8IGlzTmVnYXRpdmVMRShzLCBQKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByaXN0cmV0dG8yNTUgZW5jb2RpbmcgMScpO1xuICAgICAgICBjb25zdCBzMiA9IG1vZChzICogcyk7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKF8xbiArIGEgKiBzMik7IC8vIDQgKGEgaXMgLTEpXG4gICAgICAgIGNvbnN0IHUyID0gbW9kKF8xbiAtIGEgKiBzMik7IC8vIDVcbiAgICAgICAgY29uc3QgdTFfMiA9IG1vZCh1MSAqIHUxKTtcbiAgICAgICAgY29uc3QgdTJfMiA9IG1vZCh1MiAqIHUyKTtcbiAgICAgICAgY29uc3QgdiA9IG1vZChhICogZCAqIHUxXzIgLSB1Ml8yKTsgLy8gNlxuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlOiBJIH0gPSBpbnZlcnRTcXJ0KG1vZCh2ICogdTJfMikpOyAvLyA3XG4gICAgICAgIGNvbnN0IER4ID0gbW9kKEkgKiB1Mik7IC8vIDhcbiAgICAgICAgY29uc3QgRHkgPSBtb2QoSSAqIER4ICogdik7IC8vIDlcbiAgICAgICAgbGV0IHggPSBtb2QoKHMgKyBzKSAqIER4KTsgLy8gMTBcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRSh4LCBQKSlcbiAgICAgICAgICAgIHggPSBtb2QoLXgpOyAvLyAxMFxuICAgICAgICBjb25zdCB5ID0gbW9kKHUxICogRHkpOyAvLyAxMVxuICAgICAgICBjb25zdCB0ID0gbW9kKHggKiB5KTsgLy8gMTJcbiAgICAgICAgaWYgKCFpc1ZhbGlkIHx8IGlzTmVnYXRpdmVMRSh0LCBQKSB8fCB5ID09PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmlzdHJldHRvMjU1IGVuY29kaW5nIDInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBfUmlzdHJldHRvUG9pbnQobmV3IGVkMjU1MTkuUG9pbnQoeCwgeSwgXzFuLCB0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHJpc3RyZXR0by1lbmNvZGVkIHN0cmluZyB0byByaXN0cmV0dG8gcG9pbnQuXG4gICAgICogRGVzY3JpYmVkIGluIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NiNuYW1lLWRlY29kZSkuXG4gICAgICogQHBhcmFtIGhleCBSaXN0cmV0dG8tZW5jb2RlZCAzMiBieXRlcy4gTm90IGV2ZXJ5IDMyLWJ5dGUgc3RyaW5nIGlzIHZhbGlkIHJpc3RyZXR0byBlbmNvZGluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICByZXR1cm4gX1Jpc3RyZXR0b1BvaW50LmZyb21CeXRlcyhlbnN1cmVCeXRlcygncmlzdHJldHRvSGV4JywgaGV4LCAzMikpO1xuICAgIH1cbiAgICBzdGF0aWMgbXNtKHBvaW50cywgc2NhbGFycykge1xuICAgICAgICByZXR1cm4gcGlwcGVuZ2VyKF9SaXN0cmV0dG9Qb2ludCwgZWQyNTUxOS5Qb2ludC5GbiwgcG9pbnRzLCBzY2FsYXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyByaXN0cmV0dG8gcG9pbnQgdG8gVWludDhBcnJheS5cbiAgICAgKiBEZXNjcmliZWQgaW4gW1JGQzk0OTZdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5NDk2I25hbWUtZW5jb2RlKS5cbiAgICAgKi9cbiAgICB0b0J5dGVzKCkge1xuICAgICAgICBsZXQgeyBYLCBZLCBaLCBUIH0gPSB0aGlzLmVwO1xuICAgICAgICBjb25zdCBQID0gRnAuT1JERVI7XG4gICAgICAgIGNvbnN0IG1vZCA9IEZwLmNyZWF0ZTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QobW9kKFogKyBZKSAqIG1vZChaIC0gWSkpOyAvLyAxXG4gICAgICAgIGNvbnN0IHUyID0gbW9kKFggKiBZKTsgLy8gMlxuICAgICAgICAvLyBTcXVhcmUgcm9vdCBhbHdheXMgZXhpc3RzXG4gICAgICAgIGNvbnN0IHUyc3EgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IGludnNxcnQgfSA9IGludmVydFNxcnQobW9kKHUxICogdTJzcSkpOyAvLyAzXG4gICAgICAgIGNvbnN0IEQxID0gbW9kKGludnNxcnQgKiB1MSk7IC8vIDRcbiAgICAgICAgY29uc3QgRDIgPSBtb2QoaW52c3FydCAqIHUyKTsgLy8gNVxuICAgICAgICBjb25zdCB6SW52ID0gbW9kKEQxICogRDIgKiBUKTsgLy8gNlxuICAgICAgICBsZXQgRDsgLy8gN1xuICAgICAgICBpZiAoaXNOZWdhdGl2ZUxFKFQgKiB6SW52LCBQKSkge1xuICAgICAgICAgICAgbGV0IF94ID0gbW9kKFkgKiBTUVJUX00xKTtcbiAgICAgICAgICAgIGxldCBfeSA9IG1vZChYICogU1FSVF9NMSk7XG4gICAgICAgICAgICBYID0gX3g7XG4gICAgICAgICAgICBZID0gX3k7XG4gICAgICAgICAgICBEID0gbW9kKEQxICogSU5WU1FSVF9BX01JTlVTX0QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgRCA9IEQyOyAvLyA4XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRShYICogekludiwgUCkpXG4gICAgICAgICAgICBZID0gbW9kKC1ZKTsgLy8gOVxuICAgICAgICBsZXQgcyA9IG1vZCgoWiAtIFkpICogRCk7IC8vIDEwIChjaGVjayBmb290ZXIncyBub3RlLCBubyBzcXJ0KC1hKSlcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRShzLCBQKSlcbiAgICAgICAgICAgIHMgPSBtb2QoLXMpO1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0xFKHMsIDMyKTsgLy8gMTFcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIFJpc3RyZXR0byBwb2ludHMuXG4gICAgICogRGVzY3JpYmVkIGluIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NiNuYW1lLWVxdWFscykuXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2FtZShvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxIH0gPSB0aGlzLmVwO1xuICAgICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiB9ID0gb3RoZXIuZXA7XG4gICAgICAgIGNvbnN0IG1vZCA9IEZwLmNyZWF0ZTtcbiAgICAgICAgLy8gKHgxICogeTIgPT0geTEgKiB4MikgfCAoeTEgKiB5MiA9PSB4MSAqIHgyKVxuICAgICAgICBjb25zdCBvbmUgPSBtb2QoWDEgKiBZMikgPT09IG1vZChZMSAqIFgyKTtcbiAgICAgICAgY29uc3QgdHdvID0gbW9kKFkxICogWTIpID09PSBtb2QoWDEgKiBYMik7XG4gICAgICAgIHJldHVybiBvbmUgfHwgdHdvO1xuICAgIH1cbiAgICBpczAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhfUmlzdHJldHRvUG9pbnQuWkVSTyk7XG4gICAgfVxufVxuLy8gRG8gTk9UIGNoYW5nZSBzeW50YXg6IHRoZSBmb2xsb3dpbmcgZ3ltbmFzdGljcyBpcyBkb25lLFxuLy8gYmVjYXVzZSB0eXBlc2NyaXB0IHN0cmlwcyBjb21tZW50cywgd2hpY2ggbWFrZXMgYnVuZGxlcnMgZGlzYWJsZSB0cmVlLXNoYWtpbmcuXG4vLyBwcmV0dGllci1pZ25vcmVcbl9SaXN0cmV0dG9Qb2ludC5CQVNFID0gXG4vKiBAX19QVVJFX18gKi8gKCgpID0+IG5ldyBfUmlzdHJldHRvUG9pbnQoZWQyNTUxOS5Qb2ludC5CQVNFKSkoKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuX1Jpc3RyZXR0b1BvaW50LlpFUk8gPSBcbi8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbmV3IF9SaXN0cmV0dG9Qb2ludChlZDI1NTE5LlBvaW50LlpFUk8pKSgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5fUmlzdHJldHRvUG9pbnQuRnAgPSBcbi8qIEBfX1BVUkVfXyAqLyBGcDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuX1Jpc3RyZXR0b1BvaW50LkZuID0gXG4vKiBAX19QVVJFX18gKi8gRm47XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGByaXN0cmV0dG8yNTUuUG9pbnRgICovXG5leHBvcnQgY29uc3QgUmlzdHJldHRvUG9pbnQgPSBfUmlzdHJldHRvUG9pbnQ7XG5leHBvcnQgY29uc3QgcmlzdHJldHRvMjU1ID0geyBQb2ludDogX1Jpc3RyZXR0b1BvaW50IH07XG4vKiogSGFzaGluZyB0byByaXN0cmV0dG8yNTUgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcmlzdHJldHRvMjU1X2hhc2hlciA9IHtcbiAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgRFNUID0gb3B0aW9ucz8uRFNUIHx8ICdyaXN0cmV0dG8yNTVfWE1EOlNIQS01MTJfUjI1NU1BUF9ST18nO1xuICAgICAgICByZXR1cm4gcmlzdHJldHRvMjU1X21hcChleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIDY0LCBzaGE1MTIpKTtcbiAgICB9LFxuICAgIGhhc2hUb1NjYWxhcihtc2csIG9wdGlvbnMgPSB7IERTVDogX0RTVF9zY2FsYXIgfSkge1xuICAgICAgICByZXR1cm4gRm4uY3JlYXRlKGJ5dGVzVG9OdW1iZXJMRShleHBhbmRfbWVzc2FnZV94bWQobXNnLCBvcHRpb25zLkRTVCwgNjQsIHNoYTUxMikpKTtcbiAgICB9LFxufTtcbi8vIGV4cG9ydCBjb25zdCByaXN0cmV0dG8yNTVfb3ByZjogT1BSRiA9IGNyZWF0ZU9SUEYoe1xuLy8gICBuYW1lOiAncmlzdHJldHRvMjU1LVNIQTUxMicsXG4vLyAgIFBvaW50OiBSaXN0cmV0dG9Qb2ludCxcbi8vICAgaGFzaDogc2hhNTEyLFxuLy8gICBoYXNoVG9Hcm91cDogcmlzdHJldHRvMjU1X2hhc2hlci5oYXNoVG9DdXJ2ZSxcbi8vICAgaGFzaFRvU2NhbGFyOiByaXN0cmV0dG8yNTVfaGFzaGVyLmhhc2hUb1NjYWxhcixcbi8vIH0pO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgZWQyNTUxOV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTkuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZWQyNTUxOV9oYXNoZXIuaGFzaFRvQ3VydmUpKCk7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyBlZDI1NTE5X2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOS5qcyc7YCAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGVkMjU1MTlfaGFzaGVyLmVuY29kZVRvQ3VydmUpKCk7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyByaXN0cmV0dG8yNTVfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5LmpzJztgICovXG5leHBvcnQgY29uc3QgaGFzaFRvUmlzdHJldHRvMjU1ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiByaXN0cmV0dG8yNTVfaGFzaGVyLmhhc2hUb0N1cnZlKSgpO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgcmlzdHJldHRvMjU1X2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOS5qcyc7YCAqL1xuZXhwb3J0IGNvbnN0IGhhc2hfdG9fcmlzdHJldHRvMjU1ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiByaXN0cmV0dG8yNTVfaGFzaGVyLmhhc2hUb0N1cnZlKSgpO1xuLyoqXG4gKiBXZWlyZCAvIGJvZ3VzIHBvaW50cywgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG4gKiBBbGwgOCBlZDI1NTE5IHBvaW50cyBvZiA4LXRvcnNpb24gc3ViZ3JvdXAgY2FuIGJlIGdlbmVyYXRlZCBmcm9tIHRoZSBwb2ludFxuICogVCA9IGAyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzA1YC5cbiAqIOKfqFTin6kgPSB7IE8sIFQsIDJULCAzVCwgNFQsIDVULCA2VCwgN1QgfVxuICovXG5leHBvcnQgY29uc3QgRUQyNTUxOV9UT1JTSU9OX1NVQkdST1VQID0gW1xuICAgICcwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnYzcxNzZhNzAzZDRkZDg0ZmJhM2MwYjc2MGQxMDY3MGYyYTIwNTNmYTJjMzljY2M2NGVjN2ZkNzc5MmFjMDM3YScsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODAnLFxuICAgICcyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzA1JyxcbiAgICAnZWNmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY3ZicsXG4gICAgJzI2ZTg5NThmYzJiMjI3YjA0NWMzZjQ4OWYyZWY5OGYwZDVkZmFjMDVkM2M2MzMzOWIxMzgwMjg4NmQ1M2ZjODUnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnYzcxNzZhNzAzZDRkZDg0ZmJhM2MwYjc2MGQxMDY3MGYyYTIwNTNmYTJjMzljY2M2NGVjN2ZkNzc5MmFjMDNmYScsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWQyNTUxOS5qcy5tYXAiXSwibmFtZXMiOlsic2hhNTEyIiwiYWJ5dGVzIiwiY29uY2F0Qnl0ZXMiLCJ1dGY4VG9CeXRlcyIsInBpcHBlbmdlciIsIlByaW1lRWR3YXJkc1BvaW50IiwidHdpc3RlZEVkd2FyZHMiLCJfRFNUX3NjYWxhciIsImNyZWF0ZUhhc2hlciIsImV4cGFuZF9tZXNzYWdlX3htZCIsIkZpZWxkIiwiRnBJbnZlcnRCYXRjaCIsIkZwU3FydEV2ZW4iLCJpc05lZ2F0aXZlTEUiLCJtb2QiLCJwb3cyIiwibW9udGdvbWVyeSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwiZXF1YWxCeXRlcyIsIm51bWJlclRvQnl0ZXNMRSIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl81biIsIl84biIsImVkMjU1MTlfQ1VSVkUiLCJwIiwibiIsImgiLCJhIiwiZCIsIkd4IiwiR3kiLCJlZDI1NTE5X3Bvd18yXzI1Ml8zIiwieCIsIl8xMG4iLCJfMjBuIiwiXzQwbiIsIl84MG4iLCJQIiwieDIiLCJiMiIsImI0IiwiYjUiLCJiMTAiLCJiMjAiLCJiNDAiLCJiODAiLCJiMTYwIiwiYjI0MCIsImIyNTAiLCJwb3dfcF81XzgiLCJhZGp1c3RTY2FsYXJCeXRlcyIsImJ5dGVzIiwiRUQyNTUxOV9TUVJUX00xIiwidXZSYXRpbyIsInUiLCJ2IiwidjMiLCJ2NyIsInBvdyIsInZ4MiIsInJvb3QxIiwicm9vdDIiLCJ1c2VSb290MSIsInVzZVJvb3QyIiwibm9Sb290IiwiaXNWYWxpZCIsInZhbHVlIiwiRnAiLCJpc0xFIiwiRm4iLCJlZDI1NTE5RGVmYXVsdHMiLCJoYXNoIiwiZWQyNTUxOSIsImVkMjU1MTlfZG9tYWluIiwiZGF0YSIsImN0eCIsInBoZmxhZyIsImxlbmd0aCIsIkVycm9yIiwiVWludDhBcnJheSIsImVkMjU1MTljdHgiLCJkb21haW4iLCJlZDI1NTE5cGgiLCJPYmplY3QiLCJhc3NpZ24iLCJwcmVoYXNoIiwieDI1NTE5IiwidHlwZSIsInBvd1BtaW51czIiLCJlZHdhcmRzVG9Nb250Z29tZXJ5UHViIiwiZWR3YXJkc1B1YiIsInV0aWxzIiwidG9Nb250Z29tZXJ5IiwiZWR3YXJkc1RvTW9udGdvbWVyeSIsImVkd2FyZHNUb01vbnRnb21lcnlQcml2IiwiZWR3YXJkc1ByaXYiLCJ0b01vbnRnb21lcnlQcml2IiwiRUxMMl9DMSIsIk9SREVSIiwiRUxMMl9DMiIsIkVMTDJfQzMiLCJzcXJ0IiwibmVnIiwiT05FIiwibWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSIsIkVMTDJfQzQiLCJFTEwyX0oiLCJ0djEiLCJzcXIiLCJtdWwiLCJ4ZCIsImFkZCIsIngxbiIsInR2MiIsImd4ZCIsImd4MSIsInR2MyIsInkxMSIsInkxMiIsImUxIiwiZXFsIiwieTEiLCJjbW92IiwieDJuIiwieTIxIiwieTIyIiwiZ3gyIiwiZTIiLCJ5MiIsImUzIiwieG4iLCJ5IiwiZTQiLCJpc09kZCIsInhNbiIsInhNZCIsInlNbiIsInlNZCIsIkVMTDJfQzFfRURXQVJEUyIsIm1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOSIsInluIiwic3ViIiwieWQiLCJlIiwiWkVSTyIsInhkX2ludiIsInlkX2ludiIsImVkMjU1MTlfaGFzaGVyIiwiUG9pbnQiLCJzY2FsYXJzIiwiRFNUIiwiZW5jb2RlRFNUIiwibSIsImsiLCJleHBhbmQiLCJTUVJUX00xIiwiU1FSVF9BRF9NSU5VU19PTkUiLCJJTlZTUVJUX0FfTUlOVVNfRCIsIk9ORV9NSU5VU19EX1NRIiwiRF9NSU5VU19PTkVfU1EiLCJpbnZlcnRTcXJ0IiwibnVtYmVyIiwiTUFYXzI1NUIiLCJieXRlczI1NVRvTnVtYmVyTEUiLCJDVVJWRSIsImNyZWF0ZSIsImNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAiLCJyMCIsInIiLCJOcyIsImMiLCJEIiwiTnNfRF9pc19zcSIsInMiLCJzXyIsIk50IiwiczIiLCJXMCIsIlcxIiwiVzIiLCJXMyIsInJpc3RyZXR0bzI1NV9tYXAiLCJyMSIsInN1YmFycmF5IiwiUjEiLCJyMiIsIlIyIiwiX1Jpc3RyZXR0b1BvaW50IiwiY29uc3RydWN0b3IiLCJlcCIsImZyb21BZmZpbmUiLCJhcCIsImFzc2VydFNhbWUiLCJvdGhlciIsImluaXQiLCJoYXNoVG9DdXJ2ZSIsImhleCIsImZyb21CeXRlcyIsInUxIiwidTIiLCJ1MV8yIiwidTJfMiIsIkkiLCJEeCIsIkR5IiwidCIsImZyb21IZXgiLCJtc20iLCJwb2ludHMiLCJ0b0J5dGVzIiwiWCIsIlkiLCJaIiwiVCIsInUyc3EiLCJpbnZzcXJ0IiwiRDEiLCJEMiIsInpJbnYiLCJfeCIsIl95IiwiZXF1YWxzIiwiWDEiLCJZMSIsIlgyIiwiWTIiLCJvbmUiLCJ0d28iLCJpczAiLCJCQVNFIiwiUmlzdHJldHRvUG9pbnQiLCJyaXN0cmV0dG8yNTUiLCJyaXN0cmV0dG8yNTVfaGFzaGVyIiwibXNnIiwib3B0aW9ucyIsImhhc2hUb1NjYWxhciIsImVuY29kZVRvQ3VydmUiLCJoYXNoVG9SaXN0cmV0dG8yNTUiLCJoYXNoX3RvX3Jpc3RyZXR0bzI1NSIsIkVEMjU1MTlfVE9SU0lPTl9TVUJHUk9VUCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/ed25519.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/secp256k1.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/secp256k1.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1),\n/* harmony export */   secp256k1_hasher: () => (/* binding */ secp256k1_hasher)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha2.js */ \"(ssr)/./node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ψ,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\n// Seems like generator was produced from some seed:\n// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE = {\n    p: BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"),\n    n: BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),\n    h: BigInt(1),\n    a: BigInt(0),\n    b: BigInt(7),\n    Gx: BigInt(\"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"),\n    Gy: BigInt(\"0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\")\n};\nconst secp256k1_ENDO = {\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n    basises: [\n        [\n            BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"),\n            -BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\")\n        ],\n        [\n            BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"),\n            BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\")\n        ]\n    ]\n};\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1_CURVE.p;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fpk1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1_CURVE.p, undefined, undefined, {\n    sqrt: sqrtMod\n});\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey) === true;\n * ```\n */ const secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    ...secp256k1_CURVE,\n    Fp: Fpk1,\n    lowS: true,\n    endo: secp256k1_ENDO\n}, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toBytes(true).slice(1);\nconst numTo32b = (n)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1_CURVE.p);\nconst modN = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1_CURVE.n);\nconst Point = /* @__PURE__ */ (()=>secp256k1.Point)();\nconst hasEven = (y)=>y % _2n === _0n;\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    // TODO: replace with Point.Fn.fromBytes(priv)\n    let d_ = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_5__._normFnElement)(Point.Fn, priv);\n    let p = Point.BASE.multiply(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = hasEven(p.y) ? d_ : modN(-d_);\n    return {\n        scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.aInRange)(\"x\", x, _1n, secp256k1_CURVE.p); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (!hasEven(y)) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = Point.fromAffine({\n        x,\n        y\n    }); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = _utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN(num(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(secretKey) {\n    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, secretKey, auxRand = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(32)) {\n    const m = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n    const a = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)(\"message\", message);\n    const pub = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.inRange)(r, _1n, secp256k1_CURVE.p)) return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.inRange)(s, _1n, secp256k1_CURVE.n)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        // R = s⋅G - e⋅P, where -eP == (n-e)P\n        const R = Point.BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(modN(-e)));\n        const { x, y } = R.toAffine();\n        // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n        if (R.is0() || !hasEven(y) || x !== r) return false;\n        return true;\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */ const schnorr = /* @__PURE__ */ (()=>{\n    const size = 32;\n    const seedLength = 48;\n    const randomSecretKey = (seed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(seedLength))=>{\n        return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mapHashToField)(seed, secp256k1_CURVE.n);\n    };\n    // TODO: remove\n    secp256k1.utils.randomSecretKey;\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: schnorrGetPublicKey(secretKey)\n        };\n    }\n    return {\n        keygen,\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        Point,\n        utils: {\n            randomSecretKey: randomSecretKey,\n            randomPrivateKey: randomSecretKey,\n            taggedHash,\n            // TODO: remove\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _utils_js__WEBPACK_IMPORTED_MODULE_4__.numberToBytesBE,\n            bytesToNumberBE: _utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        },\n        info: {\n            type: \"weierstrass\",\n            publicKeyHasPrefix: false,\n            lengths: {\n                secret: size,\n                public: size,\n                signature: size * 2,\n                seed: seedLength\n            }\n        }\n    };\n})();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.isogenyMap)(Fpk1, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_5__.mapToCurveSimpleSWU)(Fpk1, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fpk1.create(BigInt(\"-11\"))\n    }))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */ const secp256k1_hasher = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.createHasher)(secp256k1.Point, (scalars)=>{\n        const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fpk1.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */ const hashToCurve = /* @__PURE__ */ (()=>secp256k1_hasher.hashToCurve)();\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */ const encodeToCurve = /* @__PURE__ */ (()=>secp256k1_hasher.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ0Qsb0VBQW9FLEdBQ3JCO0FBQ007QUFDSjtBQUN1QjtBQUNDO0FBQ1E7QUFDMkI7QUFDNUcsb0RBQW9EO0FBQ3BELDBEQUEwRDtBQUMxRCxpRUFBaUU7QUFDakUsTUFBTWlCLGtCQUFrQjtJQUNwQkMsR0FBR0MsT0FBTztJQUNWQyxHQUFHRCxPQUFPO0lBQ1ZFLEdBQUdGLE9BQU87SUFDVkcsR0FBR0gsT0FBTztJQUNWSSxHQUFHSixPQUFPO0lBQ1ZLLElBQUlMLE9BQU87SUFDWE0sSUFBSU4sT0FBTztBQUNmO0FBQ0EsTUFBTU8saUJBQWlCO0lBQ25CQyxNQUFNUixPQUFPO0lBQ2JTLFNBQVM7UUFDTDtZQUFDVCxPQUFPO1lBQXVDLENBQUNBLE9BQU87U0FBc0M7UUFDN0Y7WUFBQ0EsT0FBTztZQUF3Q0EsT0FBTztTQUFzQztLQUNoRztBQUNMO0FBQ0EsTUFBTVUsTUFBTSxhQUFhLEdBQUdWLE9BQU87QUFDbkMsTUFBTVcsTUFBTSxhQUFhLEdBQUdYLE9BQU87QUFDbkMsTUFBTVksTUFBTSxhQUFhLEdBQUdaLE9BQU87QUFDbkM7OztDQUdDLEdBQ0QsU0FBU2EsUUFBUUMsQ0FBQztJQUNkLE1BQU1DLElBQUlqQixnQkFBZ0JDLENBQUM7SUFDM0Isa0JBQWtCO0lBQ2xCLE1BQU1pQixNQUFNaEIsT0FBTyxJQUFJaUIsTUFBTWpCLE9BQU8sSUFBSWtCLE9BQU9sQixPQUFPLEtBQUttQixPQUFPbkIsT0FBTztJQUN6RSxrQkFBa0I7SUFDbEIsTUFBTW9CLE9BQU9wQixPQUFPLEtBQUtxQixPQUFPckIsT0FBTyxLQUFLc0IsT0FBT3RCLE9BQU87SUFDMUQsTUFBTXVCLEtBQUssSUFBS1QsSUFBSUEsSUFBS0MsR0FBRyxVQUFVO0lBQ3RDLE1B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RSxPQUFPLENBQUMsRUFBRTtRQUM5QyxPQUFPVixPQUFPakUsR0FBR2pEO0lBQ3JCLEdBQUc7UUFDQzZILEtBQUs7UUFDTEMsV0FBVztRQUNYN0ksR0FBR3NDLEtBQUt3RyxLQUFLO1FBQ2J0RCxHQUFHO1FBQ0hPLEdBQUc7UUFDSGdELFFBQVE7UUFDUkMsTUFBTWxLLHlEQUFNQTtJQUNoQixFQUFDLElBQUs7QUFDTixxRkFBcUYsR0FDOUUsTUFBTW1LLGNBQThCLGFBQUgsR0FBSSxLQUFNUCxpQkFBaUJPLFdBQVcsSUFBSTtBQUNsRixxRkFBcUYsR0FDOUUsTUFBTUMsZ0JBQWdDLGFBQUgsR0FBSSxLQUFNUixpQkFBaUJRLGFBQWEsSUFBSSxDQUN0RixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcz8yOTNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU0VDRyBzZWNwMjU2azEuIFNlZSBbcGRmXShodHRwczovL3d3dy5zZWNnLm9yZy9zZWMyLXYyLnBkZikuXG4gKlxuICogQmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5LWNvbXB1dGFibGUgR0xWIGVuZG9tb3JwaGlzbSDPiCxcbiAqIGNoZWNrIG91dCB7QGxpbmsgRW5kb21vcnBoaXNtT3B0c30uIFNlZW1zIHRvIGJlIHJpZ2lkIChub3QgYmFja2Rvb3JlZCkuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMi5qcyc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tIFwiLi9fc2hvcnR3X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAsIH0gZnJvbSBcIi4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qc1wiO1xuaW1wb3J0IHsgRmllbGQsIG1hcEhhc2hUb0ZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tIFwiLi9hYnN0cmFjdC9tb2R1bGFyLmpzXCI7XG5pbXBvcnQgeyBfbm9ybUZuRWxlbWVudCwgbWFwVG9DdXJ2ZVNpbXBsZVNXVSwgfSBmcm9tIFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiO1xuaW1wb3J0IHsgYUluUmFuZ2UsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBpblJhbmdlLCBudW1iZXJUb0J5dGVzQkUsIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIFNlZW1zIGxpa2UgZ2VuZXJhdG9yIHdhcyBwcm9kdWNlZCBmcm9tIHNvbWUgc2VlZDpcbi8vIGBQb2ludC5CQVNFLm11bHRpcGx5KFBvaW50LkZuLmludigybiwgTikpLnRvQWZmaW5lKCkueGBcbi8vIC8vIGdpdmVzIHNob3J0IHggMHgzYjc4Y2U1NjNmODlhMGVkOTQxNGY1YWEyOGFkMGQ5NmQ2Nzk1ZjljNjNuXG5jb25zdCBzZWNwMjU2azFfQ1VSVkUgPSB7XG4gICAgcDogQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKSxcbiAgICBuOiBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBhOiBCaWdJbnQoMCksXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEd4OiBCaWdJbnQoJzB4NzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OCcpLFxuICAgIEd5OiBCaWdJbnQoJzB4NDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOCcpLFxufTtcbmNvbnN0IHNlY3AyNTZrMV9FTkRPID0ge1xuICAgIGJldGE6IEJpZ0ludCgnMHg3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyksXG4gICAgYmFzaXNlczogW1xuICAgICAgICBbQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1JyksIC1CaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKV0sXG4gICAgICAgIFtCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4JyksIEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpXSxcbiAgICBdLFxufTtcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMV9DVVJWRS5wO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcGsxLmVxbChGcGsxLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwazEgPSBGaWVsZChzZWNwMjU2azFfQ1VSVkUucCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbi8qKlxuICogc2VjcDI1NmsxIGN1cnZlLCBFQ0RTQSBhbmQgRUNESCBtZXRob2RzLlxuICpcbiAqIEZpZWxkOiBgMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5gXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG4gKiBjb25zdCB7IHNlY3JldEtleSwgcHVibGljS2V5IH0gPSBzZWNwMjU2azEua2V5Z2VuKCk7XG4gKiBjb25zdCBtc2cgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ2hlbGxvJyk7XG4gKiBjb25zdCBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2csIHNlY3JldEtleSk7XG4gKiBjb25zdCBpc1ZhbGlkID0gc2VjcDI1NmsxLnZlcmlmeShzaWcsIG1zZywgcHVibGljS2V5KSA9PT0gdHJ1ZTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3Qgc2VjcDI1NmsxID0gY3JlYXRlQ3VydmUoeyAuLi5zZWNwMjU2azFfQ1VSVkUsIEZwOiBGcGsxLCBsb3dTOiB0cnVlLCBlbmRvOiBzZWNwMjU2azFfRU5ETyB9LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiBzaGEyNTYoY29uY2F0Qnl0ZXModGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMV9DVVJWRS5wKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMV9DVVJWRS5uKTtcbmNvbnN0IFBvaW50ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBzZWNwMjU2azEuUG9pbnQpKCk7XG5jb25zdCBoYXNFdmVuID0gKHkpID0+IHkgJSBfMm4gPT09IF8wbjtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIFBvaW50LkZuLmZyb21CeXRlcyhwcml2KVxuICAgIGxldCBkXyA9IF9ub3JtRm5FbGVtZW50KFBvaW50LkZuLCBwcml2KTtcbiAgICBsZXQgcCA9IFBvaW50LkJBU0UubXVsdGlwbHkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gaGFzRXZlbihwLnkpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgYUluUmFuZ2UoJ3gnLCB4LCBfMW4sIHNlY3AyNTZrMV9DVVJWRS5wKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKCFoYXNFdmVuKHkpKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBQb2ludC5mcm9tQWZmaW5lKHsgeCwgeSB9KTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuY29uc3QgbnVtID0gYnl0ZXNUb051bWJlckJFO1xuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4obnVtKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShzZWNyZXRLZXkpIHtcbiAgICByZXR1cm4gc2Nobm9yckdldEV4dFB1YktleShzZWNyZXRLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBzZWNyZXRLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHNlY3JldEtleSk7IC8vIGNoZWNrcyBmb3IgaXNXaXRoaW5DdXJ2ZU9yZGVyXG4gICAgY29uc3QgYSA9IGVuc3VyZUJ5dGVzKCdhdXhSYW5kJywgYXV4UmFuZCwgMzIpOyAvLyBBdXhpbGlhcnkgcmFuZG9tIGRhdGEgYTogYSAzMi1ieXRlIGFycmF5XG4gICAgY29uc3QgdCA9IG51bVRvMzJiKGQgXiBudW0odGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpOyAvLyBMZXQgdCBiZSB0aGUgYnl0ZS13aXNlIHhvciBvZiBieXRlcyhkKSBhbmQgaGFzaC9hdXgoYSlcbiAgICBjb25zdCByYW5kID0gdGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIHQsIHB4LCBtKTsgLy8gTGV0IHJhbmQgPSBoYXNoL25vbmNlKHQgfHwgYnl0ZXMoUCkgfHwgbSlcbiAgICBjb25zdCBrXyA9IG1vZE4obnVtKHJhbmQpKTsgLy8gTGV0IGsnID0gaW50KHJhbmQpIG1vZCBuXG4gICAgaWYgKGtfID09PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbiBmYWlsZWQ6IGsgaXMgemVybycpOyAvLyBGYWlsIGlmIGsnID0gMC5cbiAgICBjb25zdCB7IGJ5dGVzOiByeCwgc2NhbGFyOiBrIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KGtfKTsgLy8gTGV0IFIgPSBrJ+KLhUcuXG4gICAgY29uc3QgZSA9IGNoYWxsZW5nZShyeCwgcHgsIG0pOyAvLyBMZXQgZSA9IGludChoYXNoL2NoYWxsZW5nZShieXRlcyhSKSB8fCBieXRlcyhQKSB8fCBtKSkgbW9kIG4uXG4gICAgY29uc3Qgc2lnID0gbmV3IFVpbnQ4QXJyYXkoNjQpOyAvLyBMZXQgc2lnID0gYnl0ZXMoUikgfHwgYnl0ZXMoKGsgKyBlZCkgbW9kIG4pLlxuICAgIHNpZy5zZXQocngsIDApO1xuICAgIHNpZy5zZXQobnVtVG8zMmIobW9kTihrICsgZSAqIGQpKSwgMzIpO1xuICAgIC8vIElmIFZlcmlmeShieXRlcyhQKSwgbSwgc2lnKSAoc2VlIGJlbG93KSByZXR1cm5zIGZhaWx1cmUsIGFib3J0XG4gICAgaWYgKCFzY2hub3JyVmVyaWZ5KHNpZywgbSwgcHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ246IEludmFsaWQgc2lnbmF0dXJlIHByb2R1Y2VkJyk7XG4gICAgcmV0dXJuIHNpZztcbn1cbi8qKlxuICogVmVyaWZpZXMgU2Nobm9yciBzaWduYXR1cmUuXG4gKiBXaWxsIHN3YWxsb3cgZXJyb3JzICYgcmV0dXJuIGZhbHNlIGV4Y2VwdCBmb3IgaW5pdGlhbCB0eXBlIHZhbGlkYXRpb24gb2YgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3Qgc2lnID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSwgNjQpO1xuICAgIGNvbnN0IG0gPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHB1YiA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIDMyKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBQID0gbGlmdF94KG51bShwdWIpKTsgLy8gUCA9IGxpZnRfeChpbnQocGspKTsgZmFpbCBpZiB0aGF0IGZhaWxzXG4gICAgICAgIGNvbnN0IHIgPSBudW0oc2lnLnN1YmFycmF5KDAsIDMyKSk7IC8vIExldCByID0gaW50KHNpZ1swOjMyXSk7IGZhaWwgaWYgciDiiaUgcC5cbiAgICAgICAgaWYgKCFpblJhbmdlKHIsIF8xbiwgc2VjcDI1NmsxX0NVUlZFLnApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gbnVtKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFpblJhbmdlKHMsIF8xbiwgc2VjcDI1NmsxX0NVUlZFLm4pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgLy8gUiA9IHPii4VHIC0gZeKLhVAsIHdoZXJlIC1lUCA9PSAobi1lKVBcbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlVbnNhZmUocykuYWRkKFAubXVsdGlwbHlVbnNhZmUobW9kTigtZSkpKTtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBSLnRvQWZmaW5lKCk7XG4gICAgICAgIC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgICAgIGlmIChSLmlzMCgpIHx8ICFoYXNFdmVuKHkpIHx8IHggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogU2Nobm9yciBzaWduYXR1cmVzIG92ZXIgc2VjcDI1NmsxLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHsgc2VjcmV0S2V5LCBwdWJsaWNLZXkgfSA9IHNjaG5vcnIua2V5Z2VuKCk7XG4gKiAvLyBjb25zdCBwdWJsaWNLZXkgPSBzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAqIGNvbnN0IGlzVmFsaWQgPSBzY2hub3JyLnZlcmlmeShzaWcsIG1zZywgcHVibGljS2V5KTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGNvbnN0IHNpemUgPSAzMjtcbiAgICBjb25zdCBzZWVkTGVuZ3RoID0gNDg7XG4gICAgY29uc3QgcmFuZG9tU2VjcmV0S2V5ID0gKHNlZWQgPSByYW5kb21CeXRlcyhzZWVkTGVuZ3RoKSkgPT4ge1xuICAgICAgICByZXR1cm4gbWFwSGFzaFRvRmllbGQoc2VlZCwgc2VjcDI1NmsxX0NVUlZFLm4pO1xuICAgIH07XG4gICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVNlY3JldEtleTtcbiAgICBmdW5jdGlvbiBrZXlnZW4oc2VlZCkge1xuICAgICAgICBjb25zdCBzZWNyZXRLZXkgPSByYW5kb21TZWNyZXRLZXkoc2VlZCk7XG4gICAgICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5KHNlY3JldEtleSkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5Z2VuLFxuICAgICAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgICAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgICAgIFBvaW50LFxuICAgICAgICB1dGlsczoge1xuICAgICAgICAgICAgcmFuZG9tU2VjcmV0S2V5OiByYW5kb21TZWNyZXRLZXksXG4gICAgICAgICAgICByYW5kb21Qcml2YXRlS2V5OiByYW5kb21TZWNyZXRLZXksXG4gICAgICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgICAgICAgICBsaWZ0X3gsXG4gICAgICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgICAgICBudW1iZXJUb0J5dGVzQkUsXG4gICAgICAgICAgICBieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgICAgICBtb2QsXG4gICAgICAgIH0sXG4gICAgICAgIGluZm86IHtcbiAgICAgICAgICAgIHR5cGU6ICd3ZWllcnN0cmFzcycsXG4gICAgICAgICAgICBwdWJsaWNLZXlIYXNQcmVmaXg6IGZhbHNlLFxuICAgICAgICAgICAgbGVuZ3Roczoge1xuICAgICAgICAgICAgICAgIHNlY3JldDogc2l6ZSxcbiAgICAgICAgICAgICAgICBwdWJsaWM6IHNpemUsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBzaXplICogMixcbiAgICAgICAgICAgICAgICBzZWVkOiBzZWVkTGVuZ3RoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xufSkoKTtcbmNvbnN0IGlzb01hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaXNvZ2VueU1hcChGcGsxLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwazEsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwazEuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSkpKCk7XG4vKiogSGFzaGluZyAvIGVuY29kaW5nIHRvIHNlY3AyNTZrMSBwb2ludHMgLyBmaWVsZC4gUkZDIDkzODAgbWV0aG9kcy4gKi9cbmV4cG9ydCBjb25zdCBzZWNwMjU2azFfaGFzaGVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoc2VjcDI1NmsxLlBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwazEuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcGsxLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyBzZWNwMjU2azFfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gc2VjcDI1NmsxX2hhc2hlci5oYXNoVG9DdXJ2ZSkoKTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IHNlY3AyNTZrMV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMS5qcyc7YCAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHNlY3AyNTZrMV9oYXNoZXIuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOlsic2hhMjU2IiwicmFuZG9tQnl0ZXMiLCJjcmVhdGVDdXJ2ZSIsImNyZWF0ZUhhc2hlciIsImlzb2dlbnlNYXAiLCJGaWVsZCIsIm1hcEhhc2hUb0ZpZWxkIiwibW9kIiwicG93MiIsIl9ub3JtRm5FbGVtZW50IiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsImFJblJhbmdlIiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJlbnN1cmVCeXRlcyIsImluUmFuZ2UiLCJudW1iZXJUb0J5dGVzQkUiLCJzZWNwMjU2azFfQ1VSVkUiLCJwIiwiQmlnSW50IiwibiIsImgiLCJhIiwiYiIsIkd4IiwiR3kiLCJzZWNwMjU2azFfRU5ETyIsImJldGEiLCJiYXNpc2VzIiwiXzBuIiwiXzFuIiwiXzJuIiwic3FydE1vZCIsInkiLCJQIiwiXzNuIiwiXzZuIiwiXzExbiIsIl8yMm4iLCJfMjNuIiwiXzQ0biIsIl84OG4iLCJiMiIsImIzIiwiYjYiLCJiOSIsImIxMSIsImIyMiIsImI0NCIsImI4OCIsImIxNzYiLCJiMjIwIiwiYjIyMyIsInQxIiwidDIiLCJyb290IiwiRnBrMSIsImVxbCIsInNxciIsIkVycm9yIiwidW5kZWZpbmVkIiwic3FydCIsInNlY3AyNTZrMSIsIkZwIiwibG93UyIsImVuZG8iLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsInRhZ2dlZEhhc2giLCJ0YWciLCJtZXNzYWdlcyIsInRhZ1AiLCJ0YWdIIiwiVWludDhBcnJheSIsImZyb20iLCJjIiwiY2hhckNvZGVBdCIsInBvaW50VG9CeXRlcyIsInBvaW50IiwidG9CeXRlcyIsInNsaWNlIiwibnVtVG8zMmIiLCJtb2RQIiwieCIsIm1vZE4iLCJQb2ludCIsImhhc0V2ZW4iLCJzY2hub3JyR2V0RXh0UHViS2V5IiwicHJpdiIsImRfIiwiRm4iLCJCQVNFIiwibXVsdGlwbHkiLCJzY2FsYXIiLCJieXRlcyIsImxpZnRfeCIsInh4IiwiZnJvbUFmZmluZSIsImFzc2VydFZhbGlkaXR5IiwibnVtIiwiY2hhbGxlbmdlIiwiYXJncyIsInNjaG5vcnJHZXRQdWJsaWNLZXkiLCJzZWNyZXRLZXkiLCJzY2hub3JyU2lnbiIsIm1lc3NhZ2UiLCJhdXhSYW5kIiwibSIsInB4IiwiZCIsInQiLCJyYW5kIiwia18iLCJyeCIsImsiLCJlIiwic2lnIiwic2V0Iiwic2Nobm9yclZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInB1YiIsInIiLCJzdWJhcnJheSIsInMiLCJSIiwibXVsdGlwbHlVbnNhZmUiLCJhZGQiLCJ0b0FmZmluZSIsImlzMCIsImVycm9yIiwic2Nobm9yciIsInNpemUiLCJzZWVkTGVuZ3RoIiwicmFuZG9tU2VjcmV0S2V5Iiwic2VlZCIsInV0aWxzIiwia2V5Z2VuIiwiZ2V0UHVibGljS2V5Iiwic2lnbiIsInZlcmlmeSIsInJhbmRvbVByaXZhdGVLZXkiLCJpbmZvIiwidHlwZSIsInB1YmxpY0tleUhhc1ByZWZpeCIsImxlbmd0aHMiLCJzZWNyZXQiLCJwdWJsaWMiLCJpc29NYXAiLCJtYXAiLCJpIiwiaiIsIm1hcFNXVSIsIkEiLCJCIiwiWiIsImNyZWF0ZSIsInNlY3AyNTZrMV9oYXNoZXIiLCJzY2FsYXJzIiwiRFNUIiwiZW5jb2RlRFNUIiwiT1JERVIiLCJleHBhbmQiLCJoYXNoIiwiaGFzaFRvQ3VydmUiLCJlbmNvZGVUb0N1cnZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _validateObject: () => (/* binding */ _validateObject),\n/* harmony export */   aInRange: () => (/* binding */ aInRange),\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes),\n/* harmony export */   anumber: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   bytesToUtf8: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToUtf8),\n/* harmony export */   concatBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes),\n/* harmony export */   isHash: () => (/* binding */ isHash),\n/* harmony export */   memoized: () => (/* binding */ memoized),\n/* harmony export */   notImplemented: () => (/* binding */ notImplemented),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   randomBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.randomBytes),\n/* harmony export */   utf8ToBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Hex, bytes and number utilities.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction abool(title, value) {\n    if (typeof value !== \"boolean\") throw new Error(title + \" boolean expected, got \" + value);\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? \"0\" + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    return hex === \"\" ? _0n : BigInt(\"0x\" + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(bytes);\n    return hexToNumber((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex);\n        } catch (e) {\n            throw new Error(title + \" must be hex string or Uint8Array, cause: \" + e);\n        }\n    } else if ((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(title + \" must be hex string or Uint8Array\");\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(title + \" of length \" + expectedLength + \" expected, got \" + len);\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ // export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */ // export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n)=>typeof n === \"bigint\" && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */ function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max)) throw new Error(\"expected valid \" + title + \": \" + min + \" <= n < \" + max + \", got \" + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ function bitSet(n, pos, value) {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len)=>new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte)=>Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0))=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(\"invalid validator function\");\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(\"param \" + String(fieldName) + \" is invalid. Expected \" + type + \", got \" + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nfunction isHash(val) {\n    return typeof val === \"function\" && Number.isSafeInteger(val.outputLen);\n}\nfunction _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== \"object\") throw new Error(\"expected valid options object\");\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined) return;\n        const current = typeof val;\n        if (current !== expectedType || val === null) throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v])=>checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v])=>checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */ const notImplemented = ()=>{\n    throw new Error(\"not implemented\");\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */ function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args)=>{\n        const val = map.get(arg);\n        if (val !== undefined) return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUNELG9FQUFvRSxHQUNnRztBQUNyQjtBQUMvSSxNQUFNYyxNQUFNLGFBQWEsR0FBR0MsT0FBTztBQUNuQyxNQUFNQyxNQUFNLGFBQWEsR0FBR0QsT0FBTztBQUM1QixTQUFTRSxNQUFNQyxLQUFLLEVBQUVDLEtBQUs7SUFDOUIsSUFBSSxPQUFPQSxVQUFVLFdBQ2pCLE1BQU0sSUFBSUMsTUFBTUYsUUFBUSw0QkFBNEJDO0FBQzVEO0FBQ0EsMkJBQTJCO0FBQ3BCLFNBQVNFLG9CQUFvQkMsR0FBRztJQUNuQyxNQUFNQyxNQUFNRCxJQUFJRSxRQUFRLENBQUM7SUFDekIsT0FBT0QsSUFBSUUsTUFBTSxHQUFHLElBQUksTUFBTUYsTUFBTUE7QUFDeEM7QUFDTyxTQUFTRyxZQUFZSCxHQUFHO0lBQzNCLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU0sSUFBSUgsTUFBTSw4QkFBOEIsT0FBT0c7SUFDekQsT0FBT0EsUUFBUSxLQUFLVCxNQUFNQyxPQUFPLE9BQU9RLE1BQU0sYUFBYTtBQUMvRDtBQUNBLG9DQUFvQztBQUM3QixTQUFTSSxnQkFBZ0JDLEtBQUs7SUFDakMsT0FBT0YsWUFBWXZCLGtFQUFXQSxDQUFDeUI7QUFDbkM7QUFDTyxTQUFTQyxnQkFBZ0JELEtBQUs7SUFDakMzQiw4REFBT0EsQ0FBQzJCO0lBQ1IsT0FBT0YsWUFBWXZCLGtFQUFXQSxDQUFDMkIsV0FBV0MsSUFBSSxDQUFDSCxPQUFPSSxPQUFPO0FBQ2pFO0FBQ08sU0FBU0MsZ0JBQWdCQyxDQUFDLEVBQUVDLEdBQUc7SUFDbEMsT0FBTzVCLGtFQUFXQSxDQUFDMkIsRUFBRVYsUUFBUSxDQUFDLElBQUlZLFFBQVEsQ0FBQ0QsTUFBTSxHQUFHO0FBQ3hE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TSxDQUFDLE9BQU8sRUFBRW1GLFVBQVUsdUJBQXVCLEVBQUVXLGFBQWEsTUFBTSxFQUFFRSxRQUFRLENBQUM7SUFDbkc7SUFDQVIsT0FBT0MsT0FBTyxDQUFDRyxRQUFRSyxPQUFPLENBQUMsQ0FBQyxDQUFDbEQsR0FBR0QsRUFBRSxHQUFLb0MsV0FBV25DLEdBQUdELEdBQUc7SUFDNUQwQyxPQUFPQyxPQUFPLENBQUNJLFdBQVdJLE9BQU8sQ0FBQyxDQUFDLENBQUNsRCxHQUFHRCxFQUFFLEdBQUtvQyxXQUFXbkMsR0FBR0QsR0FBRztBQUNuRTtBQUNBOztDQUVDLEdBQ00sTUFBTW9ELGlCQUFpQjtJQUMxQixNQUFNLElBQUlsRyxNQUFNO0FBQ3BCLEVBQUU7QUFDRjs7O0NBR0MsR0FDTSxTQUFTbUcsU0FBU0MsRUFBRTtJQUN2QixNQUFNQyxNQUFNLElBQUlDO0lBQ2hCLE9BQU8sQ0FBQ0MsS0FBSyxHQUFHQztRQUNaLE1BQU16QyxNQUFNc0MsSUFBSUksR0FBRyxDQUFDRjtRQUNwQixJQUFJeEMsUUFBUUgsV0FDUixPQUFPRztRQUNYLE1BQU0yQyxXQUFXTixHQUFHRyxRQUFRQztRQUM1QkgsSUFBSU0sR0FBRyxDQUFDSixLQUFLRztRQUNiLE9BQU9BO0lBQ1g7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vdXRpbHMuanM/M2MwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhleCwgYnl0ZXMgYW5kIG51bWJlciB1dGlsaXRpZXMuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGFieXRlcyBhcyBhYnl0ZXNfLCBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXhfLCBjb25jYXRCeXRlcyBhcyBjb25jYXRCeXRlc18sIGhleFRvQnl0ZXMgYXMgaGV4VG9CeXRlc18sIGlzQnl0ZXMgYXMgaXNCeXRlc18sIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscy5qcyc7XG5leHBvcnQgeyBhYnl0ZXMsIGFudW1iZXIsIGJ5dGVzVG9IZXgsIGJ5dGVzVG9VdGY4LCBjb25jYXRCeXRlcywgaGV4VG9CeXRlcywgaXNCeXRlcywgcmFuZG9tQnl0ZXMsIHV0ZjhUb0J5dGVzLCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5leHBvcnQgZnVuY3Rpb24gYWJvb2wodGl0bGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIGJvb2xlYW4gZXhwZWN0ZWQsIGdvdCAnICsgdmFsdWUpO1xufVxuLy8gVXNlZCBpbiB3ZWllcnN0cmFzcywgZGVyXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/ICcwJyArIGhleCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICByZXR1cm4gaGV4ID09PSAnJyA/IF8wbiA6IEJpZ0ludCgnMHgnICsgaGV4KTsgLy8gQmlnIEVuZGlhblxufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXhfKGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgYWJ5dGVzXyhieXRlcyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXhfKFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzXyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXNfKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdzZWNyZXQga2V5J1xuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBvcHRpb25hbCwgd2lsbCBjb21wYXJlIHRvIHJlc3VsdCBhcnJheSdzIGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXNfKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNhdXNlOiAnICsgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCeXRlc18oaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBvZiBsZW5ndGggJyArIGV4cGVjdGVkTGVuZ3RoICsgJyBleHBlY3RlZCwgZ290ICcgKyBsZW4pO1xuICAgIHJldHVybiByZXM7XG59XG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuLy8gZXhwb3J0IGNvbnN0IHV0ZjhUb0J5dGVzOiB0eXBlb2YgdXRmOFRvQnl0ZXNfID0gdXRmOFRvQnl0ZXNfO1xuLyoqXG4gKiBDb252ZXJ0cyBieXRlcyB0byBzdHJpbmcgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIGJ5dGVzVG9VdGY4KFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pKSAvLyAnYWJjJ1xuICovXG4vLyBleHBvcnQgY29uc3QgYnl0ZXNUb1V0Zjg6IHR5cGVvZiBieXRlc1RvVXRmOF8gPSBieXRlc1RvVXRmOF87XG4vLyBJcyBwb3NpdGl2ZSBiaWdpbnRcbmNvbnN0IGlzUG9zQmlnID0gKG4pID0+IHR5cGVvZiBuID09PSAnYmlnaW50JyAmJiBfMG4gPD0gbjtcbmV4cG9ydCBmdW5jdGlvbiBpblJhbmdlKG4sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGlzUG9zQmlnKG4pICYmIGlzUG9zQmlnKG1pbikgJiYgaXNQb3NCaWcobWF4KSAmJiBtaW4gPD0gbiAmJiBuIDwgbWF4O1xufVxuLyoqXG4gKiBBc3NlcnRzIG1pbiA8PSBuIDwgbWF4LiBOT1RFOiBJdCdzIDwgbWF4IGFuZCBub3QgPD0gbWF4LlxuICogQGV4YW1wbGVcbiAqIGFJblJhbmdlKCd4JywgeCwgMW4sIDI1Nm4pOyAvLyB3b3VsZCBhc3N1bWUgeCBpcyBpbiAoMW4uLjI1NW4pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhSW5SYW5nZSh0aXRsZSwgbiwgbWluLCBtYXgpIHtcbiAgICAvLyBXaHkgbWluIDw9IG4gPCBtYXggYW5kIG5vdCBhIChtaW4gPCBuIDwgbWF4KSBPUiBiIChtaW4gPD0gbiA8PSBtYXgpP1xuICAgIC8vIGNvbnNpZGVyIFA9MjU2biwgbWluPTBuLCBtYXg9UFxuICAgIC8vIC0gYSBmb3IgbWluPTAgd291bGQgcmVxdWlyZSAtMTogICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAtMW4sIFApYFxuICAgIC8vIC0gYiB3b3VsZCBjb21tb25seSByZXF1aXJlIHN1YnRyYWN0aW9uOiAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUCAtIDFuKWBcbiAgICAvLyAtIG91ciB3YXkgaXMgdGhlIGNsZWFuZXN0OiAgICAgICAgICAgICAgIGBpblJhbmdlKCd4JywgeCwgMG4sIFApXG4gICAgaWYgKCFpblJhbmdlKG4sIG1pbiwgbWF4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YWxpZCAnICsgdGl0bGUgKyAnOiAnICsgbWluICsgJyA8PSBuIDwgJyArIG1heCArICcsIGdvdCAnICsgbik7XG59XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKiBUT0RPOiBtZXJnZSB3aXRoIG5MZW5ndGggaW4gbW9kdWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0U2V0KG4sIHBvcywgdmFsdWUpIHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuZXhwb3J0IGNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8xbiA8PCBCaWdJbnQobikpIC0gXzFuO1xuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBjb25zdCB1OG4gPSAobGVuKSA9PiBuZXcgVWludDhBcnJheShsZW4pOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbiAgICBjb25zdCB1OG9mID0gKGJ5dGUpID0+IFVpbnQ4QXJyYXkub2YoYnl0ZSk7IC8vIGFub3RoZXIgc2hvcnRjdXRcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigwKSkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgICAgICBrID0gaCh1OG9mKDB4MDApLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4b2YoMHgwMSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXNfKC4uLm91dCk7XG4gICAgfTtcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICByZXNlZWQoKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBnZW5VbnRpbDtcbn1cbi8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICAgIHN0cmluZ09yVWludDhBcnJheTogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgaXNCeXRlc18odmFsKSxcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxufTtcbi8vIHR5cGUgUmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIFQ+ID0geyBbUCBpbiBLXTogVDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFsaWRhdG9yIGZ1bmN0aW9uJyk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyYW0gJyArIFN0cmluZyhmaWVsZE5hbWUpICsgJyBpcyBpbnZhbGlkLiBFeHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgdmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbmV4cG9ydCBmdW5jdGlvbiBpc0hhc2godmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbik7XG59XG5leHBvcnQgZnVuY3Rpb24gX3ZhbGlkYXRlT2JqZWN0KG9iamVjdCwgZmllbGRzLCBvcHRGaWVsZHMgPSB7fSkge1xuICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkIG9wdGlvbnMgb2JqZWN0Jyk7XG4gICAgZnVuY3Rpb24gY2hlY2tGaWVsZChmaWVsZE5hbWUsIGV4cGVjdGVkVHlwZSwgaXNPcHQpIHtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHR5cGVvZiB2YWw7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBleHBlY3RlZFR5cGUgfHwgdmFsID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJhbSBcIiR7ZmllbGROYW1lfVwiIGlzIGludmFsaWQ6IGV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlfSwgZ290ICR7Y3VycmVudH1gKTtcbiAgICB9XG4gICAgT2JqZWN0LmVudHJpZXMoZmllbGRzKS5mb3JFYWNoKChbaywgdl0pID0+IGNoZWNrRmllbGQoaywgdiwgZmFsc2UpKTtcbiAgICBPYmplY3QuZW50cmllcyhvcHRGaWVsZHMpLmZvckVhY2goKFtrLCB2XSkgPT4gY2hlY2tGaWVsZChrLCB2LCB0cnVlKSk7XG59XG4vKipcbiAqIHRocm93cyBub3QgaW1wbGVtZW50ZWQgZXJyb3JcbiAqL1xuZXhwb3J0IGNvbnN0IG5vdEltcGxlbWVudGVkID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuLyoqXG4gKiBNZW1vaXplcyAoY2FjaGVzKSBjb21wdXRhdGlvbiByZXN1bHQuXG4gKiBVc2VzIFdlYWtNYXA6IHRoZSB2YWx1ZSBpcyBnb2luZyBhdXRvLWNsZWFuZWQgYnkgR0MgYWZ0ZXIgbGFzdCByZWZlcmVuY2UgaXMgcmVtb3ZlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemVkKGZuKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICByZXR1cm4gKGFyZywgLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBtYXAuZ2V0KGFyZyk7XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gZm4oYXJnLCAuLi5hcmdzKTtcbiAgICAgICAgbWFwLnNldChhcmcsIGNvbXB1dGVkKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiYWJ5dGVzIiwiYWJ5dGVzXyIsImJ5dGVzVG9IZXgiLCJieXRlc1RvSGV4XyIsImNvbmNhdEJ5dGVzIiwiY29uY2F0Qnl0ZXNfIiwiaGV4VG9CeXRlcyIsImhleFRvQnl0ZXNfIiwiaXNCeXRlcyIsImlzQnl0ZXNfIiwiYW51bWJlciIsImJ5dGVzVG9VdGY4IiwicmFuZG9tQnl0ZXMiLCJ1dGY4VG9CeXRlcyIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsImFib29sIiwidGl0bGUiLCJ2YWx1ZSIsIkVycm9yIiwibnVtYmVyVG9IZXhVbnBhZGRlZCIsIm51bSIsImhleCIsInRvU3RyaW5nIiwibGVuZ3RoIiwiaGV4VG9OdW1iZXIiLCJieXRlc1RvTnVtYmVyQkUiLCJieXRlcyIsImJ5dGVzVG9OdW1iZXJMRSIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwicmV2ZXJzZSIsIm51bWJlclRvQnl0ZXNCRSIsIm4iLCJsZW4iLCJwYWRTdGFydCIsIm51bWJlclRvQnl0ZXNMRSIsIm51bWJlclRvVmFyQnl0ZXNCRSIsImVuc3VyZUJ5dGVzIiwiZXhwZWN0ZWRMZW5ndGgiLCJyZXMiLCJlIiwiZXF1YWxCeXRlcyIsImEiLCJiIiwiZGlmZiIsImkiLCJpc1Bvc0JpZyIsImluUmFuZ2UiLCJtaW4iLCJtYXgiLCJhSW5SYW5nZSIsImJpdExlbiIsImJpdEdldCIsInBvcyIsImJpdFNldCIsImJpdE1hc2siLCJjcmVhdGVIbWFjRHJiZyIsImhhc2hMZW4iLCJxQnl0ZUxlbiIsImhtYWNGbiIsInU4biIsInU4b2YiLCJieXRlIiwib2YiLCJ2IiwiayIsInJlc2V0IiwiZmlsbCIsImgiLCJyZXNlZWQiLCJzZWVkIiwiZ2VuIiwib3V0Iiwic2wiLCJzbGljZSIsInB1c2giLCJnZW5VbnRpbCIsInByZWQiLCJ1bmRlZmluZWQiLCJ2YWxpZGF0b3JGbnMiLCJiaWdpbnQiLCJ2YWwiLCJmdW5jdGlvbiIsImJvb2xlYW4iLCJzdHJpbmciLCJzdHJpbmdPclVpbnQ4QXJyYXkiLCJpc1NhZmVJbnRlZ2VyIiwiTnVtYmVyIiwiYXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJmaWVsZCIsIm9iamVjdCIsIkZwIiwiaXNWYWxpZCIsImhhc2giLCJvdXRwdXRMZW4iLCJ2YWxpZGF0ZU9iamVjdCIsInZhbGlkYXRvcnMiLCJvcHRWYWxpZGF0b3JzIiwiY2hlY2tGaWVsZCIsImZpZWxkTmFtZSIsInR5cGUiLCJpc09wdGlvbmFsIiwiY2hlY2tWYWwiLCJTdHJpbmciLCJPYmplY3QiLCJlbnRyaWVzIiwiaXNIYXNoIiwiX3ZhbGlkYXRlT2JqZWN0IiwiZmllbGRzIiwib3B0RmllbGRzIiwiZXhwZWN0ZWRUeXBlIiwiaXNPcHQiLCJjdXJyZW50IiwiZm9yRWFjaCIsIm5vdEltcGxlbWVudGVkIiwibWVtb2l6ZWQiLCJmbiIsIm1hcCIsIldlYWtNYXAiLCJhcmciLCJhcmdzIiwiZ2V0IiwiY29tcHV0ZWQiLCJzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\n");

/***/ })

};
;