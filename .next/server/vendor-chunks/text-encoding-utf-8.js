"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/text-encoding-utf-8";
exports.ids = ["vendor-chunks/text-encoding-utf-8"];
exports.modules = {

/***/ "(ssr)/./node_modules/text-encoding-utf-8/lib/encoding.lib.js":
/*!**************************************************************!*\
  !*** ./node_modules/text-encoding-utf-8/lib/encoding.lib.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n//\n// Utilities\n//\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */ function inRange(a, min, max) {\n    return min <= a && a <= max;\n}\n/**\n * @param {*} o\n * @return {Object}\n */ function ToDictionary(o) {\n    if (o === undefined) return {};\n    if (o === Object(o)) return o;\n    throw TypeError(\"Could not convert argument to dictionary\");\n}\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */ function stringToCodePoints(string) {\n    // https://heycam.github.io/webidl/#dfn-obtain-unicode\n    // 1. Let S be the DOMString value.\n    var s = String(string);\n    // 2. Let n be the length of S.\n    var n = s.length;\n    // 3. Initialize i to 0.\n    var i = 0;\n    // 4. Initialize U to be an empty sequence of Unicode characters.\n    var u = [];\n    // 5. While i < n:\n    while(i < n){\n        // 1. Let c be the code unit in S at index i.\n        var c = s.charCodeAt(i);\n        // 2. Depending on the value of c:\n        // c < 0xD800 or c > 0xDFFF\n        if (c < 0xD800 || c > 0xDFFF) {\n            // Append to U the Unicode character with code point c.\n            u.push(c);\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\n            // Append to U a U+FFFD REPLACEMENT CHARACTER.\n            u.push(0xFFFD);\n        } else if (0xD800 <= c && c <= 0xDBFF) {\n            // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n            // CHARACTER.\n            if (i === n - 1) {\n                u.push(0xFFFD);\n            } else {\n                // 1. Let d be the code unit in S at index i+1.\n                var d = string.charCodeAt(i + 1);\n                // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n                if (0xDC00 <= d && d <= 0xDFFF) {\n                    // 1. Let a be c & 0x3FF.\n                    var a = c & 0x3FF;\n                    // 2. Let b be d & 0x3FF.\n                    var b = d & 0x3FF;\n                    // 3. Append to U the Unicode character with code point\n                    // 2^16+2^10*a+b.\n                    u.push(0x10000 + (a << 10) + b);\n                    // 4. Set i to i+1.\n                    i += 1;\n                } else {\n                    u.push(0xFFFD);\n                }\n            }\n        }\n        // 3. Set i to i+1.\n        i += 1;\n    }\n    // 6. Return U.\n    return u;\n}\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */ function codePointsToString(code_points) {\n    var s = \"\";\n    for(var i = 0; i < code_points.length; ++i){\n        var cp = code_points[i];\n        if (cp <= 0xFFFF) {\n            s += String.fromCharCode(cp);\n        } else {\n            cp -= 0x10000;\n            s += String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);\n        }\n    }\n    return s;\n}\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n//\n// 3. Terminology\n//\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */ var end_of_stream = -1;\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the\n * stream.\n */ function Stream(tokens) {\n    /** @type {!Array.<number>} */ this.tokens = [].slice.call(tokens);\n}\nStream.prototype = {\n    /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */ endOfStream: function() {\n        return !this.tokens.length;\n    },\n    /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */ read: function() {\n        if (!this.tokens.length) return end_of_stream;\n        return this.tokens.shift();\n    },\n    /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.\n   */ prepend: function(token) {\n        if (Array.isArray(token)) {\n            var tokens = /**@type {!Array.<number>}*/ token;\n            while(tokens.length)this.tokens.unshift(tokens.pop());\n        } else {\n            this.tokens.unshift(token);\n        }\n    },\n    /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.\n   */ push: function(token) {\n        if (Array.isArray(token)) {\n            var tokens = /**@type {!Array.<number>}*/ token;\n            while(tokens.length)this.tokens.push(tokens.shift());\n        } else {\n            this.tokens.push(token);\n        }\n    }\n};\n//\n// 4. Encodings\n//\n// 4.1 Encoders and decoders\n/** @const */ var finished = -1;\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */ function decoderError(fatal, opt_code_point) {\n    if (fatal) throw TypeError(\"Decoder error\");\n    return opt_code_point || 0xFFFD;\n}\n//\n// 7. API\n//\n/** @const */ var DEFAULT_ENCODING = \"utf-8\";\n// 7.1 Interface TextDecoder\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */ function TextDecoder(encoding, options) {\n    if (!(this instanceof TextDecoder)) {\n        return new TextDecoder(encoding, options);\n    }\n    encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n    if (encoding !== DEFAULT_ENCODING) {\n        throw new Error(\"Encoding not supported. Only utf-8 is supported\");\n    }\n    options = ToDictionary(options);\n    /** @private @type {boolean} */ this._streaming = false;\n    /** @private @type {boolean} */ this._BOMseen = false;\n    /** @private @type {?Decoder} */ this._decoder = null;\n    /** @private @type {boolean} */ this._fatal = Boolean(options[\"fatal\"]);\n    /** @private @type {boolean} */ this._ignoreBOM = Boolean(options[\"ignoreBOM\"]);\n    Object.defineProperty(this, \"encoding\", {\n        value: \"utf-8\"\n    });\n    Object.defineProperty(this, \"fatal\", {\n        value: this._fatal\n    });\n    Object.defineProperty(this, \"ignoreBOM\", {\n        value: this._ignoreBOM\n    });\n}\nTextDecoder.prototype = {\n    /**\n   * @param {ArrayBufferView=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */ decode: function decode(input, options) {\n        var bytes;\n        if (typeof input === \"object\" && input instanceof ArrayBuffer) {\n            bytes = new Uint8Array(input);\n        } else if (typeof input === \"object\" && \"buffer\" in input && input.buffer instanceof ArrayBuffer) {\n            bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);\n        } else {\n            bytes = new Uint8Array(0);\n        }\n        options = ToDictionary(options);\n        if (!this._streaming) {\n            this._decoder = new UTF8Decoder({\n                fatal: this._fatal\n            });\n            this._BOMseen = false;\n        }\n        this._streaming = Boolean(options[\"stream\"]);\n        var input_stream = new Stream(bytes);\n        var code_points = [];\n        /** @type {?(number|!Array.<number>)} */ var result;\n        while(!input_stream.endOfStream()){\n            result = this._decoder.handler(input_stream, input_stream.read());\n            if (result === finished) break;\n            if (result === null) continue;\n            if (Array.isArray(result)) code_points.push.apply(code_points, /**@type {!Array.<number>}*/ result);\n            else code_points.push(result);\n        }\n        if (!this._streaming) {\n            do {\n                result = this._decoder.handler(input_stream, input_stream.read());\n                if (result === finished) break;\n                if (result === null) continue;\n                if (Array.isArray(result)) code_points.push.apply(code_points, /**@type {!Array.<number>}*/ result);\n                else code_points.push(result);\n            }while (!input_stream.endOfStream());\n            this._decoder = null;\n        }\n        if (code_points.length) {\n            // If encoding is one of utf-8, utf-16be, and utf-16le, and\n            // ignore BOM flag and BOM seen flag are unset, run these\n            // subsubsteps:\n            if ([\n                \"utf-8\"\n            ].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {\n                // If token is U+FEFF, set BOM seen flag.\n                if (code_points[0] === 0xFEFF) {\n                    this._BOMseen = true;\n                    code_points.shift();\n                } else {\n                    // Otherwise, if token is not end-of-stream, set BOM seen\n                    // flag and append token to output.\n                    this._BOMseen = true;\n                }\n            }\n        }\n        return codePointsToString(code_points);\n    }\n};\n// 7.2 Interface TextEncoder\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */ function TextEncoder(encoding, options) {\n    if (!(this instanceof TextEncoder)) return new TextEncoder(encoding, options);\n    encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n    if (encoding !== DEFAULT_ENCODING) {\n        throw new Error(\"Encoding not supported. Only utf-8 is supported\");\n    }\n    options = ToDictionary(options);\n    /** @private @type {boolean} */ this._streaming = false;\n    /** @private @type {?Encoder} */ this._encoder = null;\n    /** @private @type {{fatal: boolean}} */ this._options = {\n        fatal: Boolean(options[\"fatal\"])\n    };\n    Object.defineProperty(this, \"encoding\", {\n        value: \"utf-8\"\n    });\n}\nTextEncoder.prototype = {\n    /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {Uint8Array} Encoded bytes, as a Uint8Array.\n   */ encode: function encode(opt_string, options) {\n        opt_string = opt_string ? String(opt_string) : \"\";\n        options = ToDictionary(options);\n        // NOTE: This option is nonstandard. None of the encodings\n        // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,\n        // so streaming is not necessary.\n        if (!this._streaming) this._encoder = new UTF8Encoder(this._options);\n        this._streaming = Boolean(options[\"stream\"]);\n        var bytes = [];\n        var input_stream = new Stream(stringToCodePoints(opt_string));\n        /** @type {?(number|!Array.<number>)} */ var result;\n        while(!input_stream.endOfStream()){\n            result = this._encoder.handler(input_stream, input_stream.read());\n            if (result === finished) break;\n            if (Array.isArray(result)) bytes.push.apply(bytes, /**@type {!Array.<number>}*/ result);\n            else bytes.push(result);\n        }\n        if (!this._streaming) {\n            while(true){\n                result = this._encoder.handler(input_stream, input_stream.read());\n                if (result === finished) break;\n                if (Array.isArray(result)) bytes.push.apply(bytes, /**@type {!Array.<number>}*/ result);\n                else bytes.push(result);\n            }\n            this._encoder = null;\n        }\n        return new Uint8Array(bytes);\n    }\n};\n//\n// 8. The encoding\n//\n// 8.1 utf-8\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */ function UTF8Decoder(options) {\n    var fatal = options.fatal;\n    // utf-8's decoder's has an associated utf-8 code point, utf-8\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\n    // (initially 0xBF).\n    var /** @type {number} */ utf8_code_point = 0, /** @type {number} */ utf8_bytes_seen = 0, /** @type {number} */ utf8_bytes_needed = 0, /** @type {number} */ utf8_lower_boundary = 0x80, /** @type {number} */ utf8_upper_boundary = 0xBF;\n    /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */ this.handler = function(stream, bite) {\n        // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n        // set utf-8 bytes needed to 0 and return error.\n        if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n            utf8_bytes_needed = 0;\n            return decoderError(fatal);\n        }\n        // 2. If byte is end-of-stream, return finished.\n        if (bite === end_of_stream) return finished;\n        // 3. If utf-8 bytes needed is 0, based on byte:\n        if (utf8_bytes_needed === 0) {\n            // 0x00 to 0x7F\n            if (inRange(bite, 0x00, 0x7F)) {\n                // Return a code point whose value is byte.\n                return bite;\n            }\n            // 0xC2 to 0xDF\n            if (inRange(bite, 0xC2, 0xDF)) {\n                // Set utf-8 bytes needed to 1 and utf-8 code point to byte\n                // − 0xC0.\n                utf8_bytes_needed = 1;\n                utf8_code_point = bite - 0xC0;\n            } else if (inRange(bite, 0xE0, 0xEF)) {\n                // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n                if (bite === 0xE0) utf8_lower_boundary = 0xA0;\n                // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n                if (bite === 0xED) utf8_upper_boundary = 0x9F;\n                // 3. Set utf-8 bytes needed to 2 and utf-8 code point to\n                // byte − 0xE0.\n                utf8_bytes_needed = 2;\n                utf8_code_point = bite - 0xE0;\n            } else if (inRange(bite, 0xF0, 0xF4)) {\n                // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n                if (bite === 0xF0) utf8_lower_boundary = 0x90;\n                // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n                if (bite === 0xF4) utf8_upper_boundary = 0x8F;\n                // 3. Set utf-8 bytes needed to 3 and utf-8 code point to\n                // byte − 0xF0.\n                utf8_bytes_needed = 3;\n                utf8_code_point = bite - 0xF0;\n            } else {\n                // Return error.\n                return decoderError(fatal);\n            }\n            // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code\n            // point to utf-8 code point << (6 × utf-8 bytes needed) and\n            // return continue.\n            utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;\n            return null;\n        }\n        // 4. If byte is not in the range utf-8 lower boundary to utf-8\n        // upper boundary, run these substeps:\n        if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n            // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n            // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n            // utf-8 upper boundary to 0xBF.\n            utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n            utf8_lower_boundary = 0x80;\n            utf8_upper_boundary = 0xBF;\n            // 2. Prepend byte to stream.\n            stream.prepend(bite);\n            // 3. Return error.\n            return decoderError(fatal);\n        }\n        // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n        // to 0xBF.\n        utf8_lower_boundary = 0x80;\n        utf8_upper_boundary = 0xBF;\n        // 6. Increase utf-8 bytes seen by one and set utf-8 code point\n        // to utf-8 code point + (byte − 0x80) << (6 × (utf-8 bytes\n        // needed − utf-8 bytes seen)).\n        utf8_bytes_seen += 1;\n        utf8_code_point += bite - 0x80 << 6 * (utf8_bytes_needed - utf8_bytes_seen);\n        // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n        // continue.\n        if (utf8_bytes_seen !== utf8_bytes_needed) return null;\n        // 8. Let code point be utf-8 code point.\n        var code_point = utf8_code_point;\n        // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n        // seen to 0.\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n        // 10. Return a code point whose value is code point.\n        return code_point;\n    };\n}\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */ function UTF8Encoder(options) {\n    var fatal = options.fatal;\n    /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */ this.handler = function(stream, code_point) {\n        // 1. If code point is end-of-stream, return finished.\n        if (code_point === end_of_stream) return finished;\n        // 2. If code point is in the range U+0000 to U+007F, return a\n        // byte whose value is code point.\n        if (inRange(code_point, 0x0000, 0x007f)) return code_point;\n        // 3. Set count and offset based on the range code point is in:\n        var count, offset;\n        // U+0080 to U+07FF:    1 and 0xC0\n        if (inRange(code_point, 0x0080, 0x07FF)) {\n            count = 1;\n            offset = 0xC0;\n        } else if (inRange(code_point, 0x0800, 0xFFFF)) {\n            count = 2;\n            offset = 0xE0;\n        } else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n            count = 3;\n            offset = 0xF0;\n        }\n        // 4.Let bytes be a byte sequence whose first byte is (code\n        // point >> (6 × count)) + offset.\n        var bytes = [\n            (code_point >> 6 * count) + offset\n        ];\n        // 5. Run these substeps while count is greater than 0:\n        while(count > 0){\n            // 1. Set temp to code point >> (6 × (count − 1)).\n            var temp = code_point >> 6 * (count - 1);\n            // 2. Append to bytes 0x80 | (temp & 0x3F).\n            bytes.push(0x80 | temp & 0x3F);\n            // 3. Decrease count by one.\n            count -= 1;\n        }\n        // 6. Return bytes bytes, in order.\n        return bytes;\n    };\n}\nexports.TextEncoder = TextEncoder;\nexports.TextDecoder = TextDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGV4dC1lbmNvZGluZy11dGYtOC9saWIvZW5jb2RpbmcubGliLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsMEVBQTBFO0FBQzFFLHVDQUF1QztBQUV2QyxFQUFFO0FBQ0YsWUFBWTtBQUNaLEVBQUU7QUFFRjs7Ozs7Q0FLQyxHQUNELFNBQVNBLFFBQVFDLENBQUMsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQzFCLE9BQU9ELE9BQU9ELEtBQUtBLEtBQUtFO0FBQzFCO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0MsYUFBYUMsQ0FBQztJQUNyQixJQUFJQSxNQUFNQyxXQUFXLE9BQU8sQ0FBQztJQUM3QixJQUFJRCxNQUFNRSxPQUFPRixJQUFJLE9BQU9BO0lBQzVCLE1BQU1HLFVBQVU7QUFDbEI7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQyxtQkFBbUJDLE1BQU07SUFDaEMsc0RBQXNEO0lBRXRELG1DQUFtQztJQUNuQyxJQUFJQyxJQUFJQyxPQUFPRjtJQUVmLCtCQUErQjtJQUMvQixJQUFJRyxJQUFJRixFQUFFRyxNQUFNO0lBRWhCLHdCQUF3QjtJQUN4QixJQUFJQyxJQUFJO0lBRVIsaUVBQWlFO0lBQ2pFLElBQUlDLElBQUksRUFBRTtJQUVWLGtCQUFrQjtJQUNsQixNQUFPRCxJQUFJRixFQUFHO1FBRVosNkNBQTZDO1FBQzdDLElBQUlJLElBQUlOLEVBQUVPLFVBQVUsQ0FBQ0g7UUFFckIsa0NBQWtDO1FBRWxDLDJCQUEyQjtRQUMzQixJQUFJRSxJQUFJLFVBQVVBLElBQUksUUFBUTtZQUM1Qix1REFBdUQ7WUFDdkRELEVBQUVHLElBQUksQ0FBQ0Y7UUFDVCxPQUdLLElBQUksVUFBVUEsS0FBS0EsS0FBSyxRQUFRO1lBQ25DLDhDQUE4QztZQUM5Q0QsRUFBRUcsSUFBSSxDQUFDO1FBQ1QsT0FHSyxJQUFJLFVBQVVGLEtBQUtBLEtBQUssUUFBUTtZQUNuQyx1REFBdUQ7WUFDdkQsYUFBYTtZQUNiLElBQUlGLE1BQU1GLElBQUks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SUFBSUUsT0FBT0gsY0FBZSxJQUFLQyxDQUFBQSxRQUFRO1lBRXZDLDJDQUEyQztZQUMzQzFCLE1BQU0xQyxJQUFJLENBQUMsT0FBUXNFLE9BQU87WUFFMUIsNEJBQTRCO1lBQzVCRixTQUFTO1FBQ1g7UUFFQSxtQ0FBbUM7UUFDbkMsT0FBTzFCO0lBQ1Q7QUFDRjtBQUVBNkIsbUJBQW1CLEdBQUdqQjtBQUN0QmlCLG1CQUFtQixHQUFHNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy90ZXh0LWVuY29kaW5nLXV0Zi04L2xpYi9lbmNvZGluZy5saWIuanM/ZGZkYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgaXMgZnJlZSBhbmQgdW5lbmN1bWJlcmVkIHNvZnR3YXJlIHJlbGVhc2VkIGludG8gdGhlIHB1YmxpYyBkb21haW4uXG4vLyBTZWUgTElDRU5TRS5tZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuLy9cbi8vIFV0aWxpdGllc1xuLy9cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZSwgaW5jbHVzaXZlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UsIGluY2x1c2l2ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSA+PSBtaW4gYW5kIGEgPD0gbWF4LlxuICovXG5mdW5jdGlvbiBpblJhbmdlKGEsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBtaW4gPD0gYSAmJiBhIDw9IG1heDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gVG9EaWN0aW9uYXJ5KG8pIHtcbiAgaWYgKG8gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHt9O1xuICBpZiAobyA9PT0gT2JqZWN0KG8pKSByZXR1cm4gbztcbiAgdGhyb3cgVHlwZUVycm9yKCdDb3VsZCBub3QgY29udmVydCBhcmd1bWVudCB0byBkaWN0aW9uYXJ5Jyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBJbnB1dCBzdHJpbmcgb2YgVVRGLTE2IGNvZGUgdW5pdHMuXG4gKiBAcmV0dXJuIHshQXJyYXkuPG51bWJlcj59IENvZGUgcG9pbnRzLlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0NvZGVQb2ludHMoc3RyaW5nKSB7XG4gIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2Rmbi1vYnRhaW4tdW5pY29kZVxuXG4gIC8vIDEuIExldCBTIGJlIHRoZSBET01TdHJpbmcgdmFsdWUuXG4gIHZhciBzID0gU3RyaW5nKHN0cmluZyk7XG5cbiAgLy8gMi4gTGV0IG4gYmUgdGhlIGxlbmd0aCBvZiBTLlxuICB2YXIgbiA9IHMubGVuZ3RoO1xuXG4gIC8vIDMuIEluaXRpYWxpemUgaSB0byAwLlxuICB2YXIgaSA9IDA7XG5cbiAgLy8gNC4gSW5pdGlhbGl6ZSBVIHRvIGJlIGFuIGVtcHR5IHNlcXVlbmNlIG9mIFVuaWNvZGUgY2hhcmFjdGVycy5cbiAgdmFyIHUgPSBbXTtcblxuICAvLyA1LiBXaGlsZSBpIDwgbjpcbiAgd2hpbGUgKGkgPCBuKSB7XG5cbiAgICAvLyAxLiBMZXQgYyBiZSB0aGUgY29kZSB1bml0IGluIFMgYXQgaW5kZXggaS5cbiAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcblxuICAgIC8vIDIuIERlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgYzpcblxuICAgIC8vIGMgPCAweEQ4MDAgb3IgYyA+IDB4REZGRlxuICAgIGlmIChjIDwgMHhEODAwIHx8IGMgPiAweERGRkYpIHtcbiAgICAgIC8vIEFwcGVuZCB0byBVIHRoZSBVbmljb2RlIGNoYXJhY3RlciB3aXRoIGNvZGUgcG9pbnQgYy5cbiAgICAgIHUucHVzaChjKTtcbiAgICB9XG5cbiAgICAvLyAweERDMDAg4omkIGMg4omkIDB4REZGRlxuICAgIGVsc2UgaWYgKDB4REMwMCA8PSBjICYmIGMgPD0gMHhERkZGKSB7XG4gICAgICAvLyBBcHBlbmQgdG8gVSBhIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVIuXG4gICAgICB1LnB1c2goMHhGRkZEKTtcbiAgICB9XG5cbiAgICAvLyAweEQ4MDAg4omkIGMg4omkIDB4REJGRlxuICAgIGVsc2UgaWYgKDB4RDgwMCA8PSBjICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAvLyAxLiBJZiBpID0gbuKIkjEsIHRoZW4gYXBwZW5kIHRvIFUgYSBVK0ZGRkQgUkVQTEFDRU1FTlRcbiAgICAgIC8vIENIQVJBQ1RFUi5cbiAgICAgIGlmIChpID09PSBuIC0gMSkge1xuICAgICAgICB1LnB1c2goMHhGRkZEKTtcbiAgICAgIH1cbiAgICAgIC8vIDIuIE90aGVyd2lzZSwgaSA8IG7iiJIxOlxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIDEuIExldCBkIGJlIHRoZSBjb2RlIHVuaXQgaW4gUyBhdCBpbmRleCBpKzEuXG4gICAgICAgIHZhciBkID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xuXG4gICAgICAgIC8vIDIuIElmIDB4REMwMCDiiaQgZCDiiaQgMHhERkZGLCB0aGVuOlxuICAgICAgICBpZiAoMHhEQzAwIDw9IGQgJiYgZCA8PSAweERGRkYpIHtcbiAgICAgICAgICAvLyAxLiBMZXQgYSBiZSBjICYgMHgzRkYuXG4gICAgICAgICAgdmFyIGEgPSBjICYgMHgzRkY7XG5cbiAgICAgICAgICAvLyAyLiBMZXQgYiBiZSBkICYgMHgzRkYuXG4gICAgICAgICAgdmFyIGIgPSBkICYgMHgzRkY7XG5cbiAgICAgICAgICAvLyAzLiBBcHBlbmQgdG8gVSB0aGUgVW5pY29kZSBjaGFyYWN0ZXIgd2l0aCBjb2RlIHBvaW50XG4gICAgICAgICAgLy8gMl4xNisyXjEwKmErYi5cbiAgICAgICAgICB1LnB1c2goMHgxMDAwMCArIChhIDw8IDEwKSArIGIpO1xuXG4gICAgICAgICAgLy8gNC4gU2V0IGkgdG8gaSsxLlxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIE90aGVyd2lzZSwgZCA8IDB4REMwMCBvciBkID4gMHhERkZGLiBBcHBlbmQgdG8gVSBhXG4gICAgICAgIC8vIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVIuXG4gICAgICAgIGVsc2UgIHtcbiAgICAgICAgICB1LnB1c2goMHhGRkZEKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMuIFNldCBpIHRvIGkrMS5cbiAgICBpICs9IDE7XG4gIH1cblxuICAvLyA2LiBSZXR1cm4gVS5cbiAgcmV0dXJuIHU7XG59XG5cbi8qKlxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGNvZGVfcG9pbnRzIEFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIG9mIFVURi0xNiBjb2RlIHVuaXRzLlxuICovXG5mdW5jdGlvbiBjb2RlUG9pbnRzVG9TdHJpbmcoY29kZV9wb2ludHMpIHtcbiAgdmFyIHMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlX3BvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjcCA9IGNvZGVfcG9pbnRzW2ldO1xuICAgIGlmIChjcCA8PSAweEZGRkYpIHtcbiAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNwIC09IDB4MTAwMDA7XG4gICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNwID4+IDEwKSArIDB4RDgwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY3AgJiAweDNGRikgKyAweERDMDApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn1cblxuXG4vL1xuLy8gSW1wbGVtZW50YXRpb24gb2YgRW5jb2Rpbmcgc3BlY2lmaWNhdGlvblxuLy8gaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvXG4vL1xuXG4vL1xuLy8gMy4gVGVybWlub2xvZ3lcbi8vXG5cbi8qKlxuICogRW5kLW9mLXN0cmVhbSBpcyBhIHNwZWNpYWwgdG9rZW4gdGhhdCBzaWduaWZpZXMgbm8gbW9yZSB0b2tlbnNcbiAqIGFyZSBpbiB0aGUgc3RyZWFtLlxuICogQGNvbnN0XG4gKi8gdmFyIGVuZF9vZl9zdHJlYW0gPSAtMTtcblxuLyoqXG4gKiBBIHN0cmVhbSByZXByZXNlbnRzIGFuIG9yZGVyZWQgc2VxdWVuY2Ugb2YgdG9rZW5zLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSB0b2tlbnMgQXJyYXkgb2YgdG9rZW5zIHRoYXQgcHJvdmlkZSB0aGVcbiAqIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gU3RyZWFtKHRva2Vucykge1xuICAvKiogQHR5cGUgeyFBcnJheS48bnVtYmVyPn0gKi9cbiAgdGhpcy50b2tlbnMgPSBbXS5zbGljZS5jYWxsKHRva2Vucyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGVuZC1vZi1zdHJlYW0gaGFzIGJlZW4gaGl0LlxuICAgKi9cbiAgZW5kT2ZTdHJlYW06IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy50b2tlbnMubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIGEgdG9rZW4gaXMgcmVhZCBmcm9tIGEgc3RyZWFtLCB0aGUgZmlyc3QgdG9rZW4gaW4gdGhlXG4gICAqIHN0cmVhbSBtdXN0IGJlIHJldHVybmVkIGFuZCBzdWJzZXF1ZW50bHkgcmVtb3ZlZCwgYW5kXG4gICAqIGVuZC1vZi1zdHJlYW0gbXVzdCBiZSByZXR1cm5lZCBvdGhlcndpc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gR2V0IHRoZSBuZXh0IHRva2VuIGZyb20gdGhlIHN0cmVhbSwgb3JcbiAgICogZW5kX29mX3N0cmVhbS5cbiAgICovXG4gICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMudG9rZW5zLmxlbmd0aClcbiAgICAgIHJldHVybiBlbmRfb2Zfc3RyZWFtO1xuICAgICByZXR1cm4gdGhpcy50b2tlbnMuc2hpZnQoKTtcbiAgIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gb25lIG9yIG1vcmUgdG9rZW5zIGFyZSBwcmVwZW5kZWQgdG8gYSBzdHJlYW0sIHRob3NlIHRva2Vuc1xuICAgKiBtdXN0IGJlIGluc2VydGVkLCBpbiBnaXZlbiBvcmRlciwgYmVmb3JlIHRoZSBmaXJzdCB0b2tlbiBpbiB0aGVcbiAgICogc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0geyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gdG9rZW4gVGhlIHRva2VuKHMpIHRvIHByZXBlbmQgdG8gdGhlIHN0cmVhbS5cbiAgICovXG4gIHByZXBlbmQ6IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICB2YXIgdG9rZW5zID0gLyoqQHR5cGUgeyFBcnJheS48bnVtYmVyPn0qLyh0b2tlbik7XG4gICAgICB3aGlsZSAodG9rZW5zLmxlbmd0aClcbiAgICAgICAgdGhpcy50b2tlbnMudW5zaGlmdCh0b2tlbnMucG9wKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRva2Vucy51bnNoaWZ0KHRva2VuKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gb25lIG9yIG1vcmUgdG9rZW5zIGFyZSBwdXNoZWQgdG8gYSBzdHJlYW0sIHRob3NlIHRva2Vuc1xuICAgKiBtdXN0IGJlIGluc2VydGVkLCBpbiBnaXZlbiBvcmRlciwgYWZ0ZXIgdGhlIGxhc3QgdG9rZW4gaW4gdGhlXG4gICAqIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHsobnVtYmVyfCFBcnJheS48bnVtYmVyPil9IHRva2VuIFRoZSB0b2tlbnMocykgdG8gcHJlcGVuZCB0byB0aGUgc3RyZWFtLlxuICAgKi9cbiAgcHVzaDogZnVuY3Rpb24odG9rZW4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbikpIHtcbiAgICAgIHZhciB0b2tlbnMgPSAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovKHRva2VuKTtcbiAgICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKVxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRva2Vucy5zaGlmdCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfVxuICB9XG59O1xuXG4vL1xuLy8gNC4gRW5jb2RpbmdzXG4vL1xuXG4vLyA0LjEgRW5jb2RlcnMgYW5kIGRlY29kZXJzXG5cbi8qKiBAY29uc3QgKi9cbnZhciBmaW5pc2hlZCA9IC0xO1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZmF0YWwgSWYgdHJ1ZSwgZGVjb2RpbmcgZXJyb3JzIHJhaXNlIGFuIGV4Y2VwdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2NvZGVfcG9pbnQgT3ZlcnJpZGUgdGhlIHN0YW5kYXJkIGZhbGxiYWNrIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjb2RlIHBvaW50IHRvIGluc2VydCBvbiBhIGRlY29kaW5nIGVycm9yLlxuICovXG5mdW5jdGlvbiBkZWNvZGVyRXJyb3IoZmF0YWwsIG9wdF9jb2RlX3BvaW50KSB7XG4gIGlmIChmYXRhbClcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0RlY29kZXIgZXJyb3InKTtcbiAgcmV0dXJuIG9wdF9jb2RlX3BvaW50IHx8IDB4RkZGRDtcbn1cblxuLy9cbi8vIDcuIEFQSVxuLy9cblxuLyoqIEBjb25zdCAqLyB2YXIgREVGQVVMVF9FTkNPRElORyA9ICd1dGYtOCc7XG5cbi8vIDcuMSBJbnRlcmZhY2UgVGV4dERlY29kZXJcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nPX0gZW5jb2RpbmcgVGhlIGxhYmVsIG9mIHRoZSBlbmNvZGluZztcbiAqICAgICBkZWZhdWx0cyB0byAndXRmLTgnLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFRleHREZWNvZGVyKGVuY29kaW5nLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUZXh0RGVjb2RlcikpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCBvcHRpb25zKTtcbiAgfVxuICBlbmNvZGluZyA9IGVuY29kaW5nICE9PSB1bmRlZmluZWQgPyBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkgOiBERUZBVUxUX0VOQ09ESU5HO1xuICBpZiAoZW5jb2RpbmcgIT09IERFRkFVTFRfRU5DT0RJTkcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kaW5nIG5vdCBzdXBwb3J0ZWQuIE9ubHkgdXRmLTggaXMgc3VwcG9ydGVkJyk7XG4gIH1cbiAgb3B0aW9ucyA9IFRvRGljdGlvbmFyeShvcHRpb25zKTtcblxuICAvKiogQHByaXZhdGUgQHR5cGUge2Jvb2xlYW59ICovXG4gIHRoaXMuX3N0cmVhbWluZyA9IGZhbHNlO1xuICAvKiogQHByaXZhdGUgQHR5cGUge2Jvb2xlYW59ICovXG4gIHRoaXMuX0JPTXNlZW4gPSBmYWxzZTtcbiAgLyoqIEBwcml2YXRlIEB0eXBlIHs/RGVjb2Rlcn0gKi9cbiAgdGhpcy5fZGVjb2RlciA9IG51bGw7XG4gIC8qKiBAcHJpdmF0ZSBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgdGhpcy5fZmF0YWwgPSBCb29sZWFuKG9wdGlvbnNbJ2ZhdGFsJ10pO1xuICAvKiogQHByaXZhdGUgQHR5cGUge2Jvb2xlYW59ICovXG4gIHRoaXMuX2lnbm9yZUJPTSA9IEJvb2xlYW4ob3B0aW9uc1snaWdub3JlQk9NJ10pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZW5jb2RpbmcnLCB7dmFsdWU6ICd1dGYtOCd9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdmYXRhbCcsIHt2YWx1ZTogdGhpcy5fZmF0YWx9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZ25vcmVCT00nLCB7dmFsdWU6IHRoaXMuX2lnbm9yZUJPTX0pO1xufVxuXG5UZXh0RGVjb2Rlci5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlldz19IGlucHV0IFRoZSBidWZmZXIgb2YgYnl0ZXMgdG8gZGVjb2RlLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gICAqL1xuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZShpbnB1dCwgb3B0aW9ucykge1xuICAgIHZhciBieXRlcztcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgJ2J1ZmZlcicgaW4gaW5wdXQgJiZcbiAgICAgICAgICAgICAgIGlucHV0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGlucHV0LmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IFRvRGljdGlvbmFyeShvcHRpb25zKTtcblxuICAgIGlmICghdGhpcy5fc3RyZWFtaW5nKSB7XG4gICAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFVURjhEZWNvZGVyKHtmYXRhbDogdGhpcy5fZmF0YWx9KTtcbiAgICAgIHRoaXMuX0JPTXNlZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fc3RyZWFtaW5nID0gQm9vbGVhbihvcHRpb25zWydzdHJlYW0nXSk7XG5cbiAgICB2YXIgaW5wdXRfc3RyZWFtID0gbmV3IFN0cmVhbShieXRlcyk7XG5cbiAgICB2YXIgY29kZV9wb2ludHMgPSBbXTtcblxuICAgIC8qKiBAdHlwZSB7PyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gKi9cbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgd2hpbGUgKCFpbnB1dF9zdHJlYW0uZW5kT2ZTdHJlYW0oKSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb2Rlci5oYW5kbGVyKGlucHV0X3N0cmVhbSwgaW5wdXRfc3RyZWFtLnJlYWQoKSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBmaW5pc2hlZClcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpXG4gICAgICAgIGNvZGVfcG9pbnRzLnB1c2guYXBwbHkoY29kZV9wb2ludHMsIC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki8ocmVzdWx0KSk7XG4gICAgICBlbHNlXG4gICAgICAgIGNvZGVfcG9pbnRzLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zdHJlYW1pbmcpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb2Rlci5oYW5kbGVyKGlucHV0X3N0cmVhbSwgaW5wdXRfc3RyZWFtLnJlYWQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZpbmlzaGVkKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKVxuICAgICAgICAgIGNvZGVfcG9pbnRzLnB1c2guYXBwbHkoY29kZV9wb2ludHMsIC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki8ocmVzdWx0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb2RlX3BvaW50cy5wdXNoKHJlc3VsdCk7XG4gICAgICB9IHdoaWxlICghaW5wdXRfc3RyZWFtLmVuZE9mU3RyZWFtKCkpO1xuICAgICAgdGhpcy5fZGVjb2RlciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGNvZGVfcG9pbnRzLmxlbmd0aCkge1xuICAgICAgLy8gSWYgZW5jb2RpbmcgaXMgb25lIG9mIHV0Zi04LCB1dGYtMTZiZSwgYW5kIHV0Zi0xNmxlLCBhbmRcbiAgICAgIC8vIGlnbm9yZSBCT00gZmxhZyBhbmQgQk9NIHNlZW4gZmxhZyBhcmUgdW5zZXQsIHJ1biB0aGVzZVxuICAgICAgLy8gc3Vic3Vic3RlcHM6XG4gICAgICBpZiAoWyd1dGYtOCddLmluZGV4T2YodGhpcy5lbmNvZGluZykgIT09IC0xICYmXG4gICAgICAgICAgIXRoaXMuX2lnbm9yZUJPTSAmJiAhdGhpcy5fQk9Nc2Vlbikge1xuICAgICAgICAvLyBJZiB0b2tlbiBpcyBVK0ZFRkYsIHNldCBCT00gc2VlbiBmbGFnLlxuICAgICAgICBpZiAoY29kZV9wb2ludHNbMF0gPT09IDB4RkVGRikge1xuICAgICAgICAgIHRoaXMuX0JPTXNlZW4gPSB0cnVlO1xuICAgICAgICAgIGNvZGVfcG9pbnRzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0b2tlbiBpcyBub3QgZW5kLW9mLXN0cmVhbSwgc2V0IEJPTSBzZWVuXG4gICAgICAgICAgLy8gZmxhZyBhbmQgYXBwZW5kIHRva2VuIHRvIG91dHB1dC5cbiAgICAgICAgICB0aGlzLl9CT01zZWVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb2RlUG9pbnRzVG9TdHJpbmcoY29kZV9wb2ludHMpO1xuICB9XG59O1xuXG4vLyA3LjIgSW50ZXJmYWNlIFRleHRFbmNvZGVyXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZz19IGVuY29kaW5nIFRoZSBsYWJlbCBvZiB0aGUgZW5jb2Rpbmc7XG4gKiAgICAgZGVmYXVsdHMgdG8gJ3V0Zi04Jy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBUZXh0RW5jb2RlcihlbmNvZGluZywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGV4dEVuY29kZXIpKVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoZW5jb2RpbmcsIG9wdGlvbnMpO1xuICBlbmNvZGluZyA9IGVuY29kaW5nICE9PSB1bmRlZmluZWQgPyBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkgOiBERUZBVUxUX0VOQ09ESU5HO1xuICBpZiAoZW5jb2RpbmcgIT09IERFRkFVTFRfRU5DT0RJTkcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kaW5nIG5vdCBzdXBwb3J0ZWQuIE9ubHkgdXRmLTggaXMgc3VwcG9ydGVkJyk7XG4gIH1cbiAgb3B0aW9ucyA9IFRvRGljdGlvbmFyeShvcHRpb25zKTtcblxuICAvKiogQHByaXZhdGUgQHR5cGUge2Jvb2xlYW59ICovXG4gIHRoaXMuX3N0cmVhbWluZyA9IGZhbHNlO1xuICAvKiogQHByaXZhdGUgQHR5cGUgez9FbmNvZGVyfSAqL1xuICB0aGlzLl9lbmNvZGVyID0gbnVsbDtcbiAgLyoqIEBwcml2YXRlIEB0eXBlIHt7ZmF0YWw6IGJvb2xlYW59fSAqL1xuICB0aGlzLl9vcHRpb25zID0ge2ZhdGFsOiBCb29sZWFuKG9wdGlvbnNbJ2ZhdGFsJ10pfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VuY29kaW5nJywge3ZhbHVlOiAndXRmLTgnfSk7XG59XG5cblRleHRFbmNvZGVyLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3N0cmluZyBUaGUgc3RyaW5nIHRvIGVuY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IEVuY29kZWQgYnl0ZXMsIGFzIGEgVWludDhBcnJheS5cbiAgICovXG4gIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlKG9wdF9zdHJpbmcsIG9wdGlvbnMpIHtcbiAgICBvcHRfc3RyaW5nID0gb3B0X3N0cmluZyA/IFN0cmluZyhvcHRfc3RyaW5nKSA6ICcnO1xuICAgIG9wdGlvbnMgPSBUb0RpY3Rpb25hcnkob3B0aW9ucyk7XG5cbiAgICAvLyBOT1RFOiBUaGlzIG9wdGlvbiBpcyBub25zdGFuZGFyZC4gTm9uZSBvZiB0aGUgZW5jb2RpbmdzXG4gICAgLy8gcGVybWl0dGVkIGZvciBlbmNvZGluZyAoaS5lLiBVVEYtOCwgVVRGLTE2KSBhcmUgc3RhdGVmdWwsXG4gICAgLy8gc28gc3RyZWFtaW5nIGlzIG5vdCBuZWNlc3NhcnkuXG4gICAgaWYgKCF0aGlzLl9zdHJlYW1pbmcpXG4gICAgICB0aGlzLl9lbmNvZGVyID0gbmV3IFVURjhFbmNvZGVyKHRoaXMuX29wdGlvbnMpO1xuICAgIHRoaXMuX3N0cmVhbWluZyA9IEJvb2xlYW4ob3B0aW9uc1snc3RyZWFtJ10pO1xuXG4gICAgdmFyIGJ5dGVzID0gW107XG4gICAgdmFyIGlucHV0X3N0cmVhbSA9IG5ldyBTdHJlYW0oc3RyaW5nVG9Db2RlUG9pbnRzKG9wdF9zdHJpbmcpKTtcbiAgICAvKiogQHR5cGUgez8obnVtYmVyfCFBcnJheS48bnVtYmVyPil9ICovXG4gICAgdmFyIHJlc3VsdDtcbiAgICB3aGlsZSAoIWlucHV0X3N0cmVhbS5lbmRPZlN0cmVhbSgpKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVyLmhhbmRsZXIoaW5wdXRfc3RyZWFtLCBpbnB1dF9zdHJlYW0ucmVhZCgpKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGZpbmlzaGVkKVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpXG4gICAgICAgIGJ5dGVzLnB1c2guYXBwbHkoYnl0ZXMsIC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki8ocmVzdWx0KSk7XG4gICAgICBlbHNlXG4gICAgICAgIGJ5dGVzLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zdHJlYW1pbmcpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZXIuaGFuZGxlcihpbnB1dF9zdHJlYW0sIGlucHV0X3N0cmVhbS5yZWFkKCkpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmaW5pc2hlZClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSlcbiAgICAgICAgICBieXRlcy5wdXNoLmFwcGx5KGJ5dGVzLCAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovKHJlc3VsdCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnl0ZXMucHVzaChyZXN1bHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZW5jb2RlciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG4gIH1cbn07XG5cbi8vXG4vLyA4LiBUaGUgZW5jb2Rpbmdcbi8vXG5cbi8vIDguMSB1dGYtOFxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0RlY29kZXJ9XG4gKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gVVRGOERlY29kZXIob3B0aW9ucykge1xuICB2YXIgZmF0YWwgPSBvcHRpb25zLmZhdGFsO1xuXG4gIC8vIHV0Zi04J3MgZGVjb2RlcidzIGhhcyBhbiBhc3NvY2lhdGVkIHV0Zi04IGNvZGUgcG9pbnQsIHV0Zi04XG4gIC8vIGJ5dGVzIHNlZW4sIGFuZCB1dGYtOCBieXRlcyBuZWVkZWQgKGFsbCBpbml0aWFsbHkgMCksIGEgdXRmLThcbiAgLy8gbG93ZXIgYm91bmRhcnkgKGluaXRpYWxseSAweDgwKSwgYW5kIGEgdXRmLTggdXBwZXIgYm91bmRhcnlcbiAgLy8gKGluaXRpYWxseSAweEJGKS5cbiAgdmFyIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyB1dGY4X2NvZGVfcG9pbnQgPSAwLFxuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIHV0ZjhfYnl0ZXNfc2VlbiA9IDAsXG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gdXRmOF9ieXRlc19uZWVkZWQgPSAwLFxuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIHV0ZjhfbG93ZXJfYm91bmRhcnkgPSAweDgwLFxuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIHV0ZjhfdXBwZXJfYm91bmRhcnkgPSAweEJGO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIFRoZSBzdHJlYW0gb2YgYnl0ZXMgYmVpbmcgZGVjb2RlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdGUgVGhlIG5leHQgYnl0ZSByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICogQHJldHVybiB7PyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gVGhlIG5leHQgY29kZSBwb2ludChzKVxuICAgKiAgICAgZGVjb2RlZCwgb3IgbnVsbCBpZiBub3QgZW5vdWdoIGRhdGEgZXhpc3RzIGluIHRoZSBpbnB1dFxuICAgKiAgICAgc3RyZWFtIHRvIGRlY29kZSBhIGNvbXBsZXRlIGNvZGUgcG9pbnQuXG4gICAqL1xuICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbihzdHJlYW0sIGJpdGUpIHtcbiAgICAvLyAxLiBJZiBieXRlIGlzIGVuZC1vZi1zdHJlYW0gYW5kIHV0Zi04IGJ5dGVzIG5lZWRlZCBpcyBub3QgMCxcbiAgICAvLyBzZXQgdXRmLTggYnl0ZXMgbmVlZGVkIHRvIDAgYW5kIHJldHVybiBlcnJvci5cbiAgICBpZiAoYml0ZSA9PT0gZW5kX29mX3N0cmVhbSAmJiB1dGY4X2J5dGVzX25lZWRlZCAhPT0gMCkge1xuICAgICAgdXRmOF9ieXRlc19uZWVkZWQgPSAwO1xuICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgfVxuXG4gICAgLy8gMi4gSWYgYnl0ZSBpcyBlbmQtb2Ytc3RyZWFtLCByZXR1cm4gZmluaXNoZWQuXG4gICAgaWYgKGJpdGUgPT09IGVuZF9vZl9zdHJlYW0pXG4gICAgICByZXR1cm4gZmluaXNoZWQ7XG5cbiAgICAvLyAzLiBJZiB1dGYtOCBieXRlcyBuZWVkZWQgaXMgMCwgYmFzZWQgb24gYnl0ZTpcbiAgICBpZiAodXRmOF9ieXRlc19uZWVkZWQgPT09IDApIHtcblxuICAgICAgLy8gMHgwMCB0byAweDdGXG4gICAgICBpZiAoaW5SYW5nZShiaXRlLCAweDAwLCAweDdGKSkge1xuICAgICAgICAvLyBSZXR1cm4gYSBjb2RlIHBvaW50IHdob3NlIHZhbHVlIGlzIGJ5dGUuXG4gICAgICAgIHJldHVybiBiaXRlO1xuICAgICAgfVxuXG4gICAgICAvLyAweEMyIHRvIDB4REZcbiAgICAgIGlmIChpblJhbmdlKGJpdGUsIDB4QzIsIDB4REYpKSB7XG4gICAgICAgIC8vIFNldCB1dGYtOCBieXRlcyBuZWVkZWQgdG8gMSBhbmQgdXRmLTggY29kZSBwb2ludCB0byBieXRlXG4gICAgICAgIC8vIOKIkiAweEMwLlxuICAgICAgICB1dGY4X2J5dGVzX25lZWRlZCA9IDE7XG4gICAgICAgIHV0ZjhfY29kZV9wb2ludCA9IGJpdGUgLSAweEMwO1xuICAgICAgfVxuXG4gICAgICAvLyAweEUwIHRvIDB4RUZcbiAgICAgIGVsc2UgaWYgKGluUmFuZ2UoYml0ZSwgMHhFMCwgMHhFRikpIHtcbiAgICAgICAgLy8gMS4gSWYgYnl0ZSBpcyAweEUwLCBzZXQgdXRmLTggbG93ZXIgYm91bmRhcnkgdG8gMHhBMC5cbiAgICAgICAgaWYgKGJpdGUgPT09IDB4RTApXG4gICAgICAgICAgdXRmOF9sb3dlcl9ib3VuZGFyeSA9IDB4QTA7XG4gICAgICAgIC8vIDIuIElmIGJ5dGUgaXMgMHhFRCwgc2V0IHV0Zi04IHVwcGVyIGJvdW5kYXJ5IHRvIDB4OUYuXG4gICAgICAgIGlmIChiaXRlID09PSAweEVEKVxuICAgICAgICAgIHV0ZjhfdXBwZXJfYm91bmRhcnkgPSAweDlGO1xuICAgICAgICAvLyAzLiBTZXQgdXRmLTggYnl0ZXMgbmVlZGVkIHRvIDIgYW5kIHV0Zi04IGNvZGUgcG9pbnQgdG9cbiAgICAgICAgLy8gYnl0ZSDiiJIgMHhFMC5cbiAgICAgICAgdXRmOF9ieXRlc19uZWVkZWQgPSAyO1xuICAgICAgICB1dGY4X2NvZGVfcG9pbnQgPSBiaXRlIC0gMHhFMDtcbiAgICAgIH1cblxuICAgICAgLy8gMHhGMCB0byAweEY0XG4gICAgICBlbHNlIGlmIChpblJhbmdlKGJpdGUsIDB4RjAsIDB4RjQpKSB7XG4gICAgICAgIC8vIDEuIElmIGJ5dGUgaXMgMHhGMCwgc2V0IHV0Zi04IGxvd2VyIGJvdW5kYXJ5IHRvIDB4OTAuXG4gICAgICAgIGlmIChiaXRlID09PSAweEYwKVxuICAgICAgICAgIHV0ZjhfbG93ZXJfYm91bmRhcnkgPSAweDkwO1xuICAgICAgICAvLyAyLiBJZiBieXRlIGlzIDB4RjQsIHNldCB1dGYtOCB1cHBlciBib3VuZGFyeSB0byAweDhGLlxuICAgICAgICBpZiAoYml0ZSA9PT0gMHhGNClcbiAgICAgICAgICB1dGY4X3VwcGVyX2JvdW5kYXJ5ID0gMHg4RjtcbiAgICAgICAgLy8gMy4gU2V0IHV0Zi04IGJ5dGVzIG5lZWRlZCB0byAzIGFuZCB1dGYtOCBjb2RlIHBvaW50IHRvXG4gICAgICAgIC8vIGJ5dGUg4oiSIDB4RjAuXG4gICAgICAgIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMztcbiAgICAgICAgdXRmOF9jb2RlX3BvaW50ID0gYml0ZSAtIDB4RjA7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiBlcnJvci5cbiAgICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZW4gKGJ5dGUgaXMgaW4gdGhlIHJhbmdlIDB4QzIgdG8gMHhGNCkgc2V0IHV0Zi04IGNvZGVcbiAgICAgIC8vIHBvaW50IHRvIHV0Zi04IGNvZGUgcG9pbnQgPDwgKDYgw5cgdXRmLTggYnl0ZXMgbmVlZGVkKSBhbmRcbiAgICAgIC8vIHJldHVybiBjb250aW51ZS5cbiAgICAgIHV0ZjhfY29kZV9wb2ludCA9IHV0ZjhfY29kZV9wb2ludCA8PCAoNiAqIHV0ZjhfYnl0ZXNfbmVlZGVkKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIDQuIElmIGJ5dGUgaXMgbm90IGluIHRoZSByYW5nZSB1dGYtOCBsb3dlciBib3VuZGFyeSB0byB1dGYtOFxuICAgIC8vIHVwcGVyIGJvdW5kYXJ5LCBydW4gdGhlc2Ugc3Vic3RlcHM6XG4gICAgaWYgKCFpblJhbmdlKGJpdGUsIHV0ZjhfbG93ZXJfYm91bmRhcnksIHV0ZjhfdXBwZXJfYm91bmRhcnkpKSB7XG5cbiAgICAgIC8vIDEuIFNldCB1dGYtOCBjb2RlIHBvaW50LCB1dGYtOCBieXRlcyBuZWVkZWQsIGFuZCB1dGYtOFxuICAgICAgLy8gYnl0ZXMgc2VlbiB0byAwLCBzZXQgdXRmLTggbG93ZXIgYm91bmRhcnkgdG8gMHg4MCwgYW5kIHNldFxuICAgICAgLy8gdXRmLTggdXBwZXIgYm91bmRhcnkgdG8gMHhCRi5cbiAgICAgIHV0ZjhfY29kZV9wb2ludCA9IHV0ZjhfYnl0ZXNfbmVlZGVkID0gdXRmOF9ieXRlc19zZWVuID0gMDtcbiAgICAgIHV0ZjhfbG93ZXJfYm91bmRhcnkgPSAweDgwO1xuICAgICAgdXRmOF91cHBlcl9ib3VuZGFyeSA9IDB4QkY7XG5cbiAgICAgIC8vIDIuIFByZXBlbmQgYnl0ZSB0byBzdHJlYW0uXG4gICAgICBzdHJlYW0ucHJlcGVuZChiaXRlKTtcblxuICAgICAgLy8gMy4gUmV0dXJuIGVycm9yLlxuICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgfVxuXG4gICAgLy8gNS4gU2V0IHV0Zi04IGxvd2VyIGJvdW5kYXJ5IHRvIDB4ODAgYW5kIHV0Zi04IHVwcGVyIGJvdW5kYXJ5XG4gICAgLy8gdG8gMHhCRi5cbiAgICB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMHg4MDtcbiAgICB1dGY4X3VwcGVyX2JvdW5kYXJ5ID0gMHhCRjtcblxuICAgIC8vIDYuIEluY3JlYXNlIHV0Zi04IGJ5dGVzIHNlZW4gYnkgb25lIGFuZCBzZXQgdXRmLTggY29kZSBwb2ludFxuICAgIC8vIHRvIHV0Zi04IGNvZGUgcG9pbnQgKyAoYnl0ZSDiiJIgMHg4MCkgPDwgKDYgw5cgKHV0Zi04IGJ5dGVzXG4gICAgLy8gbmVlZGVkIOKIkiB1dGYtOCBieXRlcyBzZWVuKSkuXG4gICAgdXRmOF9ieXRlc19zZWVuICs9IDE7XG4gICAgdXRmOF9jb2RlX3BvaW50ICs9IChiaXRlIC0gMHg4MCkgPDwgKDYgKiAodXRmOF9ieXRlc19uZWVkZWQgLSB1dGY4X2J5dGVzX3NlZW4pKTtcblxuICAgIC8vIDcuIElmIHV0Zi04IGJ5dGVzIHNlZW4gaXMgbm90IGVxdWFsIHRvIHV0Zi04IGJ5dGVzIG5lZWRlZCxcbiAgICAvLyBjb250aW51ZS5cbiAgICBpZiAodXRmOF9ieXRlc19zZWVuICE9PSB1dGY4X2J5dGVzX25lZWRlZClcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgLy8gOC4gTGV0IGNvZGUgcG9pbnQgYmUgdXRmLTggY29kZSBwb2ludC5cbiAgICB2YXIgY29kZV9wb2ludCA9IHV0ZjhfY29kZV9wb2ludDtcblxuICAgIC8vIDkuIFNldCB1dGYtOCBjb2RlIHBvaW50LCB1dGYtOCBieXRlcyBuZWVkZWQsIGFuZCB1dGYtOCBieXRlc1xuICAgIC8vIHNlZW4gdG8gMC5cbiAgICB1dGY4X2NvZGVfcG9pbnQgPSB1dGY4X2J5dGVzX25lZWRlZCA9IHV0ZjhfYnl0ZXNfc2VlbiA9IDA7XG5cbiAgICAvLyAxMC4gUmV0dXJuIGEgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSBpcyBjb2RlIHBvaW50LlxuICAgIHJldHVybiBjb2RlX3BvaW50O1xuICB9O1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0VuY29kZXJ9XG4gKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gVVRGOEVuY29kZXIob3B0aW9ucykge1xuICB2YXIgZmF0YWwgPSBvcHRpb25zLmZhdGFsO1xuICAvKipcbiAgICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSBJbnB1dCBzdHJlYW0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlX3BvaW50IE5leHQgY29kZSBwb2ludCByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICogQHJldHVybiB7KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSBCeXRlKHMpIHRvIGVtaXQuXG4gICAqL1xuICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbihzdHJlYW0sIGNvZGVfcG9pbnQpIHtcbiAgICAvLyAxLiBJZiBjb2RlIHBvaW50IGlzIGVuZC1vZi1zdHJlYW0sIHJldHVybiBmaW5pc2hlZC5cbiAgICBpZiAoY29kZV9wb2ludCA9PT0gZW5kX29mX3N0cmVhbSlcbiAgICAgIHJldHVybiBmaW5pc2hlZDtcblxuICAgIC8vIDIuIElmIGNvZGUgcG9pbnQgaXMgaW4gdGhlIHJhbmdlIFUrMDAwMCB0byBVKzAwN0YsIHJldHVybiBhXG4gICAgLy8gYnl0ZSB3aG9zZSB2YWx1ZSBpcyBjb2RlIHBvaW50LlxuICAgIGlmIChpblJhbmdlKGNvZGVfcG9pbnQsIDB4MDAwMCwgMHgwMDdmKSlcbiAgICAgIHJldHVybiBjb2RlX3BvaW50O1xuXG4gICAgLy8gMy4gU2V0IGNvdW50IGFuZCBvZmZzZXQgYmFzZWQgb24gdGhlIHJhbmdlIGNvZGUgcG9pbnQgaXMgaW46XG4gICAgdmFyIGNvdW50LCBvZmZzZXQ7XG4gICAgLy8gVSswMDgwIHRvIFUrMDdGRjogICAgMSBhbmQgMHhDMFxuICAgIGlmIChpblJhbmdlKGNvZGVfcG9pbnQsIDB4MDA4MCwgMHgwN0ZGKSkge1xuICAgICAgY291bnQgPSAxO1xuICAgICAgb2Zmc2V0ID0gMHhDMDtcbiAgICB9XG4gICAgLy8gVSswODAwIHRvIFUrRkZGRjogICAgMiBhbmQgMHhFMFxuICAgIGVsc2UgaWYgKGluUmFuZ2UoY29kZV9wb2ludCwgMHgwODAwLCAweEZGRkYpKSB7XG4gICAgICBjb3VudCA9IDI7XG4gICAgICBvZmZzZXQgPSAweEUwO1xuICAgIH1cbiAgICAvLyBVKzEwMDAwIHRvIFUrMTBGRkZGOiAzIGFuZCAweEYwXG4gICAgZWxzZSBpZiAoaW5SYW5nZShjb2RlX3BvaW50LCAweDEwMDAwLCAweDEwRkZGRikpIHtcbiAgICAgIGNvdW50ID0gMztcbiAgICAgIG9mZnNldCA9IDB4RjA7XG4gICAgfVxuXG4gICAgLy8gNC5MZXQgYnl0ZXMgYmUgYSBieXRlIHNlcXVlbmNlIHdob3NlIGZpcnN0IGJ5dGUgaXMgKGNvZGVcbiAgICAvLyBwb2ludCA+PiAoNiDDlyBjb3VudCkpICsgb2Zmc2V0LlxuICAgIHZhciBieXRlcyA9IFsoY29kZV9wb2ludCA+PiAoNiAqIGNvdW50KSkgKyBvZmZzZXRdO1xuXG4gICAgLy8gNS4gUnVuIHRoZXNlIHN1YnN0ZXBzIHdoaWxlIGNvdW50IGlzIGdyZWF0ZXIgdGhhbiAwOlxuICAgIHdoaWxlIChjb3VudCA+IDApIHtcblxuICAgICAgLy8gMS4gU2V0IHRlbXAgdG8gY29kZSBwb2ludCA+PiAoNiDDlyAoY291bnQg4oiSIDEpKS5cbiAgICAgIHZhciB0ZW1wID0gY29kZV9wb2ludCA+PiAoNiAqIChjb3VudCAtIDEpKTtcblxuICAgICAgLy8gMi4gQXBwZW5kIHRvIGJ5dGVzIDB4ODAgfCAodGVtcCAmIDB4M0YpLlxuICAgICAgYnl0ZXMucHVzaCgweDgwIHwgKHRlbXAgJiAweDNGKSk7XG5cbiAgICAgIC8vIDMuIERlY3JlYXNlIGNvdW50IGJ5IG9uZS5cbiAgICAgIGNvdW50IC09IDE7XG4gICAgfVxuXG4gICAgLy8gNi4gUmV0dXJuIGJ5dGVzIGJ5dGVzLCBpbiBvcmRlci5cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59XG5cbmV4cG9ydHMuVGV4dEVuY29kZXIgPSBUZXh0RW5jb2RlcjtcbmV4cG9ydHMuVGV4dERlY29kZXIgPSBUZXh0RGVjb2RlcjsiXSwibmFtZXMiOlsiaW5SYW5nZSIsImEiLCJtaW4iLCJtYXgiLCJUb0RpY3Rpb25hcnkiLCJvIiwidW5kZWZpbmVkIiwiT2JqZWN0IiwiVHlwZUVycm9yIiwic3RyaW5nVG9Db2RlUG9pbnRzIiwic3RyaW5nIiwicyIsIlN0cmluZyIsIm4iLCJsZW5ndGgiLCJpIiwidSIsImMiLCJjaGFyQ29kZUF0IiwicHVzaCIsImQiLCJiIiwiY29kZVBvaW50c1RvU3RyaW5nIiwiY29kZV9wb2ludHMiLCJjcCIsImZyb21DaGFyQ29kZSIsImVuZF9vZl9zdHJlYW0iLCJTdHJlYW0iLCJ0b2tlbnMiLCJzbGljZSIsImNhbGwiLCJwcm90b3R5cGUiLCJlbmRPZlN0cmVhbSIsInJlYWQiLCJzaGlmdCIsInByZXBlbmQiLCJ0b2tlbiIsIkFycmF5IiwiaXNBcnJheSIsInVuc2hpZnQiLCJwb3AiLCJmaW5pc2hlZCIsImRlY29kZXJFcnJvciIsImZhdGFsIiwib3B0X2NvZGVfcG9pbnQiLCJERUZBVUxUX0VOQ09ESU5HIiwiVGV4dERlY29kZXIiLCJlbmNvZGluZyIsIm9wdGlvbnMiLCJ0b0xvd2VyQ2FzZSIsIkVycm9yIiwiX3N0cmVhbWluZyIsIl9CT01zZWVuIiwiX2RlY29kZXIiLCJfZmF0YWwiLCJCb29sZWFuIiwiX2lnbm9yZUJPTSIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJkZWNvZGUiLCJpbnB1dCIsImJ5dGVzIiwiQXJyYXlCdWZmZXIiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJVVEY4RGVjb2RlciIsImlucHV0X3N0cmVhbSIsInJlc3VsdCIsImhhbmRsZXIiLCJhcHBseSIsImluZGV4T2YiLCJUZXh0RW5jb2RlciIsIl9lbmNvZGVyIiwiX29wdGlvbnMiLCJlbmNvZGUiLCJvcHRfc3RyaW5nIiwiVVRGOEVuY29kZXIiLCJ1dGY4X2NvZGVfcG9pbnQiLCJ1dGY4X2J5dGVzX3NlZW4iLCJ1dGY4X2J5dGVzX25lZWRlZCIsInV0ZjhfbG93ZXJfYm91bmRhcnkiLCJ1dGY4X3VwcGVyX2JvdW5kYXJ5Iiwic3RyZWFtIiwiYml0ZSIsImNvZGVfcG9pbnQiLCJjb3VudCIsIm9mZnNldCIsInRlbXAiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/text-encoding-utf-8/lib/encoding.lib.js\n");

/***/ })

};
;