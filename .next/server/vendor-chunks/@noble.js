"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble";
exports.ids = ["vendor-chunks/@noble"];
exports.modules = {

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _createCurveFields: () => (/* binding */ _createCurveFields),\n/* harmony export */   mulEndoUnsafe: () => (/* binding */ mulEndoUnsafe),\n/* harmony export */   negateCt: () => (/* binding */ negateCt),\n/* harmony export */   normalizeZ: () => (/* binding */ normalizeZ),\n/* harmony export */   pippenger: () => (/* binding */ pippenger),\n/* harmony export */   precomputeMSMUnsafe: () => (/* binding */ precomputeMSMUnsafe),\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */ function normalizeZ(c, points) {\n    const invertedZs = (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch)(c.Fp, points.map((p)=>p.Z));\n    return points.map((p, i)=>c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return {\n        windows,\n        windowSize,\n        mask,\n        maxNumber,\n        shiftBy\n    };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return {\n        nextN,\n        offset,\n        isZero,\n        isNeg,\n        isNegF,\n        offsetF\n    };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points)) throw new Error(\"array expected\");\n    points.forEach((p, i)=>{\n        if (!(p instanceof c)) throw new Error(\"invalid point at index \" + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars)) throw new Error(\"array of scalars expected\");\n    scalars.forEach((s, i)=>{\n        if (!field.isValid(s)) throw new Error(\"invalid scalar at index \" + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n) throw new Error(\"invalid wNAF\");\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */ class wNAF {\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits){\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while(n > _0n){\n            if (n & _1n) p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n     * - 𝑊 is the window size\n     * - 𝑛 is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */ precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for(let window = 0; window < windows; window++){\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for(let i = 1; i < windowSize; i++){\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */ wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n)) throw new Error(\"invalid scalar\");\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for(let window = 0; window < wo.windows; window++){\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            } else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return {\n            p,\n            f\n        };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */ wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for(let window = 0; window < wo.windows; window++){\n            if (n === _0n) break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                continue;\n            } else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === \"function\") comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1) return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */ function mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while(k1 > _0n || k2 > _0n){\n        if (k1 & _1n) p1 = p1.add(acc);\n        if (k2 & _1n) p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return {\n        p1,\n        p2\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */ function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength) throw new Error(\"arrays of points and scalars must have equal length\");\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12) windowSize = wbits - 3;\n    else if (wbits > 4) windowSize = wbits - 2;\n    else if (wbits > 0) windowSize = 2;\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for(let i = lastBits; i >= 0; i -= windowSize){\n        buckets.fill(zero);\n        for(let j = 0; j < slength; j++){\n            const scalar = scalars[j];\n            const wbits = Number(scalar >> BigInt(i) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar × 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 × 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */ validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(windowSize);\n    const tables = points.map((p)=>{\n        const res = [];\n        for(let i = 0, acc = p; i < tableSize; i++){\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars)=>{\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length) throw new Error(\"array of scalars must be smaller than array of points\");\n        let res = zero;\n        for(let i = 0; i < chunks; i++){\n            // No need to double if accumulator is still zero.\n            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for(let j = 0; j < scalars.length; j++){\n                const n = scalars[j];\n                const curr = Number(n >> shiftBy & MASK);\n                if (!curr) continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\n// TODO: remove\n/** @deprecated */ function validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n}\nfunction createField(order, field, isLE) {\n    if (field) {\n        if (field.ORDER !== order) throw new Error(\"Field.ORDER must match order: Fp == p, Fn == n\");\n        (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(field);\n        return field;\n    } else {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(order, {\n            isLE\n        });\n    }\n}\n/** Validates CURVE opts and creates fields */ function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === undefined) FpFnLE = type === \"edwards\";\n    if (!CURVE || typeof CURVE !== \"object\") throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of [\n        \"p\",\n        \"n\",\n        \"h\"\n    ]){\n        const val = CURVE[p];\n        if (!(typeof val === \"bigint\" && val > _0n)) throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type === \"weierstrass\" ? \"b\" : \"d\";\n    const params = [\n        \"Gx\",\n        \"Gy\",\n        \"a\",\n        _b\n    ];\n    for (const p of params){\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p])) throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return {\n        CURVE,\n        Fp,\n        Fn\n    };\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDRCxvRUFBb0UsR0FDTjtBQUNjO0FBQzVFLE1BQU1PLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNaLFNBQVNFLFNBQVNDLFNBQVMsRUFBRUMsSUFBSTtJQUNwQyxNQUFNQyxNQUFNRCxLQUFLRSxNQUFNO0lBQ3ZCLE9BQU9ILFlBQVlFLE1BQU1EO0FBQzdCO0FBQ0E7Ozs7O0NBS0MsR0FDTSxTQUFTRyxXQUFXQyxDQUFDLEVBQUVDLE1BQU07SUFDaEMsTUFBTUMsYUFBYWQsMERBQWFBLENBQUNZLEVBQUVHLEVBQUUsRUFBRUYsT0FBT0csR0FBRyxDQUFDLENBQUNDLElBQU1BLEVBQUVDLENBQUM7SUFDNUQsT0FBT0wsT0FBT0csR0FBRyxDQUFDLENBQUNDLEdBQUdFLElBQU1QLEVBQUVRLFVBQVUsQ0FBQ0gsRUFBRUksUUFBUSxDQUFDUCxVQUFVLENBQUNLLEVBQUU7QUFDckU7QUFDQSxTQUFTRyxVQUFVQyxDQUFDLEVBQUVDLElBQUk7SUFDdEIsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNILE1BQU1BLEtBQUssS0FBS0EsSUFBSUMsTUFDMUMsTUFBTSxJQUFJRyxNQUFNLHVDQUF1Q0gsT0FBTyxjQUFjRDtBQUNwRjtBQUNBLFNBQVNLLFVBQVVMLENBQUMsRUFBRU0sVUFBVTtJQUM1QlAsVUFBVUMsR0FBR007SUFDYixNQUFNQyxVQUFVQyxLQUFLQyxJQUFJLENBQUNILGFBQWFOLEtBQUssR0FBRyx1Q0FBdUM7SUFDdEYsTUFBTVUsYUFBYSxLQUFNVixDQUFBQSxJQUFJLElBQUkseUNBQXlDO0lBQzFFLE1BQU1XLFlBQVksS0FBS1gsR0FBRyxVQUFVO0lBQ3BDLE1BQU1ZLE9BQU90QyxrREFBT0EsQ0FBQzBCLElBQUksNkJBQTZCO0lBQ3RELE1BQU1hLFVBQVVo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SUFDdEIsSUFBSSxDQUFDQyxTQUFTLE9BQU9BLFVBQVUsVUFDM0IsTUFBTSxJQUFJaEgsTUFBTSxDQUFDLGVBQWUsRUFBRStHLEtBQUssYUFBYSxDQUFDO0lBQ3pELEtBQUssTUFBTXpILEtBQUs7UUFBQztRQUFLO1FBQUs7S0FBSSxDQUFFO1FBQzdCLE1BQU04SCxNQUFNSixLQUFLLENBQUMxSCxFQUFFO1FBQ3BCLElBQUksQ0FBRSxRQUFPOEgsUUFBUSxZQUFZQSxNQUFNNUksR0FBRSxHQUNyQyxNQUFNLElBQUl3QixNQUFNLENBQUMsTUFBTSxFQUFFVixFQUFFLHdCQUF3QixDQUFDO0lBQzVEO0lBQ0EsTUFBTUYsS0FBS3VILFlBQVlLLE1BQU0xSCxDQUFDLEVBQUUySCxVQUFVN0gsRUFBRSxFQUFFOEg7SUFDOUMsTUFBTXRFLEtBQUsrRCxZQUFZSyxNQUFNckcsQ0FBQyxFQUFFc0csVUFBVXJFLEVBQUUsRUFBRXNFO0lBQzlDLE1BQU1HLEtBQUtOLFNBQVMsZ0JBQWdCLE1BQU07SUFDMUMsTUFBTU8sU0FBUztRQUFDO1FBQU07UUFBTTtRQUFLRDtLQUFHO0lBQ3BDLEtBQUssTUFBTS9ILEtBQUtnSSxPQUFRO1FBQ3BCLGFBQWE7UUFDYixJQUFJLENBQUNsSSxHQUFHMkMsT0FBTyxDQUFDaUYsS0FBSyxDQUFDMUgsRUFBRSxHQUNwQixNQUFNLElBQUlVLE1BQU0sQ0FBQyxNQUFNLEVBQUVWLEVBQUUsd0NBQXdDLENBQUM7SUFDNUU7SUFDQTBILFFBQVFSLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT2UsTUFBTSxDQUFDLENBQUMsR0FBR1A7SUFDeEMsT0FBTztRQUFFQTtRQUFPNUg7UUFBSXdEO0lBQUc7QUFDM0IsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcz82MWQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWV0aG9kcyBmb3IgZWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gYnkgc2NhbGFycy5cbiAqIENvbnRhaW5zIHdOQUYsIHBpcHBlbmdlci5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgYml0TGVuLCBiaXRNYXNrLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgRmllbGQsIEZwSW52ZXJ0QmF0Y2gsIG5MZW5ndGgsIHZhbGlkYXRlRmllbGQgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlQ3QoY29uZGl0aW9uLCBpdGVtKSB7XG4gICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbn1cbi8qKlxuICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplWihjLCBwb2ludHMpIHtcbiAgICBjb25zdCBpbnZlcnRlZFpzID0gRnBJbnZlcnRCYXRjaChjLkZwLCBwb2ludHMubWFwKChwKSA9PiBwLlopKTtcbiAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gYy5mcm9tQWZmaW5lKHAudG9BZmZpbmUoaW52ZXJ0ZWRac1tpXSkpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVyhXLCBiaXRzKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKSB8fCBXIDw9IDAgfHwgVyA+IGJpdHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3aW5kb3cgc2l6ZSwgZXhwZWN0ZWQgWzEuLicgKyBiaXRzICsgJ10sIGdvdCBXPScgKyBXKTtcbn1cbmZ1bmN0aW9uIGNhbGNXT3B0cyhXLCBzY2FsYXJCaXRzKSB7XG4gICAgdmFsaWRhdGVXKFcsIHNjYWxhckJpdHMpO1xuICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoc2NhbGFyQml0cyAvIFcpICsgMTsgLy8gVz04IDMzLiBOb3QgMzIsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gVz04IDEyOC4gTm90IDI1NiwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7IC8vIFc9OCAyNTZcbiAgICBjb25zdCBtYXNrID0gYml0TWFzayhXKTsgLy8gVz04IDI1NSA9PSBtYXNrIDBiMTExMTExMTFcbiAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpOyAvLyBXPTggOFxuICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9O1xufVxuZnVuY3Rpb24gY2FsY09mZnNldHMobiwgd2luZG93LCB3T3B0cykge1xuICAgIGNvbnN0IHsgd2luZG93U2l6ZSwgbWFzaywgbWF4TnVtYmVyLCBzaGlmdEJ5IH0gPSB3T3B0cztcbiAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spOyAvLyBleHRyYWN0IFcgYml0cy5cbiAgICBsZXQgbmV4dE4gPSBuID4+IHNoaWZ0Qnk7IC8vIHNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgLy8gV2hhdCBhY3R1YWxseSBoYXBwZW5zIGhlcmU6XG4gICAgLy8gY29uc3QgaGlnaGVzdEJpdCA9IE51bWJlcihtYXNrIF4gKG1hc2sgPj4gMW4pKTtcbiAgICAvLyBsZXQgd2JpdHMyID0gd2JpdHMgLSAxOyAvLyBza2lwIHplcm9cbiAgICAvLyBpZiAod2JpdHMyICYgaGlnaGVzdEJpdCkgeyB3Yml0czIgXj0gTnVtYmVyKG1hc2spOyAvLyAofik7XG4gICAgLy8gc3BsaXQgaWYgYml0cyA+IG1heDogKzIyNCA9PiAyNTYtMzJcbiAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgIC8vIHdlIHNraXAgemVybywgd2hpY2ggbWVhbnMgaW5zdGVhZCBvZiBgPj0gc2l6ZS0xYCwgd2UgZG8gYD4gc2l6ZWBcbiAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyOyAvLyAtMzIsIGNhbiBiZSBtYXhOdW1iZXIgLSB3Yml0cywgYnV0IHRoZW4gd2UgbmVlZCB0byBzZXQgaXNOZWcgaGVyZS5cbiAgICAgICAgbmV4dE4gKz0gXzFuOyAvLyArMjU2IChjYXJyeSlcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFN0YXJ0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBpc1plcm8gPSB3Yml0cyA9PT0gMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgYSAwP1xuICAgIGNvbnN0IGlzTmVnID0gd2JpdHMgPCAwOyAvLyBpcyBjdXJyZW50IHdpbmRvdyBzbGljZSBuZWdhdGl2ZT9cbiAgICBjb25zdCBpc05lZ0YgPSB3aW5kb3cgJSAyICE9PSAwOyAvLyBmYWtlIHJhbmRvbSBzdGF0ZW1lbnQgZm9yIG5vaXNlXG4gICAgY29uc3Qgb2Zmc2V0RiA9IG9mZnNldFN0YXJ0OyAvLyBmYWtlIG9mZnNldCBmb3Igbm9pc2VcbiAgICByZXR1cm4geyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnLCBpc05lZ0YsIG9mZnNldEYgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG4gICAgcG9pbnRzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIGMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50IGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIGV4cGVjdGVkJyk7XG4gICAgc2NhbGFycy5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgICAgIGlmICghZmllbGQuaXNWYWxpZChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXIgYXQgaW5kZXggJyArIGkpO1xuICAgIH0pO1xufVxuLy8gU2luY2UgcG9pbnRzIGluIGRpZmZlcmVudCBncm91cHMgY2Fubm90IGJlIGVxdWFsIChkaWZmZXJlbnQgb2JqZWN0IGNvbnN0cnVjdG9yKSxcbi8vIHdlIGNhbiBoYXZlIHNpbmdsZSBwbGFjZSB0byBzdG9yZSBwcmVjb21wdXRlcy5cbi8vIEFsbG93cyB0byBtYWtlIHBvaW50cyBmcm96ZW4gLyBpbW11dGFibGUuXG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHBvaW50V2luZG93U2l6ZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0VyhQKSB7XG4gICAgLy8gVG8gZGlzYWJsZSBwcmVjb21wdXRlczpcbiAgICAvLyByZXR1cm4gMTtcbiAgICByZXR1cm4gcG9pbnRXaW5kb3dTaXplcy5nZXQoUCkgfHwgMTtcbn1cbmZ1bmN0aW9uIGFzc2VydDAobikge1xuICAgIGlmIChuICE9PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3TkFGJyk7XG59XG4vKipcbiAqIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbiAqIFRhYmxlIGdlbmVyYXRpb24gdGFrZXMgKiozME1CIG9mIHJhbSBhbmQgMTBtcyBvbiBoaWdoLWVuZCBDUFUqKixcbiAqIGJ1dCBtYXkgdGFrZSBtdWNoIGxvbmdlciBvbiBzbG93IGRldmljZXMuIEFjdHVhbCBnZW5lcmF0aW9uIHdpbGwgaGFwcGVuIG9uXG4gKiBmaXJzdCBjYWxsIG9mIGBtdWx0aXBseSgpYC4gQnkgZGVmYXVsdCwgYEJBU0VgIHBvaW50IGlzIHByZWNvbXB1dGVkLlxuICpcbiAqIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuICogQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4gKiAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbiAqIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3JcbiAqIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbiAqIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuICogLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuICogLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbiAqXG4gKiBAdG9kbyBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuXG4gKiBUaGlzIHdvdWxkIGFsbG93IHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIHdOQUYge1xuICAgIC8vIFBhcmFtZXRyaXplZCB3aXRoIGEgZ2l2ZW4gUG9pbnQgY2xhc3MgKG5vdCBpbmRpdmlkdWFsIHBvaW50KVxuICAgIGNvbnN0cnVjdG9yKFBvaW50LCBiaXRzKSB7XG4gICAgICAgIHRoaXMuQkFTRSA9IFBvaW50LkJBU0U7XG4gICAgICAgIHRoaXMuWkVSTyA9IFBvaW50LlpFUk87XG4gICAgICAgIHRoaXMuRm4gPSBQb2ludC5GbjtcbiAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICB9XG4gICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgX3Vuc2FmZUxhZGRlcihlbG0sIG4sIHAgPSB0aGlzLlpFUk8pIHtcbiAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgKiBAcGFyYW0gcG9pbnQgUG9pbnQgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgKi9cbiAgICBwcmVjb21wdXRlV2luZG93KHBvaW50LCBXKSB7XG4gICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gY2FsY1dPcHRzKFcsIHRoaXMuYml0cyk7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBsZXQgcCA9IHBvaW50O1xuICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgLy8gaT0xLCBiYyB3ZSBza2lwIDBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAqIE1vcmUgY29tcGFjdCBpbXBsZW1lbnRhdGlvbjpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLXNlY3AyNTZrMS9ibG9iLzQ3Y2IxNjY5YjZlNTA2YWQ2NmIzNWZlN2Q3NjEzMmFlOTc0NjVkYTIvaW5kZXgudHMjTDUwMi1MNTQxXG4gICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAqL1xuICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgLy8gU2NhbGFyIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gZmllbGQgb3JkZXJcbiAgICAgICAgaWYgKCF0aGlzLkZuLmlzVmFsaWQobikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyJyk7XG4gICAgICAgIC8vIEFjY3VtdWxhdG9yc1xuICAgICAgICBsZXQgcCA9IHRoaXMuWkVSTztcbiAgICAgICAgbGV0IGYgPSB0aGlzLkJBU0U7XG4gICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgIGNvbnN0IHdvID0gY2FsY1dPcHRzKFcsIHRoaXMuYml0cyk7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdvLndpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAvLyAobiA9PT0gXzBuKSBpcyBoYW5kbGVkIGFuZCBub3QgZWFybHktZXhpdGVkLiBpc0V2ZW4gYW5kIG9mZnNldEYgYXJlIHVzZWQgZm9yIG5vaXNlXG4gICAgICAgICAgICBjb25zdCB7IG5leHROLCBvZmZzZXQsIGlzWmVybywgaXNOZWcsIGlzTmVnRiwgb2Zmc2V0RiB9ID0gY2FsY09mZnNldHMobiwgd2luZG93LCB3byk7XG4gICAgICAgICAgICBuID0gbmV4dE47XG4gICAgICAgICAgICBpZiAoaXNaZXJvKSB7XG4gICAgICAgICAgICAgICAgLy8gYml0cyBhcmUgMDogYWRkIGdhcmJhZ2UgdG8gZmFrZSBwb2ludFxuICAgICAgICAgICAgICAgIC8vIEltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleTogYWRkIHJhbmRvbSBcIm5vaXNlXCIgcG9pbnQgdG8gZi5cbiAgICAgICAgICAgICAgICBmID0gZi5hZGQobmVnYXRlQ3QoaXNOZWdGLCBwcmVjb21wdXRlc1tvZmZzZXRGXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYml0cyBhcmUgMTogYWRkIHRvIHJlc3VsdCBwb2ludFxuICAgICAgICAgICAgICAgIHAgPSBwLmFkZChuZWdhdGVDdChpc05lZywgcHJlY29tcHV0ZXNbb2Zmc2V0XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydDAobik7XG4gICAgICAgIC8vIFJldHVybiBib3RoIHJlYWwgYW5kIGZha2UgcG9pbnRzOiBKSVQgd29uJ3QgZWxpbWluYXRlIGYuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGVjIHVuc2FmZSAobm9uIGNvbnN0LXRpbWUpIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICogQHBhcmFtIGFjYyBhY2N1bXVsYXRvciBwb2ludCB0byBhZGQgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uXG4gICAgICogQHJldHVybnMgcG9pbnRcbiAgICAgKi9cbiAgICB3TkFGVW5zYWZlKFcsIHByZWNvbXB1dGVzLCBuLCBhY2MgPSB0aGlzLlpFUk8pIHtcbiAgICAgICAgY29uc3Qgd28gPSBjYWxjV09wdHMoVywgdGhpcy5iaXRzKTtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd28ud2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIEVhcmx5LWV4aXQsIHNraXAgMCB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgeyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnIH0gPSBjYWxjT2Zmc2V0cyhuLCB3aW5kb3csIHdvKTtcbiAgICAgICAgICAgIG4gPSBuZXh0TjtcbiAgICAgICAgICAgIGlmIChpc1plcm8pIHtcbiAgICAgICAgICAgICAgICAvLyBXaW5kb3cgYml0cyBhcmUgMDogc2tpcCBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gcHJlY29tcHV0ZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBhY2MgPSBhY2MuYWRkKGlzTmVnID8gaXRlbS5uZWdhdGUoKSA6IGl0ZW0pOyAvLyBSZS11c2luZyBhY2MgYWxsb3dzIHRvIHNhdmUgYWRkcyBpbiBNU01cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQwKG4pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBnZXRQcmVjb21wdXRlcyhXLCBwb2ludCwgdHJhbnNmb3JtKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICBsZXQgY29tcCA9IHBvaW50UHJlY29tcHV0ZXMuZ2V0KHBvaW50KTtcbiAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KHBvaW50LCBXKTtcbiAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9pbmcgdHJhbnNmb3JtIG91dHNpZGUgb2YgaWYgYnJpbmdzIDE1JSBwZXJmIGhpdFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBjb21wID0gdHJhbnNmb3JtKGNvbXApO1xuICAgICAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KHBvaW50LCBjb21wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcDtcbiAgICB9XG4gICAgY2FjaGVkKHBvaW50LCBzY2FsYXIsIHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBXID0gZ2V0Vyhwb2ludCk7XG4gICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgdGhpcy5nZXRQcmVjb21wdXRlcyhXLCBwb2ludCwgdHJhbnNmb3JtKSwgc2NhbGFyKTtcbiAgICB9XG4gICAgdW5zYWZlKHBvaW50LCBzY2FsYXIsIHRyYW5zZm9ybSwgcHJldikge1xuICAgICAgICBjb25zdCBXID0gZ2V0Vyhwb2ludCk7XG4gICAgICAgIGlmIChXID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Vuc2FmZUxhZGRlcihwb2ludCwgc2NhbGFyLCBwcmV2KTsgLy8gRm9yIFc9MSBsYWRkZXIgaXMgfngyIGZhc3RlclxuICAgICAgICByZXR1cm4gdGhpcy53TkFGVW5zYWZlKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgcG9pbnQsIHRyYW5zZm9ybSksIHNjYWxhciwgcHJldik7XG4gICAgfVxuICAgIC8vIFdlIGNhbGN1bGF0ZSBwcmVjb21wdXRlcyBmb3IgZWxsaXB0aWMgY3VydmUgcG9pbnQgbXVsdGlwbGljYXRpb25cbiAgICAvLyB1c2luZyB3aW5kb3dlZCBtZXRob2QuIFRoaXMgc3BlY2lmaWVzIHdpbmRvdyBzaXplIGFuZFxuICAgIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICAgIGNyZWF0ZUNhY2hlKFAsIFcpIHtcbiAgICAgICAgdmFsaWRhdGVXKFcsIHRoaXMuYml0cyk7XG4gICAgICAgIHBvaW50V2luZG93U2l6ZXMuc2V0KFAsIFcpO1xuICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZShQKTtcbiAgICB9XG4gICAgaGFzQ2FjaGUoZWxtKSB7XG4gICAgICAgIHJldHVybiBnZXRXKGVsbSkgIT09IDE7XG4gICAgfVxufVxuLyoqXG4gKiBFbmRvbW9ycGhpc20tc3BlY2lmaWMgbXVsdGlwbGljYXRpb24gZm9yIEtvYmxpdHogY3VydmVzLlxuICogQ29zdDogMTI4IGRibCwgMC0yNTYgYWRkcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bEVuZG9VbnNhZmUoUG9pbnQsIHBvaW50LCBrMSwgazIpIHtcbiAgICBsZXQgYWNjID0gcG9pbnQ7XG4gICAgbGV0IHAxID0gUG9pbnQuWkVSTztcbiAgICBsZXQgcDIgPSBQb2ludC5aRVJPO1xuICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICBwMSA9IHAxLmFkZChhY2MpO1xuICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICBwMiA9IHAyLmFkZChhY2MpO1xuICAgICAgICBhY2MgPSBhY2MuZG91YmxlKCk7XG4gICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgIGsyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiB7IHAxLCBwMiB9O1xufVxuLyoqXG4gKiBQaXBwZW5nZXIgYWxnb3JpdGhtIGZvciBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIDMweCBmYXN0ZXIgdnMgbmFpdmUgYWRkaXRpb24gb24gTD00MDk2LCAxMHggZmFzdGVyIHRoYW4gcHJlY29tcHV0ZXMuXG4gKiBGb3IgTj0yNTRiaXQsIEw9MSwgaXQgZG9lczogMTAyNCBBREQgKyAyNTQgREJMLiBGb3IgTD01OiAxNTM2IEFERCArIDI1NCBEQkwuXG4gKiBBbGdvcml0aG1pY2FsbHkgY29uc3RhbnQtdGltZSAoZm9yIHNhbWUgTCksIGV2ZW4gd2hlbiAxIHBvaW50ICsgc2NhbGFyLCBvciB3aGVuIHNjYWxhciA9IDAuXG4gKiBAcGFyYW0gYyBDdXJ2ZSBQb2ludCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGZpZWxkTiBmaWVsZCBvdmVyIENVUlZFLk4gLSBpbXBvcnRhbnQgdGhhdCBpdCdzIG5vdCBvdmVyIENVUlZFLlBcbiAqIEBwYXJhbSBwb2ludHMgYXJyYXkgb2YgTCBjdXJ2ZSBwb2ludHNcbiAqIEBwYXJhbSBzY2FsYXJzIGFycmF5IG9mIEwgc2NhbGFycyAoYWthIHNlY3JldCBrZXlzIC8gYmlnaW50cylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpcHBlbmdlcihjLCBmaWVsZE4sIHBvaW50cywgc2NhbGFycykge1xuICAgIC8vIElmIHdlIHNwbGl0IHNjYWxhcnMgYnkgc29tZSB3aW5kb3cgKGxldCdzIHNheSA4IGJpdHMpLCBldmVyeSBjaHVuayB3aWxsIG9ubHlcbiAgICAvLyB0YWtlIDI1NiBidWNrZXRzIGV2ZW4gaWYgdGhlcmUgYXJlIDQwOTYgc2NhbGFycywgYWxzbyByZS11c2VzIGRvdWJsZS5cbiAgICAvLyBUT0RPOlxuICAgIC8vIC0gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAyNC83NTAucGRmXG4gICAgLy8gLSBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvMTAyODdcbiAgICAvLyAwIGlzIGFjY2VwdGVkIGluIHNjYWxhcnNcbiAgICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICAgIGNvbnN0IHBsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IHNsZW5ndGggPSBzY2FsYXJzLmxlbmd0aDtcbiAgICBpZiAocGxlbmd0aCAhPT0gc2xlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheXMgb2YgcG9pbnRzIGFuZCBzY2FsYXJzIG11c3QgaGF2ZSBlcXVhbCBsZW5ndGgnKTtcbiAgICAvLyBpZiAocGxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBtdXN0IGJlIG9mIGxlbmd0aCA+PSAyJyk7XG4gICAgY29uc3QgemVybyA9IGMuWkVSTztcbiAgICBjb25zdCB3Yml0cyA9IGJpdExlbihCaWdJbnQocGxlbmd0aCkpO1xuICAgIGxldCB3aW5kb3dTaXplID0gMTsgLy8gYml0c1xuICAgIGlmICh3Yml0cyA+IDEyKVxuICAgICAgICB3aW5kb3dTaXplID0gd2JpdHMgLSAzO1xuICAgIGVsc2UgaWYgKHdiaXRzID4gNClcbiAgICAgICAgd2luZG93U2l6ZSA9IHdiaXRzIC0gMjtcbiAgICBlbHNlIGlmICh3Yml0cyA+IDApXG4gICAgICAgIHdpbmRvd1NpemUgPSAyO1xuICAgIGNvbnN0IE1BU0sgPSBiaXRNYXNrKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTnVtYmVyKE1BU0spICsgMSkuZmlsbCh6ZXJvKTsgLy8gKzEgZm9yIHplcm8gYXJyYXlcbiAgICBjb25zdCBsYXN0Qml0cyA9IE1hdGguZmxvb3IoKGZpZWxkTi5CSVRTIC0gMSkgLyB3aW5kb3dTaXplKSAqIHdpbmRvd1NpemU7XG4gICAgbGV0IHN1bSA9IHplcm87XG4gICAgZm9yIChsZXQgaSA9IGxhc3RCaXRzOyBpID49IDA7IGkgLT0gd2luZG93U2l6ZSkge1xuICAgICAgICBidWNrZXRzLmZpbGwoemVybyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsYXIgPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgY29uc3Qgd2JpdHMgPSBOdW1iZXIoKHNjYWxhciA+PiBCaWdJbnQoaSkpICYgTUFTSyk7XG4gICAgICAgICAgICBidWNrZXRzW3diaXRzXSA9IGJ1Y2tldHNbd2JpdHNdLmFkZChwb2ludHNbal0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNJID0gemVybzsgLy8gbm90IHVzaW5nIHRoaXMgd2lsbCBkbyBzbWFsbCBzcGVlZC11cCwgYnV0IHdpbGwgbG9zZSBjdFxuICAgICAgICAvLyBTa2lwIGZpcnN0IGJ1Y2tldCwgYmVjYXVzZSBpdCBpcyB6ZXJvXG4gICAgICAgIGZvciAobGV0IGogPSBidWNrZXRzLmxlbmd0aCAtIDEsIHN1bUkgPSB6ZXJvOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICBzdW1JID0gc3VtSS5hZGQoYnVja2V0c1tqXSk7XG4gICAgICAgICAgICByZXNJID0gcmVzSS5hZGQoc3VtSSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VtID0gc3VtLmFkZChyZXNJKTtcbiAgICAgICAgaWYgKGkgIT09IDApXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0uZG91YmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4vKipcbiAqIFByZWNvbXB1dGVkIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB3aGljaCBtdWx0aXBsaWVzIHBvaW50cyB3aXRoIHNjYWFyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlY29tcHV0ZU1TTVVuc2FmZShjLCBmaWVsZE4sIHBvaW50cywgd2luZG93U2l6ZSkge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1hbmNlIEFuYWx5c2lzIG9mIFdpbmRvdy1iYXNlZCBQcmVjb21wdXRhdGlvblxuICAgICAqXG4gICAgICogQmFzZSBDYXNlICgyNTYtYml0IHNjYWxhciwgOC1iaXQgd2luZG93KTpcbiAgICAgKiAtIFN0YW5kYXJkIHByZWNvbXB1dGF0aW9uIHJlcXVpcmVzOlxuICAgICAqICAgLSAzMSBhZGRpdGlvbnMgcGVyIHNjYWxhciDDlyAyNTYgc2NhbGFycyA9IDcsOTM2IG9wc1xuICAgICAqICAgLSBQbHVzIDI1NSBzdW1tYXJ5IGFkZGl0aW9ucyA9IDgsMTkxIHRvdGFsIG9wc1xuICAgICAqICAgTm90ZTogU3VtbWFyeSBhZGRpdGlvbnMgY2FuIGJlIG9wdGltaXplZCB2aWEgYWNjdW11bGF0b3JcbiAgICAgKlxuICAgICAqIENodW5rZWQgUHJlY29tcHV0YXRpb24gQW5hbHlzaXM6XG4gICAgICogLSBVc2luZyAzMiBjaHVua3MgcmVxdWlyZXM6XG4gICAgICogICAtIDI1NSBhZGRpdGlvbnMgcGVyIGNodW5rXG4gICAgICogICAtIDI1NiBkb3VibGluZ3NcbiAgICAgKiAgIC0gVG90YWw6ICgyNTUgw5cgMzIpICsgMjU2ID0gOCw0MTYgb3BzXG4gICAgICpcbiAgICAgKiBNZW1vcnkgVXNhZ2UgQ29tcGFyaXNvbjpcbiAgICAgKiBXaW5kb3cgU2l6ZSB8IFN0YW5kYXJkIFBvaW50cyB8IENodW5rZWQgUG9pbnRzXG4gICAgICogLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLVxuICAgICAqICAgICA0LWJpdCAgIHwgICAgIDUyMCAgICAgICAgIHwgICAgICAxNVxuICAgICAqICAgICA4LWJpdCAgIHwgICAgNCwyMjQgICAgICAgIHwgICAgIDI1NVxuICAgICAqICAgIDEwLWJpdCAgIHwgICAxMyw4MjQgICAgICAgIHwgICAxLDAyM1xuICAgICAqICAgIDE2LWJpdCAgIHwgIDU1NywwNTYgICAgICAgIHwgIDY1LDUzNVxuICAgICAqXG4gICAgICogS2V5IEFkdmFudGFnZXM6XG4gICAgICogMS4gRW5hYmxlcyBsYXJnZXIgd2luZG93IHNpemVzIGR1ZSB0byByZWR1Y2VkIG1lbW9yeSBvdmVyaGVhZFxuICAgICAqIDIuIE1vcmUgZWZmaWNpZW50IGZvciBzbWFsbGVyIHNjYWxhciBjb3VudHM6XG4gICAgICogICAgLSAxNiBjaHVua3M6ICgxNiDDlyAyNTUpICsgMjU2ID0gNCwzMzYgb3BzXG4gICAgICogICAgLSB+MnggZmFzdGVyIHRoYW4gc3RhbmRhcmQgOCwxOTEgb3BzXG4gICAgICpcbiAgICAgKiBMaW1pdGF0aW9uczpcbiAgICAgKiAtIE5vdCBzdWl0YWJsZSBmb3IgcGxhaW4gcHJlY29tcHV0ZXMgKHJlcXVpcmVzIDI1NiBjb25zdGFudCBkb3VibGluZ3MpXG4gICAgICogLSBQZXJmb3JtYW5jZSBkZWdyYWRlcyB3aXRoIGxhcmdlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgLSBPcHRpbWFsIGZvciB+MjU2IHNjYWxhcnNcbiAgICAgKiAgIC0gTGVzcyBlZmZpY2llbnQgZm9yIDQwOTYrIHNjYWxhcnMgKFBpcHBlbmdlciBwcmVmZXJyZWQpXG4gICAgICovXG4gICAgdmFsaWRhdGVXKHdpbmRvd1NpemUsIGZpZWxkTi5CSVRTKTtcbiAgICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3QgdGFibGVTaXplID0gMiAqKiB3aW5kb3dTaXplIC0gMTsgLy8gdGFibGUgc2l6ZSAod2l0aG91dCB6ZXJvKVxuICAgIGNvbnN0IGNodW5rcyA9IE1hdGguY2VpbChmaWVsZE4uQklUUyAvIHdpbmRvd1NpemUpOyAvLyBjaHVua3Mgb2YgaXRlbVxuICAgIGNvbnN0IE1BU0sgPSBiaXRNYXNrKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IHRhYmxlcyA9IHBvaW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBhY2MgPSBwOyBpIDwgdGFibGVTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGFjYyk7XG4gICAgICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIChzY2FsYXJzKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICAgICAgICBpZiAoc2NhbGFycy5sZW5ndGggPiBwb2ludHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIG11c3QgYmUgc21hbGxlciB0aGFuIGFycmF5IG9mIHBvaW50cycpO1xuICAgICAgICBsZXQgcmVzID0gemVybztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3M7IGkrKykge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBkb3VibGUgaWYgYWNjdW11bGF0b3IgaXMgc3RpbGwgemVyby5cbiAgICAgICAgICAgIGlmIChyZXMgIT09IHplcm8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5kb3VibGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoY2h1bmtzICogd2luZG93U2l6ZSAtIChpICsgMSkgKiB3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2NhbGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnIgPSBOdW1iZXIoKG4gPj4gc2hpZnRCeSkgJiBNQVNLKTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHplcm8gc2NhbGFycyBjaHVua3NcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuYWRkKHRhYmxlc1tqXVtjdXJyIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cbi8vIFRPRE86IHJlbW92ZVxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpZWxkKG9yZGVyLCBmaWVsZCwgaXNMRSkge1xuICAgIGlmIChmaWVsZCkge1xuICAgICAgICBpZiAoZmllbGQuT1JERVIgIT09IG9yZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZC5PUkRFUiBtdXN0IG1hdGNoIG9yZGVyOiBGcCA9PSBwLCBGbiA9PSBuJyk7XG4gICAgICAgIHZhbGlkYXRlRmllbGQoZmllbGQpO1xuICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gRmllbGQob3JkZXIsIHsgaXNMRSB9KTtcbiAgICB9XG59XG4vKiogVmFsaWRhdGVzIENVUlZFIG9wdHMgYW5kIGNyZWF0ZXMgZmllbGRzICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZUN1cnZlRmllbGRzKHR5cGUsIENVUlZFLCBjdXJ2ZU9wdHMgPSB7fSwgRnBGbkxFKSB7XG4gICAgaWYgKEZwRm5MRSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBGcEZuTEUgPSB0eXBlID09PSAnZWR3YXJkcyc7XG4gICAgaWYgKCFDVVJWRSB8fCB0eXBlb2YgQ1VSVkUgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIHZhbGlkICR7dHlwZX0gQ1VSVkUgb2JqZWN0YCk7XG4gICAgZm9yIChjb25zdCBwIG9mIFsncCcsICduJywgJ2gnXSkge1xuICAgICAgICBjb25zdCB2YWwgPSBDVVJWRVtwXTtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcgJiYgdmFsID4gXzBuKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ1VSVkUuJHtwfSBtdXN0IGJlIHBvc2l0aXZlIGJpZ2ludGApO1xuICAgIH1cbiAgICBjb25zdCBGcCA9IGNyZWF0ZUZpZWxkKENVUlZFLnAsIGN1cnZlT3B0cy5GcCwgRnBGbkxFKTtcbiAgICBjb25zdCBGbiA9IGNyZWF0ZUZpZWxkKENVUlZFLm4sIGN1cnZlT3B0cy5GbiwgRnBGbkxFKTtcbiAgICBjb25zdCBfYiA9IHR5cGUgPT09ICd3ZWllcnN0cmFzcycgPyAnYicgOiAnZCc7XG4gICAgY29uc3QgcGFyYW1zID0gWydHeCcsICdHeScsICdhJywgX2JdO1xuICAgIGZvciAoY29uc3QgcCBvZiBwYXJhbXMpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoIUZwLmlzVmFsaWQoQ1VSVkVbcF0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDVVJWRS4ke3B9IG11c3QgYmUgdmFsaWQgZmllbGQgZWxlbWVudCBvZiBDVVJWRS5GcGApO1xuICAgIH1cbiAgICBDVVJWRSA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgQ1VSVkUpKTtcbiAgICByZXR1cm4geyBDVVJWRSwgRnAsIEZuIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsiYml0TGVuIiwiYml0TWFzayIsInZhbGlkYXRlT2JqZWN0IiwiRmllbGQiLCJGcEludmVydEJhdGNoIiwibkxlbmd0aCIsInZhbGlkYXRlRmllbGQiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJuZWdhdGVDdCIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJuZWdhdGUiLCJub3JtYWxpemVaIiwiYyIsInBvaW50cyIsImludmVydGVkWnMiLCJGcCIsIm1hcCIsInAiLCJaIiwiaSIsImZyb21BZmZpbmUiLCJ0b0FmZmluZSIsInZhbGlkYXRlVyIsIlciLCJiaXRzIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiY2FsY1dPcHRzIiwic2NhbGFyQml0cyIsIndpbmRvd3MiLCJNYXRoIiwiY2VpbCIsIndpbmRvd1NpemUiLCJtYXhOdW1iZXIiLCJtYXNrIiwic2hpZnRCeSIsImNhbGNPZmZzZXRzIiwibiIsIndpbmRvdyIsIndPcHRzIiwid2JpdHMiLCJuZXh0TiIsIm9mZnNldFN0YXJ0Iiwib2Zmc2V0IiwiYWJzIiwiaXNaZXJvIiwiaXNOZWciLCJpc05lZ0YiLCJvZmZzZXRGIiwidmFsaWRhdGVNU01Qb2ludHMiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwidmFsaWRhdGVNU01TY2FsYXJzIiwic2NhbGFycyIsImZpZWxkIiwicyIsImlzVmFsaWQiLCJwb2ludFByZWNvbXB1dGVzIiwiV2Vha01hcCIsInBvaW50V2luZG93U2l6ZXMiLCJnZXRXIiwiUCIsImdldCIsImFzc2VydDAiLCJ3TkFGIiwiY29uc3RydWN0b3IiLCJQb2ludCIsIkJBU0UiLCJaRVJPIiwiRm4iLCJfdW5zYWZlTGFkZGVyIiwiZWxtIiwiZCIsImFkZCIsImRvdWJsZSIsInByZWNvbXB1dGVXaW5kb3ciLCJwb2ludCIsImJhc2UiLCJwdXNoIiwicHJlY29tcHV0ZXMiLCJmIiwid28iLCJ3TkFGVW5zYWZlIiwiYWNjIiwiZ2V0UHJlY29tcHV0ZXMiLCJ0cmFuc2Zvcm0iLCJjb21wIiwic2V0IiwiY2FjaGVkIiwic2NhbGFyIiwidW5zYWZlIiwicHJldiIsImNyZWF0ZUNhY2hlIiwiZGVsZXRlIiwiaGFzQ2FjaGUiLCJtdWxFbmRvVW5zYWZlIiwiazEiLCJrMiIsInAxIiwicDIiLCJwaXBwZW5nZXIiLCJmaWVsZE4iLCJwbGVuZ3RoIiwibGVuZ3RoIiwic2xlbmd0aCIsInplcm8iLCJNQVNLIiwiYnVja2V0cyIsImZpbGwiLCJsYXN0Qml0cyIsImZsb29yIiwiQklUUyIsInN1bSIsImoiLCJyZXNJIiwic3VtSSIsInByZWNvbXB1dGVNU01VbnNhZmUiLCJ0YWJsZVNpemUiLCJjaHVua3MiLCJ0YWJsZXMiLCJyZXMiLCJjdXJyIiwidmFsaWRhdGVCYXNpYyIsImN1cnZlIiwiaCIsIkd4IiwiR3kiLCJuQml0TGVuZ3RoIiwibkJ5dGVMZW5ndGgiLCJPYmplY3QiLCJmcmVlemUiLCJPUkRFUiIsImNyZWF0ZUZpZWxkIiwib3JkZXIiLCJpc0xFIiwiX2NyZWF0ZUN1cnZlRmllbGRzIiwidHlwZSIsIkNVUlZFIiwiY3VydmVPcHRzIiwiRnBGbkxFIiwidW5kZWZpbmVkIiwidmFsIiwiX2IiLCJwYXJhbXMiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/edwards.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/edwards.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PrimeEdwardsPoint: () => (/* binding */ PrimeEdwardsPoint),\n/* harmony export */   eddsa: () => (/* binding */ eddsa),\n/* harmony export */   edwards: () => (/* binding */ edwards),\n/* harmony export */   twistedEdwards: () => (/* binding */ twistedEdwards)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\nfunction isEdValidXY(Fp, CURVE, x, y) {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n}\nfunction edwards(params, extraOpts = {}) {\n    const validated = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__._createCurveFields)(\"edwards\", params, extraOpts, extraOpts.FpFnLE);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor } = CURVE;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._validateObject)(extraOpts, {}, {\n        uvRatio: \"function\"\n    });\n    // Important:\n    // There are some places where Fp.BYTES is used instead of nByteLength.\n    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n    // TODO: test and find curves which behave otherwise.\n    const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;\n    const modP = (n)=>Fp.create(n); // Function overrides\n    // sqrt(u/v)\n    const uvRatio = extraOpts.uvRatio || ((u, v)=>{\n        try {\n            return {\n                isValid: true,\n                value: Fp.sqrt(Fp.div(u, v))\n            };\n        } catch (e) {\n            return {\n                isValid: false,\n                value: _0n\n            };\n        }\n    });\n    // Validate whether the passed curve params are valid.\n    // equation ax² + y² = 1 + dx²y² should work for generator point.\n    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy)) throw new Error(\"bad curve params: generator point\");\n    /**\n     * Asserts coordinate is valid: 0 <= n < MASK.\n     * Coordinates >= Fp.ORDER are allowed for zip215.\n     */ function acoord(title, n, banZero = false) {\n        const min = banZero ? _1n : _0n;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange)(\"coordinate \" + title, n, min, MASK);\n        return n;\n    }\n    function aextpoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ExtendedPoint expected\");\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoized)((p, iz)=>{\n        const { X, Y, Z } = p;\n        const is0 = p.is0();\n        if (iz == null) iz = is0 ? _8n : Fp.inv(Z); // 8 was chosen arbitrarily\n        const x = modP(X * iz);\n        const y = modP(Y * iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0) return {\n            x: _0n,\n            y: _1n\n        };\n        if (zz !== _1n) throw new Error(\"invZ was invalid\");\n        return {\n            x,\n            y\n        };\n    });\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoized)((p)=>{\n        const { a, d } = CURVE;\n        if (p.is0()) throw new Error(\"bad point: ZERO\"); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        const { X, Y, Z, T } = p;\n        const X2 = modP(X * X); // X²\n        const Y2 = modP(Y * Y); // Y²\n        const Z2 = modP(Z * Z); // Z²\n        const Z4 = modP(Z2 * Z2); // Z⁴\n        const aX2 = modP(X2 * a); // aX²\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right) throw new Error(\"bad point: equation left != right (1)\");\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT) throw new Error(\"bad point: equation left != right (2)\");\n        return true;\n    });\n    // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(X, Y, Z, T){\n            this.X = acoord(\"x\", X);\n            this.Y = acoord(\"y\", Y);\n            this.Z = acoord(\"z\", Z, true);\n            this.T = acoord(\"t\", T);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point) throw new Error(\"extended point not allowed\");\n            const { x, y } = p || {};\n            acoord(\"x\", x);\n            acoord(\"y\", y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        // Uses algo from RFC8032 5.1.3.\n        static fromBytes(bytes, zip215 = false) {\n            const len = Fp.BYTES;\n            const { a, d } = CURVE;\n            bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.copyBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abytes2)(bytes, len, \"point\"));\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abool2)(zip215, \"zip215\");\n            const normed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.copyBytes)(bytes); // copy again, we'll manipulate it\n            const lastByte = bytes[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(normed);\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange)(\"point.y\", y, _0n, max);\n            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y² - 1\n            const v = modP(d * y2 - a); // v = d y² + 1.\n            let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n            if (!isValid) throw new Error(\"bad point: invalid y coordinate\");\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd) // if x=0 and x_0 = 1, fail\n            throw new Error(\"bad point: x=0 and x_0=1\");\n            if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({\n                x,\n                y\n            });\n        }\n        static fromHex(bytes, zip215 = false) {\n            return Point.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"point\", bytes), zip215);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy) this.multiply(_2n); // random number\n            return this;\n        }\n        // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            aextpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            aextpoint(other);\n            const { a, d } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n            const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            // 1 <= scalar < L\n            if (!Fn.isValidNot0(scalar)) throw new Error(\"invalid scalar: expected 1 <= sc < curve.n\");\n            const { p, f } = wnaf.cached(this, scalar, (p)=>(0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, p));\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, [\n                p,\n                f\n            ])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n        multiplyUnsafe(scalar, acc = Point.ZERO) {\n            // 0 <= scalar < L\n            if (!Fn.isValid(scalar)) throw new Error(\"invalid scalar: expected 0 <= sc < curve.n\");\n            if (scalar === _0n) return Point.ZERO;\n            if (this.is0() || scalar === _1n) return this;\n            return wnaf.unsafe(this, scalar, (p)=>(0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, p), acc);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafe(this, CURVE.n).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        clearCofactor() {\n            if (cofactor === _1n) return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        toBytes() {\n            const { x, y } = this.toAffine();\n            // Fp.toBytes() allows non-canonical encoding of y (>= p).\n            const bytes = Fp.toBytes(y);\n            // Each y has 2 valid points: (x, y), (x,-y).\n            // When compressing, it's enough to store y and use the last byte to encode sign of x\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;\n            return bytes;\n        }\n        toHex() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes());\n        }\n        toString() {\n            return `<Point ${this.is0() ? \"ZERO\" : this.toHex()}>`;\n        }\n        // TODO: remove\n        get ex() {\n            return this.X;\n        }\n        get ey() {\n            return this.Y;\n        }\n        get ez() {\n            return this.Z;\n        }\n        get et() {\n            return this.T;\n        }\n        static normalizeZ(points) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, points);\n        }\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.pippenger)(Point, Fn, points, scalars);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        toRawBytes() {\n            return this.toBytes();\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // math field\n    Point.Fp = Fp;\n    // scalar field\n    Point.Fn = Fn;\n    const wnaf = new _curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF(Point, Fn.BITS);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */ class PrimeEdwardsPoint {\n    constructor(ep){\n        this.ep = ep;\n    }\n    // Static methods that must be implemented by subclasses\n    static fromBytes(_bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.notImplemented)();\n    }\n    static fromHex(_hex) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.notImplemented)();\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    // Common implementations\n    clearCofactor() {\n        // no-op for prime-order groups\n        return this;\n    }\n    assertValidity() {\n        this.ep.assertValidity();\n    }\n    toAffine(invertedZ) {\n        return this.ep.toAffine(invertedZ);\n    }\n    toHex() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    isTorsionFree() {\n        return true;\n    }\n    isSmallOrder() {\n        return false;\n    }\n    add(other) {\n        this.assertSame(other);\n        return this.init(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        this.assertSame(other);\n        return this.init(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return this.init(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return this.init(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return this.init(this.ep.double());\n    }\n    negate() {\n        return this.init(this.ep.negate());\n    }\n    precompute(windowSize, isLazy) {\n        return this.init(this.ep.precompute(windowSize, isLazy));\n    }\n    /** @deprecated use `toBytes` */ toRawBytes() {\n        return this.toBytes();\n    }\n}\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */ function eddsa(Point, cHash, eddsaOpts = {}) {\n    if (typeof cHash !== \"function\") throw new Error('\"hash\" function param is required');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._validateObject)(eddsaOpts, {}, {\n        adjustScalarBytes: \"function\",\n        randomBytes: \"function\",\n        domain: \"function\",\n        prehash: \"function\",\n        mapToCurve: \"function\"\n    });\n    const { prehash } = eddsaOpts;\n    const { BASE, Fp, Fn } = Point;\n    const randomBytes = eddsaOpts.randomBytes || _utils_js__WEBPACK_IMPORTED_MODULE_2__.randomBytes;\n    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes)=>bytes);\n    const domain = eddsaOpts.domain || ((data, ctx, phflag)=>{\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abool2)(phflag, \"phflag\");\n        if (ctx.length || phflag) throw new Error(\"Contexts/pre-hash are not supported\");\n        return data;\n    }); // NOOP\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return Fn.create((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(hash)); // Not Fn.fromBytes: it has length limit\n    }\n    // Get the hashed private scalar per RFC8032 5.1.5\n    function getPrivateScalar(key) {\n        const len = lengths.secretKey;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"hashed private key\", cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        return {\n            head,\n            prefix,\n            scalar\n        };\n    }\n    /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */ function getExtendedPublicKey(secretKey) {\n        const { head, prefix, scalar } = getPrivateScalar(secretKey);\n        const point = BASE.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toBytes();\n        return {\n            head,\n            prefix,\n            scalar,\n            point,\n            pointBytes\n        };\n    }\n    /** Calculates EdDSA pub key. RFC8032 5.1.5. */ function getPublicKey(secretKey) {\n        return getExtendedPublicKey(secretKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n        const msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(...msgs);\n        return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"context\", context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */ function sign(msg, secretKey, options = {}) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"message\", msg);\n        if (prehash) msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = BASE.multiply(r).toBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L\n        if (!Fn.isValid(s)) throw new Error(\"sign failed: invalid s\"); // 0 <= s < L\n        const rs = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(R, Fn.toBytes(s));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abytes2)(rs, lengths.signature, \"result\");\n    }\n    // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n    const verifyOpts = {\n        zip215: true\n    };\n    /**\n     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n     * An extended group equation is checked.\n     */ function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = lengths.signature;\n        sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"signature\", sig, len);\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"message\", msg);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"publicKey\", publicKey, lengths.publicKey);\n        if (zip215 !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abool2)(zip215, \"zip215\");\n        if (prehash) msg = prehash(msg); // for ed25519ph, etc\n        const mid = len / 2;\n        const r = sig.subarray(0, mid);\n        const s = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(sig.subarray(mid, len));\n        let A, R, SB;\n        try {\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            A = Point.fromBytes(publicKey, zip215);\n            R = Point.fromBytes(r, zip215);\n            SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside\n        } catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder()) return false; // zip215 allows public keys of small order\n        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // Extended group equation\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().is0();\n    }\n    const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448\n    const lengths = {\n        secretKey: _size,\n        publicKey: _size,\n        signature: 2 * _size,\n        seed: _size\n    };\n    function randomSecretKey(seed = randomBytes(lengths.seed)) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abytes2)(seed, lengths.seed, \"seed\");\n    }\n    function keygen(seed) {\n        const secretKey = utils.randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: getPublicKey(secretKey)\n        };\n    }\n    function isValidSecretKey(key) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isBytes)(key) && key.length === Fn.BYTES;\n    }\n    function isValidPublicKey(key, zip215) {\n        try {\n            return !!Point.fromBytes(key, zip215);\n        } catch (error) {\n            return false;\n        }\n    }\n    const utils = {\n        getExtendedPublicKey,\n        randomSecretKey,\n        isValidSecretKey,\n        isValidPublicKey,\n        /**\n         * Converts ed public key to x public key. Uses formula:\n         * - ed25519:\n         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n         * - ed448:\n         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n         */ toMontgomery (publicKey) {\n            const { y } = Point.fromBytes(publicKey);\n            const size = lengths.publicKey;\n            const is25519 = size === 32;\n            if (!is25519 && size !== 57) throw new Error(\"only defined for 25519 and 448\");\n            const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n            return Fp.toBytes(u);\n        },\n        toMontgomeryPriv (secretKey) {\n            const size = lengths.secretKey;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abytes2)(secretKey, size);\n            const hashed = cHash(secretKey.subarray(0, size));\n            return adjustScalarBytes(hashed).subarray(0, size);\n        },\n        /** @deprecated */ randomPrivateKey: randomSecretKey,\n        /** @deprecated */ precompute (windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        }\n    };\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        sign,\n        verify,\n        utils,\n        Point,\n        lengths\n    });\n}\nfunction _eddsa_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        d: c.d,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy\n    };\n    const Fp = c.Fp;\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.Field)(CURVE.n, c.nBitLength, true);\n    const curveOpts = {\n        Fp,\n        Fn,\n        uvRatio: c.uvRatio\n    };\n    const eddsaOpts = {\n        randomBytes: c.randomBytes,\n        adjustScalarBytes: c.adjustScalarBytes,\n        domain: c.domain,\n        prehash: c.prehash,\n        mapToCurve: c.mapToCurve\n    };\n    return {\n        CURVE,\n        curveOpts,\n        hash: c.hash,\n        eddsaOpts\n    };\n}\nfunction _eddsa_new_output_to_legacy(c, eddsa) {\n    const Point = eddsa.Point;\n    const legacy = Object.assign({}, eddsa, {\n        ExtendedPoint: Point,\n        CURVE: c,\n        nBitLength: Point.Fn.BITS,\n        nByteLength: Point.Fn.BYTES\n    });\n    return legacy;\n}\n// TODO: remove. Use eddsa\nfunction twistedEdwards(c) {\n    const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);\n    const Point = edwards(CURVE, curveOpts);\n    const EDDSA = eddsa(Point, hash, eddsaOpts);\n    return _eddsa_new_output_to_legacy(c, EDDSA);\n} //# sourceMappingURL=edwards.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvZWR3YXJkcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBQ0Qsb0VBQW9FLEdBQytKO0FBQ3JKO0FBQ3pDO0FBQ3JDLHFFQUFxRTtBQUNyRSxrQkFBa0I7QUFDbEIsTUFBTXFCLE1BQU1DLE9BQU8sSUFBSUMsTUFBTUQsT0FBTyxJQUFJRSxNQUFNRixPQUFPLElBQUlHLE1BQU1ILE9BQU87QUFDdEUsU0FBU0ksWUFBWUMsRUFBRSxFQUFFQyxLQUFLLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUNoQyxNQUFNQyxLQUFLSixHQUFHSyxHQUFHLENBQUNIO0lBQ2xCLE1BQU1JLEtBQUtOLEdBQUdLLEdBQUcsQ0FBQ0Y7SUFDbEIsTUFBTUksT0FBT1AsR0FBR1EsR0FBRyxDQUFDUixHQUFHUyxHQUFHLENBQUNSLE1BQU1TLENBQUMsRUFBRU4sS0FBS0U7SUFDekMsTUFBTUssUUFBUVgsR0FBR1EsR0FBRyxDQUFDUixHQUFHWSxHQUFHLEVBQUVaLEdBQUdTLEdBQUcsQ0FBQ1IsTUFBTVksQ0FBQyxFQUFFYixHQUFHUyxHQUFHLENBQUNMLElBQUlFO0lBQ3hELE9BQU9OLEdBQUdjLEdBQUcsQ0FBQ1AsTUFBTUk7QUFDeEI7QUFDTyxTQUFTSSxRQUFRQyxNQUFNLEVBQUVDLFlBQVksQ0FBQyxDQUFDO0lBQzFDLE1BQU1DLFlBQVk3Qiw2REFBa0JBLENBQUMsV0FBVzJCLFFBQVFDLFdBQVdBLFVBQVVFLE1BQU07SUFDbkYsTUFBTSxFQUFFbkIsRUFBRSxFQUFFb0IsRUFBRSxFQUFFLEdBQUdGO0lBQ25CLElBQUlqQixRQUFRaUIsVUFBVWpCLEtBQUs7SUFDM0IsTUFBTSxFQUFFb0IsR0FBR0MsUUFBUSxFQUFFLEdBQUdyQjtJQUN4QjVCLDBEQUFlQSxDQUFDNEMsV0FBVyxDQUFDLEdBQUc7UUFBRU0sU0FBUztJQUFXO0lBQ3JELGFBQWE7SUFDYix1RUFBdUU7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eEQsT0FBTztRQUNsQkMsWUFBWXVELEVBQUV2RCxVQUFVO0lBQzVCO0lBQ0EsT0FBTztRQUFFdko7UUFBT2dOO1FBQVdwRCxNQUFNa0QsRUFBRWxELElBQUk7UUFBRVQ7SUFBVTtBQUN2RDtBQUNBLFNBQVM4RCw0QkFBNEJILENBQUMsRUFBRTdELEtBQUs7SUFDekMsTUFBTXJHLFFBQVFxRyxNQUFNckcsS0FBSztJQUN6QixNQUFNc0ssU0FBU2xKLE9BQU9tSixNQUFNLENBQUMsQ0FBQyxHQUFHbEUsT0FBTztRQUNwQ21FLGVBQWV4SztRQUNmNUMsT0FBTzhNO1FBQ1BDLFlBQVluSyxNQUFNekIsRUFBRSxDQUFDdUgsSUFBSTtRQUN6QjJFLGFBQWF6SyxNQUFNekIsRUFBRSxDQUFDSyxLQUFLO0lBQy9CO0lBQ0EsT0FBTzBMO0FBQ1g7QUFDQSwwQkFBMEI7QUFDbkIsU0FBU0ksZUFBZVIsQ0FBQztJQUM1QixNQUFNLEVBQUU5TSxLQUFLLEVBQUVnTixTQUFTLEVBQUVwRCxJQUFJLEVBQUVULFNBQVMsRUFBRSxHQUFHMEQsMEJBQTBCQztJQUN4RSxNQUFNbEssUUFBUTlCLFFBQVFkLE9BQU9nTjtJQUM3QixNQUFNTyxRQUFRdEUsTUFBTXJHLE9BQU9nSCxNQUFNVDtJQUNqQyxPQUFPOEQsNEJBQTRCSCxHQUFHUztBQUMxQyxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2Vkd2FyZHMuanM/NjhiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IGF4wrIgKyB5wrIgPSAxICsgZHjCsnnCsi5cbiAqIEZvciBkZXNpZ24gcmF0aW9uYWxlIG9mIHR5cGVzIC8gZXhwb3J0cywgc2VlIHdlaWVyc3RyYXNzIG1vZHVsZSBkb2N1bWVudGF0aW9uLlxuICogVW50d2lzdGVkIEVkd2FyZHMgY3VydmVzIGV4aXN0LCBidXQgdGhleSBhcmVuJ3QgdXNlZCBpbiByZWFsLXdvcmxkIHByb3RvY29scy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgX3ZhbGlkYXRlT2JqZWN0LCBfYWJvb2wyIGFzIGFib29sLCBfYWJ5dGVzMiBhcyBhYnl0ZXMsIGFJblJhbmdlLCBieXRlc1RvSGV4LCBieXRlc1RvTnVtYmVyTEUsIGNvbmNhdEJ5dGVzLCBjb3B5Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBpc0J5dGVzLCBtZW1vaXplZCwgbm90SW1wbGVtZW50ZWQsIHJhbmRvbUJ5dGVzIGFzIHJhbmRvbUJ5dGVzV2ViLCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgX2NyZWF0ZUN1cnZlRmllbGRzLCBub3JtYWxpemVaLCBwaXBwZW5nZXIsIHdOQUYsIH0gZnJvbSBcIi4vY3VydmUuanNcIjtcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSBcIi4vbW9kdWxhci5qc1wiO1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF84biA9IEJpZ0ludCg4KTtcbmZ1bmN0aW9uIGlzRWRWYWxpZFhZKEZwLCBDVVJWRSwgeCwgeSkge1xuICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpO1xuICAgIGNvbnN0IHkyID0gRnAuc3FyKHkpO1xuICAgIGNvbnN0IGxlZnQgPSBGcC5hZGQoRnAubXVsKENVUlZFLmEsIHgyKSwgeTIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gRnAuYWRkKEZwLk9ORSwgRnAubXVsKENVUlZFLmQsIEZwLm11bCh4MiwgeTIpKSk7XG4gICAgcmV0dXJuIEZwLmVxbChsZWZ0LCByaWdodCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZWR3YXJkcyhwYXJhbXMsIGV4dHJhT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdmFsaWRhdGVkID0gX2NyZWF0ZUN1cnZlRmllbGRzKCdlZHdhcmRzJywgcGFyYW1zLCBleHRyYU9wdHMsIGV4dHJhT3B0cy5GcEZuTEUpO1xuICAgIGNvbnN0IHsgRnAsIEZuIH0gPSB2YWxpZGF0ZWQ7XG4gICAgbGV0IENVUlZFID0gdmFsaWRhdGVkLkNVUlZFO1xuICAgIGNvbnN0IHsgaDogY29mYWN0b3IgfSA9IENVUlZFO1xuICAgIF92YWxpZGF0ZU9iamVjdChleHRyYU9wdHMsIHt9LCB7IHV2UmF0aW86ICdmdW5jdGlvbicgfSk7XG4gICAgLy8gSW1wb3J0YW50OlxuICAgIC8vIFRoZXJlIGFyZSBzb21lIHBsYWNlcyB3aGVyZSBGcC5CWVRFUyBpcyB1c2VkIGluc3RlYWQgb2YgbkJ5dGVMZW5ndGguXG4gICAgLy8gU28gZmFyLCBldmVyeXRoaW5nIGhhcyBiZWVuIHRlc3RlZCB3aXRoIGN1cnZlcyBvZiBGcC5CWVRFUyA9PSBuQnl0ZUxlbmd0aC5cbiAgICAvLyBUT0RPOiB0ZXN0IGFuZCBmaW5kIGN1cnZlcyB3aGljaCBiZWhhdmUgb3RoZXJ3aXNlLlxuICAgIGNvbnN0IE1BU0sgPSBfMm4gPDwgKEJpZ0ludChGbi5CWVRFUyAqIDgpIC0gXzFuKTtcbiAgICBjb25zdCBtb2RQID0gKG4pID0+IEZwLmNyZWF0ZShuKTsgLy8gRnVuY3Rpb24gb3ZlcnJpZGVzXG4gICAgLy8gc3FydCh1L3YpXG4gICAgY29uc3QgdXZSYXRpbyA9IGV4dHJhT3B0cy51dlJhdGlvIHx8XG4gICAgICAgICgodSwgdikgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCB2YWx1ZTogRnAuc3FydChGcC5kaXYodSwgdikpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCB2YWx1ZTogXzBuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIGVxdWF0aW9uIGF4wrIgKyB5wrIgPSAxICsgZHjCsnnCsiBzaG91bGQgd29yayBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIGlmICghaXNFZFZhbGlkWFkoRnAsIENVUlZFLCBDVVJWRS5HeCwgQ1VSVkUuR3kpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjdXJ2ZSBwYXJhbXM6IGdlbmVyYXRvciBwb2ludCcpO1xuICAgIC8qKlxuICAgICAqIEFzc2VydHMgY29vcmRpbmF0ZSBpcyB2YWxpZDogMCA8PSBuIDwgTUFTSy5cbiAgICAgKiBDb29yZGluYXRlcyA+PSBGcC5PUkRFUiBhcmUgYWxsb3dlZCBmb3IgemlwMjE1LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFjb29yZCh0aXRsZSwgbiwgYmFuWmVybyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IGJhblplcm8gPyBfMW4gOiBfMG47XG4gICAgICAgIGFJblJhbmdlKCdjb29yZGluYXRlICcgKyB0aXRsZSwgbiwgbWluLCBNQVNLKTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFleHRwb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZW5kZWRQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0cyBFeHRlbmRlZCBwb2ludCB0byBkZWZhdWx0ICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICBjb25zdCB0b0FmZmluZU1lbW8gPSBtZW1vaXplZCgocCwgaXopID0+IHtcbiAgICAgICAgY29uc3QgeyBYLCBZLCBaIH0gPSBwO1xuICAgICAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgIGl6ID0gaXMwID8gXzhuIDogRnAuaW52KFopOyAvLyA4IHdhcyBjaG9zZW4gYXJiaXRyYXJpbHlcbiAgICAgICAgY29uc3QgeCA9IG1vZFAoWCAqIGl6KTtcbiAgICAgICAgY29uc3QgeSA9IG1vZFAoWSAqIGl6KTtcbiAgICAgICAgY29uc3QgenogPSBGcC5tdWwoWiwgaXopO1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIHsgeDogXzBuLCB5OiBfMW4gfTtcbiAgICAgICAgaWYgKHp6ICE9PSBfMW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGFzc2VydFZhbGlkTWVtbyA9IG1lbW9pemVkKChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChwLmlzMCgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTsgLy8gVE9ETzogb3B0aW1pemUsIHdpdGggdmFycyBiZWxvdz9cbiAgICAgICAgLy8gRXF1YXRpb24gaW4gYWZmaW5lIGNvb3JkaW5hdGVzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrJcbiAgICAgICAgLy8gRXF1YXRpb24gaW4gcHJvamVjdGl2ZSBjb29yZGluYXRlcyAoWC9aLCBZL1osIFopOiAgKGFYwrIgKyBZwrIpWsKyID0gWuKBtCArIGRYwrJZwrJcbiAgICAgICAgY29uc3QgeyBYLCBZLCBaLCBUIH0gPSBwO1xuICAgICAgICBjb25zdCBYMiA9IG1vZFAoWCAqIFgpOyAvLyBYwrJcbiAgICAgICAgY29uc3QgWTIgPSBtb2RQKFkgKiBZKTsgLy8gWcKyXG4gICAgICAgIGNvbnN0IFoyID0gbW9kUChaICogWik7IC8vIFrCslxuICAgICAgICBjb25zdCBaNCA9IG1vZFAoWjIgKiBaMik7IC8vIFrigbRcbiAgICAgICAgY29uc3QgYVgyID0gbW9kUChYMiAqIGEpOyAvLyBhWMKyXG4gICAgICAgIGNvbnN0IGxlZnQgPSBtb2RQKFoyICogbW9kUChhWDIgKyBZMikpOyAvLyAoYVjCsiArIFnCsilawrJcbiAgICAgICAgY29uc3QgcmlnaHQgPSBtb2RQKFo0ICsgbW9kUChkICogbW9kUChYMiAqIFkyKSkpOyAvLyBa4oG0ICsgZFjCslnCslxuICAgICAgICBpZiAobGVmdCAhPT0gcmlnaHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMSknKTtcbiAgICAgICAgLy8gSW4gRXh0ZW5kZWQgY29vcmRpbmF0ZXMgd2UgYWxzbyBoYXZlIFQsIHdoaWNoIGlzIHgqeT1UL1o6IGNoZWNrIFgqWSA9PSBaKlRcbiAgICAgICAgY29uc3QgWFkgPSBtb2RQKFggKiBZKTtcbiAgICAgICAgY29uc3QgWlQgPSBtb2RQKFogKiBUKTtcbiAgICAgICAgaWYgKFhZICE9PSBaVClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgyKScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICAvLyBFeHRlbmRlZCBQb2ludCB3b3JrcyBpbiBleHRlbmRlZCBjb29yZGluYXRlczogKFgsIFksIFosIFQpIOKIiyAoeD1YL1osIHk9WS9aLCBUPXh5KS5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud2lzdGVkX0Vkd2FyZHNfY3VydmUjRXh0ZW5kZWRfY29vcmRpbmF0ZXNcbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKFgsIFksIFosIFQpIHtcbiAgICAgICAgICAgIHRoaXMuWCA9IGFjb29yZCgneCcsIFgpO1xuICAgICAgICAgICAgdGhpcy5ZID0gYWNvb3JkKCd5JywgWSk7XG4gICAgICAgICAgICB0aGlzLlogPSBhY29vcmQoJ3onLCBaLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuVCA9IGFjb29yZCgndCcsIFQpO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgQ1VSVkUoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ1VSVkU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuZGVkIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBhY29vcmQoJ3gnLCB4KTtcbiAgICAgICAgICAgIGFjb29yZCgneScsIHkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBfMW4sIG1vZFAoeCAqIHkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgICAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzLCB6aXAyMTUgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gRnAuQllURVM7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuICAgICAgICAgICAgYnl0ZXMgPSBjb3B5Qnl0ZXMoYWJ5dGVzKGJ5dGVzLCBsZW4sICdwb2ludCcpKTtcbiAgICAgICAgICAgIGFib29sKHppcDIxNSwgJ3ppcDIxNScpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWVkID0gY29weUJ5dGVzKGJ5dGVzKTsgLy8gY29weSBhZ2Fpbiwgd2UnbGwgbWFuaXB1bGF0ZSBpdFxuICAgICAgICAgICAgY29uc3QgbGFzdEJ5dGUgPSBieXRlc1tsZW4gLSAxXTsgLy8gc2VsZWN0IGxhc3QgYnl0ZVxuICAgICAgICAgICAgbm9ybWVkW2xlbiAtIDFdID0gbGFzdEJ5dGUgJiB+MHg4MDsgLy8gY2xlYXIgbGFzdCBiaXRcbiAgICAgICAgICAgIGNvbnN0IHkgPSBieXRlc1RvTnVtYmVyTEUobm9ybWVkKTtcbiAgICAgICAgICAgIC8vIHppcDIxNT10cnVlIGlzIGdvb2QgZm9yIGNvbnNlbnN1cy1jcml0aWNhbCBhcHBzLiA9ZmFsc2UgZm9sbG93cyBSRkM4MDMyIC8gTklTVDE4Ni01LlxuICAgICAgICAgICAgLy8gUkZDODAzMiBwcm9oaWJpdHMgPj0gcCwgYnV0IFpJUDIxNSBkb2Vzbid0XG4gICAgICAgICAgICAvLyB6aXAyMTU9dHJ1ZTogIDAgPD0geSA8IE1BU0sgKDJeMjU2IGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgLy8gemlwMjE1PWZhbHNlOiAwIDw9IHkgPCBQICgyXjI1NS0xOSBmb3IgZWQyNTUxOSlcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHppcDIxNSA/IE1BU0sgOiBGcC5PUkRFUjtcbiAgICAgICAgICAgIGFJblJhbmdlKCdwb2ludC55JywgeSwgXzBuLCBtYXgpO1xuICAgICAgICAgICAgLy8gRWQyNTUxOTogeMKyID0gKHnCsi0xKS8oZHnCsisxKSBtb2QgcC4gRWQ0NDg6IHjCsiA9ICh5wrItMSkvKGR5wrItMSkgbW9kIHAuIEdlbmVyaWMgY2FzZTpcbiAgICAgICAgICAgIC8vIGF4wrIrecKyPTErZHjCsnnCsiA9PiB5wrItMT1keMKyecKyLWF4wrIgPT4gecKyLTE9eMKyKGR5wrItYSkgPT4geMKyPSh5wrItMSkvKGR5wrItYSlcbiAgICAgICAgICAgIGNvbnN0IHkyID0gbW9kUCh5ICogeSk7IC8vIGRlbm9taW5hdG9yIGlzIGFsd2F5cyBub24tMCBtb2QgcC5cbiAgICAgICAgICAgIGNvbnN0IHUgPSBtb2RQKHkyIC0gXzFuKTsgLy8gdSA9IHnCsiAtIDFcbiAgICAgICAgICAgIGNvbnN0IHYgPSBtb2RQKGQgKiB5MiAtIGEpOyAvLyB2ID0gZCB5wrIgKyAxLlxuICAgICAgICAgICAgbGV0IHsgaXNWYWxpZCwgdmFsdWU6IHggfSA9IHV2UmF0aW8odSwgdik7IC8vIOKImih1L3YpXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGludmFsaWQgeSBjb29yZGluYXRlJyk7XG4gICAgICAgICAgICBjb25zdCBpc1hPZGQgPSAoeCAmIF8xbikgPT09IF8xbjsgLy8gVGhlcmUgYXJlIDIgc3F1YXJlIHJvb3RzLiBVc2UgeF8wIGJpdCB0byBzZWxlY3QgcHJvcGVyXG4gICAgICAgICAgICBjb25zdCBpc0xhc3RCeXRlT2RkID0gKGxhc3RCeXRlICYgMHg4MCkgIT09IDA7IC8vIHhfMCwgbGFzdCBiaXRcbiAgICAgICAgICAgIGlmICghemlwMjE1ICYmIHggPT09IF8wbiAmJiBpc0xhc3RCeXRlT2RkKVxuICAgICAgICAgICAgICAgIC8vIGlmIHg9MCBhbmQgeF8wID0gMSwgZmFpbFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4PTAgYW5kIHhfMD0xJyk7XG4gICAgICAgICAgICBpZiAoaXNMYXN0Qnl0ZU9kZCAhPT0gaXNYT2RkKVxuICAgICAgICAgICAgICAgIHggPSBtb2RQKC14KTsgLy8gaWYgeF8wICE9IHggbW9kIDIsIHNldCB4ID0gcC14XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZSh7IHgsIHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21IZXgoYnl0ZXMsIHppcDIxNSA9IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludCcsIGJ5dGVzKSwgemlwMjE1KTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBpc0xhenkgPSB0cnVlKSB7XG4gICAgICAgICAgICB3bmFmLmNyZWF0ZUNhY2hlKHRoaXMsIHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgaWYgKCFpc0xhenkpXG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBseShfMm4pOyAvLyByYW5kb20gbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2VmdWwgaW4gZnJvbUFmZmluZSgpIC0gbm90IGZvciBmcm9tQnl0ZXMoKSwgd2hpY2ggYWx3YXlzIGNyZWF0ZWQgdmFsaWQgcG9pbnRzLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFleHRwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiwgWjogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgWDFaMiA9IG1vZFAoWDEgKiBaMik7XG4gICAgICAgICAgICBjb25zdCBYMloxID0gbW9kUChYMiAqIFoxKTtcbiAgICAgICAgICAgIGNvbnN0IFkxWjIgPSBtb2RQKFkxICogWjIpO1xuICAgICAgICAgICAgY29uc3QgWTJaMSA9IG1vZFAoWTIgKiBaMSk7XG4gICAgICAgICAgICByZXR1cm4gWDFaMiA9PT0gWDJaMSAmJiBZMVoyID09PSBZMloxO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICAvLyBGbGlwcyBwb2ludCBzaWduIHRvIGEgbmVnYXRpdmUgb25lICgteCwgeSBpbiBhZmZpbmUgY29vcmRzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChtb2RQKC10aGlzLlgpLCB0aGlzLlksIHRoaXMuWiwgbW9kUCgtdGhpcy5UKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFzdCBhbGdvIGZvciBkb3VibGluZyBFeHRlbmRlZCBQb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgICAgICAgLy8gQ29zdDogNE0gKyA0UyArIDEqYSArIDZhZGQgKyAxKjIuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgxKTsgLy8gQSA9IFgxMlxuICAgICAgICAgICAgY29uc3QgQiA9IG1vZFAoWTEgKiBZMSk7IC8vIEIgPSBZMTJcbiAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKF8ybiAqIG1vZFAoWjEgKiBaMSkpOyAvLyBDID0gMipaMTJcbiAgICAgICAgICAgIGNvbnN0IEQgPSBtb2RQKGEgKiBBKTsgLy8gRCA9IGEqQVxuICAgICAgICAgICAgY29uc3QgeDF5MSA9IFgxICsgWTE7XG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUChtb2RQKHgxeTEgKiB4MXkxKSAtIEEgLSBCKTsgLy8gRSA9IChYMStZMSkyLUEtQlxuICAgICAgICAgICAgY29uc3QgRyA9IEQgKyBCOyAvLyBHID0gRCtCXG4gICAgICAgICAgICBjb25zdCBGID0gRyAtIEM7IC8vIEYgPSBHLUNcbiAgICAgICAgICAgIGNvbnN0IEggPSBEIC0gQjsgLy8gSCA9IEQtQlxuICAgICAgICAgICAgY29uc3QgWDMgPSBtb2RQKEUgKiBGKTsgLy8gWDMgPSBFKkZcbiAgICAgICAgICAgIGNvbnN0IFkzID0gbW9kUChHICogSCk7IC8vIFkzID0gRypIXG4gICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpOyAvLyBUMyA9IEUqSFxuICAgICAgICAgICAgY29uc3QgWjMgPSBtb2RQKEYgKiBHKTsgLy8gWjMgPSBGKkdcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhc3QgYWxnbyBmb3IgYWRkaW5nIDIgRXh0ZW5kZWQgUG9pbnRzLlxuICAgICAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjYWRkaXRpb24tYWRkLTIwMDgtaHdjZFxuICAgICAgICAvLyBDb3N0OiA5TSArIDEqYSArIDEqZCArIDdhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgYWV4dHBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEsIFQ6IFQxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBYOiBYMiwgWTogWTIsIFo6IFoyLCBUOiBUMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgyKTsgLy8gQSA9IFgxKlgyXG4gICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkyKTsgLy8gQiA9IFkxKlkyXG4gICAgICAgICAgICBjb25zdCBDID0gbW9kUChUMSAqIGQgKiBUMik7IC8vIEMgPSBUMSpkKlQyXG4gICAgICAgICAgICBjb25zdCBEID0gbW9kUChaMSAqIFoyKTsgLy8gRCA9IFoxKloyXG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUCgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpKihYMitZMiktQS1CXG4gICAgICAgICAgICBjb25zdCBGID0gRCAtIEM7IC8vIEYgPSBELUNcbiAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQzsgLy8gRyA9IEQrQ1xuICAgICAgICAgICAgY29uc3QgSCA9IG1vZFAoQiAtIGEgKiBBKTsgLy8gSCA9IEItYSpBXG4gICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpOyAvLyBYMyA9IEUqRlxuICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTsgLy8gWTMgPSBHKkhcbiAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG4gICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpOyAvLyBaMyA9IEYqR1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICAvLyAxIDw9IHNjYWxhciA8IExcbiAgICAgICAgICAgIGlmICghRm4uaXNWYWxpZE5vdDAoc2NhbGFyKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyOiBleHBlY3RlZCAxIDw9IHNjIDwgY3VydmUubicpO1xuICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB3bmFmLmNhY2hlZCh0aGlzLCBzY2FsYXIsIChwKSA9PiBub3JtYWxpemVaKFBvaW50LCBwKSk7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplWihQb2ludCwgW3AsIGZdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgIC8vIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgIC8vIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLlxuICAgICAgICAvLyBEb2VzIE5PVCBhbGxvdyBzY2FsYXJzIGhpZ2hlciB0aGFuIENVUlZFLm4uXG4gICAgICAgIC8vIEFjY2VwdHMgb3B0aW9uYWwgYWNjdW11bGF0b3IgdG8gbWVyZ2Ugd2l0aCBtdWx0aXBseSAoaW1wb3J0YW50IGZvciBzcGFyc2Ugc2NhbGFycylcbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyLCBhY2MgPSBQb2ludC5aRVJPKSB7XG4gICAgICAgICAgICAvLyAwIDw9IHNjYWxhciA8IExcbiAgICAgICAgICAgIGlmICghRm4uaXNWYWxpZChzY2FsYXIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXI6IGV4cGVjdGVkIDAgPD0gc2MgPCBjdXJ2ZS5uJyk7XG4gICAgICAgICAgICBpZiAoc2NhbGFyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSB8fCBzY2FsYXIgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZSh0aGlzLCBzY2FsYXIsIChwKSA9PiBub3JtYWxpemVaKFBvaW50LCBwKSwgYWNjKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVja3MgaWYgcG9pbnQgaXMgb2Ygc21hbGwgb3JkZXIuXG4gICAgICAgIC8vIElmIHlvdSBhZGQgc29tZXRoaW5nIHRvIHNtYWxsIG9yZGVyIHBvaW50LCB5b3Ugd2lsbCBoYXZlIFwiZGlydHlcIlxuICAgICAgICAvLyBwb2ludCB3aXRoIHRvcnNpb24gY29tcG9uZW50LlxuICAgICAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGNvZmFjdG9yIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgICAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShjb2ZhY3RvcikuaXMwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBwb2ludCBieSBjdXJ2ZSBvcmRlciBhbmQgY2hlY2tzIGlmIHRoZSByZXN1bHQgaXMgMC5cbiAgICAgICAgLy8gUmV0dXJucyBgZmFsc2VgIGlzIHRoZSBwb2ludCBpcyBkaXJ0eS5cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZSh0aGlzLCBDVVJWRS5uKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBFeHRlbmRlZCBwb2ludCB0byBkZWZhdWx0ICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIHRvQWZmaW5lKGludmVydGVkWikge1xuICAgICAgICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpbnZlcnRlZFopO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0b0J5dGVzKCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICAvLyBGcC50b0J5dGVzKCkgYWxsb3dzIG5vbi1jYW5vbmljYWwgZW5jb2Rpbmcgb2YgeSAoPj0gcCkuXG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IEZwLnRvQnl0ZXMoeSk7XG4gICAgICAgICAgICAvLyBFYWNoIHkgaGFzIDIgdmFsaWQgcG9pbnRzOiAoeCwgeSksICh4LC15KS5cbiAgICAgICAgICAgIC8vIFdoZW4gY29tcHJlc3NpbmcsIGl0J3MgZW5vdWdoIHRvIHN0b3JlIHkgYW5kIHVzZSB0aGUgbGFzdCBieXRlIHRvIGVuY29kZSBzaWduIG9mIHhcbiAgICAgICAgICAgIGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdIHw9IHggJiBfMW4gPyAweDgwIDogMDtcbiAgICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgfVxuICAgICAgICB0b0hleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcygpKTtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBgPFBvaW50ICR7dGhpcy5pczAoKSA/ICdaRVJPJyA6IHRoaXMudG9IZXgoKX0+YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgZ2V0IGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuWDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ZO1xuICAgICAgICB9XG4gICAgICAgIGdldCBleigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlo7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGV0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVaKFBvaW50LCBwb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBtc20ocG9pbnRzLCBzY2FsYXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGlwcGVuZ2VyKFBvaW50LCBGbiwgcG9pbnRzLCBzY2FsYXJzKTtcbiAgICAgICAgfVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnByZWNvbXB1dGUod2luZG93U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBiYXNlIC8gZ2VuZXJhdG9yIHBvaW50XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIF8xbiwgbW9kUChDVVJWRS5HeCAqIENVUlZFLkd5KSk7XG4gICAgLy8gemVybyAvIGluZmluaXR5IC8gaWRlbnRpdHkgcG9pbnRcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KF8wbiwgXzFuLCBfMW4sIF8wbik7IC8vIDAsIDEsIDEsIDBcbiAgICAvLyBtYXRoIGZpZWxkXG4gICAgUG9pbnQuRnAgPSBGcDtcbiAgICAvLyBzY2FsYXIgZmllbGRcbiAgICBQb2ludC5GbiA9IEZuO1xuICAgIGNvbnN0IHduYWYgPSBuZXcgd05BRihQb2ludCwgRm4uQklUUyk7XG4gICAgUG9pbnQuQkFTRS5wcmVjb21wdXRlKDgpOyAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgcmV0dXJuIFBvaW50O1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBwcmltZS1vcmRlciBwb2ludHMgbGlrZSBSaXN0cmV0dG8yNTUgYW5kIERlY2FmNDQ4LlxuICogVGhlc2UgcG9pbnRzIGVsaW1pbmF0ZSBjb2ZhY3RvciBpc3N1ZXMgYnkgcmVwcmVzZW50aW5nIGVxdWl2YWxlbmNlIGNsYXNzZXNcbiAqIG9mIEVkd2FyZHMgY3VydmUgcG9pbnRzLlxuICovXG5leHBvcnQgY2xhc3MgUHJpbWVFZHdhcmRzUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKGVwKSB7XG4gICAgICAgIHRoaXMuZXAgPSBlcDtcbiAgICB9XG4gICAgLy8gU3RhdGljIG1ldGhvZHMgdGhhdCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXNcbiAgICBzdGF0aWMgZnJvbUJ5dGVzKF9ieXRlcykge1xuICAgICAgICBub3RJbXBsZW1lbnRlZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChfaGV4KSB7XG4gICAgICAgIG5vdEltcGxlbWVudGVkKCk7XG4gICAgfVxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgfVxuICAgIC8vIENvbW1vbiBpbXBsZW1lbnRhdGlvbnNcbiAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAvLyBuby1vcCBmb3IgcHJpbWUtb3JkZXIgZ3JvdXBzXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgdGhpcy5lcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIH1cbiAgICB0b0FmZmluZShpbnZlcnRlZFopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXAudG9BZmZpbmUoaW52ZXJ0ZWRaKTtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcygpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XG4gICAgfVxuICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2FtZShvdGhlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQodGhpcy5lcC5hZGQob3RoZXIuZXApKTtcbiAgICB9XG4gICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTYW1lKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCh0aGlzLmVwLnN1YnRyYWN0KG90aGVyLmVwKSk7XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubXVsdGlwbHkoc2NhbGFyKSk7XG4gICAgfVxuICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubXVsdGlwbHlVbnNhZmUoc2NhbGFyKSk7XG4gICAgfVxuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCh0aGlzLmVwLmRvdWJsZSgpKTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubmVnYXRlKCkpO1xuICAgIH1cbiAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUsIGlzTGF6eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAucHJlY29tcHV0ZSh3aW5kb3dTaXplLCBpc0xhenkpKTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgdG9CeXRlc2AgKi9cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCk7XG4gICAgfVxufVxuLyoqXG4gKiBJbml0aWFsaXplcyBFZERTQSBzaWduYXR1cmVzIG92ZXIgZ2l2ZW4gRWR3YXJkcyBjdXJ2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkZHNhKFBvaW50LCBjSGFzaCwgZWRkc2FPcHRzID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGNIYXNoICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiaGFzaFwiIGZ1bmN0aW9uIHBhcmFtIGlzIHJlcXVpcmVkJyk7XG4gICAgX3ZhbGlkYXRlT2JqZWN0KGVkZHNhT3B0cywge30sIHtcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBkb21haW46ICdmdW5jdGlvbicsXG4gICAgICAgIHByZWhhc2g6ICdmdW5jdGlvbicsXG4gICAgICAgIG1hcFRvQ3VydmU6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwcmVoYXNoIH0gPSBlZGRzYU9wdHM7XG4gICAgY29uc3QgeyBCQVNFLCBGcCwgRm4gfSA9IFBvaW50O1xuICAgIGNvbnN0IHJhbmRvbUJ5dGVzID0gZWRkc2FPcHRzLnJhbmRvbUJ5dGVzIHx8IHJhbmRvbUJ5dGVzV2ViO1xuICAgIGNvbnN0IGFkanVzdFNjYWxhckJ5dGVzID0gZWRkc2FPcHRzLmFkanVzdFNjYWxhckJ5dGVzIHx8ICgoYnl0ZXMpID0+IGJ5dGVzKTtcbiAgICBjb25zdCBkb21haW4gPSBlZGRzYU9wdHMuZG9tYWluIHx8XG4gICAgICAgICgoZGF0YSwgY3R4LCBwaGZsYWcpID0+IHtcbiAgICAgICAgICAgIGFib29sKHBoZmxhZywgJ3BoZmxhZycpO1xuICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGggfHwgcGhmbGFnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dHMvcHJlLWhhc2ggYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTsgLy8gTk9PUFxuICAgIC8vIExpdHRsZS1lbmRpYW4gU0hBNTEyIHdpdGggbW9kdWxvIG5cbiAgICBmdW5jdGlvbiBtb2ROX0xFKGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIEZuLmNyZWF0ZShieXRlc1RvTnVtYmVyTEUoaGFzaCkpOyAvLyBOb3QgRm4uZnJvbUJ5dGVzOiBpdCBoYXMgbGVuZ3RoIGxpbWl0XG4gICAgfVxuICAgIC8vIEdldCB0aGUgaGFzaGVkIHByaXZhdGUgc2NhbGFyIHBlciBSRkM4MDMyIDUuMS41XG4gICAgZnVuY3Rpb24gZ2V0UHJpdmF0ZVNjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbGVuZ3Rocy5zZWNyZXRLZXk7XG4gICAgICAgIGtleSA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbGVuKTtcbiAgICAgICAgLy8gSGFzaCBwcml2YXRlIGtleSB3aXRoIGN1cnZlJ3MgaGFzaCBmdW5jdGlvbiB0byBwcm9kdWNlIHVuaWZvcm1pbmdseSByYW5kb20gaW5wdXRcbiAgICAgICAgLy8gQ2hlY2sgYnl0ZSBsZW5ndGhzOiBlbnN1cmUoNjQsIGgoZW5zdXJlKDMyLCBrZXkpKSlcbiAgICAgICAgY29uc3QgaGFzaGVkID0gZW5zdXJlQnl0ZXMoJ2hhc2hlZCBwcml2YXRlIGtleScsIGNIYXNoKGtleSksIDIgKiBsZW4pO1xuICAgICAgICBjb25zdCBoZWFkID0gYWRqdXN0U2NhbGFyQnl0ZXMoaGFzaGVkLnNsaWNlKDAsIGxlbikpOyAvLyBjbGVhciBmaXJzdCBoYWxmIGJpdHMsIHByb2R1Y2UgRkVcbiAgICAgICAgY29uc3QgcHJlZml4ID0gaGFzaGVkLnNsaWNlKGxlbiwgMiAqIGxlbik7IC8vIHNlY29uZCBoYWxmIGlzIGNhbGxlZCBrZXkgcHJlZml4ICg1LjEuNilcbiAgICAgICAgY29uc3Qgc2NhbGFyID0gbW9kTl9MRShoZWFkKTsgLy8gVGhlIGFjdHVhbCBwcml2YXRlIHNjYWxhclxuICAgICAgICByZXR1cm4geyBoZWFkLCBwcmVmaXgsIHNjYWxhciB9O1xuICAgIH1cbiAgICAvKiogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgY3JlYXRlcyBwdWJsaWMga2V5IGZyb20gc2NhbGFyLiBSRkM4MDMyIDUuMS41ICovXG4gICAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoc2VjcmV0S2V5KSB7XG4gICAgICAgIGNvbnN0IHsgaGVhZCwgcHJlZml4LCBzY2FsYXIgfSA9IGdldFByaXZhdGVTY2FsYXIoc2VjcmV0S2V5KTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBCQVNFLm11bHRpcGx5KHNjYWxhcik7IC8vIFBvaW50IG9uIEVkd2FyZHMgY3VydmUgYWthIHB1YmxpYyBrZXlcbiAgICAgICAgY29uc3QgcG9pbnRCeXRlcyA9IHBvaW50LnRvQnl0ZXMoKTtcbiAgICAgICAgcmV0dXJuIHsgaGVhZCwgcHJlZml4LCBzY2FsYXIsIHBvaW50LCBwb2ludEJ5dGVzIH07XG4gICAgfVxuICAgIC8qKiBDYWxjdWxhdGVzIEVkRFNBIHB1YiBrZXkuIFJGQzgwMzIgNS4xLjUuICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHNlY3JldEtleSkge1xuICAgICAgICByZXR1cm4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoc2VjcmV0S2V5KS5wb2ludEJ5dGVzO1xuICAgIH1cbiAgICAvLyBpbnQoJ0xFJywgU0hBNTEyKGRvbTIoRiwgQykgfHwgbXNncykpIG1vZCBOXG4gICAgZnVuY3Rpb24gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQgPSBVaW50OEFycmF5Lm9mKCksIC4uLm1zZ3MpIHtcbiAgICAgICAgY29uc3QgbXNnID0gY29uY2F0Qnl0ZXMoLi4ubXNncyk7XG4gICAgICAgIHJldHVybiBtb2ROX0xFKGNIYXNoKGRvbWFpbihtc2csIGVuc3VyZUJ5dGVzKCdjb250ZXh0JywgY29udGV4dCksICEhcHJlaGFzaCkpKTtcbiAgICB9XG4gICAgLyoqIFNpZ25zIG1lc3NhZ2Ugd2l0aCBwcml2YXRlS2V5LiBSRkM4MDMyIDUuMS42ICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2csIHNlY3JldEtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIG1zZyA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2cgPSBwcmVoYXNoKG1zZyk7IC8vIGZvciBlZDI1NTE5cGggZXRjLlxuICAgICAgICBjb25zdCB7IHByZWZpeCwgc2NhbGFyLCBwb2ludEJ5dGVzIH0gPSBnZXRFeHRlbmRlZFB1YmxpY0tleShzZWNyZXRLZXkpO1xuICAgICAgICBjb25zdCByID0gaGFzaERvbWFpblRvU2NhbGFyKG9wdGlvbnMuY29udGV4dCwgcHJlZml4LCBtc2cpOyAvLyByID0gZG9tMihGLCBDKSB8fCBwcmVmaXggfHwgUEgoTSlcbiAgICAgICAgY29uc3QgUiA9IEJBU0UubXVsdGlwbHkocikudG9CeXRlcygpOyAvLyBSID0gckdcbiAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihvcHRpb25zLmNvbnRleHQsIFIsIHBvaW50Qnl0ZXMsIG1zZyk7IC8vIFIgfHwgQSB8fCBQSChNKVxuICAgICAgICBjb25zdCBzID0gRm4uY3JlYXRlKHIgKyBrICogc2NhbGFyKTsgLy8gUyA9IChyICsgayAqIHMpIG1vZCBMXG4gICAgICAgIGlmICghRm4uaXNWYWxpZChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbiBmYWlsZWQ6IGludmFsaWQgcycpOyAvLyAwIDw9IHMgPCBMXG4gICAgICAgIGNvbnN0IHJzID0gY29uY2F0Qnl0ZXMoUiwgRm4udG9CeXRlcyhzKSk7XG4gICAgICAgIHJldHVybiBhYnl0ZXMocnMsIGxlbmd0aHMuc2lnbmF0dXJlLCAncmVzdWx0Jyk7XG4gICAgfVxuICAgIC8vIHZlcmlmaWNhdGlvbiBydWxlIGlzIGVpdGhlciB6aXAyMTUgb3IgcmZjODAzMiAvIG5pc3QxODYtNS4gQ29uc3VsdCBmcm9tSGV4OlxuICAgIGNvbnN0IHZlcmlmeU9wdHMgPSB7IHppcDIxNTogdHJ1ZSB9O1xuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIEVkRFNBIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuIFJGQzgwMzIgNS4xLjcuXG4gICAgICogQW4gZXh0ZW5kZWQgZ3JvdXAgZXF1YXRpb24gaXMgY2hlY2tlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnLCBtc2csIHB1YmxpY0tleSwgb3B0aW9ucyA9IHZlcmlmeU9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0LCB6aXAyMTUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlbmd0aHMuc2lnbmF0dXJlO1xuICAgICAgICBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnLCBsZW4pO1xuICAgICAgICBtc2cgPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1zZyk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIGxlbmd0aHMucHVibGljS2V5KTtcbiAgICAgICAgaWYgKHppcDIxNSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYWJvb2woemlwMjE1LCAnemlwMjE1Jyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnID0gcHJlaGFzaChtc2cpOyAvLyBmb3IgZWQyNTUxOXBoLCBldGNcbiAgICAgICAgY29uc3QgbWlkID0gbGVuIC8gMjtcbiAgICAgICAgY29uc3QgciA9IHNpZy5zdWJhcnJheSgwLCBtaWQpO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckxFKHNpZy5zdWJhcnJheShtaWQsIGxlbikpO1xuICAgICAgICBsZXQgQSwgUiwgU0I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB6aXAyMTU9dHJ1ZSBpcyBnb29kIGZvciBjb25zZW5zdXMtY3JpdGljYWwgYXBwcy4gPWZhbHNlIGZvbGxvd3MgUkZDODAzMiAvIE5JU1QxODYtNS5cbiAgICAgICAgICAgIC8vIHppcDIxNT10cnVlOiAgMCA8PSB5IDwgTUFTSyAoMl4yNTYgZm9yIGVkMjU1MTkpXG4gICAgICAgICAgICAvLyB6aXAyMTU9ZmFsc2U6IDAgPD0geSA8IFAgKDJeMjU1LTE5IGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgQSA9IFBvaW50LmZyb21CeXRlcyhwdWJsaWNLZXksIHppcDIxNSk7XG4gICAgICAgICAgICBSID0gUG9pbnQuZnJvbUJ5dGVzKHIsIHppcDIxNSk7XG4gICAgICAgICAgICBTQiA9IEJBU0UubXVsdGlwbHlVbnNhZmUocyk7IC8vIDAgPD0gcyA8IGwgaXMgZG9uZSBpbnNpZGVcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXppcDIxNSAmJiBBLmlzU21hbGxPcmRlcigpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB6aXAyMTUgYWxsb3dzIHB1YmxpYyBrZXlzIG9mIHNtYWxsIG9yZGVyXG4gICAgICAgIGNvbnN0IGsgPSBoYXNoRG9tYWluVG9TY2FsYXIoY29udGV4dCwgUi50b0J5dGVzKCksIEEudG9CeXRlcygpLCBtc2cpO1xuICAgICAgICBjb25zdCBSa0EgPSBSLmFkZChBLm11bHRpcGx5VW5zYWZlKGspKTtcbiAgICAgICAgLy8gRXh0ZW5kZWQgZ3JvdXAgZXF1YXRpb25cbiAgICAgICAgLy8gWzhdW1NdQiA9IFs4XVIgKyBbOF1ba11BJ1xuICAgICAgICByZXR1cm4gUmtBLnN1YnRyYWN0KFNCKS5jbGVhckNvZmFjdG9yKCkuaXMwKCk7XG4gICAgfVxuICAgIGNvbnN0IF9zaXplID0gRnAuQllURVM7IC8vIDMyIGZvciBlZDI1NTE5LCA1NyBmb3IgZWQ0NDhcbiAgICBjb25zdCBsZW5ndGhzID0ge1xuICAgICAgICBzZWNyZXRLZXk6IF9zaXplLFxuICAgICAgICBwdWJsaWNLZXk6IF9zaXplLFxuICAgICAgICBzaWduYXR1cmU6IDIgKiBfc2l6ZSxcbiAgICAgICAgc2VlZDogX3NpemUsXG4gICAgfTtcbiAgICBmdW5jdGlvbiByYW5kb21TZWNyZXRLZXkoc2VlZCA9IHJhbmRvbUJ5dGVzKGxlbmd0aHMuc2VlZCkpIHtcbiAgICAgICAgcmV0dXJuIGFieXRlcyhzZWVkLCBsZW5ndGhzLnNlZWQsICdzZWVkJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtleWdlbihzZWVkKSB7XG4gICAgICAgIGNvbnN0IHNlY3JldEtleSA9IHV0aWxzLnJhbmRvbVNlY3JldEtleShzZWVkKTtcbiAgICAgICAgcmV0dXJuIHsgc2VjcmV0S2V5LCBwdWJsaWNLZXk6IGdldFB1YmxpY0tleShzZWNyZXRLZXkpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRTZWNyZXRLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0J5dGVzKGtleSkgJiYga2V5Lmxlbmd0aCA9PT0gRm4uQllURVM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRQdWJsaWNLZXkoa2V5LCB6aXAyMTUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhIVBvaW50LmZyb21CeXRlcyhrZXksIHppcDIxNSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGdldEV4dGVuZGVkUHVibGljS2V5LFxuICAgICAgICByYW5kb21TZWNyZXRLZXksXG4gICAgICAgIGlzVmFsaWRTZWNyZXRLZXksXG4gICAgICAgIGlzVmFsaWRQdWJsaWNLZXksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBlZCBwdWJsaWMga2V5IHRvIHggcHVibGljIGtleS4gVXNlcyBmb3JtdWxhOlxuICAgICAgICAgKiAtIGVkMjU1MTk6XG4gICAgICAgICAqICAgLSBgKHUsIHYpID0gKCgxK3kpLygxLXkpLCBzcXJ0KC00ODY2NjQpKnUveClgXG4gICAgICAgICAqICAgLSBgKHgsIHkpID0gKHNxcnQoLTQ4NjY2NCkqdS92LCAodS0xKS8odSsxKSlgXG4gICAgICAgICAqIC0gZWQ0NDg6XG4gICAgICAgICAqICAgLSBgKHUsIHYpID0gKCh5LTEpLyh5KzEpLCBzcXJ0KDE1NjMyNCkqdS94KWBcbiAgICAgICAgICogICAtIGAoeCwgeSkgPSAoc3FydCgxNTYzMjQpKnUvdiwgKDErdSkvKDEtdSkpYFxuICAgICAgICAgKi9cbiAgICAgICAgdG9Nb250Z29tZXJ5KHB1YmxpY0tleSkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSBQb2ludC5mcm9tQnl0ZXMocHVibGljS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBsZW5ndGhzLnB1YmxpY0tleTtcbiAgICAgICAgICAgIGNvbnN0IGlzMjU1MTkgPSBzaXplID09PSAzMjtcbiAgICAgICAgICAgIGlmICghaXMyNTUxOSAmJiBzaXplICE9PSA1NylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgZGVmaW5lZCBmb3IgMjU1MTkgYW5kIDQ0OCcpO1xuICAgICAgICAgICAgY29uc3QgdSA9IGlzMjU1MTkgPyBGcC5kaXYoXzFuICsgeSwgXzFuIC0geSkgOiBGcC5kaXYoeSAtIF8xbiwgeSArIF8xbik7XG4gICAgICAgICAgICByZXR1cm4gRnAudG9CeXRlcyh1KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9Nb250Z29tZXJ5UHJpdihzZWNyZXRLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBsZW5ndGhzLnNlY3JldEtleTtcbiAgICAgICAgICAgIGFieXRlcyhzZWNyZXRLZXksIHNpemUpO1xuICAgICAgICAgICAgY29uc3QgaGFzaGVkID0gY0hhc2goc2VjcmV0S2V5LnN1YmFycmF5KDAsIHNpemUpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGp1c3RTY2FsYXJCeXRlcyhoYXNoZWQpLnN1YmFycmF5KDAsIHNpemUpO1xuICAgICAgICB9LFxuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogcmFuZG9tU2VjcmV0S2V5LFxuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQucHJlY29tcHV0ZSh3aW5kb3dTaXplLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGtleWdlbixcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIHV0aWxzLFxuICAgICAgICBQb2ludCxcbiAgICAgICAgbGVuZ3RocyxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9lZGRzYV9sZWdhY3lfb3B0c190b19uZXcoYykge1xuICAgIGNvbnN0IENVUlZFID0ge1xuICAgICAgICBhOiBjLmEsXG4gICAgICAgIGQ6IGMuZCxcbiAgICAgICAgcDogYy5GcC5PUkRFUixcbiAgICAgICAgbjogYy5uLFxuICAgICAgICBoOiBjLmgsXG4gICAgICAgIEd4OiBjLkd4LFxuICAgICAgICBHeTogYy5HeSxcbiAgICB9O1xuICAgIGNvbnN0IEZwID0gYy5GcDtcbiAgICBjb25zdCBGbiA9IEZpZWxkKENVUlZFLm4sIGMubkJpdExlbmd0aCwgdHJ1ZSk7XG4gICAgY29uc3QgY3VydmVPcHRzID0geyBGcCwgRm4sIHV2UmF0aW86IGMudXZSYXRpbyB9O1xuICAgIGNvbnN0IGVkZHNhT3B0cyA9IHtcbiAgICAgICAgcmFuZG9tQnl0ZXM6IGMucmFuZG9tQnl0ZXMsXG4gICAgICAgIGFkanVzdFNjYWxhckJ5dGVzOiBjLmFkanVzdFNjYWxhckJ5dGVzLFxuICAgICAgICBkb21haW46IGMuZG9tYWluLFxuICAgICAgICBwcmVoYXNoOiBjLnByZWhhc2gsXG4gICAgICAgIG1hcFRvQ3VydmU6IGMubWFwVG9DdXJ2ZSxcbiAgICB9O1xuICAgIHJldHVybiB7IENVUlZFLCBjdXJ2ZU9wdHMsIGhhc2g6IGMuaGFzaCwgZWRkc2FPcHRzIH07XG59XG5mdW5jdGlvbiBfZWRkc2FfbmV3X291dHB1dF90b19sZWdhY3koYywgZWRkc2EpIHtcbiAgICBjb25zdCBQb2ludCA9IGVkZHNhLlBvaW50O1xuICAgIGNvbnN0IGxlZ2FjeSA9IE9iamVjdC5hc3NpZ24oe30sIGVkZHNhLCB7XG4gICAgICAgIEV4dGVuZGVkUG9pbnQ6IFBvaW50LFxuICAgICAgICBDVVJWRTogYyxcbiAgICAgICAgbkJpdExlbmd0aDogUG9pbnQuRm4uQklUUyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6IFBvaW50LkZuLkJZVEVTLFxuICAgIH0pO1xuICAgIHJldHVybiBsZWdhY3k7XG59XG4vLyBUT0RPOiByZW1vdmUuIFVzZSBlZGRzYVxuZXhwb3J0IGZ1bmN0aW9uIHR3aXN0ZWRFZHdhcmRzKGMpIHtcbiAgICBjb25zdCB7IENVUlZFLCBjdXJ2ZU9wdHMsIGhhc2gsIGVkZHNhT3B0cyB9ID0gX2VkZHNhX2xlZ2FjeV9vcHRzX3RvX25ldyhjKTtcbiAgICBjb25zdCBQb2ludCA9IGVkd2FyZHMoQ1VSVkUsIGN1cnZlT3B0cyk7XG4gICAgY29uc3QgRUREU0EgPSBlZGRzYShQb2ludCwgaGFzaCwgZWRkc2FPcHRzKTtcbiAgICByZXR1cm4gX2VkZHNhX25ld19vdXRwdXRfdG9fbGVnYWN5KGMsIEVERFNBKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkd2FyZHMuanMubWFwIl0sIm5hbWVzIjpbIl92YWxpZGF0ZU9iamVjdCIsIl9hYm9vbDIiLCJhYm9vbCIsIl9hYnl0ZXMyIiwiYWJ5dGVzIiwiYUluUmFuZ2UiLCJieXRlc1RvSGV4IiwiYnl0ZXNUb051bWJlckxFIiwiY29uY2F0Qnl0ZXMiLCJjb3B5Qnl0ZXMiLCJlbnN1cmVCeXRlcyIsImlzQnl0ZXMiLCJtZW1vaXplZCIsIm5vdEltcGxlbWVudGVkIiwicmFuZG9tQnl0ZXMiLCJyYW5kb21CeXRlc1dlYiIsIl9jcmVhdGVDdXJ2ZUZpZWxkcyIsIm5vcm1hbGl6ZVoiLCJwaXBwZW5nZXIiLCJ3TkFGIiwiRmllbGQiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfOG4iLCJpc0VkVmFsaWRYWSIsIkZwIiwiQ1VSVkUiLCJ4IiwieSIsIngyIiwic3FyIiwieTIiLCJsZWZ0IiwiYWRkIiwibXVsIiwiYSIsInJpZ2h0IiwiT05FIiwiZCIsImVxbCIsImVkd2FyZHMiLCJwYXJhbXMiLCJleHRyYU9wdHMiLCJ2YWxpZGF0ZWQiLCJGcEZuTEUiLCJGbiIsImgiLCJjb2ZhY3RvciIsInV2UmF0aW8iLCJNQVNLIiwiQllURVMiLCJtb2RQIiwibiIsImNyZWF0ZSIsInUiLCJ2IiwiaXNWYWxpZCIsInZhbHVlIiwic3FydCIsImRpdiIsImUiLCJHeCIsIkd5IiwiRXJyb3IiLCJhY29vcmQiLCJ0aXRsZSIsImJhblplcm8iLCJtaW4iLCJhZXh0cG9pbnQiLCJvdGhlciIsIlBvaW50IiwidG9BZmZpbmVNZW1vIiwicCIsIml6IiwiWCIsIlkiLCJaIiwiaXMwIiwiaW52IiwienoiLCJhc3NlcnRWYWxpZE1lbW8iLCJUIiwiWDIiLCJZMiIsIloyIiwiWjQiLCJhWDIiLCJYWSIsIlpUIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJmcmVlemUiLCJmcm9tQWZmaW5lIiwiZnJvbUJ5dGVzIiwiYnl0ZXMiLCJ6aXAyMTUiLCJsZW4iLCJub3JtZWQiLCJsYXN0Qnl0ZSIsIm1heCIsIk9SREVSIiwiaXNYT2RkIiwiaXNMYXN0Qnl0ZU9kZCIsImZyb21IZXgiLCJ0b0FmZmluZSIsInByZWNvbXB1dGUiLCJ3aW5kb3dTaXplIiwiaXNMYXp5Iiwid25hZiIsImNyZWF0ZUNhY2hlIiwibXVsdGlwbHkiLCJhc3NlcnRWYWxpZGl0eSIsImVxdWFscyIsIlgxIiwiWTEiLCJaMSIsIlgxWjIiLCJYMloxIiwiWTFaMiIsIlkyWjEiLCJaRVJPIiwibmVnYXRlIiwiZG91YmxlIiwiQSIsIkIiLCJDIiwiRCIsIngxeTEiLCJFIiwiRyIsIkYiLCJIIiwiWDMiLCJZMyIsIlQzIiwiWjMiLCJUMSIsIlQyIiwic3VidHJhY3QiLCJzY2FsYXIiLCJpc1ZhbGlkTm90MCIsImYiLCJjYWNoZWQiLCJtdWx0aXBseVVuc2FmZSIsImFjYyIsInVuc2FmZSIsImlzU21hbGxPcmRlciIsImlzVG9yc2lvbkZyZWUiLCJpbnZlcnRlZFoiLCJjbGVhckNvZmFjdG9yIiwidG9CeXRlcyIsImxlbmd0aCIsInRvSGV4IiwidG9TdHJpbmciLCJleCIsImV5IiwiZXoiLCJldCIsInBvaW50cyIsIm1zbSIsInNjYWxhcnMiLCJfc2V0V2luZG93U2l6ZSIsInRvUmF3Qnl0ZXMiLCJCQVNFIiwiQklUUyIsIlByaW1lRWR3YXJkc1BvaW50IiwiZXAiLCJfYnl0ZXMiLCJfaGV4IiwiYXNzZXJ0U2FtZSIsImluaXQiLCJlZGRzYSIsImNIYXNoIiwiZWRkc2FPcHRzIiwiYWRqdXN0U2NhbGFyQnl0ZXMiLCJkb21haW4iLCJwcmVoYXNoIiwibWFwVG9DdXJ2ZSIsImRhdGEiLCJjdHgiLCJwaGZsYWciLCJtb2ROX0xFIiwiaGFzaCIsImdldFByaXZhdGVTY2FsYXIiLCJrZXkiLCJsZW5ndGhzIiwic2VjcmV0S2V5IiwiaGFzaGVkIiwiaGVhZCIsInNsaWNlIiwicHJlZml4IiwiZ2V0RXh0ZW5kZWRQdWJsaWNLZXkiLCJwb2ludCIsInBvaW50Qnl0ZXMiLCJnZXRQdWJsaWNLZXkiLCJoYXNoRG9tYWluVG9TY2FsYXIiLCJjb250ZXh0IiwiVWludDhBcnJheSIsIm9mIiwibXNncyIsIm1zZyIsInNpZ24iLCJvcHRpb25zIiwiciIsIlIiLCJrIiwicyIsInJzIiwic2lnbmF0dXJlIiwidmVyaWZ5T3B0cyIsInZlcmlmeSIsInNpZyIsInB1YmxpY0tleSIsInVuZGVmaW5lZCIsIm1pZCIsInN1YmFycmF5IiwiU0IiLCJlcnJvciIsIlJrQSIsIl9zaXplIiwic2VlZCIsInJhbmRvbVNlY3JldEtleSIsImtleWdlbiIsInV0aWxzIiwiaXNWYWxpZFNlY3JldEtleSIsImlzVmFsaWRQdWJsaWNLZXkiLCJ0b01vbnRnb21lcnkiLCJzaXplIiwiaXMyNTUxOSIsInRvTW9udGdvbWVyeVByaXYiLCJyYW5kb21Qcml2YXRlS2V5IiwiX2VkZHNhX2xlZ2FjeV9vcHRzX3RvX25ldyIsImMiLCJuQml0TGVuZ3RoIiwiY3VydmVPcHRzIiwiX2VkZHNhX25ld19vdXRwdXRfdG9fbGVnYWN5IiwibGVnYWN5IiwiYXNzaWduIiwiRXh0ZW5kZWRQb2ludCIsIm5CeXRlTGVuZ3RoIiwidHdpc3RlZEVkd2FyZHMiLCJFRERTQSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/edwards.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _DST_scalar: () => (/* binding */ _DST_scalar),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << 8 * length) throw new Error(\"invalid I2OSP input: \" + value);\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\nfunction normDST(DST) {\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes)(DST) && typeof DST !== \"string\") throw new Error(\"DST must be Uint8Array or string\");\n    return typeof DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(DST) : DST;\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */ function expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(msg);\n    anum(lenInBytes);\n    DST = normDST(DST);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255) throw new Error(\"expand_message_xmd: invalid lenInBytes\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */ function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(msg);\n    anum(lenInBytes);\n    DST = normDST(DST);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(options, {\n        p: \"bigint\",\n        m: \"number\",\n        k: \"number\",\n        hash: \"function\"\n    });\n    const { p, k, m, hash, expand, DST } = options;\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isHash)(options.hash)) throw new Error(\"expected valid hash\");\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(msg);\n    anum(count);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xn, xd, yn, yd] = coeff.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.FpInvertBatch)(field, [\n            xd,\n            yd\n        ], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nconst _DST_scalar = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"HashToScalar-\");\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */ function createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        hashToCurve (msg, options) {\n            const opts = Object.assign({}, defaults, options);\n            const u = hash_to_field(msg, 2, opts);\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        encodeToCurve (msg, options) {\n            const optsDst = defaults.encodeDST ? {\n                DST: defaults.encodeDST\n            } : {};\n            const opts = Object.assign({}, defaults, optsDst, options);\n            const u = hash_to_field(msg, 1, opts);\n            const u0 = map(u[0]);\n            return clear(u0);\n        },\n        /** See {@link H2CHasher} */ mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(\"expected array of bigints\");\n            return clear(map(scalars));\n        },\n        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393\n        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08\n        hashToScalar (msg, options) {\n            // @ts-ignore\n            const N = Point.Fn.ORDER;\n            const opts = Object.assign({}, defaults, {\n                p: N,\n                m: 1,\n                DST: _DST_scalar\n            }, options);\n            return hash_to_field(msg, 1, opts)[0][0];\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBbUg7QUFDakU7QUFDbEQsNkZBQTZGO0FBQzdGLE1BQU1TLFFBQVFQLHNEQUFlQTtBQUM3Qiw0Q0FBNEM7QUFDNUMsU0FBU1EsTUFBTUMsS0FBSyxFQUFFQyxNQUFNO0lBQ3hCQyxLQUFLRjtJQUNMRSxLQUFLRDtJQUNMLElBQUlELFFBQVEsS0FBS0EsU0FBUyxLQUFNLElBQUlDLFFBQ2hDLE1BQU0sSUFBSUUsTUFBTSwwQkFBMEJIO0lBQzlDLE1BQU1JLE1BQU1DLE1BQU1DLElBQUksQ0FBQztRQUFFTDtJQUFPLEdBQUdNLElBQUksQ0FBQztJQUN4QyxJQUFLLElBQUlDLElBQUlQLFNBQVMsR0FBR08sS0FBSyxHQUFHQSxJQUFLO1FBQ2xDSixHQUFHLENBQUNJLEVBQUUsR0FBR1IsUUFBUTtRQUNqQkEsV0FBVztJQUNmO0lBQ0EsT0FBTyxJQUFJUyxXQUFXTDtBQUMxQjtBQUNBLFNBQVNNLE9BQU9DLENBQUMsRUFBRUMsQ0FBQztJQUNoQixNQUFNQyxNQUFNLElBQUlKLFdBQVdFLEVBQUVWLE1BQU07SUFDbkMsSUFBSyxJQUFJTyxJQUFJLEdBQUdBLElBQUlHLEVBQUVWLE1BQU0sRUFBRU8sSUFBSztRQUMvQkssR0FBRyxDQUFDTCxFQUFFLEdBQUdHLENBQUMsQ0FBQ0gsRUFBRSxHQUFHSSxDQUFDLENBQUNKLEVBQUU7SUFDeEI7SUFDQSxPQUFPSztBQUNYO0FBQ0EsU0FBU1gsS0FBS1ksSUFBSTtJQUNkLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixPQUN0QixNQUFNLElBQUlYLE1BQU07QUFDeEI7QUFDQSxTQUFTYyxRQUFRQyxHQUFHO0lBQ2hCLElBQUksQ0FBQ3pCLGtEQUFPQSxDQUFDeUIsUUFBUSxPQUFPQSxRQUFRLFVBQ2hDLE1BQU0sSUFBSWYsTUFBTTtJQUNwQixPQUFPLE9BQU9l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T0FBT0MsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR2IsVUFBVTtnQkFBRXJDLEdBQUcyRDtnQkFBRzFELEdBQUc7Z0JBQUc3QixLQUFLNkQ7WUFBWSxHQUFHbEM7WUFDM0UsT0FBT0YsY0FBY3ZCLEtBQUssR0FBRzBFLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUM1QztJQUNKO0FBQ0osRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzPzIwZDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX3ZhbGlkYXRlT2JqZWN0LCBhYnl0ZXMsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGlzQnl0ZXMsIGlzSGFzaCwgdXRmOFRvQnl0ZXMsIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBGcEludmVydEJhdGNoLCBtb2QgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGFudW0odmFsdWUpO1xuICAgIGFudW0obGVuZ3RoKTtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgSTJPU1AgaW5wdXQ6ICcgKyB2YWx1ZSk7XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhbnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gbm9ybURTVChEU1QpIHtcbiAgICBpZiAoIWlzQnl0ZXMoRFNUKSAmJiB0eXBlb2YgRFNUICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEU1QgbXVzdCBiZSBVaW50OEFycmF5IG9yIHN0cmluZycpO1xuICAgIHJldHVybiB0eXBlb2YgRFNUID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKERTVCkgOiBEU1Q7XG59XG4vKipcbiAqIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHMuXG4gKiBbUkZDIDkzODAgNS4zLjFdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjEpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICBEU1QgPSBub3JtRFNUKERTVCk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94bWQ6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4gKiAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbiAqIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4gKiAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbiAqIFtSRkMgOTM4MCA1LjMuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMikuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIERTVCA9IG5vcm1EU1QoRFNUKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGLlxuICogW1JGQyA5MzgwIDUuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjIpLlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIF92YWxpZGF0ZU9iamVjdChvcHRpb25zLCB7XG4gICAgICAgIHA6ICdiaWdpbnQnLFxuICAgICAgICBtOiAnbnVtYmVyJyxcbiAgICAgICAgazogJ251bWJlcicsXG4gICAgICAgIGhhc2g6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVCB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWlzSGFzaChvcHRpb25zLmhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkIGhhc2gnKTtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBjb2VmZiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3huLCB4ZCwgeW4sIHlkXSA9IGNvZWZmLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgLy8gNi42LjNcbiAgICAgICAgLy8gRXhjZXB0aW9uYWwgY2FzZXMgb2YgaXNvX21hcCBhcmUgaW5wdXRzIHRoYXQgY2F1c2UgdGhlIGRlbm9taW5hdG9yIG9mXG4gICAgICAgIC8vIGVpdGhlciByYXRpb25hbCBmdW5jdGlvbiB0byBldmFsdWF0ZSB0byB6ZXJvOyBzdWNoIGNhc2VzIE1VU1QgcmV0dXJuXG4gICAgICAgIC8vIHRoZSBpZGVudGl0eSBwb2ludCBvbiBFLlxuICAgICAgICBjb25zdCBbeGRfaW52LCB5ZF9pbnZdID0gRnBJbnZlcnRCYXRjaChmaWVsZCwgW3hkLCB5ZF0sIHRydWUpO1xuICAgICAgICB4ID0gZmllbGQubXVsKHhuLCB4ZF9pbnYpOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLm11bCh5biwgeWRfaW52KSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IF9EU1Rfc2NhbGFyID0gdXRmOFRvQnl0ZXMoJ0hhc2hUb1NjYWxhci0nKTtcbi8qKiBDcmVhdGVzIGhhc2gtdG8tY3VydmUgbWV0aG9kcyBmcm9tIEVDIFBvaW50IGFuZCBtYXBUb0N1cnZlIGZ1bmN0aW9uLiBTZWUge0BsaW5rIEgyQ0hhc2hlcn0uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWZhdWx0cykge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgZnVuY3Rpb24gbWFwKG51bSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKG51bSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhcihpbml0aWFsKSB7XG4gICAgICAgIGNvbnN0IFAgPSBpbml0aWFsLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgaWYgKFAuZXF1YWxzKFBvaW50LlpFUk8pKVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87IC8vIHplcm8gd2lsbCB0aHJvdyBpbiBhc3NlcnRcbiAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gUDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmYXVsdHMsXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgb3B0cyk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IG1hcCh1WzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbWFwKHVbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyKHUwLmFkZCh1MSkpO1xuICAgICAgICB9LFxuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgb3B0c0RzdCA9IGRlZmF1bHRzLmVuY29kZURTVCA/IHsgRFNUOiBkZWZhdWx0cy5lbmNvZGVEU1QgfSA6IHt9O1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRzRHN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgb3B0cyk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IG1hcCh1WzBdKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcih1MCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBTZWUge0BsaW5rIEgyQ0hhc2hlcn0gKi9cbiAgICAgICAgbWFwVG9DdXJ2ZShzY2FsYXJzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgb2Ygc2NhbGFycylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcihtYXAoc2NhbGFycykpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBoYXNoX3RvX3NjYWxhciBjYW4gcHJvZHVjZSAwOiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9lcnJhdGEvZWlkODM5M1xuICAgICAgICAvLyBSRkMgOTM4MCwgZHJhZnQtaXJ0Zi1jZnJnLWJicy1zaWduYXR1cmVzLTA4XG4gICAgICAgIGhhc2hUb1NjYWxhcihtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IE4gPSBQb2ludC5Gbi5PUkRFUjtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgeyBwOiBOLCBtOiAxLCBEU1Q6IF9EU1Rfc2NhbGFyIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2hfdG9fZmllbGQobXNnLCAxLCBvcHRzKVswXVswXTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsiX3ZhbGlkYXRlT2JqZWN0IiwiYWJ5dGVzIiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJpc0J5dGVzIiwiaXNIYXNoIiwidXRmOFRvQnl0ZXMiLCJGcEludmVydEJhdGNoIiwibW9kIiwib3MyaXAiLCJpMm9zcCIsInZhbHVlIiwibGVuZ3RoIiwiYW51bSIsIkVycm9yIiwicmVzIiwiQXJyYXkiLCJmcm9tIiwiZmlsbCIsImkiLCJVaW50OEFycmF5Iiwic3RyeG9yIiwiYSIsImIiLCJhcnIiLCJpdGVtIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIm5vcm1EU1QiLCJEU1QiLCJleHBhbmRfbWVzc2FnZV94bWQiLCJtc2ciLCJsZW5JbkJ5dGVzIiwiSCIsIm91dHB1dExlbiIsImJfaW5fYnl0ZXMiLCJibG9ja0xlbiIsInJfaW5fYnl0ZXMiLCJlbGwiLCJNYXRoIiwiY2VpbCIsIkRTVF9wcmltZSIsIlpfcGFkIiwibF9pX2Jfc3RyIiwiYl8wIiwiYXJncyIsInBzZXVkb19yYW5kb21fYnl0ZXMiLCJzbGljZSIsImV4cGFuZF9tZXNzYWdlX3hvZiIsImsiLCJka0xlbiIsImNyZWF0ZSIsInVwZGF0ZSIsImRpZ2VzdCIsImhhc2hfdG9fZmllbGQiLCJjb3VudCIsIm9wdGlvbnMiLCJwIiwibSIsImhhc2giLCJleHBhbmQiLCJsb2cycCIsInRvU3RyaW5nIiwiTCIsImxlbl9pbl9ieXRlcyIsInByYiIsInUiLCJlIiwiaiIsImVsbV9vZmZzZXQiLCJ0diIsInN1YmFycmF5IiwiaXNvZ2VueU1hcCIsImZpZWxkIiwibWFwIiwiY29lZmYiLCJyZXZlcnNlIiwieCIsInkiLCJ4biIsInhkIiwieW4iLCJ5ZCIsInZhbCIsInJlZHVjZSIsImFjYyIsImFkZCIsIm11bCIsInhkX2ludiIsInlkX2ludiIsIl9EU1Rfc2NhbGFyIiwiY3JlYXRlSGFzaGVyIiwiUG9pbnQiLCJtYXBUb0N1cnZlIiwiZGVmYXVsdHMiLCJudW0iLCJmcm9tQWZmaW5lIiwiY2xlYXIiLCJpbml0aWFsIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJlcXVhbHMiLCJaRVJPIiwiYXNzZXJ0VmFsaWRpdHkiLCJoYXNoVG9DdXJ2ZSIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJ1MCIsInUxIiwiZW5jb2RlVG9DdXJ2ZSIsIm9wdHNEc3QiLCJlbmNvZGVEU1QiLCJzY2FsYXJzIiwiaXNBcnJheSIsImhhc2hUb1NjYWxhciIsIk4iLCJGbiIsIk9SREVSIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpLegendre: () => (/* binding */ FpLegendre),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */ function pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */ function invert(number, modulo) {\n    if (number === _0n) throw new Error(\"invert: expected non-zero number\");\n    if (modulo <= _0n) throw new Error(\"invert: expected positive modulus, got \" + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n)=>{\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n) throw new Error(\"sqrt is not defined for small field\");\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while(Q % _2n === _0n){\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while(FpLegendre(_Fp, Z) === 1){\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000) throw new Error(\"Cannot find square root: probably non-prime P\");\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1) return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n)) return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1) throw new Error(\"Cannot find square root\");\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while(!Fp.eql(t, Fp.ONE)){\n            if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i) ≡ 1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while(!Fp.eql(t_tmp, Fp.ONE)){\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M) throw new Error(\"Cannot find square root\");\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */ function FpSqrt(P) {\n    // P ≡ 3 (mod 4) => √n = n^((P+1)/4)\n    if (P % _4n === _3n) return sqrt3mod4;\n    // P ≡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n) return sqrt5mod8;\n    // P ≡ 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n) return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"number\",\n        BITS: \"number\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(Fp, num, power) {\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (power === _0n) return Fp.ONE;\n    if (power === _1n) return num;\n    let p = Fp.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */ function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */ function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no) throw new Error(\"invalid Legendre symbol result\");\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {\n    if (ORDER <= _0n) throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    let _nbitLength = undefined;\n    let _sqrt = undefined;\n    let modFromBytes = false;\n    let allowedLengths = undefined;\n    if (typeof bitLenOrOpts === \"object\" && bitLenOrOpts != null) {\n        if (opts.sqrt || isLE) throw new Error(\"cannot specify opts in two arguments\");\n        const _opts = bitLenOrOpts;\n        if (_opts.BITS) _nbitLength = _opts.BITS;\n        if (_opts.sqrt) _sqrt = _opts.sqrt;\n        if (typeof _opts.isLE === \"boolean\") isLE = _opts.isLE;\n        if (typeof _opts.modFromBytes === \"boolean\") modFromBytes = _opts.modFromBytes;\n        allowedLengths = _opts.allowedLengths;\n    } else {\n        if (typeof bitLenOrOpts === \"number\") _nbitLength = bitLenOrOpts;\n        if (opts.sqrt) _sqrt = opts.sqrt;\n    }\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n    if (BYTES > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        allowedLengths: allowedLengths,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        // is valid and invertible\n        isValidNot0: (num)=>!f.is0(num) && f.isValid(num),\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: _sqrt || ((n)=>{\n            if (!sqrtP) sqrtP = FpSqrt(ORDER);\n            return sqrtP(f, n);\n        }),\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes, skipValidation = true)=>{\n            if (allowedLengths) {\n                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                    throw new Error(\"Field.fromBytes: expected \" + allowedLengths + \" bytes, got \" + bytes.length);\n                }\n                const padded = new Uint8Array(BYTES);\n                // isLE add 0 to right, !isLE to the left.\n                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n                bytes = padded;\n            }\n            if (bytes.length !== BYTES) throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n            let scalar = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n            if (modFromBytes) scalar = mod(scalar, ORDER);\n            if (!skipValidation) {\n                if (!f.isValid(scalar)) throw new Error(\"invalid field element: outside of range 0..ORDER\");\n            }\n            // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n            // protocol may allow non-reduced scalar that reduced later or changed some other way.\n            return scalar;\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c)=>c ? b : a\n    });\n    return Object.freeze(f);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(\"hashToPrivateScalar: expected \" + minLen + \"-1024 bytes of input, got \" + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBQ0Qsb0VBQW9FLEdBQzhFO0FBQ2xKLGtCQUFrQjtBQUNsQixNQUFNUSxNQUFNQyxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTSxhQUFhLEdBQUdGLE9BQU8sSUFBSUcsTUFBTSxhQUFhLEdBQUdILE9BQU87QUFDdEcsa0JBQWtCO0FBQ2xCLE1BQU1JLE1BQU0sYUFBYSxHQUFHSixPQUFPLElBQUlLLE1BQU0sYUFBYSxHQUFHTCxPQUFPLElBQUlNLE1BQU0sYUFBYSxHQUFHTixPQUFPO0FBQ3JHLGtCQUFrQjtBQUNsQixNQUFNTyxNQUFNLGFBQWEsR0FBR1AsT0FBTyxJQUFJUSxNQUFNLGFBQWEsR0FBR1IsT0FBTyxJQUFJUyxPQUFPLGFBQWEsR0FBR1QsT0FBTztBQUN0Ryx3QkFBd0I7QUFDakIsU0FBU1UsSUFBSUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3BCLE1BQU1DLFNBQVNGLElBQUlDO0lBQ25CLE9BQU9DLFVBQVVkLE1BQU1jLFNBQVNELElBQUlDO0FBQ3hDO0FBQ0E7Ozs7O0NBS0MsR0FDTSxTQUFTQyxJQUFJQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUNsQyxPQUFPQyxNQUFNQyxNQUFNRixTQUFTRixLQUFLQztBQUNyQztBQUNBLDBEQUEwRCxHQUNuRCxTQUFTSSxLQUFLQyxDQUFDLEVBQUVMLEtBQUssRUFBRUMsTUFBTTtJQUNqQyxJQUFJSyxNQUFNRDtJQUNWLE1BQU9MLFVBQVVqQixJQUFLO1FBQ2xCdUIsT0FBT0E7UUFDUEEsT0FBT0w7SUFDWDtJQUNBLE9BQU9LO0FBQ1g7QUFDQTs7O0NBR0MsR0FDTSxTQUFTQyxPQUFPQyxNQUFNLEVBQUVQLE1BQU07SUFDakMsSUFBSU8sV0FBV3pCLEtBQ1gsTUFBTSxJQUFJMEIsTUFB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QU07SUFDdEIsTUFBTXlFLFdBQVdQLG9CQUFvQkM7SUFDckMsTUFBTUYsU0FBU0ksaUJBQWlCRjtJQUNoQyxpR0FBaUc7SUFDakcsSUFBSUssTUFBTSxNQUFNQSxNQUFNUCxVQUFVTyxNQUFNLE1BQ2xDLE1BQU0sSUFBSXZKLE1BQU0sY0FBY2dKLFNBQVMsK0JBQStCTztJQUMxRSxNQUFNakssTUFBTW1ILE9BQU92SSwwREFBZUEsQ0FBQ29MLE9BQU9yTCwwREFBZUEsQ0FBQ3FMO0lBQzFELCtFQUErRTtJQUMvRSxNQUFNRyxVQUFVeEssSUFBSUssS0FBSzRKLGFBQWExSyxPQUFPQTtJQUM3QyxPQUFPaUksT0FBT3BJLDBEQUFlQSxDQUFDb0wsU0FBU0QsWUFBWXBMLDBEQUFlQSxDQUFDcUwsU0FBU0Q7QUFDaEYsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzPzBjYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlscyBmb3IgbW9kdWxhciBkaXZpc2lvbiBhbmQgZmllbGRzLlxuICogRmllbGQgb3ZlciAxMSBpcyBhIGZpbml0ZSAoR2Fsb2lzKSBmaWVsZCBpcyBpbnRlZ2VyIG51bWJlciBvcGVyYXRpb25zIGBtb2QgMTFgLlxuICogVGhlcmUgaXMgbm8gZGl2aXNpb246IGl0IGlzIHJlcGxhY2VkIGJ5IG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgX3ZhbGlkYXRlT2JqZWN0LCBhbnVtYmVyLCBiaXRNYXNrLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKSwgXzNuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg0KSwgXzVuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg1KSwgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzhuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg4KSwgXzluID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg5KSwgXzE2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIHJldHVybiBGcFBvdyhGaWVsZChtb2R1bG8pLCBudW0sIHBvd2VyKTtcbn1cbi8qKiBEb2VzIGB4XigyXnBvd2VyKWAgbW9kIHAuIGBwb3cyKDMwLCA0KWAgPT0gYDMwXigyXjQpYCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsby5cbiAqIEltcGxlbWVudGVkIHVzaW5nIFtFdWNsaWRlYW4gR0NEXShodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtLykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBleHBlY3RlZCBub24temVybyBudW1iZXInKTtcbiAgICBpZiAobW9kdWxvIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIG1vZHVsdXMsIGdvdCAnICsgbW9kdWxvKTtcbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzU3F1YXJlKEZwLCByb290LCBuKSB7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xufVxuLy8gTm90IGFsbCByb290cyBhcmUgcG9zc2libGUhIEV4YW1wbGUgd2hpY2ggd2lsbCB0aHJvdzpcbi8vIGNvbnN0IE5VTSA9XG4vLyBuID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuLy8gRnAgPSBGaWVsZChCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiJykpO1xuZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgY29uc3QgcDFkaXY0ID0gKEZwLk9SREVSICsgXzFuKSAvIF80bjtcbiAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgYXNzZXJ0SXNTcXVhcmUoRnAsIHJvb3QsIG4pO1xuICAgIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgY29uc3QgcDVkaXY4ID0gKEZwLk9SREVSIC0gXzVuKSAvIF84bjtcbiAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIHA1ZGl2OCk7XG4gICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICBhc3NlcnRJc1NxdWFyZShGcCwgcm9vdCwgbik7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG4vLyBCYXNlZCBvbiBSRkM5MzgwLCBLb25nIGFsZ29yaXRobVxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBzcXJ0OW1vZDE2KFApIHtcbiAgICBjb25zdCBGcF8gPSBGaWVsZChQKTtcbiAgICBjb25zdCB0biA9IHRvbmVsbGlTaGFua3MoUCk7XG4gICAgY29uc3QgYzEgPSB0bihGcF8sIEZwXy5uZWcoRnBfLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgIGNvbnN0IGMyID0gdG4oRnBfLCBjMSk7IC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgY29uc3QgYzMgPSB0bihGcF8sIEZwXy5uZWcoYzEpKTsgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoRnAsIG4pID0+IHtcbiAgICAgICAgbGV0IHR2MSA9IEZwLnBvdyhuLCBjNCk7IC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIGxldCB0djIgPSBGcC5tdWwodHYxLCBjMSk7IC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICBjb25zdCB0djMgPSBGcC5tdWwodHYxLCBjMik7IC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICBjb25zdCB0djQgPSBGcC5tdWwodHYxLCBjMyk7IC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICBjb25zdCBlMSA9IEZwLmVxbChGcC5zcXIodHYyKSwgbik7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgY29uc3QgZTIgPSBGcC5lcWwoRnAuc3FyKHR2MyksIG4pOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgY29uc3QgZTMgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIGNvbnN0IHJvb3QgPSBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgICMgU2VsZWN0IHNxcnQgZnJvbSB0djEgJiB0djJcbiAgICAgICAgYXNzZXJ0SXNTcXVhcmUoRnAsIHJvb3QsIG4pO1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gSW5pdGlhbGl6YXRpb24gKHByZWNvbXB1dGF0aW9uKS5cbiAgICAvLyBDYWNoaW5nIGluaXRpYWxpemF0aW9uIGNvdWxkIGJvb3N0IHBlcmYgYnkgNyUuXG4gICAgaWYgKFAgPCBfM24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3FydCBpcyBub3QgZGVmaW5lZCBmb3Igc21hbGwgZmllbGQnKTtcbiAgICAvLyBGYWN0b3IgUCAtIDEgPSBRICogMl5TLCB3aGVyZSBRIGlzIG9kZFxuICAgIGxldCBRID0gUCAtIF8xbjtcbiAgICBsZXQgUyA9IDA7XG4gICAgd2hpbGUgKFEgJSBfMm4gPT09IF8wbikge1xuICAgICAgICBRIC89IF8ybjtcbiAgICAgICAgUysrO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBxdWFkcmF0aWMgbm9uLXJlc2lkdWUgWiA+PSAyXG4gICAgbGV0IFogPSBfMm47XG4gICAgY29uc3QgX0ZwID0gRmllbGQoUCk7XG4gICAgd2hpbGUgKEZwTGVnZW5kcmUoX0ZwLCBaKSA9PT0gMSkge1xuICAgICAgICAvLyBCYXNpYyBwcmltYWxpdHkgdGVzdCBmb3IgUC4gQWZ0ZXIgeCBpdGVyYXRpb25zLCBjaGFuY2Ugb2ZcbiAgICAgICAgLy8gbm90IGZpbmRpbmcgcXVhZHJhdGljIG5vbi1yZXNpZHVlIGlzIDJeeCwgc28gMl4xMDAwLlxuICAgICAgICBpZiAoWisrID4gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3Q6IHByb2JhYmx5IG5vbi1wcmltZSBQJyk7XG4gICAgfVxuICAgIC8vIEZhc3QtcGF0aDsgdXN1YWxseSBkb25lIGJlZm9yZSBaLCBidXQgd2UgZG8gXCJwcmltYWxpdHkgdGVzdFwiLlxuICAgIGlmIChTID09PSAxKVxuICAgICAgICByZXR1cm4gc3FydDNtb2Q0O1xuICAgIC8vIFNsb3ctcGF0aFxuICAgIC8vIFRPRE86IHRlc3Qgb24gRnAyIGFuZCBvdGhlcnNcbiAgICBsZXQgY2MgPSBfRnAucG93KFosIFEpOyAvLyBjID0gel5RXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICBpZiAoRnAuaXMwKG4pKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIC8vIENoZWNrIGlmIG4gaXMgYSBxdWFkcmF0aWMgcmVzaWR1ZSB1c2luZyBMZWdlbmRyZSBzeW1ib2xcbiAgICAgICAgaWYgKEZwTGVnZW5kcmUoRnAsIG4pICE9PSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHZhcmlhYmxlcyBmb3IgdGhlIG1haW4gbG9vcFxuICAgICAgICBsZXQgTSA9IFM7XG4gICAgICAgIGxldCBjID0gRnAubXVsKEZwLk9ORSwgY2MpOyAvLyBjID0gel5RLCBtb3ZlIGNjIGZyb20gZmllbGQgX0ZwIGludG8gZmllbGQgRnBcbiAgICAgICAgbGV0IHQgPSBGcC5wb3cobiwgUSk7IC8vIHQgPSBuXlEsIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgbGV0IFIgPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gUiA9IG5eKChRKzEpLzIpLCBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgLy8gTWFpbiBsb29wXG4gICAgICAgIC8vIHdoaWxlIHQgIT0gMVxuICAgICAgICB3aGlsZSAoIUZwLmVxbCh0LCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuaXMwKHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBpZiB0PTAgcmV0dXJuIFI9MFxuICAgICAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgc21hbGxlc3QgaSA+PSAxIHN1Y2ggdGhhdCB0XigyXmkpIOKJoSAxIChtb2QgUClcbiAgICAgICAgICAgIGxldCB0X3RtcCA9IEZwLnNxcih0KTsgLy8gdF4oMl4xKVxuICAgICAgICAgICAgd2hpbGUgKCFGcC5lcWwodF90bXAsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgdF90bXAgPSBGcC5zcXIodF90bXApOyAvLyB0XigyXjIpLi4uXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IE0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZXhwb25lbnQgZm9yIGI6IDJeKE0gLSBpIC0gMSlcbiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50ID0gXzFuIDw8IEJpZ0ludChNIC0gaSAtIDEpOyAvLyBiaWdpbnQgaXMgaW1wb3J0YW50XG4gICAgICAgICAgICBjb25zdCBiID0gRnAucG93KGMsIGV4cG9uZW50KTsgLy8gYiA9IDJeKE0gLSBpIC0gMSlcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIE0gPSBpO1xuICAgICAgICAgICAgYyA9IEZwLnNxcihiKTsgLy8gYyA9IGJeMlxuICAgICAgICAgICAgdCA9IEZwLm11bCh0LCBjKTsgLy8gdCA9ICh0ICogYl4yKVxuICAgICAgICAgICAgUiA9IEZwLm11bChSLCBiKTsgLy8gUiA9IFIqYlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSO1xuICAgIH07XG59XG4vKipcbiAqIFNxdWFyZSByb290IGZvciBhIGZpbml0ZSBmaWVsZC4gV2lsbCB0cnkgb3B0aW1pemVkIHZlcnNpb25zIGZpcnN0OlxuICpcbiAqIDEuIFAg4omhIDMgKG1vZCA0KVxuICogMi4gUCDiiaEgNSAobW9kIDgpXG4gKiAzLiBQIOKJoSA5IChtb2QgMTYpXG4gKiA0LiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAqXG4gKiBEaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gKiBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gUCDiiaEgMyAobW9kIDQpID0+IOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pXG4gICAgICAgIHJldHVybiBzcXJ0M21vZDQ7XG4gICAgLy8gUCDiiaEgNSAobW9kIDgpID0+IEF0a2luIGFsZ29yaXRobSwgcGFnZSAxMCBvZiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGZcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKVxuICAgICAgICByZXR1cm4gc3FydDVtb2Q4O1xuICAgIC8vIFAg4omhIDkgKG1vZCAxNikgPT4gS29uZyBhbGdvcml0aG0sIHBhZ2UgMTEgb2YgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChhbGdvcml0aG0gNClcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bilcbiAgICAgICAgcmV0dXJuIHNxcnQ5bW9kMTYoUCk7XG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdudW1iZXInLFxuICAgICAgICBCSVRTOiAnbnVtYmVyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgX3ZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbiAgICAvLyBjb25zdCBtYXggPSAxNjM4NDtcbiAgICAvLyBpZiAoZmllbGQuQllURVMgPCAxIHx8IGZpZWxkLkJZVEVTID4gbWF4KSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQnKTtcbiAgICAvLyBpZiAoZmllbGQuQklUUyA8IDEgfHwgZmllbGQuQklUUyA+IDggKiBtYXgpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCcpO1xuICAgIHJldHVybiBmaWVsZDtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhGcCwgbnVtLCBwb3dlcikge1xuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGV4cG9uZW50LCBuZWdhdGl2ZXMgdW5zdXBwb3J0ZWQnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIEZwLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IEZwLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IEZwLm11bChwLCBkKTtcbiAgICAgICAgZCA9IEZwLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIEV4Y2VwdGlvbi1mcmVlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBmb3IgMCBlbGVtZW50cy5cbiAqIEBwYXJhbSBwYXNzWmVybyBtYXAgMCB0byAwIChpbnN0ZWFkIG9mIHVuZGVmaW5lZClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goRnAsIG51bXMsIHBhc3NaZXJvID0gZmFsc2UpIHtcbiAgICBjb25zdCBpbnZlcnRlZCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCkuZmlsbChwYXNzWmVybyA/IEZwLlpFUk8gOiB1bmRlZmluZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBtdWx0aXBsaWVkQWNjID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChGcC5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIGludmVydGVkW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gRnAubXVsKGFjYywgbnVtKTtcbiAgICB9LCBGcC5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZEFjYyA9IEZwLmludihtdWx0aXBsaWVkQWNjKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKEZwLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgaW52ZXJ0ZWRbaV0gPSBGcC5tdWwoYWNjLCBpbnZlcnRlZFtpXSk7XG4gICAgICAgIHJldHVybiBGcC5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkQWNjKTtcbiAgICByZXR1cm4gaW52ZXJ0ZWQ7XG59XG4vLyBUT0RPOiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBGcERpdihGcCwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gRnAubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBGcC5PUkRFUikgOiBGcC5pbnYocmhzKSk7XG59XG4vKipcbiAqIExlZ2VuZHJlIHN5bWJvbC5cbiAqIExlZ2VuZHJlIGNvbnN0YW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApXG4gKiB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICpcbiAqICogKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIG5vbiByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcExlZ2VuZHJlKEZwLCBuKSB7XG4gICAgLy8gV2UgY2FuIHVzZSAzcmQgYXJndW1lbnQgYXMgb3B0aW9uYWwgY2FjaGUgb2YgdGhpcyB2YWx1ZVxuICAgIC8vIGJ1dCBzZWVtcyB1bm5lZWRlZCBmb3Igbm93LiBUaGUgb3BlcmF0aW9uIGlzIHZlcnkgZmFzdC5cbiAgICBjb25zdCBwMW1vZDIgPSAoRnAuT1JERVIgLSBfMW4pIC8gXzJuO1xuICAgIGNvbnN0IHBvd2VyZWQgPSBGcC5wb3cobiwgcDFtb2QyKTtcbiAgICBjb25zdCB5ZXMgPSBGcC5lcWwocG93ZXJlZCwgRnAuT05FKTtcbiAgICBjb25zdCB6ZXJvID0gRnAuZXFsKHBvd2VyZWQsIEZwLlpFUk8pO1xuICAgIGNvbnN0IG5vID0gRnAuZXFsKHBvd2VyZWQsIEZwLm5lZyhGcC5PTkUpKTtcbiAgICBpZiAoIXllcyAmJiAhemVybyAmJiAhbm8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBMZWdlbmRyZSBzeW1ib2wgcmVzdWx0Jyk7XG4gICAgcmV0dXJuIHllcyA/IDEgOiB6ZXJvID8gMCA6IC0xO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShGcCwgbikge1xuICAgIGNvbnN0IGwgPSBGcExlZ2VuZHJlKEZwLCBuKTtcbiAgICByZXR1cm4gbCA9PT0gMTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGlmIChuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFudW1iZXIobkJpdExlbmd0aCk7XG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGZpbml0ZSBmaWVsZC4gTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogMS4gRGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsLlxuICogKiAyLiBJZGVudGljYWwgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXMuXG4gKiAqIDMuIGBPYmplY3QuZnJlZXplYC5cbiAqIEZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBTZWN1cml0eSBub3RlOiBvcGVyYXRpb25zIGRvbid0IGNoZWNrICdpc1ZhbGlkJyBmb3IgYWxsIGVsZW1lbnRzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLFxuICogaXQgaXMgY2FsbGVyIHJlc3BvbnNpYmlsaXR5IHRvIGNoZWNrIHRoaXMuXG4gKiBUaGlzIGlzIGxvdy1sZXZlbCBjb2RlLCBwbGVhc2UgbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICpcbiAqIE5vdGUgYWJvdXQgZmllbGQgcHJvcGVydGllczpcbiAqICogQ0hBUkFDVEVSSVNUSUMgcCA9IHByaW1lIG51bWJlciwgbnVtYmVyIG9mIGVsZW1lbnRzIGluIG1haW4gc3ViZ3JvdXAuXG4gKiAqIE9SREVSIHEgPSBzaW1pbGFyIHRvIGNvZmFjdG9yIGluIGN1cnZlcywgbWF5IGJlIGNvbXBvc2l0ZSBgcSA9IHBebWAuXG4gKlxuICogQHBhcmFtIE9SREVSIGZpZWxkIG9yZGVyLCBwcm9iYWJseSBwcmltZSwgb3IgY291bGQgYmUgY29tcG9zaXRlXG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmYXVsdDogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuT3JPcHRzLCAvLyBUT0RPOiB1c2Ugb3B0cyBvbmx5IGluIHYyP1xuaXNMRSA9IGZhbHNlLCBvcHRzID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290ICcgKyBPUkRFUik7XG4gICAgbGV0IF9uYml0TGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgIGxldCBfc3FydCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgbW9kRnJvbUJ5dGVzID0gZmFsc2U7XG4gICAgbGV0IGFsbG93ZWRMZW5ndGhzID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgYml0TGVuT3JPcHRzID09PSAnb2JqZWN0JyAmJiBiaXRMZW5Pck9wdHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0cy5zcXJ0IHx8IGlzTEUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzcGVjaWZ5IG9wdHMgaW4gdHdvIGFyZ3VtZW50cycpO1xuICAgICAgICBjb25zdCBfb3B0cyA9IGJpdExlbk9yT3B0cztcbiAgICAgICAgaWYgKF9vcHRzLkJJVFMpXG4gICAgICAgICAgICBfbmJpdExlbmd0aCA9IF9vcHRzLkJJVFM7XG4gICAgICAgIGlmIChfb3B0cy5zcXJ0KVxuICAgICAgICAgICAgX3NxcnQgPSBfb3B0cy5zcXJ0O1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzLmlzTEUgPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIGlzTEUgPSBfb3B0cy5pc0xFO1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzLm1vZEZyb21CeXRlcyA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgbW9kRnJvbUJ5dGVzID0gX29wdHMubW9kRnJvbUJ5dGVzO1xuICAgICAgICBhbGxvd2VkTGVuZ3RocyA9IF9vcHRzLmFsbG93ZWRMZW5ndGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiaXRMZW5Pck9wdHMgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgX25iaXRMZW5ndGggPSBiaXRMZW5Pck9wdHM7XG4gICAgICAgIGlmIChvcHRzLnNxcnQpXG4gICAgICAgICAgICBfc3FydCA9IG9wdHMuc3FydDtcbiAgICB9XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIF9uYml0TGVuZ3RoKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSIG9mIDw9IDIwNDggYnl0ZXMnKTtcbiAgICBsZXQgc3FydFA7IC8vIGNhY2hlZCBzcXJ0UFxuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIGlzTEUsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBhbGxvd2VkTGVuZ3RoczogYWxsb3dlZExlbmd0aHMsXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICcgKyB0eXBlb2YgbnVtKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIC8vIGlzIHZhbGlkIGFuZCBpbnZlcnRpYmxlXG4gICAgICAgIGlzVmFsaWROb3QwOiAobnVtKSA9PiAhZi5pczAobnVtKSAmJiBmLmlzVmFsaWQobnVtKSxcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiBfc3FydCB8fFxuICAgICAgICAgICAgKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcXJ0UClcbiAgICAgICAgICAgICAgICAgICAgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcXJ0UChmLCBuKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzLCBza2lwVmFsaWRhdGlvbiA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIGlmIChhbGxvd2VkTGVuZ3Rocykge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dlZExlbmd0aHMuaW5jbHVkZXMoYnl0ZXMubGVuZ3RoKSB8fCBieXRlcy5sZW5ndGggPiBCWVRFUykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkLmZyb21CeXRlczogZXhwZWN0ZWQgJyArIGFsbG93ZWRMZW5ndGhzICsgJyBieXRlcywgZ290ICcgKyBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheShCWVRFUyk7XG4gICAgICAgICAgICAgICAgLy8gaXNMRSBhZGQgMCB0byByaWdodCwgIWlzTEUgdG8gdGhlIGxlZnQuXG4gICAgICAgICAgICAgICAgcGFkZGVkLnNldChieXRlcywgaXNMRSA/IDAgOiBwYWRkZWQubGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBieXRlcyA9IHBhZGRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQuZnJvbUJ5dGVzOiBleHBlY3RlZCAnICsgQllURVMgKyAnIGJ5dGVzLCBnb3QgJyArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgc2NhbGFyID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICAgICAgaWYgKG1vZEZyb21CeXRlcylcbiAgICAgICAgICAgICAgICBzY2FsYXIgPSBtb2Qoc2NhbGFyLCBPUkRFUik7XG4gICAgICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uKVxuICAgICAgICAgICAgICAgIGlmICghZi5pc1ZhbGlkKHNjYWxhcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCBlbGVtZW50OiBvdXRzaWRlIG9mIHJhbmdlIDAuLk9SREVSJyk7XG4gICAgICAgICAgICAvLyBOT1RFOiB3ZSBkb24ndCB2YWxpZGF0ZSBzY2FsYXIgaGVyZSwgcGxlYXNlIHVzZSBpc1ZhbGlkLiBUaGlzIGRvbmUgc3VjaCB3YXkgYmVjYXVzZSBzb21lXG4gICAgICAgICAgICAvLyBwcm90b2NvbCBtYXkgYWxsb3cgbm9uLXJlZHVjZWQgc2NhbGFyIHRoYXQgcmVkdWNlZCBsYXRlciBvciBjaGFuZ2VkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhcjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVE9ETzogd2UgZG9uJ3QgbmVlZCBpdCBoZXJlLCBtb3ZlIG91dCB0byBzZXBhcmF0ZSBmblxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBXZSBjYW4ndCBtb3ZlIHRoaXMgb3V0IGJlY2F1c2UgRnA2LCBGcDEyIGltcGxlbWVudCBpdFxuICAgICAgICAvLyBhbmQgaXQncyB1bmNsZWFyIHdoYXQgdG8gcmV0dXJuIGluIHRoZXJlLlxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG4vLyBHZW5lcmljIHJhbmRvbSBzY2FsYXIsIHdlIGNhbiBkbyBzYW1lIGZvciBvdGhlciBmaWVsZHMgaWYgdmlhIEZwMi5tdWwoRnAyLk9ORSwgRnAyLnJhbmRvbSk/XG4vLyBUaGlzIGFsbG93cyB1bnNhZmUgbWV0aG9kcyBsaWtlIGlnbm9yZSBiaWFzIG9yIHplcm8uIFRoZXNlIHVuc2FmZSwgYnV0IG9mdGVuIHVzZWQgaW4gZGlmZmVyZW50IHByb3RvY29scyAoaWYgZGV0ZXJtaW5pc3RpYyBSTkcpLlxuLy8gd2hpY2ggbWVhbiB3ZSBjYW5ub3QgZm9yY2UgdGhpcyB2aWEgb3B0cy5cbi8vIE5vdCBzdXJlIHdoYXQgdG8gZG8gd2l0aCByYW5kb21CeXRlcywgd2UgY2FuIGFjY2VwdCBpdCBpbnNpZGUgb3B0cyBpZiB3YW50ZWQuXG4vLyBQcm9iYWJseSBuZWVkIHRvIGV4cG9ydCBnZXRNaW5IYXNoTGVuZ3RoIHNvbWV3aGVyZT9cbi8vIHJhbmRvbShieXRlcz86IFVpbnQ4QXJyYXksIHVuc2FmZUFsbG93WmVybyA9IGZhbHNlLCB1bnNhZmVBbGxvd0JpYXMgPSBmYWxzZSkge1xuLy8gICBjb25zdCBMRU4gPSAhdW5zYWZlQWxsb3dCaWFzID8gZ2V0TWluSGFzaExlbmd0aChPUkRFUikgOiBCWVRFUztcbi8vICAgaWYgKGJ5dGVzID09PSB1bmRlZmluZWQpIGJ5dGVzID0gcmFuZG9tQnl0ZXMoTEVOKTsgLy8gX29wdHMucmFuZG9tQnl0ZXM/XG4vLyAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbi8vICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuLy8gICBjb25zdCByZWR1Y2VkID0gdW5zYWZlQWxsb3daZXJvID8gbW9kKG51bSwgT1JERVIpIDogbW9kKG51bSwgT1JERVIgLSBfMW4pICsgXzFuO1xuLy8gICByZXR1cm4gcmVkdWNlZDtcbi8vIH0sXG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRcIik7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgYG1hcEtleVRvRmllbGRgIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGhhc2hMZW4pO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGxlbik7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShrZXkpIDogYnl0ZXNUb051bWJlckJFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOlsiX3ZhbGlkYXRlT2JqZWN0IiwiYW51bWJlciIsImJpdE1hc2siLCJieXRlc1RvTnVtYmVyQkUiLCJieXRlc1RvTnVtYmVyTEUiLCJlbnN1cmVCeXRlcyIsIm51bWJlclRvQnl0ZXNCRSIsIm51bWJlclRvQnl0ZXNMRSIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl80biIsIl81biIsIl83biIsIl84biIsIl85biIsIl8xNm4iLCJtb2QiLCJhIiwiYiIsInJlc3VsdCIsInBvdyIsIm51bSIsInBvd2VyIiwibW9kdWxvIiwiRnBQb3ciLCJGaWVsZCIsInBvdzIiLCJ4IiwicmVzIiwiaW52ZXJ0IiwibnVtYmVyIiwiRXJyb3IiLCJ5IiwidSIsInYiLCJxIiwiciIsIm0iLCJuIiwiZ2NkIiwiYXNzZXJ0SXNTcXVhcmUiLCJGcCIsInJvb3QiLCJlcWwiLCJzcXIiLCJzcXJ0M21vZDQiLCJwMWRpdjQiLCJPUkRFUiIsInNxcnQ1bW9kOCIsInA1ZGl2OCIsIm4yIiwibXVsIiwibnYiLCJpIiwic3ViIiwiT05FIiwic3FydDltb2QxNiIsIlAiLCJGcF8iLCJ0biIsInRvbmVsbGlTaGFua3MiLCJjMSIsIm5lZyIsImMyIiwiYzMiLCJjNCIsInR2MSIsInR2MiIsInR2MyIsInR2NCIsImUxIiwiZTIiLCJjbW92IiwiZTMiLCJRIiwiUyIsIloiLCJfRnAiLCJGcExlZ2VuZHJlIiwiY2MiLCJRMWRpdjIiLCJ0b25lbGxpU2xvdyIsImlzMCIsIk0iLCJjIiwidCIsIlIiLCJaRVJPIiwidF90bXAiLCJleHBvbmVudCIsIkZwU3FydCIsImlzTmVnYXRpdmVMRSIsIkZJRUxEX0ZJRUxEUyIsInZhbGlkYXRlRmllbGQiLCJmaWVsZCIsImluaXRpYWwiLCJNQVNLIiwiQllURVMiLCJCSVRTIiwib3B0cyIsInJlZHVjZSIsIm1hcCIsInZhbCIsInAiLCJkIiwiRnBJbnZlcnRCYXRjaCIsIm51bXMiLCJwYXNzWmVybyIsImludmVydGVkIiwiQXJyYXkiLCJsZW5ndGgiLCJmaWxsIiwidW5kZWZpbmVkIiwibXVsdGlwbGllZEFjYyIsImFjYyIsImludmVydGVkQWNjIiwiaW52IiwicmVkdWNlUmlnaHQiLCJGcERpdiIsImxocyIsInJocyIsInAxbW9kMiIsInBvd2VyZWQiLCJ5ZXMiLCJ6ZXJvIiwibm8iLCJGcElzU3F1YXJlIiwibCIsIm5MZW5ndGgiLCJuQml0TGVuZ3RoIiwiX25CaXRMZW5ndGgiLCJ0b1N0cmluZyIsIm5CeXRlTGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJiaXRMZW5Pck9wdHMiLCJpc0xFIiwiX25iaXRMZW5ndGgiLCJfc3FydCIsIm1vZEZyb21CeXRlcyIsImFsbG93ZWRMZW5ndGhzIiwic3FydCIsIl9vcHRzIiwic3FydFAiLCJmIiwiT2JqZWN0IiwiZnJlZXplIiwiY3JlYXRlIiwiaXNWYWxpZCIsImlzVmFsaWROb3QwIiwiaXNPZGQiLCJhZGQiLCJkaXYiLCJzcXJOIiwiYWRkTiIsInN1Yk4iLCJtdWxOIiwidG9CeXRlcyIsImZyb21CeXRlcyIsImJ5dGVzIiwic2tpcFZhbGlkYXRpb24iLCJpbmNsdWRlcyIsInBhZGRlZCIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJzY2FsYXIiLCJpbnZlcnRCYXRjaCIsImxzdCIsIkZwU3FydE9kZCIsImVsbSIsIkZwU3FydEV2ZW4iLCJoYXNoVG9Qcml2YXRlU2NhbGFyIiwiaGFzaCIsImdyb3VwT3JkZXIiLCJoYXNoTGVuIiwibWluTGVuIiwiZ2V0RmllbGRCeXRlc0xlbmd0aCIsImZpZWxkT3JkZXIiLCJiaXRMZW5ndGgiLCJnZXRNaW5IYXNoTGVuZ3RoIiwibWFwSGFzaFRvRmllbGQiLCJrZXkiLCJsZW4iLCJmaWVsZExlbiIsInJlZHVjZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/montgomery.js":
/*!***************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/montgomery.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   montgomery: () => (/* binding */ montgomery)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction validateOpts(curve) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(curve, {\n        adjustScalarBytes: \"function\",\n        powPminus2: \"function\"\n    });\n    return Object.freeze({\n        ...curve\n    });\n}\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n    const is25519 = type === \"x25519\";\n    if (!is25519 && type !== \"x448\") throw new Error(\"invalid type\");\n    const randomBytes_ = rand || _utils_js__WEBPACK_IMPORTED_MODULE_1__.randomBytes;\n    const montgomeryBits = is25519 ? 255 : 448;\n    const fieldLen = is25519 ? 32 : 56;\n    const Gu = is25519 ? BigInt(9) : BigInt(5);\n    // RFC 7748 #5:\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n    // (156326 - 2) / 4 = 39081 for curve448/X448\n    // const a = is25519 ? 156326n : 486662n;\n    const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n    // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n    // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n    // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n    const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;\n    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n    const modP = (n)=>(0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(n, P);\n    const GuBytes = encodeU(Gu);\n    function encodeU(u) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(modP(u), fieldLen);\n    }\n    function decodeU(u) {\n        const _u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"u coordinate\", u, fieldLen);\n        // RFC: When receiving such an array, implementations of X25519\n        // (but not X448) MUST mask the most significant bit in the final byte.\n        if (is25519) _u[31] &= 127; // 0b0111_1111\n        // RFC: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.  The non-canonical\n        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n        // - 1 through 2^448 - 1 for X448.\n        return modP((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(_u));\n    }\n    function decodeScalar(scalar) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(adjustScalarBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"scalar\", scalar, fieldLen)));\n    }\n    function scalarMult(scalar, u) {\n        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n        // Some public keys are useless, of low-order. Curve author doesn't think\n        // it needs to be validated, but we do it nonetheless.\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n) throw new Error(\"invalid private or public key received\");\n        return encodeU(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    // cswap from RFC7748 \"example code\"\n    function cswap(swap, x_2, x_3) {\n        // dummy = mask(swap) AND (x_2 XOR x_3)\n        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n        // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n        return {\n            x_2,\n            x_3\n        };\n    }\n    /**\n     * Montgomery x-only multiplication ladder.\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */ function montgomeryLadder(u, scalar) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"u\", u, _0n, P);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"scalar\", scalar, minScalar, maxScalar);\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        for(let t = BigInt(montgomeryBits - 1); t >= _0n; t--){\n            const k_t = k >> t & _1n;\n            swap ^= k_t;\n            ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n    }\n    const lengths = {\n        secretKey: fieldLen,\n        publicKey: fieldLen,\n        seed: fieldLen\n    };\n    const randomSecretKey = (seed = randomBytes_(fieldLen))=>{\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(seed, lengths.seed);\n        return seed;\n    };\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: scalarMultBase(secretKey)\n        };\n    }\n    const utils = {\n        randomSecretKey,\n        randomPrivateKey: randomSecretKey\n    };\n    return {\n        keygen,\n        getSharedSecret: (secretKey, publicKey)=>scalarMult(secretKey, publicKey),\n        getPublicKey: (secretKey)=>scalarMultBase(secretKey),\n        scalarMult,\n        scalarMultBase,\n        utils,\n        GuBytes: GuBytes.slice(),\n        lengths\n    };\n} //# sourceMappingURL=montgomery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9udGdvbWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDRCxvRUFBb0UsR0FDeUQ7QUFDMUY7QUFDbkMsTUFBTVEsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsU0FBU0csYUFBYUMsS0FBSztJQUN2QmIsMERBQWVBLENBQUNhLE9BQU87UUFDbkJDLG1CQUFtQjtRQUNuQkMsWUFBWTtJQUNoQjtJQUNBLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQztRQUFFLEdBQUdKLEtBQUs7SUFBQztBQUNwQztBQUNPLFNBQVNLLFdBQVdDLFFBQVE7SUFDL0IsTUFBTUMsUUFBUVIsYUFBYU87SUFDM0IsTUFBTSxFQUFFRSxDQUFDLEVBQUVDLElBQUksRUFBRVIsaUJBQWlCLEVBQUVDLFVBQVUsRUFBRVQsYUFBYWlCLElBQUksRUFBRSxHQUFHSDtJQUN0RSxNQUFNSSxVQUFVRixTQUFTO0lBQ3pCLElBQUksQ0FBQ0UsV0FBV0YsU0FBUyxRQUNyQixNQUFNLElBQUlHLE1BQU07SUFDcEIsTUFBTUMsZUFBZUgsUUFBUWpCLGtEQUFXQTtJQUN4QyxNQUFNcUIsaUJBQWlCSCxVQUFVLE1BQU07SUFDdkMsTUFBTUksV0FBV0osVUFBVSxLQUFLO0lBQ2hDLE1BQU1LLEtBQUtMLFVBQVVmLE9BQU8sS0FBS0EsT0FBTztJQUN4QyxlQUFlO0lBQ2YsMEVBQTBFO0lBQzFFLDZDQUE2QztJQUM3Qyx5Q0FBeUM7SUFDekMsTUFBTXFCLE1BQU1OLFVBQVVmLE9BQU8sVUFBVUEsT0FBTztJQUM5QywrREFBK0Q7SUFDL0QsMkRBQTJEO0lBQzNELDRFQUE0RTtJQUM1RSxNQUFNc0IsWUFBWVAsVUFBVWIsT0FBT0YsT0FBTyxPQUFPRSxPQUFPRixPQUFPO0lBQy9ELE1BQU11QixXQUFXUixVQUNYZixPQUFPLEtBQUtFLE9B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QUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vbnRnb21lcnkuanM/NzM0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vbnRnb21lcnkgY3VydmUgbWV0aG9kcy4gSXQncyBub3QgcmVhbGx5IHdob2xlIG1vbnRnb21lcnkgY3VydmUsXG4gKiBqdXN0IGJ1bmNoIG9mIHZlcnkgc3BlY2lmaWMgbWV0aG9kcyBmb3IgWDI1NTE5IC8gWDQ0OCBmcm9tXG4gKiBbUkZDIDc3NDhdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3NzQ4KVxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBfdmFsaWRhdGVPYmplY3QsIGFieXRlcywgYUluUmFuZ2UsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNMRSwgcmFuZG9tQnl0ZXMsIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBtb2QgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBfdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHBvd1BtaW51czI6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jdXJ2ZSB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtb250Z29tZXJ5KGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgUCwgdHlwZSwgYWRqdXN0U2NhbGFyQnl0ZXMsIHBvd1BtaW51czIsIHJhbmRvbUJ5dGVzOiByYW5kIH0gPSBDVVJWRTtcbiAgICBjb25zdCBpczI1NTE5ID0gdHlwZSA9PT0gJ3gyNTUxOSc7XG4gICAgaWYgKCFpczI1NTE5ICYmIHR5cGUgIT09ICd4NDQ4JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICBjb25zdCByYW5kb21CeXRlc18gPSByYW5kIHx8IHJhbmRvbUJ5dGVzO1xuICAgIGNvbnN0IG1vbnRnb21lcnlCaXRzID0gaXMyNTUxOSA/IDI1NSA6IDQ0ODtcbiAgICBjb25zdCBmaWVsZExlbiA9IGlzMjU1MTkgPyAzMiA6IDU2O1xuICAgIGNvbnN0IEd1ID0gaXMyNTUxOSA/IEJpZ0ludCg5KSA6IEJpZ0ludCg1KTtcbiAgICAvLyBSRkMgNzc0OCAjNTpcbiAgICAvLyBUaGUgY29uc3RhbnQgYTI0IGlzICg0ODY2NjIgLSAyKSAvIDQgPSAxMjE2NjUgZm9yIGN1cnZlMjU1MTkvWDI1NTE5IGFuZFxuICAgIC8vICgxNTYzMjYgLSAyKSAvIDQgPSAzOTA4MSBmb3IgY3VydmU0NDgvWDQ0OFxuICAgIC8vIGNvbnN0IGEgPSBpczI1NTE5ID8gMTU2MzI2biA6IDQ4NjY2Mm47XG4gICAgY29uc3QgYTI0ID0gaXMyNTUxOSA/IEJpZ0ludCgxMjE2NjUpIDogQmlnSW50KDM5MDgxKTtcbiAgICAvLyBSRkM6IHgyNTUxOSBcInRoZSByZXN1bHRpbmcgaW50ZWdlciBpcyBvZiB0aGUgZm9ybSAyXjI1NCBwbHVzXG4gICAgLy8gZWlnaHQgdGltZXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDJeMjUxIC0gMSAoaW5jbHVzaXZlKVwiXG4gICAgLy8geDQ0ODogXCIyXjQ0NyBwbHVzIGZvdXIgdGltZXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDJeNDQ1IC0gMSAoaW5jbHVzaXZlKVwiXG4gICAgY29uc3QgbWluU2NhbGFyID0gaXMyNTUxOSA/IF8ybiAqKiBCaWdJbnQoMjU0KSA6IF8ybiAqKiBCaWdJbnQoNDQ3KTtcbiAgICBjb25zdCBtYXhBZGRlZCA9IGlzMjU1MTlcbiAgICAgICAgPyBCaWdJbnQoOCkgKiBfMm4gKiogQmlnSW50KDI1MSkgLSBfMW5cbiAgICAgICAgOiBCaWdJbnQoNCkgKiBfMm4gKiogQmlnSW50KDQ0NSkgLSBfMW47XG4gICAgY29uc3QgbWF4U2NhbGFyID0gbWluU2NhbGFyICsgbWF4QWRkZWQgKyBfMW47IC8vIChpbmNsdXNpdmUpXG4gICAgY29uc3QgbW9kUCA9IChuKSA9PiBtb2QobiwgUCk7XG4gICAgY29uc3QgR3VCeXRlcyA9IGVuY29kZVUoR3UpO1xuICAgIGZ1bmN0aW9uIGVuY29kZVUodSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0xFKG1vZFAodSksIGZpZWxkTGVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlVSh1KSB7XG4gICAgICAgIGNvbnN0IF91ID0gZW5zdXJlQnl0ZXMoJ3UgY29vcmRpbmF0ZScsIHUsIGZpZWxkTGVuKTtcbiAgICAgICAgLy8gUkZDOiBXaGVuIHJlY2VpdmluZyBzdWNoIGFuIGFycmF5LCBpbXBsZW1lbnRhdGlvbnMgb2YgWDI1NTE5XG4gICAgICAgIC8vIChidXQgbm90IFg0NDgpIE1VU1QgbWFzayB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgaW4gdGhlIGZpbmFsIGJ5dGUuXG4gICAgICAgIGlmIChpczI1NTE5KVxuICAgICAgICAgICAgX3VbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAgICAgLy8gUkZDOiBJbXBsZW1lbnRhdGlvbnMgTVVTVCBhY2NlcHQgbm9uLWNhbm9uaWNhbCB2YWx1ZXMgYW5kIHByb2Nlc3MgdGhlbSBhc1xuICAgICAgICAvLyBpZiB0aGV5IGhhZCBiZWVuIHJlZHVjZWQgbW9kdWxvIHRoZSBmaWVsZCBwcmltZS4gIFRoZSBub24tY2Fub25pY2FsXG4gICAgICAgIC8vIHZhbHVlcyBhcmUgMl4yNTUgLSAxOSB0aHJvdWdoIDJeMjU1IC0gMSBmb3IgWDI1NTE5IGFuZCAyXjQ0OCAtIDJeMjI0XG4gICAgICAgIC8vIC0gMSB0aHJvdWdoIDJeNDQ4IC0gMSBmb3IgWDQ0OC5cbiAgICAgICAgcmV0dXJuIG1vZFAoYnl0ZXNUb051bWJlckxFKF91KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVNjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJMRShhZGp1c3RTY2FsYXJCeXRlcyhlbnN1cmVCeXRlcygnc2NhbGFyJywgc2NhbGFyLCBmaWVsZExlbikpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGFyTXVsdChzY2FsYXIsIHUpIHtcbiAgICAgICAgY29uc3QgcHUgPSBtb250Z29tZXJ5TGFkZGVyKGRlY29kZVUodSksIGRlY29kZVNjYWxhcihzY2FsYXIpKTtcbiAgICAgICAgLy8gU29tZSBwdWJsaWMga2V5cyBhcmUgdXNlbGVzcywgb2YgbG93LW9yZGVyLiBDdXJ2ZSBhdXRob3IgZG9lc24ndCB0aGlua1xuICAgICAgICAvLyBpdCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQsIGJ1dCB3ZSBkbyBpdCBub25ldGhlbGVzcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9jci55cC50by9lY2RoLmh0bWwjdmFsaWRhdGVcbiAgICAgICAgaWYgKHB1ID09PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBvciBwdWJsaWMga2V5IHJlY2VpdmVkJyk7XG4gICAgICAgIHJldHVybiBlbmNvZGVVKHB1KTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcHVibGljIGtleSBmcm9tIHByaXZhdGUuIEJ5IGRvaW5nIHNjYWxhciBtdWx0aXBsaWNhdGlvbiBvZiBiYXNlIHBvaW50LlxuICAgIGZ1bmN0aW9uIHNjYWxhck11bHRCYXNlKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gc2NhbGFyTXVsdChzY2FsYXIsIEd1Qnl0ZXMpO1xuICAgIH1cbiAgICAvLyBjc3dhcCBmcm9tIFJGQzc3NDggXCJleGFtcGxlIGNvZGVcIlxuICAgIGZ1bmN0aW9uIGNzd2FwKHN3YXAsIHhfMiwgeF8zKSB7XG4gICAgICAgIC8vIGR1bW15ID0gbWFzayhzd2FwKSBBTkQgKHhfMiBYT1IgeF8zKVxuICAgICAgICAvLyBXaGVyZSBtYXNrKHN3YXApIGlzIHRoZSBhbGwtMSBvciBhbGwtMCB3b3JkIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB4XzJcbiAgICAgICAgLy8gYW5kIHhfMywgY29tcHV0ZWQsIGUuZy4sIGFzIG1hc2soc3dhcCkgPSAwIC0gc3dhcC5cbiAgICAgICAgY29uc3QgZHVtbXkgPSBtb2RQKHN3YXAgKiAoeF8yIC0geF8zKSk7XG4gICAgICAgIHhfMiA9IG1vZFAoeF8yIC0gZHVtbXkpOyAvLyB4XzIgPSB4XzIgWE9SIGR1bW15XG4gICAgICAgIHhfMyA9IG1vZFAoeF8zICsgZHVtbXkpOyAvLyB4XzMgPSB4XzMgWE9SIGR1bW15XG4gICAgICAgIHJldHVybiB7IHhfMiwgeF8zIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vbnRnb21lcnkgeC1vbmx5IG11bHRpcGxpY2F0aW9uIGxhZGRlci5cbiAgICAgKiBAcGFyYW0gcG9pbnRVIHUgY29vcmRpbmF0ZSAoeCkgb24gTW9udGdvbWVyeSBDdXJ2ZSAyNTUxOVxuICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgKiBAcmV0dXJucyBuZXcgUG9pbnQgb24gTW9udGdvbWVyeSBjdXJ2ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vbnRnb21lcnlMYWRkZXIodSwgc2NhbGFyKSB7XG4gICAgICAgIGFJblJhbmdlKCd1JywgdSwgXzBuLCBQKTtcbiAgICAgICAgYUluUmFuZ2UoJ3NjYWxhcicsIHNjYWxhciwgbWluU2NhbGFyLCBtYXhTY2FsYXIpO1xuICAgICAgICBjb25zdCBrID0gc2NhbGFyO1xuICAgICAgICBjb25zdCB4XzEgPSB1O1xuICAgICAgICBsZXQgeF8yID0gXzFuO1xuICAgICAgICBsZXQgel8yID0gXzBuO1xuICAgICAgICBsZXQgeF8zID0gdTtcbiAgICAgICAgbGV0IHpfMyA9IF8xbjtcbiAgICAgICAgbGV0IHN3YXAgPSBfMG47XG4gICAgICAgIGZvciAobGV0IHQgPSBCaWdJbnQobW9udGdvbWVyeUJpdHMgLSAxKTsgdCA+PSBfMG47IHQtLSkge1xuICAgICAgICAgICAgY29uc3Qga190ID0gKGsgPj4gdCkgJiBfMW47XG4gICAgICAgICAgICBzd2FwIF49IGtfdDtcbiAgICAgICAgICAgICh7IHhfMiwgeF8zIH0gPSBjc3dhcChzd2FwLCB4XzIsIHhfMykpO1xuICAgICAgICAgICAgKHsgeF8yOiB6XzIsIHhfMzogel8zIH0gPSBjc3dhcChzd2FwLCB6XzIsIHpfMykpO1xuICAgICAgICAgICAgc3dhcCA9IGtfdDtcbiAgICAgICAgICAgIGNvbnN0IEEgPSB4XzIgKyB6XzI7XG4gICAgICAgICAgICBjb25zdCBBQSA9IG1vZFAoQSAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQiA9IHhfMiAtIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEJCID0gbW9kUChCICogQik7XG4gICAgICAgICAgICBjb25zdCBFID0gQUEgLSBCQjtcbiAgICAgICAgICAgIGNvbnN0IEMgPSB4XzMgKyB6XzM7XG4gICAgICAgICAgICBjb25zdCBEID0geF8zIC0gel8zO1xuICAgICAgICAgICAgY29uc3QgREEgPSBtb2RQKEQgKiBBKTtcbiAgICAgICAgICAgIGNvbnN0IENCID0gbW9kUChDICogQik7XG4gICAgICAgICAgICBjb25zdCBkYWNiID0gREEgKyBDQjtcbiAgICAgICAgICAgIGNvbnN0IGRhX2NiID0gREEgLSBDQjtcbiAgICAgICAgICAgIHhfMyA9IG1vZFAoZGFjYiAqIGRhY2IpO1xuICAgICAgICAgICAgel8zID0gbW9kUCh4XzEgKiBtb2RQKGRhX2NiICogZGFfY2IpKTtcbiAgICAgICAgICAgIHhfMiA9IG1vZFAoQUEgKiBCQik7XG4gICAgICAgICAgICB6XzIgPSBtb2RQKEUgKiAoQUEgKyBtb2RQKGEyNCAqIEUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgeF8yLCB4XzMgfSA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKSk7XG4gICAgICAgICh7IHhfMjogel8yLCB4XzM6IHpfMyB9ID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpKTtcbiAgICAgICAgY29uc3QgejIgPSBwb3dQbWludXMyKHpfMik7IC8vIGBGcC5wb3coeCwgUCAtIF8ybilgIGlzIG11Y2ggc2xvd2VyIGVxdWl2YWxlbnRcbiAgICAgICAgcmV0dXJuIG1vZFAoeF8yICogejIpOyAvLyBSZXR1cm4geF8yICogKHpfMl4ocCAtIDIpKVxuICAgIH1cbiAgICBjb25zdCBsZW5ndGhzID0ge1xuICAgICAgICBzZWNyZXRLZXk6IGZpZWxkTGVuLFxuICAgICAgICBwdWJsaWNLZXk6IGZpZWxkTGVuLFxuICAgICAgICBzZWVkOiBmaWVsZExlbixcbiAgICB9O1xuICAgIGNvbnN0IHJhbmRvbVNlY3JldEtleSA9IChzZWVkID0gcmFuZG9tQnl0ZXNfKGZpZWxkTGVuKSkgPT4ge1xuICAgICAgICBhYnl0ZXMoc2VlZCwgbGVuZ3Rocy5zZWVkKTtcbiAgICAgICAgcmV0dXJuIHNlZWQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBrZXlnZW4oc2VlZCkge1xuICAgICAgICBjb25zdCBzZWNyZXRLZXkgPSByYW5kb21TZWNyZXRLZXkoc2VlZCk7XG4gICAgICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBzY2FsYXJNdWx0QmFzZShzZWNyZXRLZXkpIH07XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICByYW5kb21TZWNyZXRLZXksXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHJhbmRvbVNlY3JldEtleSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleWdlbixcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0OiAoc2VjcmV0S2V5LCBwdWJsaWNLZXkpID0+IHNjYWxhck11bHQoc2VjcmV0S2V5LCBwdWJsaWNLZXkpLFxuICAgICAgICBnZXRQdWJsaWNLZXk6IChzZWNyZXRLZXkpID0+IHNjYWxhck11bHRCYXNlKHNlY3JldEtleSksXG4gICAgICAgIHNjYWxhck11bHQsXG4gICAgICAgIHNjYWxhck11bHRCYXNlLFxuICAgICAgICB1dGlscyxcbiAgICAgICAgR3VCeXRlczogR3VCeXRlcy5zbGljZSgpLFxuICAgICAgICBsZW5ndGhzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb250Z29tZXJ5LmpzLm1hcCJdLCJuYW1lcyI6WyJfdmFsaWRhdGVPYmplY3QiLCJhYnl0ZXMiLCJhSW5SYW5nZSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwibnVtYmVyVG9CeXRlc0xFIiwicmFuZG9tQnl0ZXMiLCJtb2QiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJ2YWxpZGF0ZU9wdHMiLCJjdXJ2ZSIsImFkanVzdFNjYWxhckJ5dGVzIiwicG93UG1pbnVzMiIsIk9iamVjdCIsImZyZWV6ZSIsIm1vbnRnb21lcnkiLCJjdXJ2ZURlZiIsIkNVUlZFIiwiUCIsInR5cGUiLCJyYW5kIiwiaXMyNTUxOSIsIkVycm9yIiwicmFuZG9tQnl0ZXNfIiwibW9udGdvbWVyeUJpdHMiLCJmaWVsZExlbiIsIkd1IiwiYTI0IiwibWluU2NhbGFyIiwibWF4QWRkZWQiLCJtYXhTY2FsYXIiLCJtb2RQIiwibiIsIkd1Qnl0ZXMiLCJlbmNvZGVVIiwidSIsImRlY29kZVUiLCJfdSIsImRlY29kZVNjYWxhciIsInNjYWxhciIsInNjYWxhck11bHQiLCJwdSIsIm1vbnRnb21lcnlMYWRkZXIiLCJzY2FsYXJNdWx0QmFzZSIsImNzd2FwIiwic3dhcCIsInhfMiIsInhfMyIsImR1bW15IiwiayIsInhfMSIsInpfMiIsInpfMyIsInQiLCJrX3QiLCJBIiwiQUEiLCJCIiwiQkIiLCJFIiwiQyIsIkQiLCJEQSIsIkNCIiwiZGFjYiIsImRhX2NiIiwiejIiLCJsZW5ndGhzIiwic2VjcmV0S2V5IiwicHVibGljS2V5Iiwic2VlZCIsInJhbmRvbVNlY3JldEtleSIsImtleWdlbiIsInV0aWxzIiwicmFuZG9tUHJpdmF0ZUtleSIsImdldFNoYXJlZFNlY3JldCIsImdldFB1YmxpY0tleSIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/montgomery.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/ed25519.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/curves/esm/ed25519.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_TORSION_SUBGROUP: () => (/* binding */ ED25519_TORSION_SUBGROUP),\n/* harmony export */   RistrettoPoint: () => (/* binding */ RistrettoPoint),\n/* harmony export */   ed25519: () => (/* binding */ ed25519),\n/* harmony export */   ed25519_hasher: () => (/* binding */ ed25519_hasher),\n/* harmony export */   ed25519ctx: () => (/* binding */ ed25519ctx),\n/* harmony export */   ed25519ph: () => (/* binding */ ed25519ph),\n/* harmony export */   edwardsToMontgomery: () => (/* binding */ edwardsToMontgomery),\n/* harmony export */   edwardsToMontgomeryPriv: () => (/* binding */ edwardsToMontgomeryPriv),\n/* harmony export */   edwardsToMontgomeryPub: () => (/* binding */ edwardsToMontgomeryPub),\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   hashToRistretto255: () => (/* binding */ hashToRistretto255),\n/* harmony export */   hash_to_ristretto255: () => (/* binding */ hash_to_ristretto255),\n/* harmony export */   ristretto255: () => (/* binding */ ristretto255),\n/* harmony export */   ristretto255_hasher: () => (/* binding */ ristretto255_hasher),\n/* harmony export */   x25519: () => (/* binding */ x25519)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha2.js */ \"(ssr)/./node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_curve_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./abstract/curve.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/edwards.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/edwards.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/montgomery.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/montgomery.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/utils.js\");\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\n\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n// P = 2n**255n-19n\nconst ed25519_CURVE_p = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\");\n// N = 2n**252n + 27742317777372353535851937790883648493n\n// a = Fp.create(BigInt(-1))\n// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\nconst ed25519_CURVE = /* @__PURE__ */ (()=>({\n        p: ed25519_CURVE_p,\n        n: BigInt(\"0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\"),\n        h: _8n,\n        a: BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec\"),\n        d: BigInt(\"0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3\"),\n        Gx: BigInt(\"0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\"),\n        Gy: BigInt(\"0x6666666666666666666666666666666666666666666666666666666666666658\")\n    }))();\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ed25519_CURVE_p;\n    const x2 = x * x % P;\n    const b2 = x2 * x % P; // x^3, 11\n    const b4 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b2, _2n, P) * b2 % P; // x^15, 1111\n    const b5 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b4, _1n, P) * x % P; // x^31\n    const b10 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b5, _5n, P) * b5 % P;\n    const b20 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b10, _10n, P) * b10 % P;\n    const b40 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b20, _20n, P) * b20 % P;\n    const b80 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b40, _40n, P) * b40 % P;\n    const b160 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b80, _80n, P) * b80 % P;\n    const b240 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b160, _80n, P) * b80 % P;\n    const b250 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b240, _10n, P) * b10 % P;\n    const pow_p_5_8 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b250, _2n, P) * x % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return {\n        pow_p_5_8,\n        b2\n    };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// √(-1) aka √(a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ed25519_CURVE_p;\n    const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * v * v, P); // v³\n    const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v3 * v3 * v, P); // v⁷\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * x * x, P); // vx²\n    const root1 = x; // First root candidate\n    const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P)) x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-x, P);\n    return {\n        isValid: useRoot1 || useRoot2,\n        value: x\n    };\n}\nconst Fp = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ed25519_CURVE.p, {\n        isLE: true\n    }))();\nconst Fn = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ed25519_CURVE.n, {\n        isLE: true\n    }))();\nconst ed25519Defaults = /* @__PURE__ */ (()=>({\n        ...ed25519_CURVE,\n        Fp,\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512,\n        adjustScalarBytes,\n        // dom2\n        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n        // Constant-time, u/√v\n        uvRatio\n    }))();\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const { secretKey, publicKey } = ed25519.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */ const ed25519 = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)(ed25519Defaults))();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255) throw new Error(\"Context is too big\");\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.utf8ToBytes)(\"SigEd25519 no Ed25519 collisions\"), new Uint8Array([\n        phflag ? 1 : 0,\n        ctx.length\n    ]), ctx, data);\n}\n/** Context of ed25519. Uses context for domain separation. */ const ed25519ctx = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)({\n        ...ed25519Defaults,\n        domain: ed25519_domain\n    }))();\n/** Prehashed version of ed25519. Accepts already-hashed messages in sign() and verify(). */ const ed25519ph = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)(Object.assign({}, ed25519Defaults, {\n        domain: ed25519_domain,\n        prehash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512\n    })))();\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomSecretKey());\n */ const x25519 = /* @__PURE__ */ (()=>{\n    const P = Fp.ORDER;\n    return (0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__.montgomery)({\n        P,\n        type: \"x25519\",\n        powPminus2: (x)=>{\n            // x^(p-2) aka x^(2^255-21)\n            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n            return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(pow_p_5_8, _3n, P) * b2, P);\n        },\n        adjustScalarBytes\n    });\n})();\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (()=>(ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (()=>Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (()=>Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return {\n        xMn: xn,\n        xMd: xd,\n        yMn: y,\n        yMd: _1n\n    }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const [xd_inv, yd_inv] = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch)(Fp, [\n        xd,\n        yd\n    ], true); // batch division\n    return {\n        x: Fp.mul(xn, xd_inv),\n        y: Fp.mul(yn, yd_inv)\n    }; //  13. return (xn, xd, yn, yd)\n}\n/** Hashing to ed25519 points / field. RFC 9380 methods. */ const ed25519_hasher = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(ed25519.Point, (scalars)=>map_to_curve_elligator2_edwards25519(scalars[0]), {\n        DST: \"edwards25519_XMD:SHA-512_ELL2_RO_\",\n        encodeDST: \"edwards25519_XMD:SHA-512_ELL2_NU_\",\n        p: ed25519_CURVE_p,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512\n    }))();\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\"25063068953384623474111414158702152701244531502492656460079210482610430750235\");\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\"54469307008909316920995813868745141605393597292927456921205312896311721017578\");\n// 1-d²\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\"1159843021668779879193775521855586647937357759715417654439879720876111806838\");\n// (d-1)²\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\"40440834346308536858101042469323190826248399146238708352240133220865137265952\");\n// Calculates 1/√(number)\nconst invertSqrt = (number)=>uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst bytes255ToNumberLE = (bytes)=>ed25519.Point.Fp.create((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(bytes) & MAX_255B);\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */ function calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519_CURVE;\n    const P = ed25519_CURVE_p;\n    const mod = (n)=>Fp.create(n);\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s_, P)) s_ = mod(-s_);\n    if (!Ns_D_is_sq) s = s_; // 7\n    if (!Ns_D_is_sq) c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\nfunction ristretto255_map(bytes) {\n    (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.abytes)(bytes, 64);\n    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new _RistrettoPoint(R1.add(R2));\n}\n/**\n * Wrapper over Edwards Point for ristretto255.\n *\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */ class _RistrettoPoint extends _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.PrimeEdwardsPoint {\n    constructor(ep){\n        super(ep);\n    }\n    static fromAffine(ap) {\n        return new _RistrettoPoint(ed25519.Point.fromAffine(ap));\n    }\n    assertSame(other) {\n        if (!(other instanceof _RistrettoPoint)) throw new Error(\"RistrettoPoint expected\");\n    }\n    init(ep) {\n        return new _RistrettoPoint(ep);\n    }\n    /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ static hashToCurve(hex) {\n        return ristretto255_map((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"ristrettoHash\", hex, 64));\n    }\n    static fromBytes(bytes) {\n        (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.abytes)(bytes, 32);\n        const { a, d } = ed25519_CURVE;\n        const P = ed25519_CURVE_p;\n        const mod = (n)=>Fp.create(n);\n        const s = bytes255ToNumberLE(bytes);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.equalBytes)(Fp.toBytes(s), bytes) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P)) throw new Error(\"invalid ristretto255 encoding 1\");\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P)) x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t, P) || y === _0n) throw new Error(\"invalid ristretto255 encoding 2\");\n        return new _RistrettoPoint(new ed25519.Point(x, y, _1n, t));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */ static fromHex(hex) {\n        return _RistrettoPoint.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"ristrettoHex\", hex, 32));\n    }\n    static msm(points, scalars) {\n        return (0,_abstract_curve_js__WEBPACK_IMPORTED_MODULE_7__.pippenger)(_RistrettoPoint, ed25519.Point.Fn, points, scalars);\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n     */ toBytes() {\n        let { X, Y, Z, T } = this.ep;\n        const P = ed25519_CURVE_p;\n        const mod = (n)=>Fp.create(n);\n        const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1\n        const u2 = mod(X * Y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * T); // 6\n        let D; // 7\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(T * zInv, P)) {\n            let _x = mod(Y * SQRT_M1);\n            let _y = mod(X * SQRT_M1);\n            X = _x;\n            Y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        } else {\n            D = D2; // 8\n        }\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(X * zInv, P)) Y = mod(-Y); // 9\n        let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P)) s = mod(-s);\n        return Fp.toBytes(s); // 11\n    }\n    /**\n     * Compares two Ristretto points.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n     */ equals(other) {\n        this.assertSame(other);\n        const { X: X1, Y: Y1 } = this.ep;\n        const { X: X2, Y: Y2 } = other.ep;\n        const mod = (n)=>Fp.create(n);\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    is0() {\n        return this.equals(_RistrettoPoint.ZERO);\n    }\n}\n// Do NOT change syntax: the following gymnastics is done,\n// because typescript strips comments, which makes bundlers disable tree-shaking.\n// prettier-ignore\n_RistrettoPoint.BASE = /* @__PURE__ */ (()=>new _RistrettoPoint(ed25519.Point.BASE))();\n// prettier-ignore\n_RistrettoPoint.ZERO = /* @__PURE__ */ (()=>new _RistrettoPoint(ed25519.Point.ZERO))();\n// prettier-ignore\n_RistrettoPoint.Fp = /* @__PURE__ */ (()=>Fp)();\n// prettier-ignore\n_RistrettoPoint.Fn = /* @__PURE__ */ (()=>Fn)();\nconst ristretto255 = {\n    Point: _RistrettoPoint\n};\n/** Hashing to ristretto255 points / field. RFC 9380 methods. */ const ristretto255_hasher = {\n    hashToCurve (msg, options) {\n        const DST = options?.DST || \"ristretto255_XMD:SHA-512_R255MAP_RO_\";\n        const xmd = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512);\n        return ristretto255_map(xmd);\n    },\n    hashToScalar (msg, options = {\n        DST: _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__._DST_scalar\n    }) {\n        const xmd = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, options.DST, 64, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512);\n        return Fn.create((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(xmd));\n    }\n};\n// export const ristretto255_oprf: OPRF = createORPF({\n//   name: 'ristretto255-SHA512',\n//   Point: RistrettoPoint,\n//   hash: sha512,\n//   hashToGroup: ristretto255_hasher.hashToCurve,\n//   hashToScalar: ristretto255_hasher.hashToScalar,\n// });\n/**\n * Weird / bogus points, useful for debugging.\n * All 8 ed25519 points of 8-torsion subgroup can be generated from the point\n * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.\n * ⟨T⟩ = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }\n */ const ED25519_TORSION_SUBGROUP = [\n    \"0100000000000000000000000000000000000000000000000000000000000000\",\n    \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a\",\n    \"0000000000000000000000000000000000000000000000000000000000000080\",\n    \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05\",\n    \"ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f\",\n    \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85\",\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa\"\n];\n/** @deprecated use `ed25519.utils.toMontgomery` */ function edwardsToMontgomeryPub(edwardsPub) {\n    return ed25519.utils.toMontgomery((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"pub\", edwardsPub));\n}\n/** @deprecated use `ed25519.utils.toMontgomery` */ const edwardsToMontgomery = edwardsToMontgomeryPub;\n/** @deprecated use `ed25519.utils.toMontgomeryPriv` */ function edwardsToMontgomeryPriv(edwardsPriv) {\n    return ed25519.utils.toMontgomeryPriv((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"pub\", edwardsPriv));\n}\n/** @deprecated use `ristretto255.Point` */ const RistrettoPoint = _RistrettoPoint;\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */ const hashToCurve = /* @__PURE__ */ (()=>ed25519_hasher.hashToCurve)();\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */ const encodeToCurve = /* @__PURE__ */ (()=>ed25519_hasher.encodeToCurve)();\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ const hashToRistretto255 = /* @__PURE__ */ (()=>ristretto255_hasher.hashToCurve)();\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ const hash_to_ristretto255 = /* @__PURE__ */ (()=>ristretto255_hasher.hashToCurve)(); //# sourceMappingURL=ed25519.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vZWQyNTUxOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDRCxvRUFBb0UsR0FDckI7QUFDMkI7QUFDMUI7QUFDMkI7QUFDa0I7QUFDTTtBQUM3QztBQUNnQjtBQUN0RSxrQkFBa0I7QUFDbEIsTUFBTW9CLE1BQU0sYUFBYSxHQUFHQyxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTUYsT0FBTyxJQUFJRyxNQUFNSCxPQUFPO0FBQ3RGLGtCQUFrQjtBQUNsQixNQUFNSSxNQUFNSixPQUFPLElBQUlLLE1BQU1MLE9BQU87QUFDcEMsbUJBQW1CO0FBQ25CLE1BQU1NLGtCQUFrQk4sT0FBTztBQUMvQix5REFBeUQ7QUFDekQsNEJBQTRCO0FBQzVCLDREQUE0RDtBQUM1RCxNQUFNTyxnQkFBZ0MsYUFBSCxHQUFJLEtBQU87UUFDMUNDLEdBQUdGO1FBQ0hHLEdBQUdULE9BQU87UUFDVlUsR0FBR0w7UUFDSE0sR0FBR1gsT0FBTztRQUNWWSxHQUFHWixPQUFPO1FBQ1ZhLElBQUliLE9BQU87UUFDWGMsSUFBSWQsT0FBTztJQUNmLEVBQUM7QUFDRCxTQUFTZSxvQkFBb0JDLENBQUM7SUFDMUIsa0JBQWtCO0lBQ2xCLE1BQU1DLE9BQU9qQixPQUFPLEtBQUtrQixPQUFPbEIsT0FBTyxLQUFLbUIsT0FBT25CLE9BQU8sS0FBS29CLE9BQU9wQixPQUFPO0lBQzdFLE1BQU1xQixJQUFJZjtJQUNWLE1BQU1nQixLQUFLLElBQUtOLElBQUtLO0lBQ3JCLE1BQU1FLEtBQUssS0FBTVAsSUFBS0ssR0FBRyxVQUFVO0lBQ25DLE1BQU1HLEtBQUssMkRBQU1ELElBQUlyQixLQUFLbUIsS0FBS0UsS0FBTUYsR0FBRyxhQUFhO0lBQ3JELE1BQU1JLEtBQUssMkRBQU1ELElBQUl2QixLQUFLb0IsS0FBS0wsSUFBS0ssR0FBRyxPQUFPO0lBQzlDLE1B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QXdCQyxXQUFXO0lBQy9DLE9BQU9sSyxRQUFROEosS0FBSyxDQUFDSyxnQkFBZ0IsQ0FBQzlOLHNEQUFXQSxDQUFDLE9BQU82TjtBQUM3RDtBQUNBLHlDQUF5QyxHQUNsQyxNQUFNRSxpQkFBaUIxRCxnQkFBZ0I7QUFDOUMsaUZBQWlGLEdBQzFFLE1BQU1RLGNBQThCLGFBQUgsR0FBSSxLQUFNL0MsZUFBZStDLFdBQVcsSUFBSTtBQUNoRixpRkFBaUYsR0FDMUUsTUFBTW1ELGdCQUFnQyxhQUFILEdBQUksS0FBTWxHLGVBQWVrRyxhQUFhLElBQUk7QUFDcEYsc0ZBQXNGLEdBQy9FLE1BQU1DLHFCQUFxQyxhQUFILEdBQUksS0FBTWhCLG9CQUFvQnBDLFdBQVcsSUFBSTtBQUM1RixzRkFBc0YsR0FDL0UsTUFBTXFELHVCQUF1QyxhQUFILEdBQUksS0FBTWpCLG9CQUFvQnBDLFdBQVcsSUFBSSxDQUM5RixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9lZDI1NTE5LmpzP2E2MTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBlZDI1NTE5IFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZSB3aXRoIGZvbGxvd2luZyBhZGRvbnM6XG4gKiAtIFgyNTUxOSBFQ0RIXG4gKiAtIFJpc3RyZXR0byBjb2ZhY3RvciBlbGltaW5hdGlvblxuICogLSBFbGxpZ2F0b3IgaGFzaC10by1ncm91cCAvIHBvaW50IGluZGlzdGluZ3Vpc2hhYmlsaXR5XG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMi5qcyc7XG5pbXBvcnQgeyBhYnl0ZXMsIGNvbmNhdEJ5dGVzLCB1dGY4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuaW1wb3J0IHsgcGlwcGVuZ2VyIH0gZnJvbSBcIi4vYWJzdHJhY3QvY3VydmUuanNcIjtcbmltcG9ydCB7IFByaW1lRWR3YXJkc1BvaW50LCB0d2lzdGVkRWR3YXJkcywgfSBmcm9tIFwiLi9hYnN0cmFjdC9lZHdhcmRzLmpzXCI7XG5pbXBvcnQgeyBfRFNUX3NjYWxhciwgY3JlYXRlSGFzaGVyLCBleHBhbmRfbWVzc2FnZV94bWQsIH0gZnJvbSBcIi4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qc1wiO1xuaW1wb3J0IHsgRmllbGQsIEZwSW52ZXJ0QmF0Y2gsIEZwU3FydEV2ZW4sIGlzTmVnYXRpdmVMRSwgbW9kLCBwb3cyLCB9IGZyb20gXCIuL2Fic3RyYWN0L21vZHVsYXIuanNcIjtcbmltcG9ydCB7IG1vbnRnb21lcnkgfSBmcm9tIFwiLi9hYnN0cmFjdC9tb250Z29tZXJ5LmpzXCI7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBlcXVhbEJ5dGVzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBQID0gMm4qKjI1NW4tMTluXG5jb25zdCBlZDI1NTE5X0NVUlZFX3AgPSBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZCcpO1xuLy8gTiA9IDJuKioyNTJuICsgMjc3NDIzMTc3NzczNzIzNTM1MzU4NTE5Mzc3OTA4ODM2NDg0OTNuXG4vLyBhID0gRnAuY3JlYXRlKEJpZ0ludCgtMSkpXG4vLyBkID0gLTEyMTY2NS8xMjE2NjYgYS5rLmEuIEZwLm5lZygxMjE2NjUgKiBGcC5pbnYoMTIxNjY2KSlcbmNvbnN0IGVkMjU1MTlfQ1VSVkUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgcDogZWQyNTUxOV9DVVJWRV9wLFxuICAgIG46IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE0ZGVmOWRlYTJmNzljZDY1ODEyNjMxYTVjZjVkM2VkJyksXG4gICAgaDogXzhuLFxuICAgIGE6IEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVjJyksXG4gICAgZDogQmlnSW50KCcweDUyMDM2Y2VlMmI2ZmZlNzM4Y2M3NDA3OTc3NzllODk4MDA3MDBhNGQ0MTQxZDhhYjc1ZWI0ZGNhMTM1OTc4YTMnKSxcbiAgICBHeDogQmlnSW50KCcweDIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnKSxcbiAgICBHeTogQmlnSW50KCcweDY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnKSxcbn0pKSgpO1xuZnVuY3Rpb24gZWQyNTUxOV9wb3dfMl8yNTJfMyh4KSB7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzEwbiA9IEJpZ0ludCgxMCksIF8yMG4gPSBCaWdJbnQoMjApLCBfNDBuID0gQmlnSW50KDQwKSwgXzgwbiA9IEJpZ0ludCg4MCk7XG4gICAgY29uc3QgUCA9IGVkMjU1MTlfQ1VSVkVfcDtcbiAgICBjb25zdCB4MiA9ICh4ICogeCkgJSBQO1xuICAgIGNvbnN0IGIyID0gKHgyICogeCkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjQgPSAocG93MihiMiwgXzJuLCBQKSAqIGIyKSAlIFA7IC8vIHheMTUsIDExMTFcbiAgICBjb25zdCBiNSA9IChwb3cyKGI0LCBfMW4sIFApICogeCkgJSBQOyAvLyB4XjMxXG4gICAgY29uc3QgYjEwID0gKHBvdzIoYjUsIF81biwgUCkgKiBiNSkgJSBQO1xuICAgIGNvbnN0IGIyMCA9IChwb3cyKGIxMCwgXzEwbiwgUCkgKiBiMTApICUgUDtcbiAgICBjb25zdCBiNDAgPSAocG93MihiMjAsIF8yMG4sIFApICogYjIwKSAlIFA7XG4gICAgY29uc3QgYjgwID0gKHBvdzIoYjQwLCBfNDBuLCBQKSAqIGI0MCkgJSBQO1xuICAgIGNvbnN0IGIxNjAgPSAocG93MihiODAsIF84MG4sIFApICogYjgwKSAlIFA7XG4gICAgY29uc3QgYjI0MCA9IChwb3cyKGIxNjAsIF84MG4sIFApICogYjgwKSAlIFA7XG4gICAgY29uc3QgYjI1MCA9IChwb3cyKGIyNDAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gICAgY29uc3QgcG93X3BfNV84ID0gKHBvdzIoYjI1MCwgXzJuLCBQKSAqIHgpICUgUDtcbiAgICAvLyBeIFRvIHBvdyB0byAocCszKS84LCBtdWx0aXBseSBpdCBieSB4LlxuICAgIHJldHVybiB7IHBvd19wXzVfOCwgYjIgfTtcbn1cbmZ1bmN0aW9uIGFkanVzdFNjYWxhckJ5dGVzKGJ5dGVzKSB7XG4gICAgLy8gU2VjdGlvbiA1OiBGb3IgWDI1NTE5LCBpbiBvcmRlciB0byBkZWNvZGUgMzIgcmFuZG9tIGJ5dGVzIGFzIGFuIGludGVnZXIgc2NhbGFyLFxuICAgIC8vIHNldCB0aGUgdGhyZWUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBvZiB0aGUgZmlyc3QgYnl0ZVxuICAgIGJ5dGVzWzBdICY9IDI0ODsgLy8gMGIxMTExXzEwMDBcbiAgICAvLyBhbmQgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBsYXN0IHRvIHplcm8sXG4gICAgYnl0ZXNbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAvLyBzZXQgdGhlIHNlY29uZCBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCBieXRlIHRvIDFcbiAgICBieXRlc1szMV0gfD0gNjQ7IC8vIDBiMDEwMF8wMDAwXG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLy8g4oiaKC0xKSBha2Eg4oiaKGEpIGFrYSAyXigocC0xKS80KVxuLy8gRnAuc3FydChGcC5uZWcoMSkpXG5jb25zdCBFRDI1NTE5X1NRUlRfTTEgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcxOTY4MTE2MTM3NjcwNzUwNTk1NjgwNzA3OTMwNDk4ODU0MjAxNTQ0NjA2NjUxNTkyMzg5MDE2Mjc0NDAyMTA3MzEyMzgyOTc4NDc1MicpO1xuLy8gc3FydCh1L3YpXG5mdW5jdGlvbiB1dlJhdGlvKHUsIHYpIHtcbiAgICBjb25zdCBQID0gZWQyNTUxOV9DVVJWRV9wO1xuICAgIGNvbnN0IHYzID0gbW9kKHYgKiB2ICogdiwgUCk7IC8vIHbCs1xuICAgIGNvbnN0IHY3ID0gbW9kKHYzICogdjMgKiB2LCBQKTsgLy8gduKBt1xuICAgIC8vIChwKzMpLzggYW5kIChwLTUpLzhcbiAgICBjb25zdCBwb3cgPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHUgKiB2NykucG93X3BfNV84O1xuICAgIGxldCB4ID0gbW9kKHUgKiB2MyAqIHBvdywgUCk7IC8vICh1dsKzKSh1duKBtyleKHAtNSkvOFxuICAgIGNvbnN0IHZ4MiA9IG1vZCh2ICogeCAqIHgsIFApOyAvLyB2eMKyXG4gICAgY29uc3Qgcm9vdDEgPSB4OyAvLyBGaXJzdCByb290IGNhbmRpZGF0ZVxuICAgIGNvbnN0IHJvb3QyID0gbW9kKHggKiBFRDI1NTE5X1NRUlRfTTEsIFApOyAvLyBTZWNvbmQgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCB1c2VSb290MSA9IHZ4MiA9PT0gdTsgLy8gSWYgdnjCsiA9IHUgKG1vZCBwKSwgeCBpcyBhIHNxdWFyZSByb290XG4gICAgY29uc3QgdXNlUm9vdDIgPSB2eDIgPT09IG1vZCgtdSwgUCk7IC8vIElmIHZ4wrIgPSAtdSwgc2V0IHggPC0tIHggKiAyXigocC0xKS80KVxuICAgIGNvbnN0IG5vUm9vdCA9IHZ4MiA9PT0gbW9kKC11ICogRUQyNTUxOV9TUVJUX00xLCBQKTsgLy8gVGhlcmUgaXMgbm8gdmFsaWQgcm9vdCwgdnjCsiA9IC114oiaKC0xKVxuICAgIGlmICh1c2VSb290MSlcbiAgICAgICAgeCA9IHJvb3QxO1xuICAgIGlmICh1c2VSb290MiB8fCBub1Jvb3QpXG4gICAgICAgIHggPSByb290MjsgLy8gV2UgcmV0dXJuIHJvb3QyIGFueXdheSwgZm9yIGNvbnN0LXRpbWVcbiAgICBpZiAoaXNOZWdhdGl2ZUxFKHgsIFApKVxuICAgICAgICB4ID0gbW9kKC14LCBQKTtcbiAgICByZXR1cm4geyBpc1ZhbGlkOiB1c2VSb290MSB8fCB1c2VSb290MiwgdmFsdWU6IHggfTtcbn1cbmNvbnN0IEZwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGaWVsZChlZDI1NTE5X0NVUlZFLnAsIHsgaXNMRTogdHJ1ZSB9KSkoKTtcbmNvbnN0IEZuID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGaWVsZChlZDI1NTE5X0NVUlZFLm4sIHsgaXNMRTogdHJ1ZSB9KSkoKTtcbmNvbnN0IGVkMjU1MTlEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICAuLi5lZDI1NTE5X0NVUlZFLFxuICAgIEZwLFxuICAgIGhhc2g6IHNoYTUxMixcbiAgICBhZGp1c3RTY2FsYXJCeXRlcyxcbiAgICAvLyBkb20yXG4gICAgLy8gUmF0aW8gb2YgdSB0byB2LiBBbGxvd3MgdXMgdG8gY29tYmluZSBpbnZlcnNpb24gYW5kIHNxdWFyZSByb290LiBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgIC8vIENvbnN0YW50LXRpbWUsIHUv4oiadlxuICAgIHV2UmF0aW8sXG59KSkoKTtcbi8qKlxuICogZWQyNTUxOSBjdXJ2ZSB3aXRoIEVkRFNBIHNpZ25hdHVyZXMuXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZWQyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG4gKiBjb25zdCB7IHNlY3JldEtleSwgcHVibGljS2V5IH0gPSBlZDI1NTE5LmtleWdlbigpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gZWQyNTUxOS5zaWduKG1zZywgcHJpdik7XG4gKiBlZDI1NTE5LnZlcmlmeShzaWcsIG1zZywgcHViKTsgLy8gRGVmYXVsdCBtb2RlOiBmb2xsb3dzIFpJUDIxNVxuICogZWQyNTUxOS52ZXJpZnkoc2lnLCBtc2csIHB1YiwgeyB6aXAyMTU6IGZhbHNlIH0pOyAvLyBSRkM4MDMyIC8gRklQUyAxODYtNVxuICovXG5leHBvcnQgY29uc3QgZWQyNTUxOSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdHdpc3RlZEVkd2FyZHMoZWQyNTUxOURlZmF1bHRzKSkoKTtcbmZ1bmN0aW9uIGVkMjU1MTlfZG9tYWluKGRhdGEsIGN0eCwgcGhmbGFnKSB7XG4gICAgaWYgKGN0eC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dCBpcyB0b28gYmlnJyk7XG4gICAgcmV0dXJuIGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdTaWdFZDI1NTE5IG5vIEVkMjU1MTkgY29sbGlzaW9ucycpLCBuZXcgVWludDhBcnJheShbcGhmbGFnID8gMSA6IDAsIGN0eC5sZW5ndGhdKSwgY3R4LCBkYXRhKTtcbn1cbi8qKiBDb250ZXh0IG9mIGVkMjU1MTkuIFVzZXMgY29udGV4dCBmb3IgZG9tYWluIHNlcGFyYXRpb24uICovXG5leHBvcnQgY29uc3QgZWQyNTUxOWN0eCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdHdpc3RlZEVkd2FyZHMoe1xuICAgIC4uLmVkMjU1MTlEZWZhdWx0cyxcbiAgICBkb21haW46IGVkMjU1MTlfZG9tYWluLFxufSkpKCk7XG4vKiogUHJlaGFzaGVkIHZlcnNpb24gb2YgZWQyNTUxOS4gQWNjZXB0cyBhbHJlYWR5LWhhc2hlZCBtZXNzYWdlcyBpbiBzaWduKCkgYW5kIHZlcmlmeSgpLiAqL1xuZXhwb3J0IGNvbnN0IGVkMjU1MTlwaCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdHdpc3RlZEVkd2FyZHMoT2JqZWN0LmFzc2lnbih7fSwgZWQyNTUxOURlZmF1bHRzLCB7XG4gICAgZG9tYWluOiBlZDI1NTE5X2RvbWFpbixcbiAgICBwcmVoYXNoOiBzaGE1MTIsXG59KSkpKCk7XG4vKipcbiAqIEVDREggdXNpbmcgY3VydmUyNTUxOSBha2EgeDI1NTE5LlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHgyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG4gKiBjb25zdCBwcml2ID0gJ2E1NDZlMzZiZjA1MjdjOWQzYjE2MTU0YjgyNDY1ZWRkNjIxNDRjMGFjMWZjNWExODUwNmEyMjQ0YmE0NDlhYzQnO1xuICogY29uc3QgcHViID0gJ2U2ZGI2ODY3NTgzMDMwZGIzNTk0YzFhNDI0YjE1ZjdjNzI2NjI0ZWMyNmIzMzUzYjEwYTkwM2E2ZDBhYjFjNGMnO1xuICogeDI1NTE5LmdldFNoYXJlZFNlY3JldChwcml2LCBwdWIpID09PSB4MjU1MTkuc2NhbGFyTXVsdChwcml2LCBwdWIpOyAvLyBhbGlhc2VzXG4gKiB4MjU1MTkuZ2V0UHVibGljS2V5KHByaXYpID09PSB4MjU1MTkuc2NhbGFyTXVsdEJhc2UocHJpdik7XG4gKiB4MjU1MTkuZ2V0UHVibGljS2V5KHgyNTUxOS51dGlscy5yYW5kb21TZWNyZXRLZXkoKSk7XG4gKi9cbmV4cG9ydCBjb25zdCB4MjU1MTkgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICBjb25zdCBQID0gRnAuT1JERVI7XG4gICAgcmV0dXJuIG1vbnRnb21lcnkoe1xuICAgICAgICBQLFxuICAgICAgICB0eXBlOiAneDI1NTE5JyxcbiAgICAgICAgcG93UG1pbnVzMjogKHgpID0+IHtcbiAgICAgICAgICAgIC8vIHheKHAtMikgYWthIHheKDJeMjU1LTIxKVxuICAgICAgICAgICAgY29uc3QgeyBwb3dfcF81XzgsIGIyIH0gPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHgpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZChwb3cyKHBvd19wXzVfOCwgXzNuLCBQKSAqIGIyLCBQKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgfSk7XG59KSgpO1xuLy8gSGFzaCBUbyBDdXJ2ZSBFbGxpZ2F0b3IyIE1hcCAoTk9URTogZGlmZmVyZW50IGZyb20gcmlzdHJldHRvMjU1IGVsbGlnYXRvcilcbi8vIE5PVEU6IHZlcnkgaW1wb3J0YW50IHBhcnQgaXMgdXNhZ2Ugb2YgRnBTcXJ0RXZlbiBmb3IgRUxMMl9DMV9FRFdBUkRTLCBzaW5jZVxuLy8gU2FnZU1hdGggcmV0dXJucyBkaWZmZXJlbnQgcm9vdCBmaXJzdCBhbmQgZXZlcnl0aGluZyBmYWxscyBhcGFydFxuY29uc3QgRUxMMl9DMSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKGVkMjU1MTlfQ1VSVkVfcCArIF8zbikgLyBfOG4pKCk7IC8vIDEuIGMxID0gKHEgKyAzKSAvIDggICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbmNvbnN0IEVMTDJfQzIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZwLnBvdyhfMm4sIEVMTDJfQzEpKSgpOyAvLyAyLiBjMiA9IDJeYzFcbmNvbnN0IEVMTDJfQzMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZwLnNxcnQoRnAubmVnKEZwLk9ORSkpKSgpOyAvLyAzLiBjMyA9IHNxcnQoLTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2N1cnZlMjU1MTkodSkge1xuICAgIGNvbnN0IEVMTDJfQzQgPSAoZWQyNTUxOV9DVVJWRV9wIC0gXzVuKSAvIF84bjsgLy8gNC4gYzQgPSAocSAtIDUpIC8gOCAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IEVMTDJfSiA9IEJpZ0ludCg0ODY2NjIpO1xuICAgIGxldCB0djEgPSBGcC5zcXIodSk7IC8vICAxLiAgdHYxID0gdV4yXG4gICAgdHYxID0gRnAubXVsKHR2MSwgXzJuKTsgLy8gIDIuICB0djEgPSAyICogdHYxXG4gICAgbGV0IHhkID0gRnAuYWRkKHR2MSwgRnAuT05FKTsgLy8gIDMuICAgeGQgPSB0djEgKyAxICAgICAgICAgIyBOb256ZXJvOiAtMSBpcyBzcXVhcmUgKG1vZCBwKSwgdHYxIGlzIG5vdFxuICAgIGxldCB4MW4gPSBGcC5uZWcoRUxMMl9KKTsgLy8gIDQuICB4MW4gPSAtSiAgICAgICAgICAgICAgIyB4MSA9IHgxbiAvIHhkID0gLUogLyAoMSArIDIgKiB1XjIpXG4gICAgbGV0IHR2MiA9IEZwLnNxcih4ZCk7IC8vICA1LiAgdHYyID0geGReMlxuICAgIGxldCBneGQgPSBGcC5tdWwodHYyLCB4ZCk7IC8vICA2LiAgZ3hkID0gdHYyICogeGQgICAgICAgICMgZ3hkID0geGReM1xuICAgIGxldCBneDEgPSBGcC5tdWwodHYxLCBFTEwyX0opOyAvLyAgNy4gIGd4MSA9IEogKiB0djEgICAgICAgICAjIHgxbiArIEogKiB4ZFxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICA4LiAgZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjIgKyBKICogeDFuICogeGRcbiAgICBneDEgPSBGcC5hZGQoZ3gxLCB0djIpOyAvLyAgOS4gIGd4MSA9IGd4MSArIHR2MiAgICAgICAjIHgxbl4yICsgSiAqIHgxbiAqIHhkICsgeGReMlxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICAxMC4gZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjMgKyBKICogeDFuXjIgKiB4ZCArIHgxbiAqIHhkXjJcbiAgICBsZXQgdHYzID0gRnAuc3FyKGd4ZCk7IC8vICAxMS4gdHYzID0gZ3hkXjJcbiAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gIDEyLiB0djIgPSB0djNeMiAgICAgICAgICAgIyBneGReNFxuICAgIHR2MyA9IEZwLm11bCh0djMsIGd4ZCk7IC8vICAxMy4gdHYzID0gdHYzICogZ3hkICAgICAgICMgZ3hkXjNcbiAgICB0djMgPSBGcC5tdWwodHYzLCBneDEpOyAvLyAgMTQuIHR2MyA9IHR2MyAqIGd4MSAgICAgICAjIGd4MSAqIGd4ZF4zXG4gICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gIDE1LiB0djIgPSB0djIgKiB0djMgICAgICAgIyBneDEgKiBneGReN1xuICAgIGxldCB5MTEgPSBGcC5wb3codHYyLCBFTEwyX0M0KTsgLy8gIDE2LiB5MTEgPSB0djJeYzQgICAgICAgICMgKGd4MSAqIGd4ZF43KV4oKHAgLSA1KSAvIDgpXG4gICAgeTExID0gRnAubXVsKHkxMSwgdHYzKTsgLy8gIDE3LiB5MTEgPSB5MTEgKiB0djMgICAgICAgIyBneDEqZ3hkXjMqKGd4MSpneGReNyleKChwLTUpLzgpXG4gICAgbGV0IHkxMiA9IEZwLm11bCh5MTEsIEVMTDJfQzMpOyAvLyAgMTguIHkxMiA9IHkxMSAqIGMzXG4gICAgdHYyID0gRnAuc3FyKHkxMSk7IC8vICAxOS4gdHYyID0geTExXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMjAuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMSA9IEZwLmVxbCh0djIsIGd4MSk7IC8vICAyMS4gIGUxID0gdHYyID09IGd4MVxuICAgIGxldCB5MSA9IEZwLmNtb3YoeTEyLCB5MTEsIGUxKTsgLy8gIDIyLiAgeTEgPSBDTU9WKHkxMiwgeTExLCBlMSkgICMgSWYgZyh4MSkgaXMgc3F1YXJlLCB0aGlzIGlzIGl0cyBzcXJ0XG4gICAgbGV0IHgybiA9IEZwLm11bCh4MW4sIHR2MSk7IC8vICAyMy4geDJuID0geDFuICogdHYxICAgICAgICMgeDIgPSB4Mm4gLyB4ZCA9IDIgKiB1XjIgKiB4MW4gLyB4ZFxuICAgIGxldCB5MjEgPSBGcC5tdWwoeTExLCB1KTsgLy8gIDI0LiB5MjEgPSB5MTEgKiB1XG4gICAgeTIxID0gRnAubXVsKHkyMSwgRUxMMl9DMik7IC8vICAyNS4geTIxID0geTIxICogYzJcbiAgICBsZXQgeTIyID0gRnAubXVsKHkyMSwgRUxMMl9DMyk7IC8vICAyNi4geTIyID0geTIxICogYzNcbiAgICBsZXQgZ3gyID0gRnAubXVsKGd4MSwgdHYxKTsgLy8gIDI3LiBneDIgPSBneDEgKiB0djEgICAgICAgIyBnKHgyKSA9IGd4MiAvIGd4ZCA9IDIgKiB1XjIgKiBnKHgxKVxuICAgIHR2MiA9IEZwLnNxcih5MjEpOyAvLyAgMjguIHR2MiA9IHkyMV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDI5LiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTIgPSBGcC5lcWwodHYyLCBneDIpOyAvLyAgMzAuICBlMiA9IHR2MiA9PSBneDJcbiAgICBsZXQgeTIgPSBGcC5jbW92KHkyMiwgeTIxLCBlMik7IC8vICAzMS4gIHkyID0gQ01PVih5MjIsIHkyMSwgZTIpICAjIElmIGcoeDIpIGlzIHNxdWFyZSwgdGhpcyBpcyBpdHMgc3FydFxuICAgIHR2MiA9IEZwLnNxcih5MSk7IC8vICAzMi4gdHYyID0geTFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAzMy4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUzID0gRnAuZXFsKHR2MiwgZ3gxKTsgLy8gIDM0LiAgZTMgPSB0djIgPT0gZ3gxXG4gICAgbGV0IHhuID0gRnAuY21vdih4Mm4sIHgxbiwgZTMpOyAvLyAgMzUuICB4biA9IENNT1YoeDJuLCB4MW4sIGUzKSAgIyBJZiBlMywgeCA9IHgxLCBlbHNlIHggPSB4MlxuICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGUzKTsgLy8gIDM2LiAgIHkgPSBDTU9WKHkyLCB5MSwgZTMpICAgICMgSWYgZTMsIHkgPSB5MSwgZWxzZSB5ID0geTJcbiAgICBsZXQgZTQgPSBGcC5pc09kZCh5KTsgLy8gIDM3LiAgZTQgPSBzZ24wKHkpID09IDEgICAgICAgICMgRml4IHNpZ24gb2YgeVxuICAgIHkgPSBGcC5jbW92KHksIEZwLm5lZyh5KSwgZTMgIT09IGU0KTsgLy8gIDM4LiAgIHkgPSBDTU9WKHksIC15LCBlMyBYT1IgZTQpXG4gICAgcmV0dXJuIHsgeE1uOiB4biwgeE1kOiB4ZCwgeU1uOiB5LCB5TWQ6IF8xbiB9OyAvLyAgMzkuIHJldHVybiAoeG4sIHhkLCB5LCAxKVxufVxuY29uc3QgRUxMMl9DMV9FRFdBUkRTID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGcFNxcnRFdmVuKEZwLCBGcC5uZWcoQmlnSW50KDQ4NjY2NCkpKSkoKTsgLy8gc2duMChjMSkgTVVTVCBlcXVhbCAwXG5mdW5jdGlvbiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkodSkge1xuICAgIGNvbnN0IHsgeE1uLCB4TWQsIHlNbiwgeU1kIH0gPSBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpOyAvLyAgMS4gICh4TW4sIHhNZCwgeU1uLCB5TWQpID1cbiAgICAvLyBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpXG4gICAgbGV0IHhuID0gRnAubXVsKHhNbiwgeU1kKTsgLy8gIDIuICB4biA9IHhNbiAqIHlNZFxuICAgIHhuID0gRnAubXVsKHhuLCBFTEwyX0MxX0VEV0FSRFMpOyAvLyAgMy4gIHhuID0geG4gKiBjMVxuICAgIGxldCB4ZCA9IEZwLm11bCh4TWQsIHlNbik7IC8vICA0LiAgeGQgPSB4TWQgKiB5TW4gICAgIyB4biAvIHhkID0gYzEgKiB4TSAvIHlNXG4gICAgbGV0IHluID0gRnAuc3ViKHhNbiwgeE1kKTsgLy8gIDUuICB5biA9IHhNbiAtIHhNZFxuICAgIGxldCB5ZCA9IEZwLmFkZCh4TW4sIHhNZCk7IC8vICA2LiAgeWQgPSB4TW4gKyB4TWQgICAgIyAobiAvIGQgLSAxKSAvIChuIC8gZCArIDEpID0gKG4gLSBkKSAvIChuICsgZClcbiAgICBsZXQgdHYxID0gRnAubXVsKHhkLCB5ZCk7IC8vICA3LiB0djEgPSB4ZCAqIHlkXG4gICAgbGV0IGUgPSBGcC5lcWwodHYxLCBGcC5aRVJPKTsgLy8gIDguICAgZSA9IHR2MSA9PSAwXG4gICAgeG4gPSBGcC5jbW92KHhuLCBGcC5aRVJPLCBlKTsgLy8gIDkuICB4biA9IENNT1YoeG4sIDAsIGUpXG4gICAgeGQgPSBGcC5jbW92KHhkLCBGcC5PTkUsIGUpOyAvLyAgMTAuIHhkID0gQ01PVih4ZCwgMSwgZSlcbiAgICB5biA9IEZwLmNtb3YoeW4sIEZwLk9ORSwgZSk7IC8vICAxMS4geW4gPSBDTU9WKHluLCAxLCBlKVxuICAgIHlkID0gRnAuY21vdih5ZCwgRnAuT05FLCBlKTsgLy8gIDEyLiB5ZCA9IENNT1YoeWQsIDEsIGUpXG4gICAgY29uc3QgW3hkX2ludiwgeWRfaW52XSA9IEZwSW52ZXJ0QmF0Y2goRnAsIFt4ZCwgeWRdLCB0cnVlKTsgLy8gYmF0Y2ggZGl2aXNpb25cbiAgICByZXR1cm4geyB4OiBGcC5tdWwoeG4sIHhkX2ludiksIHk6IEZwLm11bCh5biwgeWRfaW52KSB9OyAvLyAgMTMuIHJldHVybiAoeG4sIHhkLCB5biwgeWQpXG59XG4vKiogSGFzaGluZyB0byBlZDI1NTE5IHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0IGNvbnN0IGVkMjU1MTlfaGFzaGVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoZWQyNTUxOS5Qb2ludCwgKHNjYWxhcnMpID0+IG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOShzY2FsYXJzWzBdKSwge1xuICAgIERTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnZWR3YXJkczI1NTE5X1hNRDpTSEEtNTEyX0VMTDJfTlVfJyxcbiAgICBwOiBlZDI1NTE5X0NVUlZFX3AsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGE1MTIsXG59KSkoKTtcbi8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IFNRUlRfTTEgPSBFRDI1NTE5X1NRUlRfTTE7XG4vLyDiiJooYWQgLSAxKVxuY29uc3QgU1FSVF9BRF9NSU5VU19PTkUgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcyNTA2MzA2ODk1MzM4NDYyMzQ3NDExMTQxNDE1ODcwMjE1MjcwMTI0NDUzMTUwMjQ5MjY1NjQ2MDA3OTIxMDQ4MjYxMDQzMDc1MDIzNScpO1xuLy8gMSAvIOKImihhLWQpXG5jb25zdCBJTlZTUVJUX0FfTUlOVVNfRCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzU0NDY5MzA3MDA4OTA5MzE2OTIwOTk1ODEzODY4NzQ1MTQxNjA1MzkzNTk3MjkyOTI3NDU2OTIxMjA1MzEyODk2MzExNzIxMDE3NTc4Jyk7XG4vLyAxLWTCslxuY29uc3QgT05FX01JTlVTX0RfU1EgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcxMTU5ODQzMDIxNjY4Nzc5ODc5MTkzNzc1NTIxODU1NTg2NjQ3OTM3MzU3NzU5NzE1NDE3NjU0NDM5ODc5NzIwODc2MTExODA2ODM4Jyk7XG4vLyAoZC0xKcKyXG5jb25zdCBEX01JTlVTX09ORV9TUSA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzQwNDQwODM0MzQ2MzA4NTM2ODU4MTAxMDQyNDY5MzIzMTkwODI2MjQ4Mzk5MTQ2MjM4NzA4MzUyMjQwMTMzMjIwODY1MTM3MjY1OTUyJyk7XG4vLyBDYWxjdWxhdGVzIDEv4oiaKG51bWJlcilcbmNvbnN0IGludmVydFNxcnQgPSAobnVtYmVyKSA9PiB1dlJhdGlvKF8xbiwgbnVtYmVyKTtcbmNvbnN0IE1BWF8yNTVCID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyk7XG5jb25zdCBieXRlczI1NVRvTnVtYmVyTEUgPSAoYnl0ZXMpID0+IGVkMjU1MTkuUG9pbnQuRnAuY3JlYXRlKGJ5dGVzVG9OdW1iZXJMRShieXRlcykgJiBNQVhfMjU1Qik7XG4vKipcbiAqIENvbXB1dGVzIEVsbGlnYXRvciBtYXAgZm9yIFJpc3RyZXR0bzI1NS5cbiAqIERlc2NyaWJlZCBpbiBbUkZDOTM4MF0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjYXBwZW5kaXgtQikgYW5kIG9uXG4gKiB0aGUgW3dlYnNpdGVdKGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2VsbGlnYXRvci5odG1sKS5cbiAqL1xuZnVuY3Rpb24gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMCkge1xuICAgIGNvbnN0IHsgZCB9ID0gZWQyNTUxOV9DVVJWRTtcbiAgICBjb25zdCBQID0gZWQyNTUxOV9DVVJWRV9wO1xuICAgIGNvbnN0IG1vZCA9IChuKSA9PiBGcC5jcmVhdGUobik7XG4gICAgY29uc3QgciA9IG1vZChTUVJUX00xICogcjAgKiByMCk7IC8vIDFcbiAgICBjb25zdCBOcyA9IG1vZCgociArIF8xbikgKiBPTkVfTUlOVVNfRF9TUSk7IC8vIDJcbiAgICBsZXQgYyA9IEJpZ0ludCgtMSk7IC8vIDNcbiAgICBjb25zdCBEID0gbW9kKChjIC0gZCAqIHIpICogbW9kKHIgKyBkKSk7IC8vIDRcbiAgICBsZXQgeyBpc1ZhbGlkOiBOc19EX2lzX3NxLCB2YWx1ZTogcyB9ID0gdXZSYXRpbyhOcywgRCk7IC8vIDVcbiAgICBsZXQgc18gPSBtb2QocyAqIHIwKTsgLy8gNlxuICAgIGlmICghaXNOZWdhdGl2ZUxFKHNfLCBQKSlcbiAgICAgICAgc18gPSBtb2QoLXNfKTtcbiAgICBpZiAoIU5zX0RfaXNfc3EpXG4gICAgICAgIHMgPSBzXzsgLy8gN1xuICAgIGlmICghTnNfRF9pc19zcSlcbiAgICAgICAgYyA9IHI7IC8vIDhcbiAgICBjb25zdCBOdCA9IG1vZChjICogKHIgLSBfMW4pICogRF9NSU5VU19PTkVfU1EgLSBEKTsgLy8gOVxuICAgIGNvbnN0IHMyID0gcyAqIHM7XG4gICAgY29uc3QgVzAgPSBtb2QoKHMgKyBzKSAqIEQpOyAvLyAxMFxuICAgIGNvbnN0IFcxID0gbW9kKE50ICogU1FSVF9BRF9NSU5VU19PTkUpOyAvLyAxMVxuICAgIGNvbnN0IFcyID0gbW9kKF8xbiAtIHMyKTsgLy8gMTJcbiAgICBjb25zdCBXMyA9IG1vZChfMW4gKyBzMik7IC8vIDEzXG4gICAgcmV0dXJuIG5ldyBlZDI1NTE5LlBvaW50KG1vZChXMCAqIFczKSwgbW9kKFcyICogVzEpLCBtb2QoVzEgKiBXMyksIG1vZChXMCAqIFcyKSk7XG59XG5mdW5jdGlvbiByaXN0cmV0dG8yNTVfbWFwKGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzLCA2NCk7XG4gICAgY29uc3QgcjEgPSBieXRlczI1NVRvTnVtYmVyTEUoYnl0ZXMuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICBjb25zdCBSMSA9IGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjEpO1xuICAgIGNvbnN0IHIyID0gYnl0ZXMyNTVUb051bWJlckxFKGJ5dGVzLnN1YmFycmF5KDMyLCA2NCkpO1xuICAgIGNvbnN0IFIyID0gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMik7XG4gICAgcmV0dXJuIG5ldyBfUmlzdHJldHRvUG9pbnQoUjEuYWRkKFIyKSk7XG59XG4vKipcbiAqIFdyYXBwZXIgb3ZlciBFZHdhcmRzIFBvaW50IGZvciByaXN0cmV0dG8yNTUuXG4gKlxuICogRWFjaCBlZDI1NTE5L0V4dGVuZGVkUG9pbnQgaGFzIDggZGlmZmVyZW50IGVxdWl2YWxlbnQgcG9pbnRzLiBUaGlzIGNhbiBiZVxuICogYSBzb3VyY2Ugb2YgYnVncyBmb3IgcHJvdG9jb2xzIGxpa2UgcmluZyBzaWduYXR1cmVzLiBSaXN0cmV0dG8gd2FzIGNyZWF0ZWQgdG8gc29sdmUgdGhpcy5cbiAqIFJpc3RyZXR0byBwb2ludCBvcGVyYXRlcyBpbiBYOlk6WjpUIGV4dGVuZGVkIGNvb3JkaW5hdGVzIGxpa2UgRXh0ZW5kZWRQb2ludCxcbiAqIGJ1dCBpdCBzaG91bGQgd29yayBpbiBpdHMgb3duIG5hbWVzcGFjZTogZG8gbm90IGNvbWJpbmUgdGhvc2UgdHdvLlxuICogU2VlIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NikuXG4gKi9cbmNsYXNzIF9SaXN0cmV0dG9Qb2ludCBleHRlbmRzIFByaW1lRWR3YXJkc1BvaW50IHtcbiAgICBjb25zdHJ1Y3RvcihlcCkge1xuICAgICAgICBzdXBlcihlcCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKGFwKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1Jpc3RyZXR0b1BvaW50KGVkMjU1MTkuUG9pbnQuZnJvbUFmZmluZShhcCkpO1xuICAgIH1cbiAgICBhc3NlcnRTYW1lKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgX1Jpc3RyZXR0b1BvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmlzdHJldHRvUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgaW5pdChlcCkge1xuICAgICAgICByZXR1cm4gbmV3IF9SaXN0cmV0dG9Qb2ludChlcCk7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IHJpc3RyZXR0bzI1NV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTkuanMnO2AgKi9cbiAgICBzdGF0aWMgaGFzaFRvQ3VydmUoaGV4KSB7XG4gICAgICAgIHJldHVybiByaXN0cmV0dG8yNTVfbWFwKGVuc3VyZUJ5dGVzKCdyaXN0cmV0dG9IYXNoJywgaGV4LCA2NCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIGFieXRlcyhieXRlcywgMzIpO1xuICAgICAgICBjb25zdCB7IGEsIGQgfSA9IGVkMjU1MTlfQ1VSVkU7XG4gICAgICAgIGNvbnN0IFAgPSBlZDI1NTE5X0NVUlZFX3A7XG4gICAgICAgIGNvbnN0IG1vZCA9IChuKSA9PiBGcC5jcmVhdGUobik7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlczI1NVRvTnVtYmVyTEUoYnl0ZXMpO1xuICAgICAgICAvLyAxLiBDaGVjayB0aGF0IHNfYnl0ZXMgaXMgdGhlIGNhbm9uaWNhbCBlbmNvZGluZyBvZiBhIGZpZWxkIGVsZW1lbnQsIG9yIGVsc2UgYWJvcnQuXG4gICAgICAgIC8vIDMuIENoZWNrIHRoYXQgcyBpcyBub24tbmVnYXRpdmUsIG9yIGVsc2UgYWJvcnRcbiAgICAgICAgaWYgKCFlcXVhbEJ5dGVzKEZwLnRvQnl0ZXMocyksIGJ5dGVzKSB8fCBpc05lZ2F0aXZlTEUocywgUCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmlzdHJldHRvMjU1IGVuY29kaW5nIDEnKTtcbiAgICAgICAgY29uc3QgczIgPSBtb2QocyAqIHMpO1xuICAgICAgICBjb25zdCB1MSA9IG1vZChfMW4gKyBhICogczIpOyAvLyA0IChhIGlzIC0xKVxuICAgICAgICBjb25zdCB1MiA9IG1vZChfMW4gLSBhICogczIpOyAvLyA1XG4gICAgICAgIGNvbnN0IHUxXzIgPSBtb2QodTEgKiB1MSk7XG4gICAgICAgIGNvbnN0IHUyXzIgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHYgPSBtb2QoYSAqIGQgKiB1MV8yIC0gdTJfMik7IC8vIDZcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZTogSSB9ID0gaW52ZXJ0U3FydChtb2QodiAqIHUyXzIpKTsgLy8gN1xuICAgICAgICBjb25zdCBEeCA9IG1vZChJICogdTIpOyAvLyA4XG4gICAgICAgIGNvbnN0IER5ID0gbW9kKEkgKiBEeCAqIHYpOyAvLyA5XG4gICAgICAgIGxldCB4ID0gbW9kKChzICsgcykgKiBEeCk7IC8vIDEwXG4gICAgICAgIGlmIChpc05lZ2F0aXZlTEUoeCwgUCkpXG4gICAgICAgICAgICB4ID0gbW9kKC14KTsgLy8gMTBcbiAgICAgICAgY29uc3QgeSA9IG1vZCh1MSAqIER5KTsgLy8gMTFcbiAgICAgICAgY29uc3QgdCA9IG1vZCh4ICogeSk7IC8vIDEyXG4gICAgICAgIGlmICghaXNWYWxpZCB8fCBpc05lZ2F0aXZlTEUodCwgUCkgfHwgeSA9PT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJpc3RyZXR0bzI1NSBlbmNvZGluZyAyJyk7XG4gICAgICAgIHJldHVybiBuZXcgX1Jpc3RyZXR0b1BvaW50KG5ldyBlZDI1NTE5LlBvaW50KHgsIHksIF8xbiwgdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyByaXN0cmV0dG8tZW5jb2RlZCBzdHJpbmcgdG8gcmlzdHJldHRvIHBvaW50LlxuICAgICAqIERlc2NyaWJlZCBpbiBbUkZDOTQ5Nl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk0OTYjbmFtZS1kZWNvZGUpLlxuICAgICAqIEBwYXJhbSBoZXggUmlzdHJldHRvLWVuY29kZWQgMzIgYnl0ZXMuIE5vdCBldmVyeSAzMi1ieXRlIHN0cmluZyBpcyB2YWxpZCByaXN0cmV0dG8gZW5jb2RpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgcmV0dXJuIF9SaXN0cmV0dG9Qb2ludC5mcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3Jpc3RyZXR0b0hleCcsIGhleCwgMzIpKTtcbiAgICB9XG4gICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgcmV0dXJuIHBpcHBlbmdlcihfUmlzdHJldHRvUG9pbnQsIGVkMjU1MTkuUG9pbnQuRm4sIHBvaW50cywgc2NhbGFycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgcmlzdHJldHRvIHBvaW50IHRvIFVpbnQ4QXJyYXkuXG4gICAgICogRGVzY3JpYmVkIGluIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NiNuYW1lLWVuY29kZSkuXG4gICAgICovXG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgbGV0IHsgWCwgWSwgWiwgVCB9ID0gdGhpcy5lcDtcbiAgICAgICAgY29uc3QgUCA9IGVkMjU1MTlfQ1VSVkVfcDtcbiAgICAgICAgY29uc3QgbW9kID0gKG4pID0+IEZwLmNyZWF0ZShuKTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QobW9kKFogKyBZKSAqIG1vZChaIC0gWSkpOyAvLyAxXG4gICAgICAgIGNvbnN0IHUyID0gbW9kKFggKiBZKTsgLy8gMlxuICAgICAgICAvLyBTcXVhcmUgcm9vdCBhbHdheXMgZXhpc3RzXG4gICAgICAgIGNvbnN0IHUyc3EgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IGludnNxcnQgfSA9IGludmVydFNxcnQobW9kKHUxICogdTJzcSkpOyAvLyAzXG4gICAgICAgIGNvbnN0IEQxID0gbW9kKGludnNxcnQgKiB1MSk7IC8vIDRcbiAgICAgICAgY29uc3QgRDIgPSBtb2QoaW52c3FydCAqIHUyKTsgLy8gNVxuICAgICAgICBjb25zdCB6SW52ID0gbW9kKEQxICogRDIgKiBUKTsgLy8gNlxuICAgICAgICBsZXQgRDsgLy8gN1xuICAgICAgICBpZiAoaXNOZWdhdGl2ZUxFKFQgKiB6SW52LCBQKSkge1xuICAgICAgICAgICAgbGV0IF94ID0gbW9kKFkgKiBTUVJUX00xKTtcbiAgICAgICAgICAgIGxldCBfeSA9IG1vZChYICogU1FSVF9NMSk7XG4gICAgICAgICAgICBYID0gX3g7XG4gICAgICAgICAgICBZID0gX3k7XG4gICAgICAgICAgICBEID0gbW9kKEQxICogSU5WU1FSVF9BX01JTlVTX0QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgRCA9IEQyOyAvLyA4XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRShYICogekludiwgUCkpXG4gICAgICAgICAgICBZID0gbW9kKC1ZKTsgLy8gOVxuICAgICAgICBsZXQgcyA9IG1vZCgoWiAtIFkpICogRCk7IC8vIDEwIChjaGVjayBmb290ZXIncyBub3RlLCBubyBzcXJ0KC1hKSlcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRShzLCBQKSlcbiAgICAgICAgICAgIHMgPSBtb2QoLXMpO1xuICAgICAgICByZXR1cm4gRnAudG9CeXRlcyhzKTsgLy8gMTFcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIFJpc3RyZXR0byBwb2ludHMuXG4gICAgICogRGVzY3JpYmVkIGluIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NiNuYW1lLWVxdWFscykuXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2FtZShvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxIH0gPSB0aGlzLmVwO1xuICAgICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiB9ID0gb3RoZXIuZXA7XG4gICAgICAgIGNvbnN0IG1vZCA9IChuKSA9PiBGcC5jcmVhdGUobik7XG4gICAgICAgIC8vICh4MSAqIHkyID09IHkxICogeDIpIHwgKHkxICogeTIgPT0geDEgKiB4MilcbiAgICAgICAgY29uc3Qgb25lID0gbW9kKFgxICogWTIpID09PSBtb2QoWTEgKiBYMik7XG4gICAgICAgIGNvbnN0IHR3byA9IG1vZChZMSAqIFkyKSA9PT0gbW9kKFgxICogWDIpO1xuICAgICAgICByZXR1cm4gb25lIHx8IHR3bztcbiAgICB9XG4gICAgaXMwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoX1Jpc3RyZXR0b1BvaW50LlpFUk8pO1xuICAgIH1cbn1cbi8vIERvIE5PVCBjaGFuZ2Ugc3ludGF4OiB0aGUgZm9sbG93aW5nIGd5bW5hc3RpY3MgaXMgZG9uZSxcbi8vIGJlY2F1c2UgdHlwZXNjcmlwdCBzdHJpcHMgY29tbWVudHMsIHdoaWNoIG1ha2VzIGJ1bmRsZXJzIGRpc2FibGUgdHJlZS1zaGFraW5nLlxuLy8gcHJldHRpZXItaWdub3JlXG5fUmlzdHJldHRvUG9pbnQuQkFTRSA9IFxuLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgX1Jpc3RyZXR0b1BvaW50KGVkMjU1MTkuUG9pbnQuQkFTRSkpKCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbl9SaXN0cmV0dG9Qb2ludC5aRVJPID0gXG4vKiBAX19QVVJFX18gKi8gKCgpID0+IG5ldyBfUmlzdHJldHRvUG9pbnQoZWQyNTUxOS5Qb2ludC5aRVJPKSkoKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuX1Jpc3RyZXR0b1BvaW50LkZwID0gXG4vKiBAX19QVVJFX18gKi8gKCgpID0+IEZwKSgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5fUmlzdHJldHRvUG9pbnQuRm4gPSBcbi8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gRm4pKCk7XG5leHBvcnQgY29uc3QgcmlzdHJldHRvMjU1ID0geyBQb2ludDogX1Jpc3RyZXR0b1BvaW50IH07XG4vKiogSGFzaGluZyB0byByaXN0cmV0dG8yNTUgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcmlzdHJldHRvMjU1X2hhc2hlciA9IHtcbiAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgRFNUID0gb3B0aW9ucz8uRFNUIHx8ICdyaXN0cmV0dG8yNTVfWE1EOlNIQS01MTJfUjI1NU1BUF9ST18nO1xuICAgICAgICBjb25zdCB4bWQgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIDY0LCBzaGE1MTIpO1xuICAgICAgICByZXR1cm4gcmlzdHJldHRvMjU1X21hcCh4bWQpO1xuICAgIH0sXG4gICAgaGFzaFRvU2NhbGFyKG1zZywgb3B0aW9ucyA9IHsgRFNUOiBfRFNUX3NjYWxhciB9KSB7XG4gICAgICAgIGNvbnN0IHhtZCA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIG9wdGlvbnMuRFNULCA2NCwgc2hhNTEyKTtcbiAgICAgICAgcmV0dXJuIEZuLmNyZWF0ZShieXRlc1RvTnVtYmVyTEUoeG1kKSk7XG4gICAgfSxcbn07XG4vLyBleHBvcnQgY29uc3QgcmlzdHJldHRvMjU1X29wcmY6IE9QUkYgPSBjcmVhdGVPUlBGKHtcbi8vICAgbmFtZTogJ3Jpc3RyZXR0bzI1NS1TSEE1MTInLFxuLy8gICBQb2ludDogUmlzdHJldHRvUG9pbnQsXG4vLyAgIGhhc2g6IHNoYTUxMixcbi8vICAgaGFzaFRvR3JvdXA6IHJpc3RyZXR0bzI1NV9oYXNoZXIuaGFzaFRvQ3VydmUsXG4vLyAgIGhhc2hUb1NjYWxhcjogcmlzdHJldHRvMjU1X2hhc2hlci5oYXNoVG9TY2FsYXIsXG4vLyB9KTtcbi8qKlxuICogV2VpcmQgLyBib2d1cyBwb2ludHMsIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICogQWxsIDggZWQyNTUxOSBwb2ludHMgb2YgOC10b3JzaW9uIHN1Ymdyb3VwIGNhbiBiZSBnZW5lcmF0ZWQgZnJvbSB0aGUgcG9pbnRcbiAqIFQgPSBgMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmMwNWAuXG4gKiDin6hU4p+pID0geyBPLCBULCAyVCwgM1QsIDRULCA1VCwgNlQsIDdUIH1cbiAqL1xuZXhwb3J0IGNvbnN0IEVEMjU1MTlfVE9SU0lPTl9TVUJHUk9VUCA9IFtcbiAgICAnMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzN2EnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwJyxcbiAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmMwNScsXG4gICAgJ2VjZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmN2YnLFxuICAgICcyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzg1JyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzZmEnLFxuXTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGVkMjU1MTkudXRpbHMudG9Nb250Z29tZXJ5YCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkd2FyZHNUb01vbnRnb21lcnlQdWIoZWR3YXJkc1B1Yikge1xuICAgIHJldHVybiBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeShlbnN1cmVCeXRlcygncHViJywgZWR3YXJkc1B1YikpO1xufVxuLyoqIEBkZXByZWNhdGVkIHVzZSBgZWQyNTUxOS51dGlscy50b01vbnRnb21lcnlgICovXG5leHBvcnQgY29uc3QgZWR3YXJkc1RvTW9udGdvbWVyeSA9IGVkd2FyZHNUb01vbnRnb21lcnlQdWI7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeVByaXZgICovXG5leHBvcnQgZnVuY3Rpb24gZWR3YXJkc1RvTW9udGdvbWVyeVByaXYoZWR3YXJkc1ByaXYpIHtcbiAgICByZXR1cm4gZWQyNTUxOS51dGlscy50b01vbnRnb21lcnlQcml2KGVuc3VyZUJ5dGVzKCdwdWInLCBlZHdhcmRzUHJpdikpO1xufVxuLyoqIEBkZXByZWNhdGVkIHVzZSBgcmlzdHJldHRvMjU1LlBvaW50YCAqL1xuZXhwb3J0IGNvbnN0IFJpc3RyZXR0b1BvaW50ID0gX1Jpc3RyZXR0b1BvaW50O1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgZWQyNTUxOV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTkuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZWQyNTUxOV9oYXNoZXIuaGFzaFRvQ3VydmUpKCk7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyBlZDI1NTE5X2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOS5qcyc7YCAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGVkMjU1MTlfaGFzaGVyLmVuY29kZVRvQ3VydmUpKCk7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyByaXN0cmV0dG8yNTVfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5LmpzJztgICovXG5leHBvcnQgY29uc3QgaGFzaFRvUmlzdHJldHRvMjU1ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiByaXN0cmV0dG8yNTVfaGFzaGVyLmhhc2hUb0N1cnZlKSgpO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgcmlzdHJldHRvMjU1X2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOS5qcyc7YCAqL1xuZXhwb3J0IGNvbnN0IGhhc2hfdG9fcmlzdHJldHRvMjU1ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiByaXN0cmV0dG8yNTVfaGFzaGVyLmhhc2hUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWQyNTUxOS5qcy5tYXAiXSwibmFtZXMiOlsic2hhNTEyIiwiYWJ5dGVzIiwiY29uY2F0Qnl0ZXMiLCJ1dGY4VG9CeXRlcyIsInBpcHBlbmdlciIsIlByaW1lRWR3YXJkc1BvaW50IiwidHdpc3RlZEVkd2FyZHMiLCJfRFNUX3NjYWxhciIsImNyZWF0ZUhhc2hlciIsImV4cGFuZF9tZXNzYWdlX3htZCIsIkZpZWxkIiwiRnBJbnZlcnRCYXRjaCIsIkZwU3FydEV2ZW4iLCJpc05lZ2F0aXZlTEUiLCJtb2QiLCJwb3cyIiwibW9udGdvbWVyeSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwiZXF1YWxCeXRlcyIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl81biIsIl84biIsImVkMjU1MTlfQ1VSVkVfcCIsImVkMjU1MTlfQ1VSVkUiLCJwIiwibiIsImgiLCJhIiwiZCIsIkd4IiwiR3kiLCJlZDI1NTE5X3Bvd18yXzI1Ml8zIiwieCIsIl8xMG4iLCJfMjBuIiwiXzQwbiIsIl84MG4iLCJQIiwieDIiLCJiMiIsImI0IiwiYjUiLCJiMTAiLCJiMjAiLCJiNDAiLCJiODAiLCJiMTYwIiwiYjI0MCIsImIyNTAiLCJwb3dfcF81XzgiLCJhZGp1c3RTY2FsYXJCeXRlcyIsImJ5dGVzIiwiRUQyNTUxOV9TUVJUX00xIiwidXZSYXRpbyIsInUiLCJ2IiwidjMiLCJ2NyIsInBvdyIsInZ4MiIsInJvb3QxIiwicm9vdDIiLCJ1c2VSb290MSIsInVzZVJvb3QyIiwibm9Sb290IiwiaXNWYWxpZCIsInZhbHVlIiwiRnAiLCJpc0xFIiwiRm4iLCJlZDI1NTE5RGVmYXVsdHMiLCJoYXNoIiwiZWQyNTUxOSIsImVkMjU1MTlfZG9tYWluIiwiZGF0YSIsImN0eCIsInBoZmxhZyIsImxlbmd0aCIsIkVycm9yIiwiVWludDhBcnJheSIsImVkMjU1MTljdHgiLCJkb21haW4iLCJlZDI1NTE5cGgiLCJPYmplY3QiLCJhc3NpZ24iLCJwcmVoYXNoIiwieDI1NTE5IiwiT1JERVIiLCJ0eXBlIiwicG93UG1pbnVzMiIsIkVMTDJfQzEiLCJFTEwyX0MyIiwiRUxMMl9DMyIsInNxcnQiLCJuZWciLCJPTkUiLCJtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5IiwiRUxMMl9DNCIsIkVMTDJfSiIsInR2MSIsInNxciIsIm11bCIsInhkIiwiYWRkIiwieDFuIiwidHYyIiwiZ3hkIiwiZ3gxIiwidHYzIiwieTExIiwieTEyIiwiZTEiLCJlcWwiLCJ5MSIsImNtb3YiLCJ4Mm4iLCJ5MjEiLCJ5MjIiLCJneDIiLCJlMiIsInkyIiwiZTMiLCJ4biIsInkiLCJlNCIsImlzT2RkIiwieE1uIiwieE1kIiwieU1uIiwieU1kIiwiRUxMMl9DMV9FRFdBUkRTIiwibWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfZWR3YXJkczI1NTE5IiwieW4iLCJzdWIiLCJ5ZCIsImUiLCJaRVJPIiwieGRfaW52IiwieWRfaW52IiwiZWQyNTUxOV9oYXNoZXIiLCJQb2ludCIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJtIiwiayIsImV4cGFuZCIsIlNRUlRfTTEiLCJTUVJUX0FEX01JTlVTX09ORSIsIklOVlNRUlRfQV9NSU5VU19EIiwiT05FX01JTlVTX0RfU1EiLCJEX01JTlVTX09ORV9TUSIsImludmVydFNxcnQiLCJudW1iZXIiLCJNQVhfMjU1QiIsImJ5dGVzMjU1VG9OdW1iZXJMRSIsImNyZWF0ZSIsImNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAiLCJyMCIsInIiLCJOcyIsImMiLCJEIiwiTnNfRF9pc19zcSIsInMiLCJzXyIsIk50IiwiczIiLCJXMCIsIlcxIiwiVzIiLCJXMyIsInJpc3RyZXR0bzI1NV9tYXAiLCJyMSIsInN1YmFycmF5IiwiUjEiLCJyMiIsIlIyIiwiX1Jpc3RyZXR0b1BvaW50IiwiY29uc3RydWN0b3IiLCJlcCIsImZyb21BZmZpbmUiLCJhcCIsImFzc2VydFNhbWUiLCJvdGhlciIsImluaXQiLCJoYXNoVG9DdXJ2ZSIsImhleCIsImZyb21CeXRlcyIsInRvQnl0ZXMiLCJ1MSIsInUyIiwidTFfMiIsInUyXzIiLCJJIiwiRHgiLCJEeSIsInQiLCJmcm9tSGV4IiwibXNtIiwicG9pbnRzIiwiWCIsIlkiLCJaIiwiVCIsInUyc3EiLCJpbnZzcXJ0IiwiRDEiLCJEMiIsInpJbnYiLCJfeCIsIl95IiwiZXF1YWxzIiwiWDEiLCJZMSIsIlgyIiwiWTIiLCJvbmUiLCJ0d28iLCJpczAiLCJCQVNFIiwicmlzdHJldHRvMjU1IiwicmlzdHJldHRvMjU1X2hhc2hlciIsIm1zZyIsIm9wdGlvbnMiLCJ4bWQiLCJoYXNoVG9TY2FsYXIiLCJFRDI1NTE5X1RPUlNJT05fU1VCR1JPVVAiLCJlZHdhcmRzVG9Nb250Z29tZXJ5UHViIiwiZWR3YXJkc1B1YiIsInV0aWxzIiwidG9Nb250Z29tZXJ5IiwiZWR3YXJkc1RvTW9udGdvbWVyeSIsImVkd2FyZHNUb01vbnRnb21lcnlQcml2IiwiZWR3YXJkc1ByaXYiLCJ0b01vbnRnb21lcnlQcml2IiwiUmlzdHJldHRvUG9pbnQiLCJlbmNvZGVUb0N1cnZlIiwiaGFzaFRvUmlzdHJldHRvMjU1IiwiaGFzaF90b19yaXN0cmV0dG8yNTUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/ed25519.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/curves/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _abool2: () => (/* binding */ _abool2),\n/* harmony export */   _abytes2: () => (/* binding */ _abytes2),\n/* harmony export */   _validateObject: () => (/* binding */ _validateObject),\n/* harmony export */   aInRange: () => (/* binding */ aInRange),\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes),\n/* harmony export */   anumber: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber),\n/* harmony export */   asciiToBytes: () => (/* binding */ asciiToBytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   bytesToUtf8: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToUtf8),\n/* harmony export */   concatBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes),\n/* harmony export */   copyBytes: () => (/* binding */ copyBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes),\n/* harmony export */   isHash: () => (/* binding */ isHash),\n/* harmony export */   memoized: () => (/* binding */ memoized),\n/* harmony export */   notImplemented: () => (/* binding */ notImplemented),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   randomBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.randomBytes),\n/* harmony export */   utf8ToBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Hex, bytes and number utilities.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction abool(title, value) {\n    if (typeof value !== \"boolean\") throw new Error(title + \" boolean expected, got \" + value);\n}\n// tmp name until v2\nfunction _abool2(value, title = \"\") {\n    if (typeof value !== \"boolean\") {\n        const prefix = title && `\"${title}\"`;\n        throw new Error(prefix + \"expected boolean, got type=\" + typeof value);\n    }\n    return value;\n}\n// tmp name until v2\n/** Asserts something is Uint8Array. */ function _abytes2(value, length, title = \"\") {\n    const bytes = (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || needsLen && len !== length) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : \"\";\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + \"expected Uint8Array\" + ofLen + \", got \" + got);\n    }\n    return value;\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? \"0\" + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    return hex === \"\" ? _0n : BigInt(\"0x\" + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(bytes);\n    return hexToNumber((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex);\n        } catch (e) {\n            throw new Error(title + \" must be hex string or Uint8Array, cause: \" + e);\n        }\n    } else if ((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(title + \" must be hex string or Uint8Array\");\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(title + \" of length \" + expectedLength + \" expected, got \" + len);\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */ function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as utf8ToBytes for ASCII or throws.\n */ function asciiToBytes(ascii) {\n    return Uint8Array.from(ascii, (c, i)=>{\n        const charCode = c.charCodeAt(0);\n        if (c.length !== 1 || charCode > 127) {\n            throw new Error(`string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`);\n        }\n        return charCode;\n    });\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ // export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */ // export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n)=>typeof n === \"bigint\" && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */ function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max)) throw new Error(\"expected valid \" + title + \": \" + min + \" <= n < \" + max + \", got \" + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ function bitSet(n, pos, value) {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len)=>new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte)=>Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0))=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(\"invalid validator function\");\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(\"param \" + String(fieldName) + \" is invalid. Expected \" + type + \", got \" + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nfunction isHash(val) {\n    return typeof val === \"function\" && Number.isSafeInteger(val.outputLen);\n}\nfunction _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== \"object\") throw new Error(\"expected valid options object\");\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined) return;\n        const current = typeof val;\n        if (current !== expectedType || val === null) throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v])=>checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v])=>checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */ const notImplemented = ()=>{\n    throw new Error(\"not implemented\");\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */ function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args)=>{\n        const val = map.get(arg);\n        if (val !== undefined) return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ0Qsb0VBQW9FLEdBQ2dHO0FBQ3JCO0FBQy9JLE1BQU1jLE1BQU0sYUFBYSxHQUFHQyxPQUFPO0FBQ25DLE1BQU1DLE1BQU0sYUFBYSxHQUFHRCxPQUFPO0FBQzVCLFNBQVNFLE1BQU1DLEtBQUssRUFBRUMsS0FBSztJQUM5QixJQUFJLE9BQU9BLFVBQVUsV0FDakIsTUFBTSxJQUFJQyxNQUFNRixRQUFRLDRCQUE0QkM7QUFDNUQ7QUFDQSxvQkFBb0I7QUFDYixTQUFTRSxRQUFRRixLQUFLLEVBQUVELFFBQVEsRUFBRTtJQUNyQyxJQUFJLE9BQU9DLFVBQVUsV0FBVztRQUM1QixNQUFNRyxTQUFTSixTQUFTLENBQUMsQ0FBQyxFQUFFQSxNQUFNLENBQUMsQ0FBQztRQUNwQyxNQUFNLElBQUlFLE1BQU1FLFNBQVMsZ0NBQWdDLE9BQU9IO0lBQ3BFO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLG9CQUFvQjtBQUNwQixxQ0FBcUMsR0FDOUIsU0FBU0ksU0FBU0osS0FBSyxFQUFFSyxNQUFNLEVBQUVOLFFBQVEsRUFBRTtJQUM5QyxNQUFNTyxRQUFRaEIsK0RBQVFBLENBQUNVO0lBQ3ZCLE1BQU1PLE1BQU1QLE9BQU9LO0lBQ25CLE1BQU1HLFdBQVdILFdBQVdJO0lBQzVCLElBQUksQ0FBQ0gsU0FBVUUsWUFBWUQsUUFBUUYsUUFBUztRQUN4QyxNQUFNRixTQUFTSixTQUFTLENBQUMsQ0FBQyxFQUFFQSxNQUFNLEVBQUUsQ0FBQztRQUNyQyxNQUFNVyxRQUFRRixXQUFXLENBQUMsV0FBVyxFQUFFSCxPQUFPLENBQUMsR0FBRztRQUNsRCxNQUFNTSxNQUFNTCxRQUFRLENBQUMsT0FBTyxFQUFFQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxPQUFPUCxNQUFNLENB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QUM3QixJQUFJWSxTQUFTaEMsUUFBUW5FLFdBQ2pCO1FBQ0osTUFBTW9HLFVBQVUsT0FBT2pDO1FBQ3ZCLElBQUlpQyxZQUFZRixnQkFBZ0IvQixRQUFRLE1BQ3BDLE1BQU0sSUFBSTNFLE1BQU0sQ0FBQyxPQUFPLEVBQUUrRixVQUFVLHVCQUF1QixFQUFFVyxhQUFhLE1BQU0sRUFBRUUsUUFBUSxDQUFDO0lBQ25HO0lBQ0FSLE9BQU9DLE9BQU8sQ0FBQ0csUUFBUUssT0FBTyxDQUFDLENBQUMsQ0FBQ2pELEdBQUdELEVBQUUsR0FBS21DLFdBQVdsQyxHQUFHRCxHQUFHO0lBQzVEeUMsT0FBT0MsT0FBTyxDQUFDSSxXQUFXSSxPQUFPLENBQUMsQ0FBQyxDQUFDakQsR0FBR0QsRUFBRSxHQUFLbUMsV0FBV2xDLEdBQUdELEdBQUc7QUFDbkU7QUFDQTs7Q0FFQyxHQUNNLE1BQU1tRCxpQkFBaUI7SUFDMUIsTUFBTSxJQUFJOUcsTUFBTTtBQUNwQixFQUFFO0FBQ0Y7OztDQUdDLEdBQ00sU0FBUytHLFNBQVNDLEVBQUU7SUFDdkIsTUFBTUMsTUFBTSxJQUFJQztJQUNoQixPQUFPLENBQUNDLEtBQUssR0FBR0M7UUFDWixNQUFNekMsTUFBTXNDLElBQUlJLEdBQUcsQ0FBQ0Y7UUFDcEIsSUFBSXhDLFFBQVFuRSxXQUNSLE9BQU9tRTtRQUNYLE1BQU0yQyxXQUFXTixHQUFHRyxRQUFRQztRQUM1QkgsSUFBSU0sR0FBRyxDQUFDSixLQUFLRztRQUNiLE9BQU9BO0lBQ1g7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3V0aWxzLmpzPzAzZWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZXgsIGJ5dGVzIGFuZCBudW1iZXIgdXRpbGl0aWVzLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBhYnl0ZXMgYXMgYWJ5dGVzXywgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4XywgY29uY2F0Qnl0ZXMgYXMgY29uY2F0Qnl0ZXNfLCBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXNfLCBpc0J5dGVzIGFzIGlzQnl0ZXNfLCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuZXhwb3J0IHsgYWJ5dGVzLCBhbnVtYmVyLCBieXRlc1RvSGV4LCBieXRlc1RvVXRmOCwgY29uY2F0Qnl0ZXMsIGhleFRvQnl0ZXMsIGlzQnl0ZXMsIHJhbmRvbUJ5dGVzLCB1dGY4VG9CeXRlcywgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuZXhwb3J0IGZ1bmN0aW9uIGFib29sKHRpdGxlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBib29sZWFuIGV4cGVjdGVkLCBnb3QgJyArIHZhbHVlKTtcbn1cbi8vIHRtcCBuYW1lIHVudGlsIHYyXG5leHBvcnQgZnVuY3Rpb24gX2Fib29sMih2YWx1ZSwgdGl0bGUgPSAnJykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aXRsZSAmJiBgXCIke3RpdGxlfVwiYDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArICdleHBlY3RlZCBib29sZWFuLCBnb3QgdHlwZT0nICsgdHlwZW9mIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLy8gdG1wIG5hbWUgdW50aWwgdjJcbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hYnl0ZXMyKHZhbHVlLCBsZW5ndGgsIHRpdGxlID0gJycpIHtcbiAgICBjb25zdCBieXRlcyA9IGlzQnl0ZXNfKHZhbHVlKTtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZT8ubGVuZ3RoO1xuICAgIGNvbnN0IG5lZWRzTGVuID0gbGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKCFieXRlcyB8fCAobmVlZHNMZW4gJiYgbGVuICE9PSBsZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRpdGxlICYmIGBcIiR7dGl0bGV9XCIgYDtcbiAgICAgICAgY29uc3Qgb2ZMZW4gPSBuZWVkc0xlbiA/IGAgb2YgbGVuZ3RoICR7bGVuZ3RofWAgOiAnJztcbiAgICAgICAgY29uc3QgZ290ID0gYnl0ZXMgPyBgbGVuZ3RoPSR7bGVufWAgOiBgdHlwZT0ke3R5cGVvZiB2YWx1ZX1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4ICsgJ2V4cGVjdGVkIFVpbnQ4QXJyYXknICsgb2ZMZW4gKyAnLCBnb3QgJyArIGdvdCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIFVzZWQgaW4gd2VpZXJzdHJhc3MsIGRlclxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyAnMCcgKyBoZXggOiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgcmV0dXJuIGhleCA9PT0gJycgPyBfMG4gOiBCaWdJbnQoJzB4JyArIGhleCk7IC8vIEJpZyBFbmRpYW5cbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4XyhieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGFieXRlc18oYnl0ZXMpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4XyhVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlc18obi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzXyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAnc2VjcmV0IGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzXyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjYXVzZTogJyArIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnl0ZXNfKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheScpO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgb2YgbGVuZ3RoICcgKyBleHBlY3RlZExlbmd0aCArICcgZXhwZWN0ZWQsIGdvdCAnICsgbGVuKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQ29tcGFyZXMgMiB1OGEtcyBpbiBraW5kYSBjb25zdGFudCB0aW1lXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkaWZmID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGRpZmYgfD0gYVtpXSBeIGJbaV07XG4gICAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG4vKipcbiAqIENvcGllcyBVaW50OEFycmF5LiBXZSBjYW4ndCB1c2UgdThhLnNsaWNlKCksIGJlY2F1c2UgdThhIGNhbiBiZSBCdWZmZXIsXG4gKiBhbmQgQnVmZmVyI3NsaWNlIGNyZWF0ZXMgbXV0YWJsZSBjb3B5LiBOZXZlciB1c2UgQnVmZmVycyFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlCeXRlcyhieXRlcykge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnl0ZXMpO1xufVxuLyoqXG4gKiBEZWNvZGVzIDctYml0IEFTQ0lJIHN0cmluZyB0byBVaW50OEFycmF5LCB0aHJvd3Mgb24gbm9uLWFzY2lpIHN5bWJvbHNcbiAqIFNob3VsZCBiZSBzYWZlIHRvIHVzZSBmb3IgdGhpbmdzIGV4cGVjdGVkIHRvIGJlIEFTQ0lJLlxuICogUmV0dXJucyBleGFjdCBzYW1lIHJlc3VsdCBhcyB1dGY4VG9CeXRlcyBmb3IgQVNDSUkgb3IgdGhyb3dzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNjaWlUb0J5dGVzKGFzY2lpKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhc2NpaSwgKGMsIGkpID0+IHtcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmIChjLmxlbmd0aCAhPT0gMSB8fCBjaGFyQ29kZSA+IDEyNykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpbmcgY29udGFpbnMgbm9uLUFTQ0lJIGNoYXJhY3RlciBcIiR7YXNjaWlbaV19XCIgd2l0aCBjb2RlICR7Y2hhckNvZGV9IGF0IHBvc2l0aW9uICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhckNvZGU7XG4gICAgfSk7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbi8vIGV4cG9ydCBjb25zdCB1dGY4VG9CeXRlczogdHlwZW9mIHV0ZjhUb0J5dGVzXyA9IHV0ZjhUb0J5dGVzXztcbi8qKlxuICogQ29udmVydHMgYnl0ZXMgdG8gc3RyaW5nIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSBieXRlc1RvVXRmOChVaW50OEFycmF5LmZyb20oWzk3LCA5OCwgOTldKSkgLy8gJ2FiYydcbiAqL1xuLy8gZXhwb3J0IGNvbnN0IGJ5dGVzVG9VdGY4OiB0eXBlb2YgYnl0ZXNUb1V0ZjhfID0gYnl0ZXNUb1V0ZjhfO1xuLy8gSXMgcG9zaXRpdmUgYmlnaW50XG5jb25zdCBpc1Bvc0JpZyA9IChuKSA9PiB0eXBlb2YgbiA9PT0gJ2JpZ2ludCcgJiYgXzBuIDw9IG47XG5leHBvcnQgZnVuY3Rpb24gaW5SYW5nZShuLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBpc1Bvc0JpZyhuKSAmJiBpc1Bvc0JpZyhtaW4pICYmIGlzUG9zQmlnKG1heCkgJiYgbWluIDw9IG4gJiYgbiA8IG1heDtcbn1cbi8qKlxuICogQXNzZXJ0cyBtaW4gPD0gbiA8IG1heC4gTk9URTogSXQncyA8IG1heCBhbmQgbm90IDw9IG1heC5cbiAqIEBleGFtcGxlXG4gKiBhSW5SYW5nZSgneCcsIHgsIDFuLCAyNTZuKTsgLy8gd291bGQgYXNzdW1lIHggaXMgaW4gKDFuLi4yNTVuKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYUluUmFuZ2UodGl0bGUsIG4sIG1pbiwgbWF4KSB7XG4gICAgLy8gV2h5IG1pbiA8PSBuIDwgbWF4IGFuZCBub3QgYSAobWluIDwgbiA8IG1heCkgT1IgYiAobWluIDw9IG4gPD0gbWF4KT9cbiAgICAvLyBjb25zaWRlciBQPTI1Nm4sIG1pbj0wbiwgbWF4PVBcbiAgICAvLyAtIGEgZm9yIG1pbj0wIHdvdWxkIHJlcXVpcmUgLTE6ICAgICAgICAgIGBpblJhbmdlKCd4JywgeCwgLTFuLCBQKWBcbiAgICAvLyAtIGIgd291bGQgY29tbW9ubHkgcmVxdWlyZSBzdWJ0cmFjdGlvbjogIGBpblJhbmdlKCd4JywgeCwgMG4sIFAgLSAxbilgXG4gICAgLy8gLSBvdXIgd2F5IGlzIHRoZSBjbGVhbmVzdDogICAgICAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIDBuLCBQKVxuICAgIGlmICghaW5SYW5nZShuLCBtaW4sIG1heCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgdmFsaWQgJyArIHRpdGxlICsgJzogJyArIG1pbiArICcgPD0gbiA8ICcgKyBtYXggKyAnLCBnb3QgJyArIG4pO1xufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICogVE9ETzogbWVyZ2Ugd2l0aCBuTGVuZ3RoIGluIG1vZHVsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdFNldChuLCBwb3MsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMW4gPDwgQmlnSW50KG4pKSAtIF8xbjtcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgY29uc3QgdThuID0gKGxlbikgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG4gICAgY29uc3QgdThvZiA9IChieXRlKSA9PiBVaW50OEFycmF5Lm9mKGJ5dGUpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oMCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThvZigweDAwKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OG9mKDB4MDEpLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzXyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IGlzQnl0ZXNfKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHZhbGlkYXRvciBmdW5jdGlvbicpO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcmFtICcgKyBTdHJpbmcoZmllbGROYW1lKSArICcgaXMgaW52YWxpZC4gRXhwZWN0ZWQgJyArIHR5cGUgKyAnLCBnb3QgJyArIHZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG5leHBvcnQgZnVuY3Rpb24gaXNIYXNoKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF92YWxpZGF0ZU9iamVjdChvYmplY3QsIGZpZWxkcywgb3B0RmllbGRzID0ge30pIHtcbiAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YWxpZCBvcHRpb25zIG9iamVjdCcpO1xuICAgIGZ1bmN0aW9uIGNoZWNrRmllbGQoZmllbGROYW1lLCBleHBlY3RlZFR5cGUsIGlzT3B0KSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHQgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0eXBlb2YgdmFsO1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gZXhwZWN0ZWRUeXBlIHx8IHZhbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyYW0gXCIke2ZpZWxkTmFtZX1cIiBpcyBpbnZhbGlkOiBleHBlY3RlZCAke2V4cGVjdGVkVHlwZX0sIGdvdCAke2N1cnJlbnR9YCk7XG4gICAgfVxuICAgIE9iamVjdC5lbnRyaWVzKGZpZWxkcykuZm9yRWFjaCgoW2ssIHZdKSA9PiBjaGVja0ZpZWxkKGssIHYsIGZhbHNlKSk7XG4gICAgT2JqZWN0LmVudHJpZXMob3B0RmllbGRzKS5mb3JFYWNoKChbaywgdl0pID0+IGNoZWNrRmllbGQoaywgdiwgdHJ1ZSkpO1xufVxuLyoqXG4gKiB0aHJvd3Mgbm90IGltcGxlbWVudGVkIGVycm9yXG4gKi9cbmV4cG9ydCBjb25zdCBub3RJbXBsZW1lbnRlZCA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcbi8qKlxuICogTWVtb2l6ZXMgKGNhY2hlcykgY29tcHV0YXRpb24gcmVzdWx0LlxuICogVXNlcyBXZWFrTWFwOiB0aGUgdmFsdWUgaXMgZ29pbmcgYXV0by1jbGVhbmVkIGJ5IEdDIGFmdGVyIGxhc3QgcmVmZXJlbmNlIGlzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplZChmbikge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIChhcmcsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gbWFwLmdldChhcmcpO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGZuKGFyZywgLi4uYXJncyk7XG4gICAgICAgIG1hcC5zZXQoYXJnLCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImFieXRlcyIsImFieXRlc18iLCJieXRlc1RvSGV4IiwiYnl0ZXNUb0hleF8iLCJjb25jYXRCeXRlcyIsImNvbmNhdEJ5dGVzXyIsImhleFRvQnl0ZXMiLCJoZXhUb0J5dGVzXyIsImlzQnl0ZXMiLCJpc0J5dGVzXyIsImFudW1iZXIiLCJieXRlc1RvVXRmOCIsInJhbmRvbUJ5dGVzIiwidXRmOFRvQnl0ZXMiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJhYm9vbCIsInRpdGxlIiwidmFsdWUiLCJFcnJvciIsIl9hYm9vbDIiLCJwcmVmaXgiLCJfYWJ5dGVzMiIsImxlbmd0aCIsImJ5dGVzIiwibGVuIiwibmVlZHNMZW4iLCJ1bmRlZmluZWQiLCJvZkxlbiIsImdvdCIsIm51bWJlclRvSGV4VW5wYWRkZWQiLCJudW0iLCJoZXgiLCJ0b1N0cmluZyIsImhleFRvTnVtYmVyIiwiYnl0ZXNUb051bWJlckJFIiwiYnl0ZXNUb051bWJlckxFIiwiVWludDhBcnJheSIsImZyb20iLCJyZXZlcnNlIiwibnVtYmVyVG9CeXRlc0JFIiwibiIsInBhZFN0YXJ0IiwibnVtYmVyVG9CeXRlc0xFIiwibnVtYmVyVG9WYXJCeXRlc0JFIiwiZW5zdXJlQnl0ZXMiLCJleHBlY3RlZExlbmd0aCIsInJlcyIsImUiLCJlcXVhbEJ5dGVzIiwiYSIsImIiLCJkaWZmIiwiaSIsImNvcHlCeXRlcyIsImFzY2lpVG9CeXRlcyIsImFzY2lpIiwiYyIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsImlzUG9zQmlnIiwiaW5SYW5nZSIsIm1pbiIsIm1heCIsImFJblJhbmdlIiwiYml0TGVuIiwiYml0R2V0IiwicG9zIiwiYml0U2V0IiwiYml0TWFzayIsImNyZWF0ZUhtYWNEcmJnIiwiaGFzaExlbiIsInFCeXRlTGVuIiwiaG1hY0ZuIiwidThuIiwidThvZiIsImJ5dGUiLCJvZiIsInYiLCJrIiwicmVzZXQiLCJmaWxsIiwiaCIsInJlc2VlZCIsInNlZWQiLCJnZW4iLCJvdXQiLCJzbCIsInNsaWNlIiwicHVzaCIsImdlblVudGlsIiwicHJlZCIsInZhbGlkYXRvckZucyIsImJpZ2ludCIsInZhbCIsImZ1bmN0aW9uIiwiYm9vbGVhbiIsInN0cmluZyIsInN0cmluZ09yVWludDhBcnJheSIsImlzU2FmZUludGVnZXIiLCJOdW1iZXIiLCJhcnJheSIsIkFycmF5IiwiaXNBcnJheSIsImZpZWxkIiwib2JqZWN0IiwiRnAiLCJpc1ZhbGlkIiwiaGFzaCIsIm91dHB1dExlbiIsInZhbGlkYXRlT2JqZWN0IiwidmFsaWRhdG9ycyIsIm9wdFZhbGlkYXRvcnMiLCJjaGVja0ZpZWxkIiwiZmllbGROYW1lIiwidHlwZSIsImlzT3B0aW9uYWwiLCJjaGVja1ZhbCIsIlN0cmluZyIsIk9iamVjdCIsImVudHJpZXMiLCJpc0hhc2giLCJfdmFsaWRhdGVPYmplY3QiLCJmaWVsZHMiLCJvcHRGaWVsZHMiLCJleHBlY3RlZFR5cGUiLCJpc09wdCIsImN1cnJlbnQiLCJmb3JFYWNoIiwibm90SW1wbGVtZW50ZWQiLCJtZW1vaXplZCIsImZuIiwibWFwIiwiV2Vha01hcCIsImFyZyIsImFyZ3MiLCJnZXQiLCJjb21wdXRlZCIsInNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/_md.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_md.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj),\n/* harmony export */   SHA224_IV: () => (/* binding */ SHA224_IV),\n/* harmony export */   SHA256_IV: () => (/* binding */ SHA256_IV),\n/* harmony export */   SHA384_IV: () => (/* binding */ SHA384_IV),\n/* harmony export */   SHA512_IV: () => (/* binding */ SHA512_IV),\n/* harmony export */   setBigUint64: () => (/* binding */ setBigUint64)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */ \n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */ function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */ function Chi(a, b, c) {\n    return a & b ^ ~a & c;\n}\n/** Majority function, true if any two inputs is true. */ function Maj(a, b, c) {\n    return a & b ^ a & c ^ b & c;\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */ /** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */ const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */ const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8,\n    0x367cd507,\n    0x3070dd17,\n    0xf70e5939,\n    0xffc00b31,\n    0x68581511,\n    0x64f98fa7,\n    0xbefa4fa4\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */ const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d,\n    0xc1059ed8,\n    0x629a292a,\n    0x367cd507,\n    0x9159015a,\n    0x3070dd17,\n    0x152fecd8,\n    0xf70e5939,\n    0x67332667,\n    0xffc00b31,\n    0x8eb44a87,\n    0x68581511,\n    0xdb0c2e0d,\n    0x64f98fa7,\n    0x47b5481d,\n    0xbefa4fa4\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */ const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667,\n    0xf3bcc908,\n    0xbb67ae85,\n    0x84caa73b,\n    0x3c6ef372,\n    0xfe94f82b,\n    0xa54ff53a,\n    0x5f1d36f1,\n    0x510e527f,\n    0xade682d1,\n    0x9b05688c,\n    0x2b3e6c1f,\n    0x1f83d9ab,\n    0xfb41bd6b,\n    0x5be0cd19,\n    0x137e2179\n]); //# sourceMappingURL=_md.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUN1RjtBQUN4Riw4RkFBOEYsR0FDdkYsU0FBU08sYUFBYUMsSUFBSSxFQUFFQyxVQUFVLEVBQUVDLEtBQUssRUFBRUMsSUFBSTtJQUN0RCxJQUFJLE9BQU9ILEtBQUtELFlBQVksS0FBSyxZQUM3QixPQUFPQyxLQUFLRCxZQUFZLENBQUNFLFlBQVlDLE9BQU9DO0lBQ2hELE1BQU1DLE9BQU9DLE9BQU87SUFDcEIsTUFBTUMsV0FBV0QsT0FBTztJQUN4QixNQUFNRSxLQUFLQyxPQUFPLFNBQVVKLE9BQVFFO0lBQ3BDLE1BQU1HLEtBQUtELE9BQU9OLFFBQVFJO0lBQzFCLE1BQU1JLElBQUlQLE9BQU8sSUFBSTtJQUNyQixNQUFNUSxJQUFJUixPQUFPLElBQUk7SUFDckJILEtBQUtZLFNBQVMsQ0FBQ1gsYUFBYVMsR0FBR0gsSUFBSUo7SUFDbkNILEtBQUtZLFNBQVMsQ0FBQ1gsYUFBYVUsR0FBR0YsSUFBSU47QUFDdkM7QUFDQSxzQkFBc0IsR0FDZixTQUFTVSxJQUFJQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUN2QixPQUFPLElBQUtELElBQU0sQ0FBQ0QsSUFBSUU7QUFDM0I7QUFDQSx1REFBdUQsR0FDaEQsU0FBU0MsSUFBSUgsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFDdkIsT0FBTyxJQUFLRCxJQUFNRCxJQUFJRSxJQUFNRCxJQUFJQztBQUNwQztBQUNBOzs7Q0FHQyxHQUNNLE1BQU1FLGVBQWUxQiwyQ0FBSUE7SUFDNUIyQixZQUFZQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFbkIsSUFBSSxDQUFFO1FBQzlDLEtBQUs7UUFDTCxJQUFJLENBQUNvQixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ04sUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ25CLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUN3QixNQUFNLEdBQUcsSUFBSUMsV0FBV1I7UUFDN0IsSUFBSSxDQUFDcEIsSUFBSSxHQUFHSCxxREFBVUEsQ0FBQyxJQUFJLENBQUM4QixNQUFNO0lBQ3RDO0lBQ0FFLE9BQU9DLElBQUksRUFBRTtRQUNUcEMsa0RBQU9BLENBQUMsSUFBSTtRQUNab0MsT0FBT2hDLGtEQUFPQSxDQUFDZ0M7UUFDZnJDLGlEQUFNQSxDQUFDcUM7UUFDUCxNQUFNLEVBQUU5QixJQUFJLEVBQUUyQixNQUFNLEVBQUVQLFFBQVEsRUFBRSxHQUFHLElBQUk7UUFDdkMsTUFBTVcsTUFBTUQsS0FBS04sTUFBTTtRQUN2QixJQUFLLElBQUlDLE1BQU0sR0FBR0EsTUFBTU0sS0FBTTtZQUMxQixNQUFNQyxPQUFPQyxLQUFLQyxHQUFHLENBQUNkLFdBQVcsSUFBSSxDQUFDSyxHQUFHLEVBQUVNLE1BQU1OO1lBQ2pELDhFQUE4RTtZQUM5RSxJQUFJTyxTQUFTWixVQUFVO2dCQUNuQixNQUFNZSxXQUFXdEMscURBQVVBLENBQUNpQztnQkFDNUIsTUFBT1YsWUFBWVcsTUFBTU4sS0FBS0EsT0FBT0wsU0FDakMsSUFBSSxDQUFDZ0IsT0FBTyxDQUFDRCxVQUFVVjtnQkFDM0I7WUFDSjtZQUNBRSxPQUFPVSxHQUFHLENBQUNQLEtBQUtRLFFBQVEsQ0FBQ2IsS0FBS0EsTUFBTU8sT0FBTyxJQUFJLENBQUNQLEdBQUc7WUFDbkQsSUFBSSxDQUFDQSxHQUFHLElBQUlPO1lBQ1pQLE9BQU9PO1lBQ1AsSUFBSSxJQUFJLENBQUNQLEdBQUcsS0FBS0wsVUFBVTtnQkFDdkIsSUFBSSxDQUFDZ0IsT0FBTyxDQUFDcEMsTUFBTTtnQkFDbkIsSUFBSSxDQUFDeUIsR0FBRyxHQUFHO1lBQ2Y7UUFDSjtRQUNBLElBQUksQ0FBQ0QsTUFBTSxJQUFJTSxLQUFLTixNQUFNO1FBQzFCLElBQUksQ0FBQ2UsVUFBVTtRQUNmLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLFdBQVdDLEdBQUcsRUFBRTtRQUNaL0Msa0RBQU9BLENBQUMsSUFBSTtRQUNaQyxrREFBT0EsQ0FBQzhDLEtBQUssSUFBSTtRQUNqQixJQUFJLENBQUNsQixRQUFRLEdBQUc7UUFDaEIsVUFBVTtRQUNWLGlFQUFpRTtRQUNqRSxzRUFBc0U7UUFDdEUsTUFBTSxFQUFFSSxNQUFNLEVBQUUzQixJQUFJLEVBQUVvQixRQUFRLEVBQUVqQixJQUFJLEVBQUUsR0FBRyxJQUFJO1FBQzdDLElBQUksRUFBRXNCLEdBQUcsRUFBRSxHQUFHLElBQUk7UUFDbEIsb0NBQW9DO1FBQ3BDRSxNQUFNLENBQUNGLE1BQU0sR0FBRztRQUNoQjdCLGdEQUFLQSxDQUFDLElBQUksQ0FBQytCLE1BQU0sQ0FBQ1csUUFBUSxDQUFDYjtRQUMzQix5RUFBeUU7UUFDekUsK0NBQStDO1FBQy9DLElBQUksSUFBSSxDQUFDSCxTQUFTLEdBQUdGLFdBQVdLLEtBQUs7WUFDakMsSUFBSSxDQUFDVyxPQUFPLENBQUNwQyxNQUFNO1lBQ25CeUIsTUFBTTtRQUNWO1FBQ0EsdUNBQXVDO1FBQ3ZDLElBQUssSUFBSWlCLElBQUlqQixLQUFLaUIsSUFBSXRCLFVBQVVzQixJQUM1QmYsTUFBTSxDQUFDZSxFQUFFLEdBQUc7UUFDaEIsZ0dBQWdHO1FBQ2hHLG9GQUFvRjtRQUNwRixpREFBaUQ7UUFDakQzQyxhQUFhQyxNQUFNb0IsV0FBVyxHQUFHZixPQUFPLElBQUksQ0FBQ21CLE1BQU0sR0FBRyxJQUFJckI7UUFDMUQsSUFBSSxDQUFDaUMsT0FBTyxDQUFDcEMsTUFBTTtRQUNuQixNQUFNMkMsUUFBUTlDLHFEQUFVQSxDQUFDNEM7UUFDekIsTUFBTVYsTUFBTSxJQUFJLENBQUNWLFNBQVM7UUFDMUIseUZBQXlGO1FBQ3pGLElBQUlVLE1BQU0sR0FDTixNQUFNLElBQUlhLE1BQU07UUFDcEIsTUFBTUMsU0FBU2QsTUFBTTtRQUNyQixNQUFNZSxRQUFRLElBQUksQ0FBQ0MsR0FBRztRQUN0QixJQUFJRixTQUFTQyxNQUFNdEIsTUFBTSxFQUNyQixNQUFNLElBQUlvQixNQUFNO1FBQ3BCLElBQUssSUFBSUYsSUFBSSxHQUFHQSxJQUFJRyxRQUFRSCxJQUN4QkMsTUFBTS9CLFNBQVMsQ0FBQyxJQUFJOEIsR0FBR0ksS0FBSyxDQUFDSixFQUFFLEVBQUV2QztJQUN6QztJQUNBNkMsU0FBUztRQUNMLE1BQU0sRUFBRXJCLE1BQU0sRUFBRU4sU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUNsQyxJQUFJLENBQUNtQixVQUFVLENBQUNiO1FBQ2hCLE1BQU1zQixNQUFNdEIsT0FBT3VCLEtBQUssQ0FBQyxHQUFHN0I7UUFDNUIsSUFBSSxDQUFDOEIsT0FBTztRQUNaLE9BQU9GO0lBQ1g7SUFDQUcsV0FBV0MsRUFBRSxFQUFFO1FBQ1hBLE1BQU9BLENBQUFBLEtBQUssSUFBSSxJQUFJLENBQUNsQyxXQUFXLEVBQUM7UUFDakNrQyxHQUFHaEIsR0FBRyxJQUFJLElBQUksQ0FBQ1UsR0FBRztRQUNsQixNQUFNLEVBQUUzQixRQUFRLEVBQUVPLE1BQU0sRUFBRUgsTUFBTSxFQUFFRCxRQUFRLEVBQUVHLFNBQVMsRUFBRUQsR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUNuRTRCLEdBQUczQixTQUFTLEdBQUdBO1FBQ2YyQixHQUFHOUIsUUFBUSxHQUFHQTtRQUNkOEIsR0FBRzdCLE1BQU0sR0FBR0E7UUFDWjZCLEdBQUc1QixHQUFHLEdBQUdBO1FBQ1QsSUFBSUQsU0FBU0osVUFDVGlDLEdBQUcxQixNQUFNLENBQUNVLEdBQUcsQ0FBQ1Y7UUFDbEIsT0FBTzBCO0lBQ1g7SUFDQUMsUUFBUTtRQUNKLE9BQU8sSUFBSSxDQUFDRixVQUFVO0lBQzFCO0FBQ0o7QUFDQTs7O0NBR0MsR0FDRCwwRUFBMEUsR0FDbkUsTUFBTUcsWUFBWSxhQUFhLEdBQUdDLFlBQVlDLElBQUksQ0FBQztJQUN0RDtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGLEVBQUU7QUFDSCw0RUFBNEUsR0FDckUsTUFBTUMsWUFBWSxhQUFhLEdBQUdGLFlBQVlDLElBQUksQ0FBQztJQUN0RDtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGLEVBQUU7QUFDSCwyRUFBMkUsR0FDcEUsTUFBTUUsWUFBWSxhQUFhLEdBQUdILFlBQVlDLElBQUksQ0FBQztJQUN0RDtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkYsRUFBRTtBQUNILDBFQUEwRSxHQUNuRSxNQUFNRyxZQUFZLGFBQWEsR0FBR0osWUFBWUMsSUFBSSxDQUFDO0lBQ3REO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RixFQUFFLENBQ0gsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0cGxhY2UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzP2EwODciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBNZXJrbGUtRGFtZ2FyZCBoYXNoIHV0aWxzLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBIYXNoLCBhYnl0ZXMsIGFleGlzdHMsIGFvdXRwdXQsIGNsZWFuLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKiBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0LiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX2RhdGF2aWV3X3NldGJpZ3VpbnQ2NCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vKiogQ2hvaWNlOiBhID8gYiA6IGMgKi9cbmV4cG9ydCBmdW5jdGlvbiBDaGkoYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAmIGIpIF4gKH5hICYgYyk7XG59XG4vKiogTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1dHMgaXMgdHJ1ZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNYWooYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG59XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhhc2hNRCBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgYWJ5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpblxuICAgICAgICAvLyBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhbCBTSEEtMiBzdGF0ZTogZnJhY3Rpb25hbCBwYXJ0cyBvZiBzcXVhcmUgcm9vdHMgb2YgZmlyc3QgMTYgcHJpbWVzIDIuLjUzLlxuICogQ2hlY2sgb3V0IGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgIGZvciByZWNvbXB1dGF0aW9uIGd1aWRlLlxuICovXG4vKiogSW5pdGlhbCBTSEEyNTYgc3RhdGUuIEJpdHMgMC4uMzIgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnQgY29uc3QgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTksXG5dKTtcbi8qKiBJbml0aWFsIFNIQTIyNCBzdGF0ZS4gQml0cyAzMi4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0IGNvbnN0IFNIQTIyNF9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LCAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0LFxuXSk7XG4vKiogSW5pdGlhbCBTSEEzODQgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0IGNvbnN0IFNIQTM4NF9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LCAweDYyOWEyOTJhLCAweDM2N2NkNTA3LCAweDkxNTkwMTVhLCAweDMwNzBkZDE3LCAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQsXG5dKTtcbi8qKiBJbml0aWFsIFNIQTUxMiBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMi4uMTkgKi9cbmV4cG9ydCBjb25zdCBTSEE1MTJfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCwgMHhiYjY3YWU4NSwgMHg4NGNhYTczYiwgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiwgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLCAweDliMDU2ODhjLCAweDJiM2U2YzFmLCAweDFmODNkOWFiLCAweGZiNDFiZDZiLCAweDViZTBjZDE5LCAweDEzN2UyMTc5LFxuXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbIkhhc2giLCJhYnl0ZXMiLCJhZXhpc3RzIiwiYW91dHB1dCIsImNsZWFuIiwiY3JlYXRlVmlldyIsInRvQnl0ZXMiLCJzZXRCaWdVaW50NjQiLCJ2aWV3IiwiYnl0ZU9mZnNldCIsInZhbHVlIiwiaXNMRSIsIl8zMm4iLCJCaWdJbnQiLCJfdTMyX21heCIsIndoIiwiTnVtYmVyIiwid2wiLCJoIiwibCIsInNldFVpbnQzMiIsIkNoaSIsImEiLCJiIiwiYyIsIk1haiIsIkhhc2hNRCIsImNvbnN0cnVjdG9yIiwiYmxvY2tMZW4iLCJvdXRwdXRMZW4iLCJwYWRPZmZzZXQiLCJmaW5pc2hlZCIsImxlbmd0aCIsInBvcyIsImRlc3Ryb3llZCIsImJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJ1cGRhdGUiLCJkYXRhIiwibGVuIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJkYXRhVmlldyIsInByb2Nlc3MiLCJzZXQiLCJzdWJhcnJheSIsInJvdW5kQ2xlYW4iLCJkaWdlc3RJbnRvIiwib3V0IiwiaSIsIm92aWV3IiwiRXJyb3IiLCJvdXRMZW4iLCJzdGF0ZSIsImdldCIsImRpZ2VzdCIsInJlcyIsInNsaWNlIiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byIsImNsb25lIiwiU0hBMjU2X0lWIiwiVWludDMyQXJyYXkiLCJmcm9tIiwiU0hBMjI0X0lWIiwiU0hBMzg0X0lWIiwiU0hBNTEyX0lWIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */ const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for(let i = 0; i < len; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nconst rotr32L = (h, _l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64); //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDRCxNQUFNQSxhQUFhLGFBQWEsR0FBR0MsT0FBTyxLQUFLLEtBQUs7QUFDcEQsTUFBTUMsT0FBTyxhQUFhLEdBQUdELE9BQU87QUFDcEMsU0FBU0UsUUFBUUMsQ0FBQyxFQUFFQyxLQUFLLEtBQUs7SUFDMUIsSUFBSUEsSUFDQSxPQUFPO1FBQUVDLEdBQUdDLE9BQU9ILElBQUlKO1FBQWFRLEdBQUdELE9BQU8sS0FBTUwsT0FBUUY7SUFBWTtJQUM1RSxPQUFPO1FBQUVNLEdBQUdDLE9BQU8sS0FBTUwsT0FBUUYsY0FBYztRQUFHUSxHQUFHRCxPQUFPSCxJQUFJSixjQUFjO0lBQUU7QUFDcEY7QUFDQSxTQUFTUyxNQUFNQyxHQUFHLEVBQUVMLEtBQUssS0FBSztJQUMxQixNQUFNTSxNQUFNRCxJQUFJRSxNQUFNO0lBQ3RCLElBQUlDLEtBQUssSUFBSUMsWUFBWUg7SUFDekIsSUFBSUksS0FBSyxJQUFJRCxZQUFZSDtJQUN6QixJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSUwsS0FBS0ssSUFBSztRQUMxQixNQUFNLEVBQUVWLENBQUMsRUFBRUUsQ0FBQyxFQUFFLEdBQUdMLFFBQVFPLEdBQUcsQ0FBQ00sRUFBRSxFQUFFWDtRQUNqQyxDQUFDUSxFQUFFLENBQUNHLEVBQUUsRUFBRUQsRUFBRSxDQUFDQyxFQUFFLENBQUMsR0FBRztZQUFDVjtZQUFHRTtTQUFFO0lBQzNCO0lBQ0EsT0FBTztRQUFDSztRQUFJRTtLQUFHO0FBQ25CO0FBQ0EsTUFBTUUsUUFBUSxDQUFDWCxHQUFHRSxJQUFNLE9BQVFGLE1BQU0sTUFBTUosT0FBUUQsT0FBT08sTUFBTTtBQUNqRSx1QkFBdUI7QUFDdkIsTUFBTVUsUUFBUSxDQUFDWixHQUFHYSxJQUFJQyxJQUFNZCxNQUFNYztBQUNsQyxNQUFNQyxRQUFR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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzPzdkYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXJzIGZvciB1NjQuIEJpZ1VpbnQ2NEFycmF5IGlzIHRvbyBzbG93IGFzIHBlciAyMDI1LCBzbyB3ZSBpbXBsZW1lbnQgaXQgdXNpbmcgVWludDMyQXJyYXkuXG4gKiBAdG9kbyByZS1jaGVjayBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzQyMjEyNTg4XG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBsc3QubGVuZ3RoO1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBhZGQsIGFkZDNILCBhZGQzTCwgYWRkNEgsIGFkZDRMLCBhZGQ1SCwgYWRkNUwsIGZyb21CaWcsIHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgcm90cjMySCwgcm90cjMyTCwgcm90ckJILCByb3RyQkwsIHJvdHJTSCwgcm90clNMLCBzaHJTSCwgc2hyU0wsIHNwbGl0LCB0b0JpZyB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbIlUzMl9NQVNLNjQiLCJCaWdJbnQiLCJfMzJuIiwiZnJvbUJpZyIsIm4iLCJsZSIsImgiLCJOdW1iZXIiLCJsIiwic3BsaXQiLCJsc3QiLCJsZW4iLCJsZW5ndGgiLCJBaCIsIlVpbnQzMkFycmF5IiwiQWwiLCJpIiwidG9CaWciLCJzaHJTSCIsIl9sIiwicyIsInNoclNMIiwicm90clNIIiwicm90clNMIiwicm90ckJIIiwicm90ckJMIiwicm90cjMySCIsIl9oIiwicm90cjMyTCIsInJvdGxTSCIsInJvdGxTTCIsInJvdGxCSCIsInJvdGxCTCIsImFkZCIsIkJoIiwiQmwiLCJhZGQzTCIsIkNsIiwiYWRkM0giLCJsb3ciLCJDaCIsImFkZDRMIiwiRGwiLCJhZGQ0SCIsIkRoIiwiYWRkNUwiLCJFbCIsImFkZDVIIiwiRWgiLCJ1NjQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/cryptoNode.js":
/*!******************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/**\n * Internal webcrypto alias.\n * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n * Falls back to Node.js built-in crypto for Node.js <=v14.\n * See utils.ts for details.\n * @module\n */ // @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"randomBytes\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDRCxhQUFhO0FBQ3FCO0FBQzNCLE1BQU1DLFNBQVNELDJNQUFFQSxJQUFJLE9BQU9BLDJNQUFFQSxLQUFLLFlBQVksME5BQWlCQSxHQUNqRUEsa0RBQVksR0FDWkEsMk1BQUVBLElBQUksT0FBT0EsMk1BQUVBLEtBQUssWUFBWSw0TkFBbUJBLEdBQy9DQSwyTUFBRUEsR0FDRkcsVUFBVSxDQUNwQixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzP2RhNWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCB3ZWJjcnlwdG8gYWxpYXMuXG4gKiBXZSBwcmVmZXIgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIG5vZGUuanMgMTYrLlxuICogRmFsbHMgYmFjayB0byBOb2RlLmpzIGJ1aWx0LWluIGNyeXB0byBmb3IgTm9kZS5qcyA8PXYxNC5cbiAqIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbiAqIEBtb2R1bGVcbiAqL1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmNcbiAgICA/IG5jLndlYmNyeXB0b1xuICAgIDogbmMgJiYgdHlwZW9mIG5jID09PSAnb2JqZWN0JyAmJiAncmFuZG9tQnl0ZXMnIGluIG5jXG4gICAgICAgID8gbmNcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJuYyIsImNyeXB0byIsIndlYmNyeXB0byIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */ \nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ahash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(pad);\n    }\n    update(buf) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7O0NBR0MsR0FDeUU7QUFDbkUsTUFBTU0sYUFBYUYsMkNBQUlBO0lBQzFCRyxZQUFZQyxJQUFJLEVBQUVDLElBQUksQ0FBRTtRQUNwQixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakJULGdEQUFLQSxDQUFDTTtRQUNOLE1BQU1JLE1BQU1QLGtEQUFPQSxDQUFDSTtRQUNwQixJQUFJLENBQUNJLEtBQUssR0FBR0wsS0FBS00sTUFBTTtRQUN4QixJQUFJLE9BQU8sSUFBSSxDQUFDRCxLQUFLLENBQUNFLE1BQU0sS0FBSyxZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDcEIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDSixLQUFLLENBQUNJLFFBQVE7UUFDbkMsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSSxDQUFDTCxLQUFLLENBQUNLLFNBQVM7UUFDckMsTUFBTUQsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDOUIsTUFBTUUsTUFBTSxJQUFJQyxXQUFXSDtRQUMzQix3Q0FBd0M7UUFDeENFLElBQUlFLEdBQUcsQ0FBQ1QsSUFBSVUsTUFBTSxHQUFHTCxXQUFXVCxLQUFLTSxNQUFNLEdBQUdDLE1BQU0sQ0FBQ0gsS0FBS1csTUFBTSxLQUFLWDtRQUNyRSxJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUk7UUFDZCxJQUFJLENBQUNYLEtBQUssQ0FBQ0UsTUFBTSxDQUFDSTtRQUNsQixtSEFBbUg7UUFDbkgsSUFBSSxDQUFDTSxLQUFLLEdBQUdqQixLQUFLTSxNQUFNO1FBQ3hCLHVDQUF1QztRQUN2QyxJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUksT0FBTztRQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQ1YsTUFBTSxDQUFDSTtRQUNsQmhCLGdEQUFLQSxDQUFDZ0I7SUFDVjtJQUNBSixPQUFPVyxHQUFHLEVBQUU7UUFDUnpCLGtEQUFPQSxDQUFDLElBQUk7UUFDWixJQUFJLENBQUNZLEtBQUssQ0FBQ0UsTUFBTSxDQUFDVztRQUNsQixPQUFPLElBQUk7SUFDZjtJQUNBQyxXQUFXQyxHQUFHLEVBQUU7UUFDWjNCLGtEQUFPQSxDQUFDLElBQUk7UUFDWkQsaURBQU1BLENBQUM0QixLQUFLLElBQUksQ0FBQ1YsU0FBUztRQUMxQixJQUFJLENBQUNSLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNHLEtBQUssQ0FBQ2MsVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNILEtBQUssQ0FBQ1YsTUFBTSxDQUFDYTtRQUNsQixJQUFJLENBQUNILEtBQUssQ0FBQ0UsVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNDLE9BQU87SUFDaEI7SUFDQU4sU0FBUztRQUNMLE1BQU1LLE1BQU0sSUFBSVIsV0FBVyxJQUFJLENBQUNLLEtBQUssQ0FBQ1AsU0FBUztRQUMvQyxJQUFJLENBQUNTLFVBQVUsQ0FBQ0M7UUFDaEIsT0FBT0E7SUFDWDtJQUNBRSxXQUFXQyxFQUFFLEVBQUU7UUFDWCxtR0FBbUc7UUFDbkdBLE1BQU9BLENBQUFBLEtBQUtDLE9BQU9sQixNQUFNLENBQUNrQixPQUFPQyxjQUFjLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBQztRQUN6RCxNQUFNLEVBQUVSLEtBQUssRUFBRVosS0FBSyxFQUFFSCxRQUFRLEVBQUVDLFNBQVMsRUFBRU0sUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBRyxJQUFJO1FBQ3ZFYSxLQUFLQTtRQUNMQSxHQUFHckIsUUFBUSxHQUFHQTtRQUNkcUIsR0FBR3BCLFNBQVMsR0FBR0E7UUFDZm9CLEdBQUdkLFFBQVEsR0FBR0E7UUFDZGMsR0FBR2IsU0FBUyxHQUFHQTtRQUNmYSxHQUFHTixLQUFLLEdBQUdBLE1BQU1LLFVBQVUsQ0FBQ0MsR0FBR04sS0FBSztRQUNwQ00sR0FBR2xCLEtBQUssR0FBR0EsTUFBTWlCLFVBQVUsQ0FBQ0MsR0FBR2xCLEtBQUs7UUFDcEMsT0FBT2tCO0lBQ1g7SUFDQUcsUUFBUTtRQUNKLE9BQU8sSUFBSSxDQUFDSixVQUFVO0lBQzFCO0lBQ0FELFVBQVU7UUFDTixJQUFJLENBQUNsQixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDYyxLQUFLLENBQUNJLE9BQU87UUFDbEIsSUFBSSxDQUFDaEIsS0FBSyxDQUFDZ0IsT0FBTztJQUN0QjtBQUNKO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTU0sT0FBTyxDQUFDM0IsTUFBTUksS0FBS3dCLFVBQVksSUFBSTlCLEtBQUtFLE1BQU1JLEtBQUtHLE1BQU0sQ0FBQ3FCLFNBQVNiLE1BQU0sR0FBRztBQUN6RlksS0FBS3JCLE1BQU0sR0FBRyxDQUFDTixNQUFNSSxNQUFRLElBQUlOLEtBQUtFLE1BQU1JLE1BQzVDLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/MGNjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBhYnl0ZXMsIGFleGlzdHMsIGFoYXNoLCBjbGVhbiwgSGFzaCwgdG9CeXRlcyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhaGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBjbGVhbihwYWQpO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhYnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG4gKiBpbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuICogY29uc3QgbWFjMSA9IGhtYWMoc2hhMjU2LCAna2V5JywgJ21lc3NhZ2UnKTtcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbImFieXRlcyIsImFleGlzdHMiLCJhaGFzaCIsImNsZWFuIiwiSGFzaCIsInRvQnl0ZXMiLCJITUFDIiwiY29uc3RydWN0b3IiLCJoYXNoIiwiX2tleSIsImZpbmlzaGVkIiwiZGVzdHJveWVkIiwia2V5IiwiaUhhc2giLCJjcmVhdGUiLCJ1cGRhdGUiLCJFcnJvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkIiwiVWludDhBcnJheSIsInNldCIsImxlbmd0aCIsImRpZ2VzdCIsImkiLCJvSGFzaCIsImJ1ZiIsImRpZ2VzdEludG8iLCJvdXQiLCJkZXN0cm95IiwiX2Nsb25lSW50byIsInRvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJjbG9uZSIsImhtYWMiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/sha2.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha2.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   SHA384: () => (/* binding */ SHA384),\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   SHA512_224: () => (/* binding */ SHA512_224),\n/* harmony export */   SHA512_256: () => (/* binding */ SHA512_256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */ \n\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */ // prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 32){\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\nclass SHA224 extends SHA256 {\n    constructor(){\n        super(28);\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (()=>_u64_js__WEBPACK_IMPORTED_MODULE_2__.split([\n        \"0x428a2f98d728ae22\",\n        \"0x7137449123ef65cd\",\n        \"0xb5c0fbcfec4d3b2f\",\n        \"0xe9b5dba58189dbbc\",\n        \"0x3956c25bf348b538\",\n        \"0x59f111f1b605d019\",\n        \"0x923f82a4af194f9b\",\n        \"0xab1c5ed5da6d8118\",\n        \"0xd807aa98a3030242\",\n        \"0x12835b0145706fbe\",\n        \"0x243185be4ee4b28c\",\n        \"0x550c7dc3d5ffb4e2\",\n        \"0x72be5d74f27b896f\",\n        \"0x80deb1fe3b1696b1\",\n        \"0x9bdc06a725c71235\",\n        \"0xc19bf174cf692694\",\n        \"0xe49b69c19ef14ad2\",\n        \"0xefbe4786384f25e3\",\n        \"0x0fc19dc68b8cd5b5\",\n        \"0x240ca1cc77ac9c65\",\n        \"0x2de92c6f592b0275\",\n        \"0x4a7484aa6ea6e483\",\n        \"0x5cb0a9dcbd41fbd4\",\n        \"0x76f988da831153b5\",\n        \"0x983e5152ee66dfab\",\n        \"0xa831c66d2db43210\",\n        \"0xb00327c898fb213f\",\n        \"0xbf597fc7beef0ee4\",\n        \"0xc6e00bf33da88fc2\",\n        \"0xd5a79147930aa725\",\n        \"0x06ca6351e003826f\",\n        \"0x142929670a0e6e70\",\n        \"0x27b70a8546d22ffc\",\n        \"0x2e1b21385c26c926\",\n        \"0x4d2c6dfc5ac42aed\",\n        \"0x53380d139d95b3df\",\n        \"0x650a73548baf63de\",\n        \"0x766a0abb3c77b2a8\",\n        \"0x81c2c92e47edaee6\",\n        \"0x92722c851482353b\",\n        \"0xa2bfe8a14cf10364\",\n        \"0xa81a664bbc423001\",\n        \"0xc24b8b70d0f89791\",\n        \"0xc76c51a30654be30\",\n        \"0xd192e819d6ef5218\",\n        \"0xd69906245565a910\",\n        \"0xf40e35855771202a\",\n        \"0x106aa07032bbd1b8\",\n        \"0x19a4c116b8d2d0c8\",\n        \"0x1e376c085141ab53\",\n        \"0x2748774cdf8eeb99\",\n        \"0x34b0bcb5e19b48a8\",\n        \"0x391c0cb3c5c95a63\",\n        \"0x4ed8aa4ae3418acb\",\n        \"0x5b9cca4f7763e373\",\n        \"0x682e6ff3d6b2b8a3\",\n        \"0x748f82ee5defb2fc\",\n        \"0x78a5636f43172f60\",\n        \"0x84c87814a1f0ab72\",\n        \"0x8cc702081a6439ec\",\n        \"0x90befffa23631e28\",\n        \"0xa4506cebde82bde9\",\n        \"0xbef9a3f7b2c67915\",\n        \"0xc67178f2e372532b\",\n        \"0xca273eceea26619c\",\n        \"0xd186b8c721c0c207\",\n        \"0xeada7dd6cde0eb1e\",\n        \"0xf57d4f7fee6ed178\",\n        \"0x06f067aa72176fba\",\n        \"0x0a637dc5a2c898a6\",\n        \"0x113f9804bef90dae\",\n        \"0x1b710b35131c471b\",\n        \"0x28db77f523047d84\",\n        \"0x32caab7b40c72493\",\n        \"0x3c9ebe0a15c9bebc\",\n        \"0x431d67c49c100d4c\",\n        \"0x4cc5d4becb3e42b6\",\n        \"0x597f299cfc657e2a\",\n        \"0x5fcb6fab3ad6faec\",\n        \"0x6c44198c4a475817\"\n    ].map((n)=>BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (()=>K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (()=>K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 64){\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [\n            Ah,\n            Al,\n            Bh,\n            Bl,\n            Ch,\n            Cl,\n            Dh,\n            Dl,\n            Eh,\n            El,\n            Fh,\n            Fl,\n            Gh,\n            Gl,\n            Hh,\n            Hl\n        ];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4){\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32(offset += 4);\n        }\n        for(let i = 16; i < 80; i++){\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for(let i = 0; i < 80; i++){\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = Eh & Fh ^ ~Eh & Gh;\n            const CHIl = El & Fl ^ ~El & Gl;\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 39);\n            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor(){\n        super(48);\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8,\n    0x19544da2,\n    0x73e19966,\n    0x89dcd4d6,\n    0x1dfab7ae,\n    0x32ff9c82,\n    0x679dd514,\n    0x582f9fcf,\n    0x0f6d2b69,\n    0x7bd44da8,\n    0x77e36f73,\n    0x04c48942,\n    0x3f9d85a8,\n    0x6a1d36c8,\n    0x1112e6ad,\n    0x91d692a1\n]);\n/** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194,\n    0xfc2bf72c,\n    0x9f555fa3,\n    0xc84c64c2,\n    0x2393b86b,\n    0x6f53b151,\n    0x96387719,\n    0x5940eabd,\n    0x96283ee2,\n    0xa88effe3,\n    0xbe5e1e25,\n    0x53863992,\n    0x2b0199fc,\n    0x2c85b8aa,\n    0x0eb72ddc,\n    0x81c52ca2\n]);\nclass SHA512_224 extends SHA512 {\n    constructor(){\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor(){\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */ const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA256());\n/** SHA2-224 hash function from RFC 4634 */ const sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA224());\n/** SHA2-512 hash function from RFC 4634. */ const sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA512());\n/** SHA2-384 hash function from RFC 4634. */ const sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */ const sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */ const sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA512_224()); //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDdUY7QUFDdkQ7QUFDc0I7QUFDdkQ7OztDQUdDLEdBQ0Qsa0JBQWtCO0FBQ2xCLE1BQU1XLFdBQVcsYUFBYSxHQUFHQyxZQUFZQyxJQUFJLENBQUM7SUFDOUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsNkRBQTZELEdBQzdELE1BQU1DLFdBQVcsYUFBYSxHQUFHLElBQUlGLFlBQVk7QUFDMUMsTUFBTUcsZUFBZWQsMENBQU1BO0lBQzlCZSxZQUFZQyxZQUFZLEVBQUUsQ0FBRTtRQUN4QixLQUFLLENBQUMsSUFBSUEsV0FBVyxHQUFHO1FBQ3hCLG1FQUFtRTtRQUNuRSx1REFBdUQ7UUFDdkQsSUFBSSxDQUFDQyxDQUFDLEdBQUdkLDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hCLElBQUksQ0FBQ2UsQ0FBQyxHQUFHZiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNnQixDQUFDLEdBQUdoQiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNpQixDQUFDLEdBQUdqQiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4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QUFHO1FBQ3ZCLElBQUksQ0FBQzdDLEVBQUUsR0FBRzZDLE9BQU8sQ0FBQyxHQUFHLEdBQUc7UUFDeEIsSUFBSSxDQUFDNUMsRUFBRSxHQUFHNEMsT0FBTyxDQUFDLEdBQUcsR0FBRztRQUN4QixJQUFJLENBQUMzQyxFQUFFLEdBQUcyQyxPQUFPLENBQUMsR0FBRyxHQUFHO1FBQ3hCLElBQUksQ0FBQzFDLEVBQUUsR0FBRzBDLE9BQU8sQ0FBQyxHQUFHLEdBQUc7UUFDeEIsSUFBSSxDQUFDekMsRUFBRSxHQUFHeUMsT0FBTyxDQUFDLEdBQUcsR0FBRztRQUN4QixJQUFJLENBQUN4QyxFQUFFLEdBQUd3QyxPQUFPLENBQUMsR0FBRyxHQUFHO0lBQzVCO0FBQ0o7QUFDQTs7Ozs7O0NBTUMsR0FDTSxNQUFNRyxTQUFTLGFBQWEsR0FBR3hHLHVEQUFZQSxDQUFDLElBQU0sSUFBSU0sVUFBVTtBQUN2RSx5Q0FBeUMsR0FDbEMsTUFBTW1HLFNBQVMsYUFBYSxHQUFHekcsdURBQVlBLENBQUMsSUFBTSxJQUFJbUMsVUFBVTtBQUN2RSwwQ0FBMEMsR0FDbkMsTUFBTXVFLFNBQVMsYUFBYSxHQUFHMUcsdURBQVlBLENBQUMsSUFBTSxJQUFJNkMsVUFBVTtBQUN2RSwwQ0FBMEMsR0FDbkMsTUFBTThELFNBQVMsYUFBYSxHQUFHM0csdURBQVlBLENBQUMsSUFBTSxJQUFJbUcsVUFBVTtBQUN2RTs7O0NBR0MsR0FDTSxNQUFNUyxhQUFhLGFBQWEsR0FBRzVHLHVEQUFZQSxDQUFDLElBQU0sSUFBSXVHLGNBQWM7QUFDL0U7OztDQUdDLEdBQ00sTUFBTU0sYUFBYSxhQUFhLEdBQUc3Ryx1REFBWUEsQ0FBQyxJQUFNLElBQUlzRyxjQUFjLENBQy9FLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldHBsYWNlLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTIuanM/N2M2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNIQTIgaGFzaCBmdW5jdGlvbi4gQS5rLmEuIHNoYTI1Niwgc2hhMzg0LCBzaGE1MTIsIHNoYTUxMl8yMjQsIHNoYTUxMl8yNTYuXG4gKiBTSEEyNTYgaXMgdGhlIGZhc3Rlc3QgaGFzaCBpbXBsZW1lbnRhYmxlIGluIEpTLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqIENoZWNrIG91dCBbUkZDIDQ2MzRdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDYzNCkgYW5kXG4gKiBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IENoaSwgSGFzaE1ELCBNYWosIFNIQTIyNF9JViwgU0hBMjU2X0lWLCBTSEEzODRfSVYsIFNIQTUxMl9JViB9IGZyb20gXCIuL19tZC5qc1wiO1xuaW1wb3J0ICogYXMgdTY0IGZyb20gXCIuL191NjQuanNcIjtcbmltcG9ydCB7IGNsZWFuLCBjcmVhdGVIYXNoZXIsIHJvdHIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqXG4gKiBSb3VuZCBjb25zdGFudHM6XG4gKiBGaXJzdCAzMiBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8qKiBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyLiBcIldcIiBjb21lcyBzdHJhaWdodCBmcm9tIHNwZWMuICovXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuZXhwb3J0IGNsYXNzIFNIQTI1NiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuID0gMzIpIHtcbiAgICAgICAgc3VwZXIoNjQsIG91dHB1dExlbiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihTSEEyNTZfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICAgICAgdGhpcy5BID0gU0hBMjI0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjI0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjI0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjI0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjI0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjI0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjI0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjI0X0lWWzddIHwgMDtcbiAgICB9XG59XG4vLyBTSEEyLTUxMiBpcyBzbG93ZXIgdGhhbiBzaGEyNTYgaW4ganMgYmVjYXVzZSB1NjQgb3BlcmF0aW9ucyBhcmUgc2xvdy5cbi8vIFJvdW5kIGNvbnRhbnRzXG4vLyBGaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEs1MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG5jb25zdCBTSEE1MTJfS2ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMF0pKCk7XG5jb25zdCBTSEE1MTJfS2wgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMV0pKCk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuID0gNjQpIHtcbiAgICAgICAgc3VwZXIoMTI4LCBvdXRwdXRMZW4sIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gU0hBNTEyX0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFNIQTUxMl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBTSEE1MTJfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gU0hBNTEyX0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFNIQTUxMl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBTSEE1MTJfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gU0hBNTEyX0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFNIQTUxMl9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBTSEE1MTJfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gU0hBNTEyX0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFNIQTUxMl9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gU0hBNTEyX0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBTSEE1MTJfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFNIQTUxMl9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gU0hBNTEyX0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBTSEE1MTJfSVZbMTVdIHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIGNsZWFuKFNIQTUxMl9XX0gsIFNIQTUxMl9XX0wpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig0OCk7XG4gICAgICAgIHRoaXMuQWggPSBTSEEzODRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gU0hBMzg0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFNIQTM4NF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBTSEEzODRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gU0hBMzg0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFNIQTM4NF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBTSEEzODRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gU0hBMzg0X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFNIQTM4NF9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBTSEEzODRfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gU0hBMzg0X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBTSEEzODRfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IFNIQTM4NF9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gU0hBMzg0X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBTSEEzODRfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IFNIQTM4NF9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbi8qKlxuICogVHJ1bmNhdGVkIFNIQTUxMi8yNTYgYW5kIFNIQTUxMi8yMjQuXG4gKiBTSEE1MTJfSVYgaXMgWE9SZWQgd2l0aCAweGE1YTVhNWE1YTVhNWE1YTUsIHRoZW4gdXNlZCBhcyBcImludGVybWVkaWFyeVwiIElWIG9mIFNIQTUxMi90LlxuICogVGhlbiB0IGhhc2hlcyBzdHJpbmcgdG8gcHJvZHVjZSByZXN1bHQgSVYuXG4gKiBTZWUgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AuXG4gKi9cbi8qKiBTSEE1MTIvMjI0IElWICovXG5jb25zdCBUMjI0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4OGMzZDM3YzgsIDB4MTk1NDRkYTIsIDB4NzNlMTk5NjYsIDB4ODlkY2Q0ZDYsIDB4MWRmYWI3YWUsIDB4MzJmZjljODIsIDB4Njc5ZGQ1MTQsIDB4NTgyZjlmY2YsXG4gICAgMHgwZjZkMmI2OSwgMHg3YmQ0NGRhOCwgMHg3N2UzNmY3MywgMHgwNGM0ODk0MiwgMHgzZjlkODVhOCwgMHg2YTFkMzZjOCwgMHgxMTEyZTZhZCwgMHg5MWQ2OTJhMSxcbl0pO1xuLyoqIFNIQTUxMi8yNTYgSVYgKi9cbmNvbnN0IFQyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHgyMjMxMjE5NCwgMHhmYzJiZjcyYywgMHg5ZjU1NWZhMywgMHhjODRjNjRjMiwgMHgyMzkzYjg2YiwgMHg2ZjUzYjE1MSwgMHg5NjM4NzcxOSwgMHg1OTQwZWFiZCxcbiAgICAweDk2MjgzZWUyLCAweGE4OGVmZmUzLCAweGJlNWUxZTI1LCAweDUzODYzOTkyLCAweDJiMDE5OWZjLCAweDJjODViOGFhLCAweDBlYjcyZGRjLCAweDgxYzUyY2EyLFxuXSk7XG5leHBvcnQgY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICAgICAgdGhpcy5BaCA9IFQyMjRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gVDIyNF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBUMjI0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFQyMjRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gVDIyNF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBUMjI0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFQyMjRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gVDIyNF9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBUMjI0X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFQyMjRfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gVDIyNF9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gVDIyNF9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gVDIyNF9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gVDIyNF9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gVDIyNF9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gVDIyNF9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMzIpO1xuICAgICAgICB0aGlzLkFoID0gVDI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBUMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFQyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gVDI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBUMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFQyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gVDI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBUMjU2X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFQyNTZfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gVDI1Nl9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBUMjU2X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBUMjU2X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBUMjU2X0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBUMjU2X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBUMjU2X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBUMjU2X0lWWzE1XSB8IDA7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuXG4gKlxuICogSXQgaXMgdGhlIGZhc3Rlc3QgSlMgaGFzaCwgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKiBUbyBicmVhayBzaGEyNTYgdXNpbmcgYmlydGhkYXkgYXR0YWNrLCBhdHRhY2tlcnMgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzLlxuICogQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTI1NigpKTtcbi8qKiBTSEEyLTIyNCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQgKi9cbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vKiogU0hBMi01MTIgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTUxMigpKTtcbi8qKiBTSEEyLTM4NCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLyoqXG4gKiBTSEEyLTUxMi8yNTYgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuLyoqXG4gKiBTSEEyLTUxMi8yMjQgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yMjQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiXSwibmFtZXMiOlsiQ2hpIiwiSGFzaE1EIiwiTWFqIiwiU0hBMjI0X0lWIiwiU0hBMjU2X0lWIiwiU0hBMzg0X0lWIiwiU0hBNTEyX0lWIiwidTY0IiwiY2xlYW4iLCJjcmVhdGVIYXNoZXIiLCJyb3RyIiwiU0hBMjU2X0siLCJVaW50MzJBcnJheSIsImZyb20iLCJTSEEyNTZfVyIsIlNIQTI1NiIsImNvbnN0cnVjdG9yIiwib3V0cHV0TGVuIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJnZXQiLCJzZXQiLCJwcm9jZXNzIiwidmlldyIsIm9mZnNldCIsImkiLCJnZXRVaW50MzIiLCJXMTUiLCJXMiIsInMwIiwiczEiLCJzaWdtYTEiLCJUMSIsInNpZ21hMCIsIlQyIiwicm91bmRDbGVhbiIsImRlc3Ryb3kiLCJidWZmZXIiLCJTSEEyMjQiLCJLNTEyIiwic3BsaXQiLCJtYXAiLCJuIiwiQmlnSW50IiwiU0hBNTEyX0toIiwiU0hBNTEyX0tsIiwiU0hBNTEyX1dfSCIsIlNIQTUxMl9XX0wiLCJTSEE1MTIiLCJBaCIsIkFsIiwiQmgiLCJCbCIsIkNoIiwiQ2wiLCJEaCIsIkRsIiwiRWgiLCJFbCIsIkZoIiwiRmwiLCJHaCIsIkdsIiwiSGgiLCJIbCIsIlcxNWgiLCJXMTVsIiwiczBoIiwicm90clNIIiwic2hyU0giLCJzMGwiLCJyb3RyU0wiLCJzaHJTTCIsIlcyaCIsIlcybCIsInMxaCIsInJvdHJCSCIsInMxbCIsInJvdHJCTCIsIlNVTWwiLCJhZGQ0TCIsIlNVTWgiLCJhZGQ0SCIsInNpZ21hMWgiLCJzaWdtYTFsIiwiQ0hJaCIsIkNISWwiLCJUMWxsIiwiYWRkNUwiLCJUMWgiLCJhZGQ1SCIsIlQxbCIsInNpZ21hMGgiLCJzaWdtYTBsIiwiTUFKaCIsIk1BSmwiLCJoIiwibCIsImFkZCIsIkFsbCIsImFkZDNMIiwiYWRkM0giLCJTSEEzODQiLCJUMjI0X0lWIiwiVDI1Nl9JViIsIlNIQTUxMl8yMjQiLCJTSEE1MTJfMjU2Iiwic2hhMjU2Iiwic2hhMjI0Iiwic2hhNTEyIiwic2hhMzg0Iiwic2hhNTEyXzI1NiIsInNoYTUxMl8yMjQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sha2.js */ \"(ssr)/./node_modules/@noble/hashes/esm/sha2.js\");\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */ \n/** @deprecated Use import from `noble/hashes/sha2` module */ const SHA256 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */ const sha256 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */ const SHA224 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */ const sha224 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.sha224; //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQ3VHO0FBQ3hHLDJEQUEyRCxHQUNwRCxNQUFNSSxTQUFTQyw0Q0FBT0EsQ0FBQztBQUM5QiwyREFBMkQsR0FDcEQsTUFBTUMsU0FBU0MsNENBQU9BLENBQUM7QUFDOUIsMkRBQTJELEdBQ3BELE1BQU1QLFNBQVNDLDRDQUFPQSxDQUFDO0FBQzlCLDJEQUEyRCxHQUNwRCxNQUFNQyxTQUFTQyw0Q0FBT0EsQ0FBQyxDQUM5QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanM/NmYxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNIQTItMjU2IGEuay5hLiBzaGEyNTYuIEluIEpTLCBpdCBpcyB0aGUgZmFzdGVzdCBoYXNoLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqXG4gKiBUbyBicmVhayBzaGEyNTYgdXNpbmcgYmlydGhkYXkgYXR0YWNrLCBhdHRhY2tlcnMgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzLlxuICogQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqXG4gKiBDaGVjayBvdXQgW0ZJUFMgMTgwLTRdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYpLlxuICogQG1vZHVsZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuaW1wb3J0IHsgU0hBMjI0IGFzIFNIQTIyNG4sIHNoYTIyNCBhcyBzaGEyMjRuLCBTSEEyNTYgYXMgU0hBMjU2biwgc2hhMjU2IGFzIHNoYTI1Nm4sIH0gZnJvbSBcIi4vc2hhMi5qc1wiO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IFNIQTI1NiA9IFNIQTI1Nm47XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gc2hhMjU2bjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydCBjb25zdCBTSEEyMjQgPSBTSEEyMjRuO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IHNoYTIyNG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbIlNIQTIyNCIsIlNIQTIyNG4iLCJzaGEyMjQiLCJzaGEyMjRuIiwiU0hBMjU2IiwiU0hBMjU2biIsInNoYTI1NiIsInNoYTI1Nm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/sha3.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha3.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */ \n// prettier-ignore\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s);\n/** `keccakf1600` internal function, additionally allows to adjust round count. */ function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta θ\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(B);\n}\n/** Keccak sponge function. */ class Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200)) throw new Error(\"only keccak-f1600 function is supported\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(this.state32);\n        keccakP(this.state32, this.rounds);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this, false);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aoutput)(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */ const sha3_224 = /* @__PURE__ */ (()=>gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */ const sha3_256 = /* @__PURE__ */ (()=>gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */ const sha3_384 = /* @__PURE__ */ (()=>gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */ const sha3_512 = /* @__PURE__ */ (()=>gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */ const keccak_224 = /* @__PURE__ */ (()=>gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */ const keccak_256 = /* @__PURE__ */ (()=>gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */ const keccak_384 = /* @__PURE__ */ (()=>gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */ const keccak_512 = /* @__PURE__ */ (()=>gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createXOFer)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */ const shake128 = /* @__PURE__ */ (()=>genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */ const shake256 = /* @__PURE__ */ (()=>genShake(0x1f, 136, 256 / 8))(); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7O0NBVUMsR0FDaUU7QUFDbEUsa0JBQWtCO0FBQytHO0FBQ2pJLDBDQUEwQztBQUMxQyw4Q0FBOEM7QUFDOUMsMkNBQTJDO0FBQzNDLE1BQU1nQixNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNSCxPQUFPO0FBQ25CLE1BQU1JLFFBQVFKLE9BQU87QUFDckIsTUFBTUssU0FBU0wsT0FBTztBQUN0QixNQUFNTSxVQUFVLEVBQUU7QUFDbEIsTUFBTUMsWUFBWSxFQUFFO0FBQ3BCLE1BQU1DLGFBQWEsRUFBRTtBQUNyQixJQUFLLElBQUlDLFFBQVEsR0FBR0MsSUFBSVQsS0FBS1UsSUFBSSxHQUFHQyxJQUFJLEdBQUdILFFBQVEsSUFBSUEsUUFBUztJQUM1RCxLQUFLO0lBQ0wsQ0FBQ0UsR0FBR0MsRUFBRSxHQUFHO1FBQUNBO1FBQUksS0FBSUQsSUFBSSxJQUFJQyxDQUFBQSxJQUFLO0tBQUU7SUFDakNOLFFBQVFPLElBQUksQ0FBQyxJQUFLLEtBQUlELElBQUlELENBQUFBO0lBQzFCLGFBQWE7SUFDYkosVUFBVU0sSUFBSSxDQUFDLENBQUdKLFFBQVEsS0FBTUEsQ0FBQUEsUUFBUSxLQUFNLElBQUs7SUFDbkQsT0FBTztJQUNQLElBQUlLLElBQUlmO0lBQ1IsSUFBSyxJQUFJZ0IsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7UUFDeEJMLElBQUksQ0FBQyxLQUFNVCxNQUFRLENBQUNTLEtBQUtQLEdBQUUsSUFBS0UsTUFBTSxJQUFLRDtRQUMzQyxJQUFJTSxJQUFJUixLQUNKWSxLQUFLYixPQUFRLENBQUNBLE9BQU8sYUFBYSxHQUFHRCxPQUFPZSxFQUFDLElBQUtkO0lBQzFEO0lBQ0FPLFdBQVdLLElBQUksQ0FBQ0M7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RixJQUFJLE1BQU0sS0FBSyxNQUFNLEVBQUMsSUFBSztBQUMxRSw0QkFBNEIsR0FDckIsTUFBTUcsV0FBMkIsYUFBSCxHQUFJLEtBQU1ILElBQUksTUFBTSxLQUFLLE1BQU0sRUFBQyxJQUFLO0FBQzFFLDRCQUE0QixHQUNyQixNQUFNSSxXQUEyQixhQUFILEdBQUksS0FBTUosSUFBSSxNQUFNLElBQUksTUFBTSxFQUFDLElBQUs7QUFDekUsOEJBQThCLEdBQ3ZCLE1BQU1LLGFBQTZCLGFBQUgsR0FBSSxLQUFNTCxJQUFJLE1BQU0sS0FBSyxNQUFNLEVBQUMsSUFBSztBQUM1RSx1REFBdUQsR0FDaEQsTUFBTU0sYUFBNkIsYUFBSCxHQUFJLEtBQU1OLElBQUksTUFBTSxLQUFLLE1BQU0sRUFBQyxJQUFLO0FBQzVFLDhCQUE4QixHQUN2QixNQUFNTyxhQUE2QixhQUFILEdBQUksS0FBTVAsSUFBSSxNQUFNLEtBQUssTUFBTSxFQUFDLElBQUs7QUFDNUUsOEJBQThCLEdBQ3ZCLE1BQU1RLGFBQTZCLGFBQUgsR0FBSSxLQUFNUixJQUFJLE1BQU0sSUFBSSxNQUFNLEVBQUMsSUFBSztBQUMzRSxNQUFNUyxXQUFXLENBQUM1QyxRQUFRRCxVQUFVRSxZQUFjaEQsc0RBQVdBLENBQUMsQ0FBQzRGLE9BQU8sQ0FBQyxDQUFDLEdBQUssSUFBSWhELE9BQU9FLFVBQVVDLFFBQVE2QyxLQUFLQyxLQUFLLEtBQUtDLFlBQVk5QyxZQUFZNEMsS0FBS0MsS0FBSyxFQUFFO0FBQzdKLHdDQUF3QyxHQUNqQyxNQUFNRSxXQUEyQixhQUFILEdBQUksS0FBTUosU0FBUyxNQUFNLEtBQUssTUFBTSxFQUFDLElBQUs7QUFDL0Usd0NBQXdDLEdBQ2pDLE1BQU1LLFdBQTJCLGFBQUgsR0FBSSxLQUFNTCxTQUFTLE1BQU0sS0FBSyxNQUFNLEVBQUMsSUFBSyxDQUMvRSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzP2I0MmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTSEEzIChrZWNjYWspIGhhc2ggZnVuY3Rpb24sIGJhc2VkIG9uIGEgbmV3IFwiU3BvbmdlIGZ1bmN0aW9uXCIgZGVzaWduLlxuICogRGlmZmVyZW50IGZyb20gb2xkZXIgaGFzaGVzLCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4gKlxuICogQ2hlY2sgb3V0IFtGSVBTLTIwMl0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjIwMi5wZGYpLFxuICogW1dlYnNpdGVdKGh0dHBzOi8va2VjY2FrLnRlYW0va2VjY2FrLmh0bWwpLFxuICogW3RoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIFNIQS0zIGFuZCBLZWNjYWtdKGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xNTcyNy93aGF0LWFyZS10aGUta2V5LWRpZmZlcmVuY2VzLWJldHdlZW4tdGhlLWRyYWZ0LXNoYS0zLXN0YW5kYXJkLWFuZC10aGUta2VjY2FrLXN1YikuXG4gKlxuICogQ2hlY2sgb3V0IGBzaGEzLWFkZG9uc2AgbW9kdWxlIGZvciBjU0hBS0UsIGsxMiwgYW5kIG90aGVycy5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCBzcGxpdCB9IGZyb20gXCIuL191NjQuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgYWJ5dGVzLCBhZXhpc3RzLCBhbnVtYmVyLCBhb3V0cHV0LCBjbGVhbiwgY3JlYXRlSGFzaGVyLCBjcmVhdGVYT0ZlciwgSGFzaCwgc3dhcDMySWZCRSwgdG9CeXRlcywgdTMyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIE5vIF9fUFVSRV9fIGFubm90YXRpb25zIGluIHNoYTMgaGVhZGVyOlxuLy8gRVZFUllUSElORyBpcyBpbiBmYWN0IHVzZWQgb24gZXZlcnkgZXhwb3J0LlxuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgXzduID0gQmlnSW50KDcpO1xuY29uc3QgXzI1Nm4gPSBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IEJpZ0ludCgweDcxKTtcbmNvbnN0IFNIQTNfUEkgPSBbXTtcbmNvbnN0IFNIQTNfUk9UTCA9IFtdO1xuY29uc3QgX1NIQTNfSU9UQSA9IFtdO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgLyogQF9fUFVSRV9fICovIEJpZ0ludChqKSkgLSBfMW4pO1xuICAgIH1cbiAgICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBJT1RBUyA9IHNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuY29uc3QgU0hBM19JT1RBX0ggPSBJT1RBU1swXTtcbmNvbnN0IFNIQTNfSU9UQV9MID0gSU9UQVNbMV07XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCTChoLCBsLCBzKSA6IHJvdGxTTChoLCBsLCBzKSk7XG4vKiogYGtlY2Nha2YxNjAwYCBpbnRlcm5hbCBmdW5jdGlvbiwgYWRkaXRpb25hbGx5IGFsbG93cyB0byBhZGp1c3Qgcm91bmQgY291bnQuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgY2xlYW4oQik7XG59XG4vKiogS2VjY2FrIHNwb25nZSBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjbGFzcyBLZWNjYWsgZXh0ZW5kcyBIYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgIGFudW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICAvLyAwIDwgYmxvY2tMZW4gPCAyMDBcbiAgICAgICAgaWYgKCEoMCA8IGJsb2NrTGVuICYmIGJsb2NrTGVuIDwgMjAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb25seSBrZWNjYWstZjE2MDAgZnVuY3Rpb24gaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSB1MzIodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgICAgc3dhcDMySWZCRSh0aGlzLnN0YXRlMzIpO1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICBzd2FwMzJJZkJFKHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgYWJ5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdGVbdGhpcy5wb3MrK10gXj0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIC8vIERvIHRoZSBwYWRkaW5nXG4gICAgICAgIHN0YXRlW3Bvc10gXj0gc3VmZml4O1xuICAgICAgICBpZiAoKHN1ZmZpeCAmIDB4ODApICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxuICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgc3RhdGVbYmxvY2tMZW4gLSAxXSBePSAweDgwO1xuICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgIH1cbiAgICB3cml0ZUludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBhYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIGFudW1iZXIoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW4odGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIHJvdW5kcywgZW5hYmxlWE9GIH0gPSB0aGlzO1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcbiAgICAgICAgdG8uc3RhdGUzMi5zZXQodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdG8ucG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xuICAgICAgICB0by5maW5pc2hlZCA9IHRoaXMuZmluaXNoZWQ7XG4gICAgICAgIHRvLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXG4gICAgICAgIHRvLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IHRoaXMuZGVzdHJveWVkO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XG4vKiogU0hBMy0yMjQgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCkpKCk7XG4vKiogU0hBMy0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20ga2VjY2FrLTI1Ni4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCkpKCk7XG4vKiogU0hBMy0zODQgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCkpKCk7XG4vKiogU0hBMy01MTIgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzUxMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KSkoKTtcbi8qKiBrZWNjYWstMjI0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCkpKCk7XG4vKioga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni4gKi9cbmV4cG9ydCBjb25zdCBrZWNjYWtfMjU2ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KSkoKTtcbi8qKiBrZWNjYWstMzg0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCkpKCk7XG4vKioga2VjY2FrLTUxMiBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha181MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDAxLCA3MiwgNTEyIC8gOCkpKCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IGNyZWF0ZVhPRmVyKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuLyoqIFNIQUtFMTI4IFhPRiB3aXRoIDEyOC1iaXQgc2VjdXJpdHkuICovXG5leHBvcnQgY29uc3Qgc2hha2UxMjggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCkpKCk7XG4vKiogU0hBS0UyNTYgWE9GIHdpdGggMjU2LWJpdCBzZWN1cml0eS4gKi9cbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIl0sIm5hbWVzIjpbInJvdGxCSCIsInJvdGxCTCIsInJvdGxTSCIsInJvdGxTTCIsInNwbGl0IiwiYWJ5dGVzIiwiYWV4aXN0cyIsImFudW1iZXIiLCJhb3V0cHV0IiwiY2xlYW4iLCJjcmVhdGVIYXNoZXIiLCJjcmVhdGVYT0ZlciIsIkhhc2giLCJzd2FwMzJJZkJFIiwidG9CeXRlcyIsInUzMiIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl83biIsIl8yNTZuIiwiXzB4NzFuIiwiU0hBM19QSSIsIlNIQTNfUk9UTCIsIl9TSEEzX0lPVEEiLCJyb3VuZCIsIlIiLCJ4IiwieSIsInB1c2giLCJ0IiwiaiIsIklPVEFTIiwiU0hBM19JT1RBX0giLCJTSEEzX0lPVEFfTCIsInJvdGxIIiwiaCIsImwiLCJzIiwicm90bEwiLCJrZWNjYWtQIiwicm91bmRzIiwiQiIsIlVpbnQzMkFycmF5IiwiaWR4MSIsImlkeDAiLCJCMCIsIkIxIiwiVGgiLCJUbCIsImN1ckgiLCJjdXJMIiwic2hpZnQiLCJQSSIsIktlY2NhayIsImNvbnN0cnVjdG9yIiwiYmxvY2tMZW4iLCJzdWZmaXgiLCJvdXRwdXRMZW4iLCJlbmFibGVYT0YiLCJwb3MiLCJwb3NPdXQiLCJmaW5pc2hlZCIsImRlc3Ryb3llZCIsIkVycm9yIiwic3RhdGUiLCJVaW50OEFycmF5Iiwic3RhdGUzMiIsImNsb25lIiwiX2Nsb25lSW50byIsImtlY2NhayIsInVwZGF0ZSIsImRhdGEiLCJsZW4iLCJsZW5ndGgiLCJ0YWtlIiwiTWF0aCIsIm1pbiIsImkiLCJmaW5pc2giLCJ3cml0ZUludG8iLCJvdXQiLCJidWZmZXJPdXQiLCJzZXQiLCJzdWJhcnJheSIsInhvZkludG8iLCJ4b2YiLCJieXRlcyIsImRpZ2VzdEludG8iLCJkZXN0cm95IiwiZGlnZXN0IiwidG8iLCJnZW4iLCJzaGEzXzIyNCIsInNoYTNfMjU2Iiwic2hhM18zODQiLCJzaGEzXzUxMiIsImtlY2Nha18yMjQiLCJrZWNjYWtfMjU2Iiwia2VjY2FrXzM4NCIsImtlY2Nha181MTIiLCJnZW5TaGFrZSIsIm9wdHMiLCJka0xlbiIsInVuZGVmaW5lZCIsInNoYWtlMTI4Iiwic2hha2UyNTYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   ahash: () => (/* binding */ ahash),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   clean: () => (/* binding */ clean),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   createOptHasher: () => (/* binding */ createOptHasher),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   createXOFer: () => (/* binding */ createXOFer),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   kdfInputToBytes: () => (/* binding */ kdfInputToBytes),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   swap32IfBE: () => (/* binding */ swap32IfBE),\n/* harmony export */   swap8IfBE: () => (/* binding */ swap8IfBE),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@noble/hashes/esm/cryptoNode.js\");\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\n/** Asserts something is positive integer. */ function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(\"positive integer expected, got \" + n);\n}\n/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\n}\n/** Asserts something is hash */ function ahash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.createHasher\");\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\n/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(\"digestInto() expects output buffer of length at least \" + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */ function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */ function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */ function clean(...arrays) {\n    for(let i = 0; i < arrays.length; i++){\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */ function rotr(word, shift) {\n    return word << 32 - shift | word >>> shift;\n}\n/** The rotate left (circular left shift) operation for uint32 */ function rotl(word, shift) {\n    return word << shift | word >>> 32 - shift >>> 0;\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */ const isLE = /* @__PURE__ */ (()=>new Uint8Array(new Uint32Array([\n        0x11223344\n    ]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */ function byteSwap(word) {\n    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\n}\n/** Conditionally byte swap if on a big-endian platform */ const swap8IfBE = isLE ? (n)=>n : (n)=>byteSwap(n);\n/** @deprecated */ const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */ function byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++){\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nconst swap32IfBE = isLE ? (u)=>u : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore\n    typeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\")();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin) return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */ const nextTick = async ()=>{};\n/** Returns control to thread each 'tick' ms to avoid blocking. */ async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"string expected\");\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */ function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */ function kdfInputToBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && ({}).toString.call(opts) !== \"[object Object]\") throw new Error(\"options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */ class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */ function createHasher(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nconst wrapConstructor = createHasher;\nconst wrapConstructorWithOpts = createOptHasher;\nconst wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */ function randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes === \"function\") {\n        return Uint8Array.from(_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUNELG9FQUFvRSxHQUNwRSxvRkFBb0Y7QUFDcEYsc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRSw4REFBOEQ7QUFDOUQsK0RBQStEO0FBQy9ELDJFQUEyRTtBQUM3QjtBQUM5QyxtRkFBbUYsR0FDNUUsU0FBU0MsUUFBUUMsQ0FBQztJQUNyQixPQUFPQSxhQUFhQyxjQUFlQyxZQUFZQyxNQUFNLENBQUNILE1BQU1BLEVBQUVJLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLO0FBQ3ZGO0FBQ0EsMkNBQTJDLEdBQ3BDLFNBQVNDLFFBQVFDLENBQUM7SUFDckIsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE1BQU1BLElBQUksR0FDaEMsTUFBTSxJQUFJRyxNQUFNLG9DQUFvQ0g7QUFDNUQ7QUFDQSxxQ0FBcUMsR0FDOUIsU0FBU0ksT0FBT0MsQ0FBQyxFQUFFLEdBQUdDLE9BQU87SUFDaEMsSUFBSSxDQUFDZCxRQUFRYSxJQUNULE1BQU0sSUFBSUYsTUFBTTtJQUNwQixJQUFJRyxRQUFRQyxNQUFNLEdBQUcsS0FBSyxDQUFDRCxRQUFRRSxRQUFRLENBQUNILEVBQUVFLE1BQU0sR0FDaEQsTUFBTSxJQUFJSixNQUFNLG1DQUFtQ0csVUFBVSxrQkFBa0JELEVBQUVFLE1BQU07QUFDL0Y7QUFDQSw4QkFBOEIsR0FDdkIsU0FBU0UsTUFBTUMsQ0FBQztJQUNuQixJQUFJLE9BQU9BLE1BQU0sY0FBYyxPQUFPQSxFQUFFQyxNQUFNLEtBQUssWUFDL0MsTUFBTSxJQUFJUixNQUFNO0lBQ3BCSixRQUFRVyxFQUFFRSxTQUFTO0lBQ25CYixRQUFRVyxFQUFFRyxRQUFRO0FBQ3RCO0FBQ0EsOERBQThELEdBQ3ZELFNBQVNDLFFBQVFDLFFBQVEsRUFBRUMsZ0JBQWdCLElBQUk7SUFD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ckksd0RBQU1BLElBQUksT0FBT0Esd0RBQU1BLENBQUNzSSxlQUFlLEtBQUssWUFBWTtRQUN4RCxPQUFPdEksd0RBQU1BLENBQUNzSSxlQUFlLENBQUMsSUFBSW5JLFdBQVdrSTtJQUNqRDtJQUNBLCtCQUErQjtJQUMvQixJQUFJckksd0RBQU1BLElBQUksT0FBT0Esd0RBQU1BLENBQUNvSSxXQUFXLEtBQUssWUFBWTtRQUNwRCxPQUFPakksV0FBV3VELElBQUksQ0FBQzFELHdEQUFNQSxDQUFDb0ksV0FBVyxDQUFDQztJQUM5QztJQUNBLE1BQU0sSUFBSXpILE1BQU07QUFDcEIsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcz9lZjdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0aWVzIGZvciBoZXgsIGJ5dGVzLCBDU1BSTkcuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbi8qKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuIEJlIGNhcmVmdWw6IG5vZGVqcyBCdWZmZXIgd2lsbCByZXR1cm4gdHJ1ZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgcG9zaXRpdmUgaW50ZWdlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIGdvdCAnICsgbik7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJyArIGxlbmd0aHMgKyAnLCBnb3QgbGVuZ3RoPScgKyBiLmxlbmd0aCk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgaGFzaCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFoYXNoKGgpIHtcbiAgICBpZiAodHlwZW9mIGggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGguY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMuY3JlYXRlSGFzaGVyJyk7XG4gICAgYW51bWJlcihoLm91dHB1dExlbik7XG4gICAgYW51bWJlcihoLmJsb2NrTGVuKTtcbn1cbi8qKiBBc3NlcnRzIGEgaGFzaCBpbnN0YW5jZSBoYXMgbm90IGJlZW4gZGVzdHJveWVkIC8gZmluaXNoZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG4vKiogQXNzZXJ0cyBvdXRwdXQgaXMgcHJvcGVybHktc2l6ZWQgYnl0ZSBhcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGFieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICcgKyBtaW4pO1xuICAgIH1cbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHU4LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHU4KGFycikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIENhc3QgdTggLyB1MTYgLyB1MzIgdG8gdTMyLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHUzMihhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xufVxuLyoqIFplcm9pemUgYSBieXRlIGFycmF5LiBXYXJuaW5nOiBKUyBwcm92aWRlcyBubyBndWFyYW50ZWVzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuKC4uLmFycmF5cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5c1tpXS5maWxsKDApO1xuICAgIH1cbn1cbi8qKiBDcmVhdGUgRGF0YVZpZXcgb2YgYW4gYXJyYXkgZm9yIGVhc3kgYnl0ZS1sZXZlbCBtYW5pcHVsYXRpb24uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmlldyhhcnIpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG4vKiogVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5leHBvcnQgZnVuY3Rpb24gcm90cih3b3JkLCBzaGlmdCkge1xuICAgIHJldHVybiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbn1cbi8qKiBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5leHBvcnQgZnVuY3Rpb24gcm90bCh3b3JkLCBzaGlmdCkge1xuICAgIHJldHVybiAod29yZCA8PCBzaGlmdCkgfCAoKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSkgPj4+IDApO1xufVxuLyoqIElzIGN1cnJlbnQgcGxhdGZvcm0gbGl0dGxlLWVuZGlhbj8gTW9zdCBhcmUuIEJpZy1FbmRpYW4gcGxhdGZvcm06IElCTSAqL1xuZXhwb3J0IGNvbnN0IGlzTEUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQpKCk7XG4vKiogVGhlIGJ5dGUgc3dhcCBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwKHdvcmQpIHtcbiAgICByZXR1cm4gKCgod29yZCA8PCAyNCkgJiAweGZmMDAwMDAwKSB8XG4gICAgICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgKCh3b3JkID4+PiAyNCkgJiAweGZmKSk7XG59XG4vKiogQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtICovXG5leHBvcnQgY29uc3Qgc3dhcDhJZkJFID0gaXNMRVxuICAgID8gKG4pID0+IG5cbiAgICA6IChuKSA9PiBieXRlU3dhcChuKTtcbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGNvbnN0IGJ5dGVTd2FwSWZCRSA9IHN3YXA4SWZCRTtcbi8qKiBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5ICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0IGNvbnN0IHN3YXAzMklmQkUgPSBpc0xFXG4gICAgPyAodSkgPT4gdVxuICAgIDogYnl0ZVN3YXAzMjtcbi8vIEJ1aWx0LWluIGhleCBjb252ZXJzaW9uIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfdWludDhhcnJheV9mcm9taGV4XG5jb25zdCBoYXNIZXhCdWlsdGluID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBcbi8vIEB0cy1pZ25vcmVcbnR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvSGV4ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBVaW50OEFycmF5LmZyb21IZXggPT09ICdmdW5jdGlvbicpKCk7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQ29udmVydCBieXRlIGFycmF5IHRvIGhleCBzdHJpbmcuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gYnl0ZXMudG9IZXgoKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaCkge1xuICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2ggLSBhc2NpaXMuXzA7IC8vICcyJyA9PiA1MC00OFxuICAgIGlmIChjaCA+PSBhc2NpaXMuQSAmJiBjaCA8PSBhc2NpaXMuRilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICAgIGlmIChjaCA+PSBhc2NpaXMuYSAmJiBjaCA8PSBhc2NpaXMuZilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5hIC0gMTApOyAvLyAnYicgPT4gOTgtKDk3LTEwKVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXkuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb21IZXgoaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBtdWx0aXBseSBmaXJzdCBvY3RldCwgZS5nLiAnYTMnID0+IDEwKjE2KzMgPT4gMTYwICsgMyA9PiAxNjNcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLyoqXG4gKiBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuICogQ2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4gKiBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8qKiBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgc3RyaW5nIHRvIGJ5dGVzIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIENvbnZlcnRzIGJ5dGVzIHRvIHN0cmluZyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgYnl0ZXNUb1V0ZjgoVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSkpIC8vICdhYmMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvVXRmOChieXRlcykge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBIZWxwZXIgZm9yIEtERnM6IGNvbnN1bWVzIHVpbnQ4YXJyYXkgb3Igc3RyaW5nLlxuICogV2hlbiBzdHJpbmcgaXMgcGFzc2VkLCBkb2VzIHV0ZjggZGVjb2RpbmcsIHVzaW5nIFRleHREZWNvZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24ga2RmSW5wdXRUb0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYge30udG9TdHJpbmcuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG4vKiogRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2UgKi9cbmV4cG9ydCBjbGFzcyBIYXNoIHtcbn1cbi8qKiBXcmFwcyBoYXNoIGZ1bmN0aW9uLCBjcmVhdGluZyBhbiBpbnRlcmZhY2Ugb24gdG9wIG9mIGl0ICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPcHRIYXNoZXIoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlWE9GZXIoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgY29uc3Qgd3JhcENvbnN0cnVjdG9yID0gY3JlYXRlSGFzaGVyO1xuZXhwb3J0IGNvbnN0IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gY3JlYXRlT3B0SGFzaGVyO1xuZXhwb3J0IGNvbnN0IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gY3JlYXRlWE9GZXI7XG4vKiogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIFBSTkcuIFVzZXMgaW50ZXJuYWwgT1MtbGV2ZWwgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIC8vIExlZ2FjeSBOb2RlLmpzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImNyeXB0byIsImlzQnl0ZXMiLCJhIiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYW51bWJlciIsIm4iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJhYnl0ZXMiLCJiIiwibGVuZ3RocyIsImxlbmd0aCIsImluY2x1ZGVzIiwiYWhhc2giLCJoIiwiY3JlYXRlIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJhZXhpc3RzIiwiaW5zdGFuY2UiLCJjaGVja0ZpbmlzaGVkIiwiZGVzdHJveWVkIiwiZmluaXNoZWQiLCJhb3V0cHV0Iiwib3V0IiwibWluIiwidTgiLCJhcnIiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsInUzMiIsIlVpbnQzMkFycmF5IiwiTWF0aCIsImZsb29yIiwiY2xlYW4iLCJhcnJheXMiLCJpIiwiZmlsbCIsImNyZWF0ZVZpZXciLCJEYXRhVmlldyIsInJvdHIiLCJ3b3JkIiwic2hpZnQiLCJyb3RsIiwiaXNMRSIsImJ5dGVTd2FwIiwic3dhcDhJZkJFIiwiYnl0ZVN3YXBJZkJFIiwiYnl0ZVN3YXAzMiIsInN3YXAzMklmQkUiLCJ1IiwiaGFzSGV4QnVpbHRpbiIsImZyb20iLCJ0b0hleCIsImZyb21IZXgiLCJoZXhlcyIsIkFycmF5IiwiXyIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJieXRlc1RvSGV4IiwiYnl0ZXMiLCJoZXgiLCJhc2NpaXMiLCJfMCIsIl85IiwiQSIsIkYiLCJmIiwiYXNjaWlUb0Jhc2UxNiIsImNoIiwiaGV4VG9CeXRlcyIsImhsIiwiYWwiLCJhcnJheSIsImFpIiwiaGkiLCJuMSIsImNoYXJDb2RlQXQiLCJuMiIsInVuZGVmaW5lZCIsImNoYXIiLCJuZXh0VGljayIsImFzeW5jTG9vcCIsIml0ZXJzIiwidGljayIsImNiIiwidHMiLCJEYXRlIiwibm93IiwiZGlmZiIsInV0ZjhUb0J5dGVzIiwic3RyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJieXRlc1RvVXRmOCIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwidG9CeXRlcyIsImRhdGEiLCJrZGZJbnB1dFRvQnl0ZXMiLCJjb25jYXRCeXRlcyIsInN1bSIsInJlcyIsInBhZCIsInNldCIsImNoZWNrT3B0cyIsImRlZmF1bHRzIiwib3B0cyIsImNhbGwiLCJtZXJnZWQiLCJPYmplY3QiLCJhc3NpZ24iLCJIYXNoIiwiY3JlYXRlSGFzaGVyIiwiaGFzaENvbnMiLCJoYXNoQyIsIm1zZyIsInVwZGF0ZSIsImRpZ2VzdCIsInRtcCIsImNyZWF0ZU9wdEhhc2hlciIsImNyZWF0ZVhPRmVyIiwid3JhcENvbnN0cnVjdG9yIiwid3JhcENvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyIsInJhbmRvbUJ5dGVzIiwiYnl0ZXNMZW5ndGgiLCJnZXRSYW5kb21WYWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/utils.js\n");

/***/ })

};
;