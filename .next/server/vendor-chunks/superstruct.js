"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/superstruct";
exports.ids = ["vendor-chunks/superstruct"];
exports.modules = {

/***/ "(ssr)/./node_modules/superstruct/dist/index.mjs":
/*!*************************************************!*\
  !*** ./node_modules/superstruct/dist/index.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   StructError: () => (/* binding */ StructError),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   defaulted: () => (/* binding */ defaulted),\n/* harmony export */   define: () => (/* binding */ define),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   enums: () => (/* binding */ enums),\n/* harmony export */   func: () => (/* binding */ func),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonempty: () => (/* binding */ nonempty),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   pattern: () => (/* binding */ pattern),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   refine: () => (/* binding */ refine),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   trimmed: () => (/* binding */ trimmed),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */ /**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */ class StructError extends TypeError {\n    constructor(failure, failures){\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join(\".\")} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null) this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = ()=>{\n            return cached ?? (cached = [\n                failure,\n                ...failures()\n            ]);\n        };\n    }\n}\n/**\n * Check if a value is an iterator.\n */ function isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === \"function\";\n}\n/**\n * Check if a value is a plain object.\n */ function isObject(x) {\n    return typeof x === \"object\" && x != null;\n}\n/**\n * Check if a value is a non-array object.\n */ function isNonArrayObject(x) {\n    return isObject(x) && !Array.isArray(x);\n}\n/**\n * Check if a value is a plain object.\n */ function isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */ function print(value) {\n    if (typeof value === \"symbol\") {\n        return value.toString();\n    }\n    return typeof value === \"string\" ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */ function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */ function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    } else if (result === false) {\n        result = {};\n    } else if (typeof result === \"string\") {\n        result = {\n            message: result\n        };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : \"\"}, but received: \\`${print(value)}\\`` } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */ function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [\n            result\n        ];\n    }\n    for (const r of result){\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */ function* run(value, struct, options = {}) {\n    const { path = [], branch = [\n        value\n    ], coerce = false, mask = false } = options;\n    const ctx = {\n        path,\n        branch,\n        mask\n    };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n    }\n    let status = \"valid\";\n    for (const failure of struct.validator(value, ctx)){\n        failure.explanation = options.message;\n        status = \"not_valid\";\n        yield [\n            failure,\n            undefined\n        ];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)){\n        const ts = run(v, s, {\n            path: k === undefined ? path : [\n                ...path,\n                k\n            ],\n            branch: k === undefined ? branch : [\n                ...branch,\n                v\n            ],\n            coerce,\n            mask,\n            message: options.message\n        });\n        for (const t of ts){\n            if (t[0]) {\n                status = t[0].refinement != null ? \"not_refined\" : \"not_valid\";\n                yield [\n                    t[0],\n                    undefined\n                ];\n            } else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                } else if (value instanceof Map) {\n                    value.set(k, v);\n                } else if (value instanceof Set) {\n                    value.add(v);\n                } else if (isObject(value)) {\n                    if (v !== undefined || k in value) value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== \"not_valid\") {\n        for (const failure of struct.refiner(value, ctx)){\n            failure.explanation = options.message;\n            status = \"not_refined\";\n            yield [\n                failure,\n                undefined\n            ];\n        }\n    }\n    if (status === \"valid\") {\n        yield [\n            undefined,\n            value\n        ];\n    }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */ class Struct {\n    constructor(props){\n        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {} } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context)=>{\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.validator = ()=>[];\n        }\n        if (refiner) {\n            this.refiner = (value, context)=>{\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.refiner = ()=>[];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */ assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */ create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */ is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema. Masking applies recursively to\n     * props of `object` structs only.\n     */ mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `coerce` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful. Also, `mask` will turn on\n     * masking of the unknown `object` props recursively if passed.\n     */ validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */ function assert(value, struct, message) {\n    const result = validate(value, struct, {\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */ function create(value, struct, message) {\n    const result = validate(value, struct, {\n        coerce: true,\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */ function mask(value, struct, message) {\n    const result = validate(value, struct, {\n        coerce: true,\n        mask: true,\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */ function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */ function validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function*() {\n            for (const t of tuples){\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [\n            error,\n            undefined\n        ];\n    } else {\n        const v = tuple[1];\n        return [\n            undefined,\n            v\n        ];\n    }\n}\nfunction assign(...Structs) {\n    const isType = Structs[0].type === \"type\";\n    const schemas = Structs.map((s)=>s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */ function define(name, validator) {\n    return new Struct({\n        type: name,\n        schema: null,\n        validator\n    });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */ function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),\n        validator (value, ctx) {\n            if (value === undefined) {\n                return true;\n            } else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        }\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */ function dynamic(fn) {\n    return new Struct({\n        type: \"dynamic\",\n        schema: null,\n        *entries (value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */ function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: \"lazy\",\n        schema: null,\n        *entries (value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */ function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = {\n        ...schema\n    };\n    for (const key of keys){\n        delete subschema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */ function partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? {\n        ...struct.schema\n    } : {\n        ...struct\n    };\n    for(const key in schema){\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === \"type\") {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */ function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys){\n        subschema[key] = schema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */ function struct(name, validator) {\n    console.warn(\"superstruct@0.11 - The `struct` helper has been renamed to `define`.\");\n    return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */ function any() {\n    return define(\"any\", ()=>true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: \"array\",\n        schema: Element,\n        *entries (value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()){\n                    yield [\n                        i,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator (value) {\n            return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */ function bigint() {\n    return define(\"bigint\", (value)=>{\n        return typeof value === \"bigint\";\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */ function boolean() {\n    return define(\"boolean\", (value)=>{\n        return typeof value === \"boolean\";\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */ function date() {\n    return define(\"date\", (value)=>{\n        return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \\`Date\\` object, but received: ${print(value)}`;\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v)=>print(v)).join();\n    for (const key of values){\n        schema[key] = key;\n    }\n    return new Struct({\n        type: \"enums\",\n        schema,\n        validator (value) {\n            return values.includes(value) || `Expected one of \\`${description}\\`, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a function.\n */ function func() {\n    return define(\"func\", (value)=>{\n        return typeof value === \"function\" || `Expected a function, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */ function instance(Class) {\n    return define(\"instance\", (value)=>{\n        return value instanceof Class || `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is an integer.\n */ function integer() {\n    return define(\"integer\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */ function intersection(Structs) {\n    return new Struct({\n        type: \"intersection\",\n        schema: null,\n        *entries (value, ctx) {\n            for (const S of Structs){\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator (value, ctx) {\n            for (const S of Structs){\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner (value, ctx) {\n            for (const S of Structs){\n                yield* S.refiner(value, ctx);\n            }\n        }\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: \"literal\",\n        schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? constant : null,\n        validator (value) {\n            return value === constant || `Expected the literal \\`${description}\\`, but received: ${print(value)}`;\n        }\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: \"map\",\n        schema: null,\n        *entries (value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()){\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator (value) {\n            return value instanceof Map || `Expected a \\`Map\\` object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */ function never() {\n    return define(\"never\", ()=>false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */ function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === null || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is a number.\n */ function number() {\n    return define(\"number\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: \"object\",\n        schema: schema ? schema : null,\n        *entries (value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns){\n                    unknowns.delete(key);\n                    yield [\n                        key,\n                        value[key],\n                        schema[key]\n                    ];\n                }\n                for (const key of unknowns){\n                    yield [\n                        key,\n                        value[key],\n                        Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value, ctx) {\n            if (!isNonArrayObject(value)) {\n                return value;\n            }\n            const coerced = {\n                ...value\n            };\n            // The `object` struct has special behaviour enabled by the mask flag.\n            // When masking, properties that are not in the schema are deleted from\n            // the coerced object instead of eventually failing validaiton.\n            if (ctx.mask && schema) {\n                for(const key in coerced){\n                    if (schema[key] === undefined) {\n                        delete coerced[key];\n                    }\n                }\n            }\n            return coerced;\n        }\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */ function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */ function record(Key, Value) {\n    return new Struct({\n        type: \"record\",\n        schema: null,\n        *entries (value) {\n            if (isObject(value)) {\n                for(const k in value){\n                    const v = value[k];\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return isNonArrayObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */ function regexp() {\n    return define(\"regexp\", (value)=>{\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: \"set\",\n        schema: null,\n        *entries (value) {\n            if (Element && value instanceof Set) {\n                for (const v of value){\n                    yield [\n                        v,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator (value) {\n            return value instanceof Set || `Expected a \\`Set\\` object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a string.\n */ function string() {\n    return define(\"string\", (value)=>{\n        return typeof value === \"string\" || `Expected a string, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */ function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: \"tuple\",\n        schema: null,\n        *entries (value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for(let i = 0; i < length; i++){\n                    yield [\n                        i,\n                        value[i],\n                        Structs[i] || Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        }\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */ function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: \"type\",\n        schema,\n        *entries (value) {\n            if (isObject(value)) {\n                for (const k of keys){\n                    yield [\n                        k,\n                        value[k],\n                        schema[k]\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return isNonArrayObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */ function union(Structs) {\n    const description = Structs.map((s)=>s.type).join(\" | \");\n    return new Struct({\n        type: \"union\",\n        schema: null,\n        coercer (value, ctx) {\n            for (const S of Structs){\n                const [error, coerced] = S.validate(value, {\n                    coerce: true,\n                    mask: ctx.mask\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator (value, ctx) {\n            const failures = [];\n            for (const S of Structs){\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                } else {\n                    for (const [failure] of tuples){\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures\n            ];\n        }\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */ function unknown() {\n    return define(\"unknown\", ()=>true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx)=>{\n            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x)=>{\n        const f = typeof fallback === \"function\" ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = {\n                ...x\n            };\n            let changed = false;\n            for(const key in f){\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function trimmed(struct) {\n    return coerce(struct, string(), (x)=>x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */ function empty(struct) {\n    return refine(struct, \"empty\", (value)=>{\n        const size = getSize(value);\n        return size === 0 || `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``;\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    } else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */ function max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"max\", (value)=>{\n        return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? \"\" : \"or equal to \"}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */ function min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"min\", (value)=>{\n        return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? \"\" : \"or equal to \"}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */ function nonempty(struct) {\n    return refine(struct, \"nonempty\", (value)=>{\n        const size = getSize(value);\n        return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */ function pattern(struct, regexp) {\n    return refine(struct, \"pattern\", (value)=>{\n        return regexp.test(value) || `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`;\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */ function size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, \"size\", (value)=>{\n        if (typeof value === \"number\" || value instanceof Date) {\n            return min <= value && value <= max || `${expected} ${of} but received \\`${value}\\``;\n        } else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return min <= size && size <= max || `${expected} with a size ${of} but received one with a size of \\`${size}\\``;\n        } else {\n            const { length } = value;\n            return min <= length && length <= max || `${expected} with a length ${of} but received one with a length of \\`${length}\\``;\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */ function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner (value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures){\n                yield {\n                    ...failure,\n                    refinement: name\n                };\n            }\n        }\n    });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDRDs7Ozs7OztDQU9DLEdBQ0QsTUFBTUEsb0JBQW9CQztJQUN0QkMsWUFBWUMsT0FBTyxFQUFFQyxRQUFRLENBQUU7UUFDM0IsSUFBSUM7UUFDSixNQUFNLEVBQUVDLE9BQU8sRUFBRUMsV0FBVyxFQUFFLEdBQUdDLE1BQU0sR0FBR0w7UUFDMUMsTUFBTSxFQUFFTSxJQUFJLEVBQUUsR0FBR047UUFDakIsTUFBTU8sTUFBTUQsS0FBS0UsTUFBTSxLQUFLLElBQUlMLFVBQVUsQ0FBQyxTQUFTLEVBQUVHLEtBQUtHLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRU4sUUFBUSxDQUFDO1FBQ3BGLEtBQUssQ0FBQ0MsZUFBZUc7UUFDckIsSUFBSUgsZUFBZSxNQUNmLElBQUksQ0FBQ00sS0FBSyxHQUFHSDtRQUNqQkksT0FBT0MsTUFBTSxDQUFDLElBQUksRUFBRVA7UUFDcEIsSUFBSSxDQUFDUSxJQUFJLEdBQUcsSUFBSSxDQUFDZCxXQUFXLENBQUNjLElBQUk7UUFDakMsSUFBSSxDQUFDWixRQUFRLEdBQUc7WUFDWixPQUFRQyxVQUFXQSxDQUFBQSxTQUFTO2dCQUFDRjttQkFBWUM7YUFBVztRQUN4RDtJQUNKO0FBQ0o7QUFFQTs7Q0FFQyxHQUNELFNBQVNhLFdBQVdDLENBQUM7SUFDakIsT0FBT0MsU0FBU0QsTUFBTSxPQUFPQSxDQUFDLENBQUNFLE9BQU9DLFFBQVEsQ0FBQyxLQUFLO0FBQ3hEO0FBQ0E7O0NBRUMsR0FDRCxTQUFTRixTQUFTRCxDQUFDO0lBQ2YsT0FBTyxPQUFPQSxNQUFNLFlBQVlBLEtBQUs7QUFDekM7QUFDQTs7Q0FFQyxHQUNELFNBQVNJLGlCQUFpQkosQ0FBQztJQUN2QixPQUFPQyxTQUFTRCxNQUFNLENBQUNLLE1B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LEdBQ0QsU0FBUzhJLE9BQU8vRyxNQUFNLEVBQUUxQixJQUFJLEVBQUVtRCxPQUFPO0lBQ2pDLE9BQU8sSUFBSUMsT0FBTztRQUNkLEdBQUcxQixNQUFNO1FBQ1QsQ0FBQ3lCLFNBQVFwQyxLQUFLLEVBQUVzQixHQUFHO1lBQ2YsT0FBT1gsT0FBT3lCLE9BQU8sQ0FBQ3BDLE9BQU9zQjtZQUM3QixNQUFNYixTQUFTMkIsUUFBUXBDLE9BQU9zQjtZQUM5QixNQUFNakQsV0FBVzJDLFdBQVdQLFFBQVFhLEtBQUtYLFFBQVFYO1lBQ2pELEtBQUssTUFBTTVCLFdBQVdDLFNBQVU7Z0JBQzVCLE1BQU07b0JBQUUsR0FBR0QsT0FBTztvQkFBRTBDLFlBQVk3QjtnQkFBSztZQUN6QztRQUNKO0lBQ0o7QUFDSjtBQUU2WixDQUM3WixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRwbGFjZS8uL25vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9kaXN0L2luZGV4Lm1qcz80NDZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBgU3RydWN0RmFpbHVyZWAgcmVwcmVzZW50cyBhIHNpbmdsZSBzcGVjaWZpYyBmYWlsdXJlIGluIHZhbGlkYXRpb24uXG4gKi9cbi8qKlxuICogYFN0cnVjdEVycm9yYCBvYmplY3RzIGFyZSB0aHJvd24gKG9yIHJldHVybmVkKSB3aGVuIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogVmFsaWRhdGlvbiBsb2dpYyBpcyBkZXNpZ24gdG8gZXhpdCBlYXJseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gVGhlIGVycm9yXG4gKiByZXByZXNlbnRzIHRoZSBmaXJzdCBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgdmFsaWRhdGlvbi4gRm9yIG1vcmUgZGV0YWlsLFxuICogdGhlIGBlcnJvci5mYWlsdXJlc2AgcHJvcGVydHkgaXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcnVuIHRvXG4gKiBjb250aW51ZSB2YWxpZGF0aW9uIGFuZCByZWNlaXZlIGFsbCB0aGUgZmFpbHVyZXMgaW4gdGhlIGRhdGEuXG4gKi9cbmNsYXNzIFN0cnVjdEVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihmYWlsdXJlLCBmYWlsdXJlcykge1xuICAgICAgICBsZXQgY2FjaGVkO1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIGV4cGxhbmF0aW9uLCAuLi5yZXN0IH0gPSBmYWlsdXJlO1xuICAgICAgICBjb25zdCB7IHBhdGggfSA9IGZhaWx1cmU7XG4gICAgICAgIGNvbnN0IG1zZyA9IHBhdGgubGVuZ3RoID09PSAwID8gbWVzc2FnZSA6IGBBdCBwYXRoOiAke3BhdGguam9pbignLicpfSAtLSAke21lc3NhZ2V9YDtcbiAgICAgICAgc3VwZXIoZXhwbGFuYXRpb24gPz8gbXNnKTtcbiAgICAgICAgaWYgKGV4cGxhbmF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gbXNnO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJlc3QpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHRoaXMuZmFpbHVyZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGNhY2hlZCA/PyAoY2FjaGVkID0gW2ZhaWx1cmUsIC4uLmZhaWx1cmVzKCldKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaXRlcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmFibGUoeCkge1xuICAgIHJldHVybiBpc09iamVjdCh4KSAmJiB0eXBlb2YgeFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9IG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBub24tYXJyYXkgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc05vbkFycmF5T2JqZWN0KHgpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgIUFycmF5LmlzQXJyYXkoeCk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoeCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpO1xuICAgIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuLyoqXG4gKiBSZXR1cm4gYSB2YWx1ZSBhcyBhIHByaW50YWJsZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHByaW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogYCR7dmFsdWV9YDtcbn1cbi8qKlxuICogU2hpZnRzIChyZW1vdmVzIGFuZCByZXR1cm5zKSB0aGUgZmlyc3QgdmFsdWUgZnJvbSB0aGUgYGlucHV0YCBpdGVyYXRvci5cbiAqIExpa2UgYEFycmF5LnByb3RvdHlwZS5zaGlmdCgpYCBidXQgZm9yIGFuIGBJdGVyYXRvcmAuXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0SXRlcmF0b3IoaW5wdXQpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpbnB1dC5uZXh0KCk7XG4gICAgcmV0dXJuIGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn1cbi8qKlxuICogQ29udmVydCBhIHNpbmdsZSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhIGZhaWx1cmUuXG4gKi9cbmZ1bmN0aW9uIHRvRmFpbHVyZShyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICByZXN1bHQgPSB7fTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmVzdWx0ID0geyBtZXNzYWdlOiByZXN1bHQgfTtcbiAgICB9XG4gICAgY29uc3QgeyBwYXRoLCBicmFuY2ggfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3QgeyByZWZpbmVtZW50LCBtZXNzYWdlID0gYEV4cGVjdGVkIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgJHtyZWZpbmVtZW50ID8gYCB3aXRoIHJlZmluZW1lbnQgXFxgJHtyZWZpbmVtZW50fVxcYGAgOiAnJ30sIGJ1dCByZWNlaXZlZDogXFxgJHtwcmludCh2YWx1ZSl9XFxgYCwgfSA9IHJlc3VsdDtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVmaW5lbWVudCxcbiAgICAgICAga2V5OiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0sXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGJyYW5jaCxcbiAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICBtZXNzYWdlLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnQgYSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhbiBpdGVyYWJsZSBvZiBmYWlsdXJlcy5cbiAqL1xuZnVuY3Rpb24qIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0l0ZXJhYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdF07XG4gICAgfVxuICAgIGZvciAoY29uc3QgciBvZiByZXN1bHQpIHtcbiAgICAgICAgY29uc3QgZmFpbHVyZSA9IHRvRmFpbHVyZShyLCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKTtcbiAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgIHlpZWxkIGZhaWx1cmU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENoZWNrIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgdHJhdmVyc2luZyBkZWVwbHkgaW50byBuZXN0ZWQgdmFsdWVzLCBhbmRcbiAqIHJldHVybmluZyBhbiBpdGVyYXRvciBvZiBmYWlsdXJlcyBvciBzdWNjZXNzLlxuICovXG5mdW5jdGlvbiogcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcGF0aCA9IFtdLCBicmFuY2ggPSBbdmFsdWVdLCBjb2VyY2UgPSBmYWxzZSwgbWFzayA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGN0eCA9IHsgcGF0aCwgYnJhbmNoLCBtYXNrIH07XG4gICAgaWYgKGNvZXJjZSkge1xuICAgICAgICB2YWx1ZSA9IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgIH1cbiAgICBsZXQgc3RhdHVzID0gJ3ZhbGlkJztcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgICBzdGF0dXMgPSAnbm90X3ZhbGlkJztcbiAgICAgICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGZvciAobGV0IFtrLCB2LCBzXSBvZiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KSkge1xuICAgICAgICBjb25zdCB0cyA9IHJ1bih2LCBzLCB7XG4gICAgICAgICAgICBwYXRoOiBrID09PSB1bmRlZmluZWQgPyBwYXRoIDogWy4uLnBhdGgsIGtdLFxuICAgICAgICAgICAgYnJhbmNoOiBrID09PSB1bmRlZmluZWQgPyBicmFuY2ggOiBbLi4uYnJhbmNoLCB2XSxcbiAgICAgICAgICAgIGNvZXJjZSxcbiAgICAgICAgICAgIG1hc2ssXG4gICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdHMpIHtcbiAgICAgICAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gdFswXS5yZWZpbmVtZW50ICE9IG51bGwgPyAnbm90X3JlZmluZWQnIDogJ25vdF92YWxpZCc7XG4gICAgICAgICAgICAgICAgeWllbGQgW3RbMF0sIHVuZGVmaW5lZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2VyY2UpIHtcbiAgICAgICAgICAgICAgICB2ID0gdFsxXTtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KGssIHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hZGQodik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkIHx8IGsgaW4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0dXMgIT09ICdub3RfdmFsaWQnKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICAgICAgZmFpbHVyZS5leHBsYW5hdGlvbiA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdub3RfcmVmaW5lZCc7XG4gICAgICAgICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAndmFsaWQnKSB7XG4gICAgICAgIHlpZWxkIFt1bmRlZmluZWQsIHZhbHVlXTtcbiAgICB9XG59XG5cbi8qKlxuICogYFN0cnVjdGAgb2JqZWN0cyBlbmNhcHN1bGF0ZSB0aGUgdmFsaWRhdGlvbiBsb2dpYyBmb3IgYSBzcGVjaWZpYyB0eXBlIG9mXG4gKiB2YWx1ZXMuIE9uY2UgY29uc3RydWN0ZWQsIHlvdSB1c2UgdGhlIGBhc3NlcnRgLCBgaXNgIG9yIGB2YWxpZGF0ZWAgaGVscGVycyB0b1xuICogdmFsaWRhdGUgdW5rbm93biBpbnB1dCBkYXRhIGFnYWluc3QgdGhlIHN0cnVjdC5cbiAqL1xuY2xhc3MgU3RydWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBjb25zdCB7IHR5cGUsIHNjaGVtYSwgdmFsaWRhdG9yLCByZWZpbmVyLCBjb2VyY2VyID0gKHZhbHVlKSA9PiB2YWx1ZSwgZW50cmllcyA9IGZ1bmN0aW9uKiAoKSB7IH0sIH0gPSBwcm9wcztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgIHRoaXMuY29lcmNlciA9IGNvZXJjZXI7XG4gICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAoKSA9PiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICAgKi9cbiAgICBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydCh2YWx1ZSwgdGhpcywgbWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIGNvZXJjaW9uIGxvZ2ljLCB0aGVuIHZhbGlkYXRlIGl0LlxuICAgICAqL1xuICAgIGNyZWF0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFzayBhIHZhbHVlLCBjb2VyY2luZyBhbmQgdmFsaWRhdGluZyBpdCwgYnV0IHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2ZcbiAgICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS4gTWFza2luZyBhcHBsaWVzIHJlY3Vyc2l2ZWx5IHRvXG4gICAgICogcHJvcHMgb2YgYG9iamVjdGAgc3RydWN0cyBvbmx5LlxuICAgICAqL1xuICAgIG1hc2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1hc2sodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24gbG9naWMsIHJldHVybmluZyBhIHR1cGxlXG4gICAgICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgcGFzcyBgdHJ1ZWAgZm9yIHRoZSBgY29lcmNlYCBhcmd1bWVudCB0byBjb2VyY2VcbiAgICAgKiB0aGUgdmFsdWUgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdmFsaWRhdGUgaXQuIElmIHlvdSBkbywgdGhlIHJlc3VsdCB3aWxsXG4gICAgICogY29udGFpbiB0aGUgY29lcmNlZCByZXN1bHQgd2hlbiBzdWNjZXNzZnVsLiBBbHNvLCBgbWFza2Agd2lsbCB0dXJuIG9uXG4gICAgICogbWFza2luZyBvZiB0aGUgdW5rbm93biBgb2JqZWN0YCBwcm9wcyByZWN1cnNpdmVseSBpZiBwYXNzZWQuXG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QsIHRocm93aW5nIGlmIGl0IGRvZXNuJ3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgeyBtZXNzYWdlIH0pO1xuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgY29lcmNpb24gbG9naWMgb2Ygc3RydWN0IGFuZCB2YWxpZGF0ZSBpdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlKHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IGNvZXJjZTogdHJ1ZSwgbWVzc2FnZSB9KTtcbiAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbMV07XG4gICAgfVxufVxuLyoqXG4gKiBNYXNrIGEgdmFsdWUsIHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2YgcHJvcGVydGllcyBkZWZpbmVkIGJ5IGEgc3RydWN0LlxuICovXG5mdW5jdGlvbiBtYXNrKHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IGNvZXJjZTogdHJ1ZSwgbWFzazogdHJ1ZSwgbWVzc2FnZSB9KTtcbiAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbMV07XG4gICAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdC5cbiAqL1xuZnVuY3Rpb24gaXModmFsdWUsIHN0cnVjdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QpO1xuICAgIHJldHVybiAhcmVzdWx0WzBdO1xufVxuLyoqXG4gKiBWYWxpZGF0ZSBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHJldHVybmluZyBhbiBlcnJvciBpZiBpbnZhbGlkLCBvciB0aGVcbiAqIHZhbHVlICh3aXRoIHBvdGVudGlhbCBjb2VyY2lvbikgaWYgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHR1cGxlcyA9IHJ1bih2YWx1ZSwgc3RydWN0LCBvcHRpb25zKTtcbiAgICBjb25zdCB0dXBsZSA9IHNoaWZ0SXRlcmF0b3IodHVwbGVzKTtcbiAgICBpZiAodHVwbGVbMF0pIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU3RydWN0RXJyb3IodHVwbGVbMF0sIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdHVwbGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW2Vycm9yLCB1bmRlZmluZWRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdiA9IHR1cGxlWzFdO1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdl07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ24oLi4uU3RydWN0cykge1xuICAgIGNvbnN0IGlzVHlwZSA9IFN0cnVjdHNbMF0udHlwZSA9PT0gJ3R5cGUnO1xuICAgIGNvbnN0IHNjaGVtYXMgPSBTdHJ1Y3RzLm1hcCgocykgPT4gcy5zY2hlbWEpO1xuICAgIGNvbnN0IHNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLnNjaGVtYXMpO1xuICAgIHJldHVybiBpc1R5cGUgPyB0eXBlKHNjaGVtYSkgOiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcikge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHsgdHlwZTogbmFtZSwgc2NoZW1hOiBudWxsLCB2YWxpZGF0b3IgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgc3RydWN0LCBidXQgdGhlIHZhbHVlIGlzIGFsbG93ZWQgdG9cbiAqIGJlIGB1bmRlZmluZWRgLiBgbG9nYCB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgdmFsdWUgaXMgbm90IGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGVkKHN0cnVjdCwgbG9nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IHdpdGggZHluYW1pYyB2YWxpZGF0aW9uIGxvZ2ljLlxuICpcbiAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgdGhlIHZhbHVlIGN1cnJlbnRseSBiZWluZyB2YWxpZGF0ZWQsIGFuZCBtdXN0XG4gKiByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHZhbGlkYXRlIGl0IHdpdGguIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBtb2RlbFxuICogdmFsaWRhdGlvbiBsb2dpYyB0aGF0IGNoYW5nZXMgYmFzZWQgb24gaXRzIGlucHV0LlxuICovXG5mdW5jdGlvbiBkeW5hbWljKGZuKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnZHluYW1pYycsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB5aWVsZCogc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBsYXppbHkgZXZhbHVhdGVkIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdmFsaWRhdGlvbiBpcyBydW4gd2l0aCB0aGUgc3RydWN0LCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAqIGFuZCBtdXN0IHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdXNlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXMgd2hlcmUgeW91XG4gKiB3YW50IHRvIGhhdmUgc2VsZi1yZWZlcmVudGlhbCBzdHJ1Y3RzIGZvciBuZXN0ZWQgZGF0YSBzdHJ1Y3R1cmVzIHRvIGF2b2lkIGFcbiAqIGNpcmN1bGFyIGRlZmluaXRpb24gcHJvYmxlbS5cbiAqL1xuZnVuY3Rpb24gbGF6eShmbikge1xuICAgIGxldCBzdHJ1Y3Q7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnbGF6eScsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IGV4Y2x1ZGluZ1xuICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgT21pdGAgdXRpbGl0eS5cbiAqL1xuZnVuY3Rpb24gb21pdChzdHJ1Y3QsIGtleXMpIHtcbiAgICBjb25zdCB7IHNjaGVtYSB9ID0gc3RydWN0O1xuICAgIGNvbnN0IHN1YnNjaGVtYSA9IHsgLi4uc2NoZW1hIH07XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBkZWxldGUgc3Vic2NoZW1hW2tleV07XG4gICAgfVxuICAgIHN3aXRjaCAoc3RydWN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgICByZXR1cm4gdHlwZShzdWJzY2hlbWEpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgd2l0aCBhbGwgb2YgaXRzXG4gKiBwcm9wZXJ0aWVzIGFsbG93ZWQgdG8gYmUgYHVuZGVmaW5lZGAuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBhcnRpYWxgIHV0aWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHBhcnRpYWwoc3RydWN0KSB7XG4gICAgY29uc3QgaXNTdHJ1Y3QgPSBzdHJ1Y3QgaW5zdGFuY2VvZiBTdHJ1Y3Q7XG4gICAgY29uc3Qgc2NoZW1hID0gaXNTdHJ1Y3QgPyB7IC4uLnN0cnVjdC5zY2hlbWEgfSA6IHsgLi4uc3RydWN0IH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIHNjaGVtYVtrZXldID0gb3B0aW9uYWwoc2NoZW1hW2tleV0pO1xuICAgIH1cbiAgICBpZiAoaXNTdHJ1Y3QgJiYgc3RydWN0LnR5cGUgPT09ICd0eXBlJykge1xuICAgICAgICByZXR1cm4gdHlwZShzY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0KHNjaGVtYSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IG9ubHkgaW5jbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBQaWNrYCB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiBwaWNrKHN0cnVjdCwga2V5cykge1xuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBzdWJzY2hlbWFba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0cnVjdC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUoc3Vic2NoZW1hKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Qoc3Vic2NoZW1hKTtcbiAgICB9XG59XG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLlxuICovXG5mdW5jdGlvbiBzdHJ1Y3QobmFtZSwgdmFsaWRhdG9yKSB7XG4gICAgY29uc29sZS53YXJuKCdzdXBlcnN0cnVjdEAwLjExIC0gVGhlIGBzdHJ1Y3RgIGhlbHBlciBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLicpO1xuICAgIHJldHVybiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFueSgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdhbnknLCAoKSA9PiB0cnVlKTtcbn1cbmZ1bmN0aW9uIGFycmF5KEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgIHNjaGVtYTogRWxlbWVudCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChFbGVtZW50ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaSwgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtpLCB2LCBFbGVtZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGFycmF5IHZhbHVlLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYmlnaW50LlxuICovXG5mdW5jdGlvbiBiaWdpbnQoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnYmlnaW50JywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdib29sZWFuJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGBEYXRlYC5cbiAqXG4gKiBOb3RlOiB0aGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBpcyAqbm90KiBhbiBpbnZhbGlkIGBEYXRlYCBvYmplY3QsXG4gKiB3aGljaCBjYW4gb2NjdXIgd2hlbiBwYXJzaW5nIGEgZGF0ZSBmYWlscyBidXQgc3RpbGwgcmV0dXJucyBhIGBEYXRlYC5cbiAqL1xuZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdkYXRlJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAoKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIHZhbGlkIFxcYERhdGVcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZW51bXModmFsdWVzKSB7XG4gICAgY29uc3Qgc2NoZW1hID0ge307XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZXMubWFwKCh2KSA9PiBwcmludCh2KSkuam9pbigpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlcykge1xuICAgICAgICBzY2hlbWFba2V5XSA9IGtleTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnZW51bXMnLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXMuaW5jbHVkZXModmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIG9uZSBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmdW5jKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2Z1bmMnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGEgc3BlY2lmaWMgY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGluc3RhbmNlKENsYXNzKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnaW5zdGFuY2UnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIENsYXNzIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGAke0NsYXNzLm5hbWV9XFxgIGluc3RhbmNlLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGludGVnZXIoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnaW50ZWdlcicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIGFsbCBvZiBhIHNldCBvZiB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKFN0cnVjdHMpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdpbnRlcnNlY3Rpb24nLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFMuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKnZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBTLnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogUy5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gbGl0ZXJhbChjb25zdGFudCkge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gcHJpbnQoY29uc3RhbnQpO1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgY29uc3RhbnQ7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgIHNjaGVtYTogdCA9PT0gJ3N0cmluZycgfHwgdCA9PT0gJ251bWJlcicgfHwgdCA9PT0gJ2Jvb2xlYW4nID8gY29uc3RhbnQgOiBudWxsLFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT09IGNvbnN0YW50IHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIHRoZSBsaXRlcmFsIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gbWFwKEtleSwgVmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdtYXAnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoS2V5ICYmIFZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTWFwID8gbmV3IE1hcCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgXFxgTWFwXFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgbm8gdmFsdWUgZXZlciBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbmV2ZXIoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnbmV2ZXInLCAoKSA9PiBmYWxzZSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYW4gZXhpc3Rpbmcgc3RydWN0IHRvIGFsbG93IGBudWxsYCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG51bGxhYmxlKHN0cnVjdCkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIG51bWJlcigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdudW1iZXInLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICgodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpKSB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgbnVtYmVyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0KHNjaGVtYSkge1xuICAgIGNvbnN0IGtub3ducyA9IHNjaGVtYSA/IE9iamVjdC5rZXlzKHNjaGVtYSkgOiBbXTtcbiAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEgPyBzY2hlbWEgOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmtub3ducyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrbm93bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5rbm93bnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIHNjaGVtYVtrZXldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5rbm93bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgTmV2ZXJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzTm9uQXJyYXlPYmplY3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAoIWlzTm9uQXJyYXlPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29lcmNlZCA9IHsgLi4udmFsdWUgfTtcbiAgICAgICAgICAgIC8vIFRoZSBgb2JqZWN0YCBzdHJ1Y3QgaGFzIHNwZWNpYWwgYmVoYXZpb3VyIGVuYWJsZWQgYnkgdGhlIG1hc2sgZmxhZy5cbiAgICAgICAgICAgIC8vIFdoZW4gbWFza2luZywgcHJvcGVydGllcyB0aGF0IGFyZSBub3QgaW4gdGhlIHNjaGVtYSBhcmUgZGVsZXRlZCBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgY29lcmNlZCBvYmplY3QgaW5zdGVhZCBvZiBldmVudHVhbGx5IGZhaWxpbmcgdmFsaWRhaXRvbi5cbiAgICAgICAgICAgIGlmIChjdHgubWFzayAmJiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb2VyY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29lcmNlZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gYWxsb3cgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBrZXlzIGFuZCB2YWx1ZXMgb2Ygc3BlY2lmaWMgdHlwZXMsIGJ1dFxuICogd2l0aG91dCBlbnN1cmluZyBhbnkgc3BlY2lmaWMgc2hhcGUgb2YgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUmVjb3JkYCB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiByZWNvcmQoS2V5LCBWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3JlY29yZCcsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIHYsIFZhbHVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIChpc05vbkFycmF5T2JqZWN0KHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc05vbkFycmF5T2JqZWN0KHZhbHVlKSA/IHsgLi4udmFsdWUgfSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFJlZ0V4cGAuXG4gKlxuICogTm90ZTogdGhpcyBkb2VzIG5vdCB0ZXN0IHRoZSB2YWx1ZSBhZ2FpbnN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24hIEZvciB0aGF0XG4gKiB5b3UgbmVlZCB0byB1c2UgdGhlIGBwYXR0ZXJuKClgIHJlZmluZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cCgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdyZWdleHAnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0KEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoRWxlbWVudCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbdiwgdiwgRWxlbWVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTZXQgPyBuZXcgU2V0KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTZXQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBTZXRcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmcoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnc3RyaW5nJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdHVwbGUgb2YgYSBzcGVjaWZpYyBsZW5ndGgsIGFuZCB0aGF0IGVhY2ggb2YgaXRzXG4gKiBlbGVtZW50cyBpcyBvZiBhIHNwZWNpZmljIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHR1cGxlKFN0cnVjdHMpIHtcbiAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChTdHJ1Y3RzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtpLCB2YWx1ZVtpXSwgU3RydWN0c1tpXSB8fCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBoYXMgYSBzZXQgb2Yga25vd24gcHJvcGVydGllcyBvZiBzcGVjaWZpYyB0eXBlcy5cbiAqXG4gKiBOb3RlOiBVbnJlY29nbml6ZWQgcHJvcGVydGllcyBhcmUgYWxsb3dlZCBhbmQgdW50b3VjaGVkLiBUaGlzIGlzIHNpbWlsYXIgdG9cbiAqIGhvdyBUeXBlU2NyaXB0J3Mgc3RydWN0dXJhbCB0eXBpbmcgd29ya3MuXG4gKi9cbmZ1bmN0aW9uIHR5cGUoc2NoZW1hKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYSk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHlwZScsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdmFsdWVba10sIHNjaGVtYVtrXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNOb25BcnJheU9iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOb25BcnJheU9iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIG9uZSBvZiBhIHNldCBvZiB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gdW5pb24oU3RydWN0cykge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gU3RydWN0cy5tYXAoKHMpID0+IHMudHlwZSkuam9pbignIHwgJyk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndW5pb24nLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZXJyb3IsIGNvZXJjZWRdID0gUy52YWxpZGF0ZSh2YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1hc2s6IGN0eC5tYXNrLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgWy4uLnR1cGxlc10gPSBydW4odmFsdWUsIFMsIGN0eCk7XG4gICAgICAgICAgICAgICAgY29uc3QgW2ZpcnN0XSA9IHR1cGxlcztcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ZhaWx1cmVdIG9mIHR1cGxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIHZhbHVlIHRvIHNhdGlzZnkgYSB1bmlvbiBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gLFxuICAgICAgICAgICAgICAgIC4uLmZhaWx1cmVzLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLCB3aXRob3V0IHdpZGVuaW5nIGl0cyB0eXBlIHRvIGBhbnlgLlxuICovXG5mdW5jdGlvbiB1bmtub3duKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ3Vua25vd24nLCAoKSA9PiB0cnVlKTtcbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgY29lcmNpb24gc3RlcCB0byBpdHMgaW5wdXQuXG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSBpbnB1dCBkYXRhIGJlZm9yZSB2YWxpZGF0aW5nIGl0LCB0byBpbmNyZWFzZSB0aGVcbiAqIGxpa2VsaWhvb2QgdGhhdCBpdCBwYXNzZXMgdmFsaWRhdGlvbuKAlGZvciBleGFtcGxlIGZvciBkZWZhdWx0IHZhbHVlcywgcGFyc2luZ1xuICogZGlmZmVyZW50IGZvcm1hdHMsIGV0Yy5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuZnVuY3Rpb24gY29lcmNlKHN0cnVjdCwgY29uZGl0aW9uLCBjb2VyY2VyKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgIGNvZXJjZXI6ICh2YWx1ZSwgY3R4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXModmFsdWUsIGNvbmRpdGlvbilcbiAgICAgICAgICAgICAgICA/IHN0cnVjdC5jb2VyY2VyKGNvZXJjZXIodmFsdWUsIGN0eCksIGN0eClcbiAgICAgICAgICAgICAgICA6IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgc3RydWN0IHRvIHJlcGxhY2UgYHVuZGVmaW5lZGAgdmFsdWVzIHdpdGggYSBkZWZhdWx0LlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0ZWQoc3RydWN0LCBmYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHVua25vd24oKSwgKHgpID0+IHtcbiAgICAgICAgY29uc3QgZiA9IHR5cGVvZiBmYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGZhbGxiYWNrKCkgOiBmYWxsYmFjaztcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiBpc1BsYWluT2JqZWN0KHgpICYmIGlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHsgLi4ueCB9O1xuICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGYpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IGZba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgc3RydWN0IHRvIHRyaW0gc3RyaW5nIGlucHV0cy5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuZnVuY3Rpb24gdHJpbW1lZChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gY29lcmNlKHN0cnVjdCwgc3RyaW5nKCksICh4KSA9PiB4LnRyaW0oKSk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBtYXAsIG9yIHNldCBpcyBlbXB0eS5cbiAqL1xuZnVuY3Rpb24gZW1wdHkoc3RydWN0KSB7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdlbXB0eScsICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAoc2l6ZSA9PT0gMCB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGVtcHR5ICR7c3RydWN0LnR5cGV9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2l6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGJlbG93IGEgdGhyZXNob2xkLlxuICovXG5mdW5jdGlvbiBtYXgoc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZXhjbHVzaXZlIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnbWF4JywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBleGNsdXNpdmVcbiAgICAgICAgICAgID8gdmFsdWUgPCB0aHJlc2hvbGRcbiAgICAgICAgICAgIDogdmFsdWUgPD0gdGhyZXNob2xkIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbGVzcyB0aGFuICR7ZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJ30ke3RocmVzaG9sZH0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYDtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBhYm92ZSBhIHRocmVzaG9sZC5cbiAqL1xuZnVuY3Rpb24gbWluKHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGV4Y2x1c2l2ZSB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21pbicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICAgICAgICA/IHZhbHVlID4gdGhyZXNob2xkXG4gICAgICAgICAgICA6IHZhbHVlID49IHRocmVzaG9sZCB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGdyZWF0ZXIgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICd9JHt0aHJlc2hvbGR9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGA7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwIG9yIHNldCBpcyBub3QgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIG5vbmVtcHR5KHN0cnVjdCkge1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnbm9uZW1wdHknLCAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGdldFNpemUodmFsdWUpO1xuICAgICAgICByZXR1cm4gKHNpemUgPiAwIHx8IGBFeHBlY3RlZCBhIG5vbmVtcHR5ICR7c3RydWN0LnR5cGV9IGJ1dCByZWNlaXZlZCBhbiBlbXB0eSBvbmVgKTtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcgbWF0Y2hlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqL1xuZnVuY3Rpb24gcGF0dGVybihzdHJ1Y3QsIHJlZ2V4cCkge1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAncGF0dGVybicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHJlZ2V4cC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbWF0Y2hpbmcgXFxgLyR7cmVnZXhwLnNvdXJjZX0vXFxgIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCJgKTtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBudW1iZXIsIGRhdGUsIG1hcCwgb3Igc2V0IGhhcyBhIHNpemUgKG9yIGxlbmd0aCwgb3IgdGltZSkgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAuXG4gKi9cbmZ1bmN0aW9uIHNpemUoc3RydWN0LCBtaW4sIG1heCA9IG1pbikge1xuICAgIGNvbnN0IGV4cGVjdGVkID0gYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX1gO1xuICAgIGNvbnN0IG9mID0gbWluID09PSBtYXggPyBgb2YgXFxgJHttaW59XFxgYCA6IGBiZXR3ZWVuIFxcYCR7bWlufVxcYCBhbmQgXFxgJHttYXh9XFxgYDtcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3NpemUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4KSB8fFxuICAgICAgICAgICAgICAgIGAke2V4cGVjdGVkfSAke29mfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgY29uc3QgeyBzaXplIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAoKG1pbiA8PSBzaXplICYmIHNpemUgPD0gbWF4KSB8fFxuICAgICAgICAgICAgICAgIGAke2V4cGVjdGVkfSB3aXRoIGEgc2l6ZSAke29mfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIFxcYCR7c2l6ZX1cXGBgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAoKG1pbiA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICBgJHtleHBlY3RlZH0gd2l0aCBhIGxlbmd0aCAke29mfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBsZW5ndGggb2YgXFxgJHtsZW5ndGh9XFxgYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIHJlZmluZW1lbnQgdG8gdGhlIHZhbGlkYXRpb24uXG4gKlxuICogVGhlIHJlZmluZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZWNlaXZlIGEgdmFsdWUgb2YgdGhlIHN0cnVjdCdzIHR5cGUsXG4gKiBiZWNhdXNlIHRoZSBzdHJ1Y3QncyBleGlzdGluZyB2YWxpZGF0aW9uIHdpbGwgYWxyZWFkeSBoYXZlIHBhc3NlZC4gVGhpc1xuICogYWxsb3dzIHlvdSB0byBsYXllciBhZGRpdGlvbmFsIHZhbGlkYXRpb24gb24gdG9wIG9mIGV4aXN0aW5nIHN0cnVjdHMuXG4gKi9cbmZ1bmN0aW9uIHJlZmluZShzdHJ1Y3QsIG5hbWUsIHJlZmluZXIpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gdG9GYWlsdXJlcyhyZXN1bHQsIGN0eCwgc3RydWN0LCB2YWx1ZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB7IC4uLmZhaWx1cmUsIHJlZmluZW1lbnQ6IG5hbWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgU3RydWN0LCBTdHJ1Y3RFcnJvciwgYW55LCBhcnJheSwgYXNzZXJ0LCBhc3NpZ24sIGJpZ2ludCwgYm9vbGVhbiwgY29lcmNlLCBjcmVhdGUsIGRhdGUsIGRlZmF1bHRlZCwgZGVmaW5lLCBkZXByZWNhdGVkLCBkeW5hbWljLCBlbXB0eSwgZW51bXMsIGZ1bmMsIGluc3RhbmNlLCBpbnRlZ2VyLCBpbnRlcnNlY3Rpb24sIGlzLCBsYXp5LCBsaXRlcmFsLCBtYXAsIG1hc2ssIG1heCwgbWluLCBuZXZlciwgbm9uZW1wdHksIG51bGxhYmxlLCBudW1iZXIsIG9iamVjdCwgb21pdCwgb3B0aW9uYWwsIHBhcnRpYWwsIHBhdHRlcm4sIHBpY2ssIHJlY29yZCwgcmVmaW5lLCByZWdleHAsIHNldCwgc2l6ZSwgc3RyaW5nLCBzdHJ1Y3QsIHRyaW1tZWQsIHR1cGxlLCB0eXBlLCB1bmlvbiwgdW5rbm93biwgdmFsaWRhdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJTdHJ1Y3RFcnJvciIsIlR5cGVFcnJvciIsImNvbnN0cnVjdG9yIiwiZmFpbHVyZSIsImZhaWx1cmVzIiwiY2FjaGVkIiwibWVzc2FnZSIsImV4cGxhbmF0aW9uIiwicmVzdCIsInBhdGgiLCJtc2ciLCJsZW5ndGgiLCJqb2luIiwiY2F1c2UiLCJPYmplY3QiLCJhc3NpZ24iLCJuYW1lIiwiaXNJdGVyYWJsZSIsIngiLCJpc09iamVjdCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXNOb25BcnJheU9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsImlzUGxhaW5PYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRQcm90b3R5cGVPZiIsInByaW50IiwidmFsdWUiLCJKU09OIiwic3RyaW5naWZ5Iiwic2hpZnRJdGVyYXRvciIsImlucHV0IiwiZG9uZSIsIm5leHQiLCJ1bmRlZmluZWQiLCJ0b0ZhaWx1cmUiLCJyZXN1bHQiLCJjb250ZXh0Iiwic3RydWN0IiwiYnJhbmNoIiwidHlwZSIsInJlZmluZW1lbnQiLCJrZXkiLCJ0b0ZhaWx1cmVzIiwiciIsInJ1biIsIm9wdGlvbnMiLCJjb2VyY2UiLCJtYXNrIiwiY3R4IiwiY29lcmNlciIsInN0YXR1cyIsInZhbGlkYXRvciIsImsiLCJ2IiwicyIsImVudHJpZXMiLCJ0cyIsInQiLCJNYXAiLCJzZXQiLCJTZXQiLCJhZGQiLCJyZWZpbmVyIiwiU3RydWN0IiwicHJvcHMiLCJzY2hlbWEiLCJhc3NlcnQiLCJjcmVhdGUiLCJpcyIsInZhbGlkYXRlIiwidHVwbGVzIiwidHVwbGUiLCJlcnJvciIsIlN0cnVjdHMiLCJpc1R5cGUiLCJzY2hlbWFzIiwibWFwIiwib2JqZWN0IiwiZGVmaW5lIiwiZGVwcmVjYXRlZCIsImxvZyIsImR5bmFtaWMiLCJmbiIsImxhenkiLCJvbWl0Iiwia2V5cyIsInN1YnNjaGVtYSIsInBhcnRpYWwiLCJpc1N0cnVjdCIsIm9wdGlvbmFsIiwicGljayIsImNvbnNvbGUiLCJ3YXJuIiwiYW55IiwiYXJyYXkiLCJFbGVtZW50IiwiaSIsInNsaWNlIiwiYmlnaW50IiwiYm9vbGVhbiIsImRhdGUiLCJEYXRlIiwiaXNOYU4iLCJnZXRUaW1lIiwiZW51bXMiLCJ2YWx1ZXMiLCJkZXNjcmlwdGlvbiIsImluY2x1ZGVzIiwiZnVuYyIsImluc3RhbmNlIiwiQ2xhc3MiLCJpbnRlZ2VyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaW50ZXJzZWN0aW9uIiwiUyIsImxpdGVyYWwiLCJjb25zdGFudCIsIktleSIsIlZhbHVlIiwibmV2ZXIiLCJudWxsYWJsZSIsIm51bWJlciIsImtub3ducyIsIk5ldmVyIiwidW5rbm93bnMiLCJkZWxldGUiLCJjb2VyY2VkIiwicmVjb3JkIiwicmVnZXhwIiwiUmVnRXhwIiwic3RyaW5nIiwiTWF0aCIsIm1heCIsInVuaW9uIiwiZmlyc3QiLCJwdXNoIiwidW5rbm93biIsImNvbmRpdGlvbiIsImRlZmF1bHRlZCIsImZhbGxiYWNrIiwiZiIsInN0cmljdCIsInJldCIsImNoYW5nZWQiLCJ0cmltbWVkIiwidHJpbSIsImVtcHR5IiwicmVmaW5lIiwic2l6ZSIsImdldFNpemUiLCJ0aHJlc2hvbGQiLCJleGNsdXNpdmUiLCJtaW4iLCJub25lbXB0eSIsInBhdHRlcm4iLCJ0ZXN0Iiwic291cmNlIiwiZXhwZWN0ZWQiLCJvZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/superstruct/dist/index.mjs\n");

/***/ })

};
;